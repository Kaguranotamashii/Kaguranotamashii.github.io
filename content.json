{"meta":{"title":"神楽の魂的博客","subtitle":"","description":"吾魂兮无求乎永生,竭尽兮人事之所","author":"神楽の魂","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2021-11-27T05:33:58.000Z","updated":"2022-04-30T12:32:40.368Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"说说","date":"2022-04-30T00:52:55.000Z","updated":"2022-04-30T12:21:15.133Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":"new Artitalk({ appId: 'uglz6tnJasD6sm9qHMVU1oJk-MdYXbMMI', appKey: 'UYbIjFxE6uFOHkNjLCUxHf6R' })"},{"title":"link","date":"2022-02-16T16:04:18.000Z","updated":"2022-04-19T14:10:30.578Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"categories |分类 |归档","date":"2021-11-27T05:46:32.000Z","updated":"2022-04-29T15:51:52.679Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-12-07T16:06:22.000Z","updated":"2022-04-29T23:50:14.713Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"z 我是一名北京信息科技大学，电子信息工程的一名学生"},{"title":"标签","date":"2021-11-27T05:46:37.000Z","updated":"2022-04-30T12:22:11.827Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的相册","date":"2022-05-07T03:01:32.134Z","updated":"2022-05-07T03:01:32.134Z","comments":true,"path":"gallery/index.html","permalink":"http://example.com/gallery/index.html","excerpt":"","text":"我的世界 和老朋友联机1.18截的风景... 我的世界 和老朋友联机1.18截的风景..."},{"title":"gallery","date":"2022-05-07T01:31:46.804Z","updated":"2022-05-07T01:31:46.804Z","comments":true,"path":"gallery/gallery/marvel/marvel.html","permalink":"http://example.com/gallery/gallery/marvel/marvel.html","excerpt":"","text":""},{"title":"gallery","date":"2022-05-07T02:56:02.804Z","updated":"2022-05-07T02:56:02.804Z","comments":true,"path":"gallery/2022/wdsj/index.html","permalink":"http://example.com/gallery/2022/wdsj/index.html","excerpt":"","text":"废旧矿洞的冒险 世界最高峰! 雨林小家 雪山冒险 被追杀后，转角遇到了最美风景"}],"posts":[{"title":"六月集训","slug":"text","date":"2022-05-31T05:22:47.000Z","updated":"2022-06-02T16:59:35.710Z","comments":true,"path":"2022/05/31/text/","link":"","permalink":"http://example.com/2022/05/31/text/","excerpt":"","text":"文章目录[TOC] 一、概念1、顺序存储 顺序存储结构，是指用一段地址连续的存储单元依次存储线性表的数据元素。 2、存储方式 在编程语言中，用一维数组来实现顺序存储结构，在C语言中，把第一个数据元素存储到下标为 0 的位置中，把第 2 个数据元素存储到下标为 1 的位置中，以此类推。 3、长度和容量 数组的长度指的是数组当前有多少个元素，数组的容量指的是数组最大能够存放多少个元素。如果数组元素大于最大能存储的范围，在程序上是不允许的，可能会产生意想不到的问题，实现上是需要规避的。 如上图所示，数组的长度为 5，即红色部分；容量为 8，即红色 加 蓝色部分。 4、数据结构定义12345678#define MAXN 1024#define DataType int // (1)struct SeqList &#123; DataType data[MAXN]; // (2) int length; // (3)&#125;; 1234567 ( 1 ) (1)(1) 数组类型为DataType，定义为int； ( 2 ) (2)(2) SeqList定义的就是一个最多存放MAXN个元素的数组，MAXN代表数组容量； ( 3 ) (3)(3) length代表数组长度，即当前的元素个数。 二、常用接口实现1、只读接口1）索引 索引 就是通过 数组下标 寻找 数组元素 的过程。C语言实现如下： 1234DataType SeqListIndex(struct SeqList *sq, int i) &#123; return sq-&gt;data[i]; // (1)&#125;123 ( 1 ) (1)(1) 调用方需要注意 i ii 的取值必须为非负整数，且小于数组最大长度。否则有可能导致异常，引发崩溃。 索引的算法时间复杂度为 O ( 1 ) O(1)O(1)。 2）查找 查找 就是通过 数组元素 寻找 数组下标 的过程，是索引的逆过程。 对于有序数组，可以采用 二分 进行查找，时间复杂度为 O ( l o g 2 n ) O(log_2n)O(log2​n)；对于无序数组，只能通过遍历比较，由于元素可能不在数组中，可能遍历全表，所以查找的最坏时间复杂度为 O ( n ) O(n)O(n)。 简单介绍一个线性查找的例子，实现如下： 12345678910DataType SeqListFind(struct SeqList *sq, DataType dt) &#123; int i; for(i = 0; i &lt; sq-&gt;length; ++i) &#123; // (1) if(sq-&gt;data[i] == dt) &#123; return i; // (2) &#125; &#125; return -1; // (3)&#125;123456789 ( 1 ) (1)(1) 遍历数组元素； ( 2 ) (2)(2) 对数组元素 和 传入的数据进行判等，一旦发现相等就返回对应数据的下标； ( 3 ) (3)(3) 当数组遍历完还是找不到，说明这个数据肯定是不存在的，直接返回 − 1 -1−1。 3）获取长度 获取 数组的长度 指的是查询当前有多少元素。可以直接用结构体的内部变量。C语言代码实现如下： 1234DataType SeqListGetLength(struct SeqList *sq) &#123; return sq-&gt;length; &#125;123 2、可写接口1）插入 插入接口定义为：在数组的第 k kk 个元素前插入一个数 v vv。由于数组是连续存储的，那么从 k kk 个元素往后的元素都必须往后移动一位，当 k = 0 k=0k=0 时，所有元素都必须移动，所以最坏时间复杂度为 O ( n ) O(n)O(n)。C语言代码实现如下： 12345678910111213int SeqListInsert(struct SeqList *sq, int k, DataType v) &#123; int i; if(sq-&gt;length == MAXN) &#123; return 0; // (1) &#125; for(i = sq-&gt;length; i &gt; k; --i) &#123; sq-&gt;data[i] = sq-&gt;data[i-1]; // (2) &#125; sq-&gt;data[k] = v; // (3) sq-&gt;length ++; // (4) return 1; // (5) &#125;123456789101112 ( 1 ) (1)(1) 当元素个数已满时，返回 0 00 代表插入失败； ( 2 ) (2)(2) 从第 k kk 个数开始，每个数往后移动一个位置，注意必须逆序； ( 3 ) (3)(3) 将第 k kk 个数变成 v vv； ( 4 ) (4)(4) 插入了一个数，数组长度加一； ( 5 ) (5)(5) 返回 1 11 代表插入成功； 2）删除 删除接口定义为：将数组的第 k kk 个元素删除。由于数组是连续存储的，那么第 k kk 个元素删除，往后的元素势必要往前移动一位，当 k = 0 k=0k=0 时，所有元素都必须移动，所以最坏时间复杂度为 O ( n ) O(n)O(n)。C语言代码实现如下： 123456789101112int SeqListDelete(struct SeqList *sq, int k) &#123; int i; if(sq-&gt;length == 0) &#123; return 0; // (1) &#125; for(i = k; i &lt; sq-&gt;length - 1; ++i) &#123; sq-&gt;data[i] = sq-&gt;data[i+1]; // (2) &#125; sq-&gt;length --; // (3) return 1; // (4) &#125;1234567891011 ( 1 ) (1)(1) 返回0代表删除失败； ( 2 ) (2)(2) 从前往后； ( 3 ) (3)(3) 数组长度减一； ( 4 ) (4)(4) 返回1代表删除成功； 三、优缺点1、优点 1）无须为表示表中元素逻辑关系而增加额外的存储空间； 2）随机存取元素时可以达到 O ( 1 ) O(1)O(1)，效率高； 2、缺点 1）插入和删除时需要移动大量元素； 2）必须一开始就确定存储空间的容量； 四、数组相关算法1、线性枚举1）问题描述 给定一个长度为 n ( 1 ≤ n ≤ 1 0 5 ) n(1 \\le n \\le 10^5)n(1≤n≤105) 的整型数组，求所有数组元素中的其中的最小值。 2）动图演示 3）示例说明 蓝色的数据代表的是数组数据，红色的数据代表当前枚举到的数据，这样就可以遍历所有的数据进行逻辑处理了。 4）算法描述 遍历数组，进行条件判断，条件满足则执行逻辑。这里的条件就是 枚举到的数 是否小于 当前最小值，执行逻辑为 将 当前枚举到的数 赋值给 当前最小值； 5）源码详解12345678910int findMin(int* nums, int numsSize)&#123; int i, min = 100000; for(i = 0; i &lt; numsSize; ++i) &#123; // (1) if(nums[i] &lt; min) &#123; // (2) min = nums[i]; &#125; &#125; return min; // (3)&#125;123456789 ( 1 ) (1)(1) 遍历数组中所有的数； ( 2 ) (2)(2) 如果 当前枚举到的数 比记录的变量min小，则将它赋值给min；否则，不做任何处理； ( 3 ) (3)(3) 最后，min中存储的就是整个数组的最小值。 2、前缀和差分1）问题描述 给定一个 n ( n ≤ 1 0 5 ) n (n \\le 10^5)n(n≤105) 个元素的整型数组 a i aia**i，再给出 m ( m ≤ 1 0 5 ) m(m \\le 10^5)m(m≤105) 次询问，每次询问是一个区间 [ l , r ] [l, r][l,r]，求 h ( l , r ) = ∑ k = l r a k h(l,r) = \\sum{k=l}^r a_kh(l,r)=∑k=lra**k 2）动图演示 3）样例分析 如上图所示，只需要记录一个前缀和，然后就可以通过一次减法将区间的值计算出来。时间复杂度 O ( 1 ) O(1)O(1)。这种就是差分的思想。 4）算法描述 第一个枚举，利用一个数组sum，存储前 i ii 个元素的和。 第二个枚举，读入 m mm 组数据 l , r l, rl,r，对每组数据，通过 O ( 1 ) O(1)O(1) 获取答案，即 s u m r − s u m l − 1 sumr - sum{l-1}sum**r​−sum**l−1​。 5）源码详解123456789101112131415161718int sum[maxn];int* prefixSum(int* nums, int numsSize, int m, int *l, int *r)&#123; int i; int *ret; for(i = 0; i &lt; numsSize; ++i) &#123; sum[i] = nums[i]; if(i) sum[i] += sum[i-1]; // (1) &#125; ret = (int *) malloc( m * sizeof(int) ); // (2) for(i = 0; i &lt; m; ++i) &#123; int leftsum = l[i]==0? 0 : sum[l[i]-1]; // (3) int rightsum = sum[r[i]]; ret[i] = rightsum - leftsum; // (4) &#125; return ret;&#125;1234567891011121314151617 ( 1 ) (1)(1) 计算前缀和； ( 2 ) (2)(2) 需要返回的数组； ( 3 ) (3)(3) 这里是为了防止数组下标越界； ( 4 ) (4)(4) 核心 O ( 1 ) O(1)O(1) 的差分计算； 3、双指针1）问题描述 给定一个长度为 n ( 1 ≤ n ≤ 1 0 7 ) n (1 \\le n \\le 10^7)n(1≤n≤107) 的字符串 s ss，求一个最长的满足所有字符不重复的子串。 2）动图演示 3）样例说明 维护两个指针 i ii 和 j jj，区间 [ i , j ] [i, j][i,j] 内的子串，应该时刻保持其中所有字符不重复，一旦发现重复字符，就需要自增 i ii（即执行 i = i + 1 i = i + 1i=i+1）；否则，执行 j = j + 1 j = j + 1j=j+1，直到 j jj 不能再增加为止。 过程中，记录合法情况下 j − i + 1 j - i + 1j−i+1 的最大值。 4）算法描述 如上文所述，这种利用问题特性，通过两个指针，不断调整区间，从而求出问题最优解的算法就叫 “尺取法”，由于利用的是两个指针，所以又叫 “双指针” 算法。 这里 “尺” 的含义，主要还是因为这类问题，最终要求解的都是连续的序列（子串），就好比一把尺子一样，故而得名。 算法描述如下： 1）初始化 i = 0 i=0i=0, j = i − 1 j=i-1j=i−1，代表一开始 “尺子” 的长度为 0； 2）增加 “尺子” 的长度，即 j = j + 1 j = j +1j=j+1； 3）判断当前这把 “尺子” [ i , j ] [i, j][i,j] 是否满足题目给出的条件： 3.a）如果不满足，则减小 “尺子” 长度，即 i = i + 1 i = i + 1i=i+1，回到 3）； 3.b）如果满足，记录最优解，回到 2）； 上面这段文字描述的比较官方，其实这个算法的核心，只有一句话：满足条件时， j jj++；不满足条件时， i ii++； 如图所示，当区间 [ i , j ] [i, j][i,j] 满足条件时，用蓝色表示，此时 j jj 自增；反之闪红，此时 i ii 自增。 5）源码详解12345678910111213141516int getmaxlen(int n, char *str, int&amp; l, int&amp; r) &#123; int ans = 0, i = 0, j = -1, len; // 1) memset(h, 0, sizeof(h)); // 2) while (j++ &lt; n - 1) &#123; // 3) ++h[ str[j] ]; // 4) while (h[ str[j] ] &gt; 1) &#123; // 5) --h[ str[i] ]; ++i; &#125; len = j - i + 1; if(len &gt; ans) // 6) ans = len, l = i, r = j; &#125; return ans;&#125;123456789101112131415 1）初始化 i = 0, j = -1，代表 s [ i : j ] s[i:j]s[i:j] 为一个空串，从空串开始枚举； 2）需要维护一个哈希表，哈希表记录的是当前枚举的区间 s [ i : j ] s[i:j]s[i:j] 中每个字符的个数； 3）只推进子串的右端点； 4）在哈希表中记录字符的个数； 5）当 h[ str[j] ] &gt; 1满足时，代表出现了重复字符str[j]，这时候左端点 i ii 推进，直到没有重复字符为止； 6）记录当前最优解的长度 j - i + 1，更新； 这个算法执行完毕，我们就可以得到最长不重复子串的长度为 a n s ansans，并且 i ii 和 j jj 这两个指针分别只自增 n nn 次，两者自增相互独立，是一个相加而非相乘的关系，所以这个算法的时间复杂度为 O ( n ) O(n)O(n) 。 4、二分枚举1）问题描述 给定一个 n ( n ≤ 1 0 6 ) n(n \\le 10^6)n(n≤106) 个元素的有序整型数组和一个 t a r g e t targettarge**t 值，求在 O ( l o g 2 n ) O(log_2n)O(log2n) 的时间内找到值为 t a r g e t targettarge**t 的整型的数组下标，不存在则返回 -1。 2）动图演示 3）样例说明 需要找值为 5 55 的这个元素。 黄色箭头 代表都是左区间端点 l ll，红色箭头 代表右区间端点 r rr。蓝色的数据为数组数据，绿色的数字代表的是数组下标，初始化 l = 0 l = 0l=0，r = 7 r = 7r=7，由于数组有序，则可以直接折半，令 m i d = ( l + r ) / 2 = 3 mid = (l + r) / 2 = 3mid=(l+r)/2=3，则 5 55 一定落入区间 [ 0 , 3 ] [0, 3][0,3]，这时候令 r = 3 r = 3r=3，继续执行，直到 l &gt; r l &gt; rl&gt;r 结束迭代。 最后，当 m i d = 2 mid=2mid=2 时，找到数据 5。 4）算法描述 a）令初始情况下，数组下标从 0 开始，且数组长度为 n nn，则定义一个区间，它的左端点是 l = 0 l=0l=0，右端点是 r = n − 1 r = n-1r=n−1； b）生成一个区间中点 m i d = ( l + r ) / 2 mid = (l + r) / 2mid=(l+r)/2，并且判断 m i d midmid 对应的数组元素和给定的目标值的大小关系，主要有三种： b.1）目标值 等于 数组元素，直接返回 m i d midmid； b.2）目标值 大于 数组元素，则代表目标值应该出现在区间 [ m i d + 1 , r ] [mid+1, r][mid+1,r]，迭代左区间端点：l = m i d + 1 l = mid + 1l=mid+1； b.3）目标值 小于 数组元素，则代表目标值应该出现在区间 [ l , m i d − 1 ] [l, mid-1][l,mid−1]，迭代右区间端点：r = m i d − 1 r = mid - 1r=mid−1； c）如果这时候 l &gt; r l &gt; rl&gt;r，则说明没有找到目标值，返回 − 1 -1−1；否则，回到 b）继续迭代。 5）源码详解123456789101112131415int search(int *nums, int numsSize, int target) &#123; int l = 0, r = numsSize - 1; // (1) while(l &lt;= r) &#123; // (2) int mid = (l + r) &gt;&gt; 1; // (3) if(nums[mid] == target) &#123; return mid; // (4) &#125;else if(target &gt; nums[mid]) &#123; l = mid + 1; // (5) &#125;else if(target &lt; nums[mid]) &#123; r = mid - 1; // (6) &#125; &#125; return -1; // (7)&#125;1234567891011121314 ( 1 ) (1)(1) 初始化区间左右端点； ( 2 ) (2)(2) 一直迭代左右区间的端点，直到 左端点 大于 右端点 结束； ( 3 ) (3)(3) &gt;&gt; 1等价于除 2，也就是这里mid代表的是l和r的中点； ( 4 ) (4)(4) nums[mid] == target表示正好找到了这个数，则直接返回下标mid； ( 5 ) (5)(5) target &gt; nums[mid]表示target这个数在区间 [ m i d + 1 , r ] [mid+1, r][mid+1,r] 中，所以才有左区间赋值如下：l = mid + 1; ( 6 ) (6)(6) target &lt; nums[mid]表示target这个数在区间 [ l , m i d − 1 ] [l, mid - 1][l,mid−1] 中，所以才有右区间赋值如下：r = mid - 1; ( 7 ) (7)(7) 这一步呼应了 ( 2 ) (2)(2)，表示这不到给定的数，直接返回 -1； 5、三分枚举 三分枚举 类似 二分枚举 的思想，也是将区间一下子砍掉一块基本完全不可能的块，从而减小算法的时间复杂度。只不过 二分枚举 解决的是 单调性 问题。而 三分枚举 解决的是 极值问题。 6、插入排序1）问题描述 给定一个 n nn 个元素的数组，数组下标从 0 00 开始，采用「 插入排序 」将数组按照 「升序」排列。 2）动图演示 3）样例说明 图示 含义 ■ 的柱形 代表尚未排好序的数 ■ 的柱形 代表正在执行 比较 和 移动 的数 ■ 的柱形 代表已经排好序的数 ■ 的柱形 代表待执行插入的数 我们看到，首先需要将 「第二个元素」 和 「第一个元素」 进行 「比较」，如果 前者 小于等于 后者，则将 后者 进行向后 「移动」，前者 则执行插入； 然后，进行第二轮「比较」，即 「第三个元素」 和 「第二个元素」、「第一个元素」 进行 「比较」， 直到 「前三个元素」 保持有序 。 最后，经过一定轮次的「比较」 和 「移动」之后，一定可以保证所有元素都是 「升序」 排列的。 4）算法描述 整个算法的执行过程分以下几步： 1） 循环迭代变量 i = 1 → n − 1 i = 1 \\to n-1i=1→n−1； 2） 每次迭代，令 x = a [ i ] x = a[i]x=a[i]，j = i − 1 j = i-1j=i−1，循环执行比较 x xx 和 a [ j ] a[j]a[j]，如果产生 x ≤ a [ j ] x \\le a[j]x≤a[j] 则执行 a [ j + 1 ] = a [ j ] a[j+1] = a[j]a[j+1]=a[j]。然后执行 j = j + 1 j = j + 1j=j+1，继续执行 2）；否则，跳出循环，回到 1）。 5）源码详解12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int a[1010];void Input(int n, int *a) &#123; for(int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125;&#125;void Output(int n, int *a) &#123; for(int i = 0; i &lt; n; ++i) &#123; if(i) printf(&quot; &quot;); printf(&quot;%d&quot;, a[i]); &#125; puts(&quot;&quot;);&#125;void InsertSort(int n, int *a) &#123; // (1) int i, j; for(i = 1; i &lt; n; ++i) &#123; int x = a[i]; // (2) for(j = i-1; j &gt;= 0; --j) &#123; // (3) if(x &lt;= a[j]) &#123; // (4) a[j+1] = a[j]; // (5) &#125;else break; // (6) &#125; a[j+1] = x; // (7) &#125;&#125; int main() &#123; int n; while(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; Input(n, a); InsertSort(n, a); Output(n, a); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142 ( 1 ) (1)(1) void InsertSort(int n, int *a)为 插入排序 的实现，代表对a[]数组进行升序排序。 ( 2 ) (2)(2) 此时a[i]前面的 i-1个数都认为是排好序的，令x = a[i]； ( 3 ) (3)(3) 逆序的枚举所有的已经排好序的数； ( 4 ) (4)(4) 如果枚举到的数a[j]比需要插入的数x大，则当前数往后挪一个位置； ( 5 ) (5)(5) 执行挪位置的 O ( 1 ) O(1)O(1) 操作； ( 6 ) (6)(6) 否则，跳出循环； ( 7 ) (7)(7) 将x插入到合适位置； 7、选择排序1）问题描述 给定一个 n nn 个元素的数组，数组下标从 0 00 开始，采用「 选择排序 」将数组按照 「升序」排列。 2）动图演示 3）样例说明 图示 含义 ■ 的柱形 代表尚未排好序的数 ■ 的柱形 代表正在执行 比较 的数 ■ 的柱形 代表已经排好序的数 ■ 的柱形 有两种：1、记录最小元素 2、执行交换的元素 我们发现，首先从 「第一个元素」 到 「最后一个元素」 中选择出一个 「最小的元素」，和 「第一个元素」 进行 「交换」； 然后，从 「第二个元素」 到 「最后一个元素」 中选择出一个 「最小的元素」，和 「第二个元素」 进行 「交换」。 最后，一定可以保证所有元素都是 「升序」 排列的。 4）算法描述 整个算法的执行过程分以下几步： 1） 循环迭代变量 i = 0 → n − 1 i = 0 \\to n-1i=0→n−1； 2） 每次迭代，令 m i n = i min = imin=i，j = i + 1 j = i+1j=i+1； 3） 循环执行比较 a [ j ] a[j]a[j] 和 a [ m i n ] a[min]a[min]，如果产生 a [ j ] &lt; a [ m i n ] a[j] \\lt a[min]a[j]&lt;a[min] 则执行 m i n = j min = jmin=j。执行 j = j + 1 j = j + 1j=j+1，继续执行这一步，直到 j = = n j == nj==n； 4） 交换 a [ i ] a[i]a[i] 和 a [ m i n ] a[min]a[min]，回到 1）。 5）源码详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;int a[1010];void Input(int n, int *a) &#123; for(int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125;&#125;void Output(int n, int *a) &#123; for(int i = 0; i &lt; n; ++i) &#123; if(i) printf(&quot; &quot;); printf(&quot;%d&quot;, a[i]); &#125; puts(&quot;&quot;);&#125;void Swap(int *a, int *b) &#123; int tmp = *a; *a = *b; *b = tmp;&#125;void SelectionSort(int n, int *a) &#123; // (1) int i, j; for(i = 0; i &lt; n - 1; ++i) &#123; // (2) int min = i; // (3) for(j = i+1; j &lt; n; ++j) &#123; // (4) if(a[j] &lt; a[min]) &#123; min = j; // (5) &#125; &#125; Swap(&amp;a[i], &amp;a[min]); // (6) &#125;&#125;int main() &#123; int n; while(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; Input(n, a); SelectionSort(n, a); Output(n, a); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 ( 1 ) (1)(1) void SelectionSort(int n, int *a)为选择排序的实现，代表对a[]数组进行升序排序。 ( 2 ) (2)(2) 从首元素个元素开始进行 n − 1 n-1n−1 次跌迭代。 ( 3 ) (3)(3) 首先，记录min代表当前第 i ii 轮迭代的最小元素的下标为 i ii。 ( 4 ) (4)(4) 然后，迭代枚举第 i + 1 i+1i+1 个元素到 最后的元素。 ( 5 ) (5)(5) 选择一个最小的元素，并且存储下标到min中。 ( 6 ) (6)(6) 将 第 i ii 个元素 和 最小的元素 进行交换。 8、冒泡排序1）问题描述 给定一个 n nn 个元素的数组，数组下标从 0 00 开始，采用「 冒泡排序 」将数组按照 「升序」排列。 2）动图演示 3）样例说明 图示 含义 ■ 的柱形 代表尚未排好序的数 ■ 的柱形 代表正在执行比较的两个数 ■ 的柱形 代表已经排好序的数 我们看到，首先需要将 「第一个元素」 和 「第二个元素」 进行 「比较」，如果 前者 大于 后者，则进行 「交换」，然后再比较 「第二个元素」 和 「第三个元素」 ，以此类推，直到 「最大的那个元素」 被移动到 「最后的位置」 。 然后，进行第二轮「比较」，直到 「次大的那个元素」 被移动到 「倒数第二的位置」 。 最后，经过一定轮次的「比较」 和 「交换」之后，一定可以保证所有元素都是 「升序」 排列的。 4）算法描述 整个算法的执行过程分以下几步： 1） 循环迭代变量 i = 0 → n − 1 i = 0 \\to n-1i=0→n−1； 2） 每次迭代，令 j = i j = ij=i，循环执行比较 a [ j ] a[j]a[j] 和 a [ j + 1 ] a[j+1]a[j+1]，如果产生 a [ j ] &gt; a [ j + 1 ] a[j] \\gt a[j+1]a[j]&gt;a[j+1] 则交换两者的值。然后执行 j = j + 1 j = j + 1j=j+1，这时候对 j jj 进行判断，如果 j ≥ n − 1 j \\ge n-1j≥n−1，则回到 1），否则继续执行 2）。 5）源码详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;int a[1010];void Input(int n, int *a) &#123; for(int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125;&#125;void Output(int n, int *a) &#123; for(int i = 0; i &lt; n; ++i) &#123; if(i) printf(&quot; &quot;); printf(&quot;%d&quot;, a[i]); &#125; puts(&quot;&quot;);&#125;void Swap(int *a, int *b) &#123; int tmp = *a; *a = *b; *b = tmp;&#125;void BubbleSort(int n, int *a) &#123; // (1) bool swapped; int last = n; do &#123; swapped = false; // (2) for(int i = 0; i &lt; last - 1; ++i) &#123; // (3) if(a[i] &gt; a[i+1]) &#123; // (4) Swap(&amp;a[i], &amp;a[i+1]); // (5) swapped = true; // (6) &#125; &#125; --last; &#125;while (swapped);&#125; int main() &#123; int n; while(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; Input(n, a); BubbleSort(n, a); Output(n, a); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 ( 1 ) (1)(1) void BubbleSort(int n, int *a)为冒泡排序的实现，代表对a[]数组进行升序排序。 ( 2 ) (2)(2) swapped标记本轮迭代下来，是否有元素产生了交换。 ( 3 ) (3)(3) 每次冒泡的结果，会执行last的自减，所以待排序的元素会越来越少。 ( 4 ) (4)(4) 如果发现两个相邻元素产生逆序，则将它们进行交换。保证右边的元素一定不比左边的小。 ( 5 ) (5)(5) swap实现了元素的交换，这里需要用&amp;转换成地址作为传参。 ( 6 ) (6)(6) 标记更新。一旦标记更新，则代表进行了交换，所以下次迭代必须继续。 关于 「 顺序表 」 的内容到这里就结束了。 有关🌳《画解数据结构》🌳 的源码均开源，链接如下：《画解数据结构》","categories":[],"tags":[]},{"title":"c++快速入门","slug":"c-快速入门","date":"2022-05-02T10:02:11.000Z","updated":"2022-05-10T15:58:28.728Z","comments":true,"path":"2022/05/02/c-快速入门/","link":"","permalink":"http://example.com/2022/05/02/c-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"c++标准输入输出 头文件iostream cout是标准输出流变量 &lt;&lt;是运算符 加入o是输出流对象 x是一个数据 0&lt;&lt;x cout是标准名字空间std的一个名字 必须加上名字空间限定std::cout 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;using std::cout;using std::endl;using std::cin;int main() &#123; cout &lt;&lt; &quot;HELLO WORLD\\n&quot;; int a; cin &gt;&gt; a; cout &lt;&lt; &quot;a\\n&quot;&lt;&lt;a; ofstream oF(&quot;text.txt&quot;); oF &lt;&lt; 3.14 &lt;&lt; &quot;&quot; &lt;&lt; &quot;helllo world&quot;; oF.close(); ifstream iF(&quot;text.txt&quot;); double d; string str; iF &gt;&gt; d &gt;&gt; str; cout &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt; endl; return 0;&#125; 引用变量和引用形参12345678#include&lt;instream&gt;int main()&#123; double d; int &amp;r=d; cout&lt; &#125; 引用变量是其他变量的别名，如同一个人的外号或者小名 既然是引用，定义比那两点时候就必须指明其引用是哪个变量 1int a=3;int &amp;r=a; 函数的引用形参：引用实参 1234567swap(a,b)swap(int &amp;x,int&amp;y)&#123;int t=x;x=y;y=t;&#125; 函数的默认形参 函数形参可以有默认值 1void print(char ch,int n=1); 默认形参必须在非默认形参右边 1add(y,x=1.z=3); 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;void print(char ch, int n = 3) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; ch; &#125; cout &lt;&lt; &quot;\\n&quot;;&#125;int main() &#123; print(&#x27;A&#x27;, 1); print(&#x27;A&#x27;, 2); print(&#x27;A&#x27;, 3); print(&#x27;A&#x27;);&#125;/*AAAAAAAAA*/ 函数重载123456789101112//函数重载//c++允许作用域里面有同名函数，只要形参不同int add(int a, int b) &#123; return a + b;&#125;double add(double a, double b) &#123; return a + b;&#125;int main() &#123; cout &lt;&lt; add(11, 11)&lt;&lt;&quot; &quot;; cout &lt;&lt; add(1.22, 12.1);&#125; 函数模板通用算法，函数模板 也叫泛型算法 123456789template&lt;typename T&gt;T add(T a, T b) &#123; return a + b;&#125;int main() &#123; cout &lt;&lt; add&lt;int&gt;(1, 1)&lt;&lt;endl; cout &lt;&lt; add&lt;string&gt;(&quot;hello&quot;, &quot; world&quot;) &lt;&lt; endl; cout &lt;&lt; add&lt;double&gt;(1.1, 23.1) &lt;&lt; endl;&#125; string是一个用户定义类型 表示的是符串 1string s=&quot;hello&quot;,s2(&quot;world&quot;); 12345678int main() &#123; string s = &quot;hello&quot;, s2(&quot;world&quot;); cout &lt;&lt; s.size() &lt;&lt; endl; string s3 = s.substr(1, 3); cout &lt;&lt; s3 &lt;&lt; endl; string s4 = s + &quot; &quot; + s2; cout &lt;&lt; s4 &lt;&lt; endl;&#125; 12//索引修改// vector向量类似数组可以动态增长 是一个类模板 123456789101112#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; vector&lt;int&gt; v=&#123;1,22,2,1&#125;; v.push_back(23);//+ cout &lt;&lt; v[4]; v.pop_back(); //报错cout &lt;&lt; v[4]; v.resize(2);&#125; 动态内存1234567891011121314151617int main() &#123; int* p = new int; *p = 3; cout &lt;&lt; p&lt;&lt;&#x27;\\t&#x27;&lt;&lt;*p; cout &lt;&lt; &#x27;\\n&#x27;; int n; cin &gt;&gt; n; int* arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i]&lt;&lt;&#x27;\\t&#x27;; &#125;&#125; 面向对象类与对象1234567891011121314151617181920212223242526#include &lt;iostream&gt; #include &lt;string&gt; using namespace std;class student &#123;public: //接口 void print() &#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;score &lt;&lt; endl; &#125; string get_name() &#123; return name; &#125; double get_score() &#123; return score; &#125; void set_name(string n) &#123; name = n; &#125; void set_score(double s) &#123; score = s; &#125;private: string name; double score;&#125;;int main() &#123; student stu; stu.set_name(&quot;Li Ping&quot;); stu.set_score(78.5); stu.print(); // print(&amp;stu); cout &lt;&lt; stu.get_name() &lt;&lt; &quot; &quot; &lt;&lt; stu.get_score() &lt;&lt; endl;&#125; 继承访问控制和继承派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 我们可以根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Shape &#123;public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125;protected: int width; int height;&#125;;class Rectangle :public Shape &#123;//继承语法public: int getArea() &#123; return (width * height); &#125;&#125;;int main() &#123; Rectangle Rect; Rect.setHeight(5); Rect.setWidth(6); cout &lt;&lt; Rect.getArea();&#125; 函数重载123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std; class printData&#123; public: void print(int i) &#123; cout &lt;&lt; &quot;整数为: &quot; &lt;&lt; i &lt;&lt; endl; &#125; void print(double f) &#123; cout &lt;&lt; &quot;浮点数为: &quot; &lt;&lt; f &lt;&lt; endl; &#125; void print(char c[]) &#123; cout &lt;&lt; &quot;字符串为: &quot; &lt;&lt; c &lt;&lt; endl; &#125;&#125;; int main(void)&#123; printData pd; // 输出整数 pd.print(5); // 输出浮点数 pd.print(500.263); // 输出字符串 char c[] = &quot;Hello C++&quot;; pd.print(c); return 0;&#125; function initialize() { var mapProp = { center:new google.maps.LatLng(51.508742,-0.120850), zoom:5, mapTypeId:google.maps.MapTypeId.ROADMAP }; var map=new google.maps.Map(document.getElementById(\"googleMap\"),mapProp); } google.maps.event.addDomListener(window, 'load', initialize);","categories":[],"tags":[]},{"title":"git出现的问题","slug":"git出现的问题","date":"2022-04-11T15:22:08.000Z","updated":"2022-04-29T23:52:24.654Z","comments":true,"path":"2022/04/11/git出现的问题/","link":"","permalink":"http://example.com/2022/04/11/git%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"今天学习使用vscode的源代码管理时候同步时出现了fatal: unable to access ‘xxxx: Failed to connect to github.com port 443 after 21098 ms: Timed out这个错误。","text":"今天学习使用vscode的源代码管理时候同步时出现了fatal: unable to access ‘xxxx: Failed to connect to github.com port 443 after 21098 ms: Timed out这个错误。 提示含义是通过443端口连接github.com错误。 解决办法为 123git config --global --unset http.proxy#删除配置git config --global http.proxy 127.0.0.1:xxxx#根据自己的代理插件设置全局端口git config --local http.proxy 127.0.0.1:xxxx #为某个 git 项目单独设置代理 比如我用某个小猫默认的7080","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://example.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Java SE","slug":"java基础学习笔记","date":"2022-02-21T05:47:24.000Z","updated":"2022-05-22T11:10:09.684Z","comments":true,"path":"2022/02/21/java基础学习笔记/","link":"","permalink":"http://example.com/2022/02/21/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"DOS 变量constant 常量1final type barName=valie; 变量的分类局部变量 成员变量 静态变量 局部变量在方法语句块 成员变量 对象 类内部，方法外面 从属对象 会自动默认初始化 静态变量 类内部 static修饰 从属类 primitive data type 整数byte 一字节 -127-127 short 2字节 -2^15-2^15-1 int 4字节 2^31-2^32-1 long 8字节 -2^63 十进制 八进制以0开头 十六进制以0x 0X 二进制0b oB开头 floating point numberfloat四字节 double八字节 字符型booleantrue false 一个字节或者四个字节 运算符 强制转换类 cast（type）var Scanner处理键盘输入1234567891011121314import java.util.Scanner;public class Scanner1 &#123; public static void main(String[] args) &#123; Scanner s =new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String uname =s.nextLine(); System.out.println(&quot;输入你的年龄&quot;); int age=s.nextInt(); System.out.println(&quot;用户名&quot;+uname); System.out.println(&quot;年龄&quot;+age); &#125;&#125; 控制语句APIstringscannerequals1234if(name.equals(name_1)&amp;&amp;password_1.equals(password))&#123; System.out.println(&quot;成功&quot;); break; &#125; 遍历charAt123for (int i = 0; i &lt; line.length(); i++) &#123; System.out.println(line.charAt(i)); &#125; stringBuilder的添加和反转append和reverse 12345678910111213 StringBuilder sb=new StringBuilder(); sb.append(&quot;hello&quot;); sb.append(&quot;java&quot;); System.out.println(sb); sb.reverse(); System.out.println(sb);//hellojava//avajollehstringbuilder转为string string s =sb.tostring（）； string转为stringbuilder StringBuilder sb=new StringBuilder(s); IDEA1234567891011121314快捷和补全单行ctrl+/多行ctrl+shitft+/CTRL+alt+L格式化快速生成main（）方法 psvm输入语句sout内容辅助CTRL+shifr+space\\自动生成构造器insert+alt查看错误alt+enter看源码ctrl+左键 数组Array数组必须初始化使用 静态 type name = new type【length】 123int a[] =new int [5];int [] arr =new int [5];int []arr=&#123;551,2,377&#125;; arrayList 集合123456789101112 ArrayList&lt;String&gt; array =new ArrayList&lt;&gt;(); System.out.println(array); array.add(&quot;hello world&quot;); array.add(&quot;java&quot;);array.add(&quot;java good&quot;); System.out.println(array); array.add(1,&quot;syr&quot;); System.out.println(array); [][hello world, java, java good][hello world, syr, java, java good] arraylist基本常用方法 public boolean remove(obiect o) 删除指定元素 public E remove(int index) 删除索引元素，返回被删元素 public E set(int index,E element) 修改，返回被修改的元素 public E get（int index） 返沪索引元素 public int size（） 返回集合的元素 方法methodJava方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 1234定义 public static type name()&#123; &#125; 方法重载overload 多个方法在一个类 方法具有相同的方法名 返回类型或者数量不同 一个类中定义多个名称相同，但是参数泪飙不同的的方法 123456789101112131415161718192021public class fangfa &#123; public static void main(String[] args) &#123; System.out.println(sum(123,2131)); System.out.println(sum(12.1,23.1)); System.out.println(sum(123,231,32)); &#125; //int add public static int sum(int a,int b)&#123; return a+b; &#125; public static double sum(double a,double b)&#123; return a+b; &#125; public static int sum(int a,int b,int c)&#123; return a+b+c; &#125;&#125;//225435.2386 递归StackOverflowError 大量占用系统堆栈 类和对象（Object Oriented Programing）类是java基本的组成结构 类的定义123456public class car&#123; //每个文件必须有一个public class，名字与文件名相同&#125;class tyre&#123;&#125;//可以定义多个classclass engine&#123;&#125;class seat&#123;&#125; 对于一个类来说有三种成员 field属性 成员变量属性用于定义这个类或者更类对象包含的数据或者静态特征 修饰符 type name=默认 method方法方法从属于类和对象 修饰符 返回类型 name（）{ 构造方法 构造器 constructor构造器能用于对象的初始化，而不是创建对象 构造器用new关键字调用 构造器虽然没有返回值，但不能定义返回值类型 如果没有定义构造器，则编译器会自动定义一个无参的构造方法，如果一定义的则编译器不会自动添加 构造器的方法名必须与类名字相同 课堂练习可以生成具有特定坐标的点对象 提供可以计算点到另外一点距离的方法 12345678910111213141516171819package 第五章面向对象.构造器.点;public class Point &#123; double x,y; Point (double _x,double _y)&#123; x=_x;y=_y; &#125; public double getDistance(Point p)&#123; return Math.sqrt((x-p.x)*(y-p.y)+(y-p.y)*(y-p.y)); &#125; public static void main(String[] args) &#123; Point p1=new Point(3.0,4.0); Point origin =new Point(0.0,0.0); System.out.println(p1.getDistance(origin)); &#125;&#125; 构造方法的重载jvm虚拟机 栈的特点 堆的特点 Garbage Collection垃圾回收机制垃圾回收过程 发现无用的对象 回收无用对象占用内存空间 无用对象为没有任何引用 算法1引用计数法 通用的分代垃圾回收机制 内存泄漏创建大量的无用对象 1234string str=&quot;&quot;;for(int i=0;i&lt;11000:i++)&#123;str+=i;//相当于产生了11000个string对象&#125; 静态集合类的使用hassomap vector list等这些最容易出现，这些静态变量的生命周期 各种连接对象 监听器使用不当 可以用system.gc()但是只是通知jvm object可以用finalize方法，是java给程序员的 this关键词就是当前对象的地址 this用法 普通方法中 this总是指向调用该方法的对象 构造方法中，this总是指向正要初始化的对象 static 静态初始化块构造方法用于对象的普通属性的初始化 静态初始快中，用于初始化类，初始化静态属性 静态初始化快中不能直接访问非static成员 变量分类 包机制package import 相当于文件夹对文件的作用，用于管理类，解决类的重名问题 面向对象三大特征继承extends代码复用，方便建模 1234567891011121314151617181920212223242526272829package 第五章面向对象.extends1;public class text &#123; public static void main(String[] args) &#123; Student s1 =new Student(&quot;songyuran&quot;,11,&quot;CS&quot;); s1.xuexi(); &#125;&#125;class Persin&#123; String name; int height; public void rest()&#123; System.out.println(&quot;xiuxi&quot;); &#125;&#125;class Student extends Persin&#123; String major; public void xuexi()&#123; System.out.println(&quot;xuexi&quot;); rest(); System.out.println(this.name); &#125; public Student(String name,int height,String major)&#123; this.name=name; this.height=height; this.major=major; &#125;&#125; instanceof判断类型 12s1 instanceof Person//trues1 instanceof Student//true 父类 又叫超类 基类 子类：派生类 接口有多继承 方法重写override子类重写父亲的方法，替换父类行为，重写是实现多态的必要条件 == 方法名字 形参列表 《=返回值类型和声明异常类型，子类小于等于父类 》=子类大于父类 final关键词 修饰变量 修饰方法 不可被子类重写，但是可以重载，final class a{} 修饰类 不可被继承 组合组合比较灵活，继承只能有一个父类，组合可以有多个属性 封装三大特征之一 提高安全 复用 高内聚低耦合 封装的实现关键词访问限制修饰符 1234567891011package text.b;public class Test &#123; public static void main(String[] args) &#123; User u=new User(99,&quot;宋宇然&quot;,true); System.out.println(u.getId()); System.out.println(u.getName()); System.out.println(u.isMan()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package text.b;public class User &#123; private int id; private String name; private boolean man; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isMan() &#123; return man; &#125; public void setMan(boolean man) &#123; this.man = man; &#125; public void printUserInfo()&#123; System.out.println(id); System.out.println(man); System.out.println(name); &#125; public User(int id, String name, boolean man) &#123; this.id = id; this.name = name; this.man = man; &#125;&#125; 多态polymorphism同一种方法调用 不同对象行为完全不同 123456789101112131415161718public class Animal&#123; public void shout()&#123; System.out.println(&quot;叫了一声&quot;); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println(&quot;wangwang&quot;); &#125; public void seeDoor()&#123; System.out.println(&quot;see door&quot;); &#125;&#125;class Cat extends Animal&#123; public void shout()&#123; System.out.println(&quot;miaomiao&quot;); &#125;&#125; 123456789public class TestPolym&#123; public static void main(String[] args)&#123; animaCry(new DOg()); animalCry(new Cat()); &#125; static void animalCry(Animal a)&#123; a.shout(); &#125;&#125; 对象的转型casting父类引用指向子类叫向上转型，属于自动 反之 123456789101112public class TestPolym&#123; public static void main(String[] args)&#123; Animal animal=new Dog(); animal.shout(); //不能运行animal.seeDoor();需要强制转换 Dog d =(Dog)animal; d.seeDoor(); &#125; static void animalCry(Animal a)&#123; a.shout(); &#125;&#125; Object类所有类是Object的子类 toString返回地址1234567891011121314public class tosting &#123; String name; String pwd; @Override public String toString() &#123; return &quot;用户名&quot;+name+&quot;密码&quot;+pwd; &#125; public static void main(String[] args)&#123; tosting to=new tosting(); System.out.println(to.toString()); &#125;&#125; equals和====代表对方是否相同，type和地址 equals()比较内容相同 equals()默认比较两个对象的hashcode 可以重写equals 重写equals()1234567891011121314151617181920212223public class TestObject extends Object&#123; int id; String name; String pwd; public TestObject(int id,String name,String pwd)&#123; this.name=name; this.pwd=pwd; this.id=id; &#125; @Override public boolean equals(Object o)&#123; if(this==o)return true; if(o==null||getclass()!=o.getClass())return false; return id==that.id; &#125; public String toString()&#123;return &quot;用户名:&quot; +name+&quot;密码:&quot;+pwd;&#125; public static void main(String[] args)&#123; TestObject t= new TestObject(1001,&quot;zhangshan,&quot;123456); TestObject t2=new TestObject(1001,&quot;zhangwu,&quot;123123123); System.out.println(t.equals(t2)); &#125;&#125; supersuper可以看作直接父类对象的引用 在一个类中，若是构造方法第一行没有第哦啊用super或者this java默认调用 12public class test 抽象类和接口抽象方法和抽象类 抽象方法 ** 使用abstract修饰方法 没有方法体 只有声明 定义是一种规范 就是告诉子类必须要给抽象方法具体实现 抽象类 包含抽象方法的类叫抽象类 通过抽象类可以严格限制子类的设计，使得子类之间梗通用 接口interface是一组规范，所以类要遵守","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"日常分享","slug":"日常分享","date":"2022-02-16T12:35:32.000Z","updated":"2022-04-19T15:17:12.336Z","comments":true,"path":"2022/02/16/日常分享/","link":"","permalink":"http://example.com/2022/02/16/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/","excerpt":"","text":"虽然说折磨黑苹果是快乐的事情，但是你选择了淘宝120元的服务。说实话，我这台黑苹果 是一体机戴尔optiplex5260，我高中的时候也试过很多个EFI，也没有成功，无奈选择了淘宝的黑苹果服务，师傅花了三四小时换EFI，最后终于弄成半完美。 123456戴尔optiplex5260i58500uhd630三星DDR4 2666hz目前还有麦克风不能用，耳机只能用蓝牙以外都没有太大的问题了，xcode完美使用 链接：https://pan.baidu.com/s/1ofmjPTdfuhRmyOi2owbIyw提取码：yhc1 在mac上敲代码和win的体检不太一样，mac的idea多了些功能比如说符号。 xcode是纯英文，使用起来有些困难。","categories":[],"tags":[{"name":"黑苹果","slug":"黑苹果","permalink":"http://example.com/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"闲谈","slug":"闲谈","permalink":"http://example.com/tags/%E9%97%B2%E8%B0%88/"}]},{"title":"swift学习笔记","slug":"swift学习笔记","date":"2022-01-21T13:16:51.000Z","updated":"2022-04-19T14:59:40.293Z","comments":true,"path":"2022/01/21/swift学习笔记/","link":"","permalink":"http://example.com/2022/01/21/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"乐，swift确实是一门好的语言，但是我恐怕没有时间学它","text":"乐，swift确实是一门好的语言，但是我恐怕没有时间学它","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"http://example.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"http://example.com/tags/ios/"}]},{"title":"2021review","slug":"2021Review","date":"2022-01-17T15:35:02.000Z","updated":"2022-04-28T03:39:04.474Z","comments":true,"path":"2022/01/17/2021Review/","link":"","permalink":"http://example.com/2022/01/17/2021Review/","excerpt":"创建了自己的博客这么久，对于大一上学期自己学习生活做一个简单的总结和记录学习和生活。","text":"创建了自己的博客这么久，对于大一上学期自己学习生活做一个简单的总结和记录学习和生活。 高考-&gt;被录取-&gt;入学-&gt;健翔桥两个月-&gt;沙河 高考我在高中的时候最渴望的事情就是摆脱高中的各种约束和奇怪的规则，现在我确实离开了我的母校，但现在又有些怀念起我的母校了。 记得初入学的我是那么有朝气，对美好的高中生活有着很强烈的渴望。但是在疫情后被改变了。 后来疫情缓解后，再次回到母校，一些原因让我对它，有些失望。直到我毕业典礼那天，我知道以往后我不会再次来到这熟悉的教室和操场了，不仅仅有些怀念起来了，这或许就是斯德哥尔摩效应吧。 高考我是在西城护国寺考的老实说吧，这几天给我留下了相当深刻的印象，忘不掉我和父亲在老旧街道走行，他为我讲述过往的荣誉与血泪。忘不掉亲自看见北京四中长什么样子。忘不掉的是那156中学。说起来也巧，我隔壁班就一位和我一起在156中学考试的小语种考生。 录取高考后等成绩是最焦虑的，老实说吧我看到成绩单那时候，真的傻了，考的是我我有史以来最差的一次（21北京数学和化学历年最难，而且日语也出现了十年未有的书信类） 本来信息科大是我的铺底学校，但为了保护志愿不被调剂，被迫将信息科大放到了志愿置顶。等录取是很漫长焦虑，当我拿到录取通知书那天，就像碇シンジ和渚カヲル在海边相遇那天。我万分惊喜，珍惜地拿着属于我荣誉。高中的血与泪在那天化为灰烬。 我们的情人不过是随便借个名字，用幻想吹出来的肥皂泡…… 好了，收下吧！ 你可以假戏真做。 我本来是无病呻吟，漫无目的地吐露爱情……但你是可以让漂泊不定的鸟儿于此的人。 好了，收下吧。用毫无实际的雄辩 你总有一天也会明白的…… 《西哈诺 德 贝热拉克》 健翔桥漫长的暑假过去了，我来到了健翔桥校区，它很小但是却很温馨。 我很喜欢盘古大厦，每当我迷失在北四环的时候永远是它，作为了我们回到学校指路的灯塔。有时候在浓雾中，盘古大厦若隐若现，就像随时崩塌的样子。 从学二走到教学楼，不到三两分钟。 我在健翔桥印象最深的是学哥学姐日日夜夜在阶梯教室奋斗自习，计算机学院拿着笔记本用着编译器敲代码的样子可以说是健翔桥的一道美丽的风景线了 后来我等到了心中早已期待很久的iFlab社团的招新，记得面试那天是北京入冬来第一场大雪!我是第一位面试的，面对学长的提问我确实慌张了，同时也对未来更加充满了期望。 入社后，我接触了不少厉害的CS大佬，以及各种新生CS卷王。我还编了个笑话，我在电信二班认识的人，还不如未来转入计科班人多。（现在我已经没有转CS的想法了） 两个月很快就过去了，老实说吧，健翔桥虽然是八人间，但是我依然恋恋不舍，不想和优秀的学哥学姐离开。这一天还是来了。 沙河昌平是神奇的地方，我姑姑在这里上学，我父亲第一份工作就在这里，未来几年我也继续在昌平上学，每天的龙泽地铁总是会被挤满北漂和上班族，还记得一次做昌58来的学校，经过某一站的时候，人突然满了，这是比在北四环座公交车从来没有的感觉。 我在沙河又认识到了不少专业的强者，以及有思想的人。 2021年对我来说是挑战是机遇，虽然有很多失望的事情。 但是我希望我在2022年，尽量不让自己留下太多的遗憾。 2022年我的期望的目标 交女朋友 自己用ARDUINO做个闹钟 学自己真正喜欢的 一定要学好英语！！！！ 我的朋友，如果你对2021年留有遗憾，对2022年充满期待，那么我会祝福你，在2022不留遗憾，成为自己所期待的那样。我们会在下一年的年终问题里，寻找你的答案。 人よ、幸福たれ！ ——《素晴らしき日々》","categories":[],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"http://example.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"}]},{"title":"数据结构学习笔记","slug":"数据结构","date":"2022-01-15T06:11:27.000Z","updated":"2022-05-23T10:45:25.231Z","comments":true,"path":"2022/01/15/数据结构/","link":"","permalink":"http://example.com/2022/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"Algorithms + Data Structures = Programs","text":"Algorithms + Data Structures = Programs 数据结构与算法 严蔚敏 王卓_哔哩哔哩_bilibili 一.导论1.基本概念和术语Data 数据Data Element 数据元素node节点Data Ltem 数据项Data Object数据对象 2数据结构 Data Structure数据结构包括以下三个部分 数据结构之间的逻辑关系 也叫逻辑结构 数据元素关系在计算机内存中的表示 也叫数据结构的物理结构或者数据的存储结构 数据的运算和实现 即对数据结构元素可以施加操作也i及在对应存储结构的实现 逻辑结构 3.数据类型一些基本的数据结构可以用数据类型实现，如数组字符串等而另一些常用的数据结构如栈队列 树图不能直接用数据类型表示 抽象数据类型可以用DSP三元组表示出来 D是数据对象 S是D上的关系集 P是对D的基本操作集 定义格式 12345678910111213Abstract Data Type 抽象数据类型名&#123;数据对象数据关系基本操作&#125;Abstract Data Type抽象数据名基本操作定义格式为基本操作名（参数表）初始条件《初始条件描述》操作结果《操作结果描述》参数表：赋值参数 职位操作提供输入值 引入参数&amp;打头 除可提供输入值外 还将返回操作结果 4算法 有穷性 确定性 可行性 输入 输出 算法的设计和要求 正确性 可读性 健壮性 高效性（鲁棒性） 5.算法的分析1.时间效率算法的时间效率的度量 算法运行时间＝每条语句频度语句执行一次时间 123456789n*n矩阵相乘的算法for(i=1;i&lt;=n,i++)//n+1次 for(j=1;j&lt;=n;j++)//n（n+1） c[i][j]=0;//n*n for(k=0;k&lt;=n;k++)//n*n*（n+1） c[i][j]=c[i][j]+a[i][k]*b[k][j];//n*n*n执行n*n*n T（n）为2n^3+3n^2+2n+1 算法时间复杂度的渐进表示法 比较算法比较我们仅仅比较数量级 T1(n)=10*n^2和T2(n)=5n^3 O 前者好 有一个辅助的f（n）使得当n无限大，T(N)/F(N)极限为不同为零的常熟 则称f（n）是t（n）的同数级函数 记作T(n)=O（f(n)） 称O（f(n)）为算法的渐进时间复杂度简称为时间复杂度 F(n)=n^m+n^m-1…….则T(N)=o(N^M) 算法基本操作次数也和问题输入而不同 12345678910比如说 for(i=0;i&lt;n,i++) if(a[i]==e)return i+1; return 0;最好只有一次执行最坏要执行n次 最坏时间复杂度：最坏情况下最好时间复杂度：最好情况下平均时间复杂度为O(n) 复杂的算法，可以分成几部分利用O的加乘法则 加法T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))) 乘法T(n)=T1(n)xT2(n)=O(f(n))xO(g(n))=O((f(n)xg(n)) 2空间复杂度算法所要的存储空间度量 S（n）=O（f（n）） n为为问题的规模 123456789101112将一维数组a的n个数逆序放到元素组for(i=0;i&lt;n/2;i++)&#123; t=a[i]; a[i]=a[n-i-1]; a[n-1-i]=t;&#125;//空间复杂度为O（1）for(i=0;i&lt;n;i++)b[i]=a[n-1-i];for(i=0;i&lt;n;i++) a[i]=b[i];//空间复杂度为O（n） 二.线性表linear list1线性表的定义和特点 例子 如26英文字母 数据元素都是字母为线性 线性表的逻辑特征在非空中有且仅有一个开始或者终端的结点，他没有前趋而仅有一个后续a2 或者没有后趋，而仅有一个直接前趋an-1 案例引入一元多项式 2.线性表的类型定义 基本操作 lnitlist（&amp;L）构造一个空的线性表L DestroyList（&amp;L）初始条件线性表已经有了 操作结果摧毁线性表 ClearList（&amp;L）初始条件线性表存在了 操作结果重置为空表 ListEmpty（L）初始条件 线性表存在 操作结果如果为空表为ture ListLength（L）初始条件 线性表存在 操作结果返回L中数据元素个数 GetElem（L，i，&amp;e）初始太久存在 操作结果用e返回L中第i哥元素值 LocateElem（L，e，compare（））初始线性表存在，compare是数据元素判定函数 操作结果返回L中第一个与e满足compare的数据元素的位序若这样的数据元素不存在返回0 PriorElem(L,cur_e,&amp;pre_e)初始为L存在 操作结果cur_e为L的元素，不是第一个，则pre_e返回他的前驱，否则操作失败 pre_e没有意义 NextElem(L,cur_e,&amp;next_e)初始L存在，如果cur存在返回后继 Listinsert（&amp;L，i，e）L存在 L在第i个位置之前插入新的元素e，L的长度加1 ListDelete（&amp;L，i，&amp;e）L存在 删除L的第i个元素，用e返回，L减一。 ListTraversr（&amp;L，visited（））L存在 操作结果依次对线性表中每个元素调用visited（） 3.线性表的顺序表示和实现12345678910111213141516171819//顺序表的类型定义typedef struct&#123; ElemType data[];//*data为动态分配 int length;&#125;SqList;//SqList L;L.data=(ElemType*)malloc(sizeof(ElemTAype)*M)////#define LIST_INTI_SIZE 100typedef struct &#123; int elem[LIST_INTI_SIZE]; int length;&#125;Sqlist; 12345678910111213141516171819202122//多项式的顺序存储结构类型定义#define MAXSIZE 1000//最大长度typedef struct &#123; float p; int e;&#125;Polynomial;typedef struct &#123; Polynomial* elem;//存储基地址//数组 int length;//当前的项个数&#125;SqList;//图书表的顺序存储#define MAXSIZE 1000typedef struct &#123; char no[20]; char name[50]; float price;&#125;book;typedef struct &#123; book* elem; int length;&#125;SqList; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &quot;stdio.h&quot; #include &quot;stdlib.h&quot; #include &quot;math.h&quot; #include &quot;time.h&quot;#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0//#define OVERFLOW -2#define INFEASIBLE -1#define MAXSIZE 20 typedef char ElemType;typedef int Status;typedef struct&#123; ElemType *elem; int length;&#125;SqList;//1.线性表的初始化Status InitList_Sq(SqList* L)&#123; //分配空间 L-&gt;elem = (ElemType*)malloc(sizeof(ElemType) * MAXSIZE); //L-&gt;elem = new ElemType[MAXSIZE]; C++写法 if (!L-&gt;elem)exit(OVERFLOW);//分配失败 L-&gt;length = 0; return OK;//空表长度为零&#125;//2.摧毁线性表Lvoid DestroyList(SqList* L)&#123; if (L-&gt;elem) free(L-&gt;elem);//delete L-&gt;elem;释放空间&#125;//3.清空线性表void ClearList(SqList* L)&#123; L-&gt;length = 0;//将线性表长度为0&#125;int GetLength(SqList* L)&#123; return (L-&gt;length);&#125;//4判断线性表为空int IsEmpty(SqList L)&#123; if (L.length == 0) return 1; else return 0;&#125;//5顺序表的取值int GetElem(SqList L, int i, ElemType&amp; e)&#123; if (i&lt;1 || i&gt;L.length) return ERROR; e = L.elem[i - 1]; return OK;&#125;//6插入Status Listlnsert_Sq(SqList* L, int i, ElemType e)&#123; int j; if (i&lt;1 || i&gt;L-&gt;length + 1)return ERROR; if (L-&gt;length == MAXSIZE) return ERROR; for (j = L-&gt;length; j &gt;= i - 1; j--) L-&gt;elem[j+1] = L-&gt;elem[j]; L-&gt;elem[i - 1] = e; L-&gt;length++; return OK;&#125;//7删除Status ListDelete_Sq(SqList* L, int i)&#123; int j; if (i&lt;1 || i&gt;L-&gt;length) return ERROR; for (j = i; j &lt;= L-&gt;length; j++) L-&gt;elem[j - 1] = L-&gt;elem[j]; L-&gt;length--; return OK;&#125;int main()&#123; SqList L; InitList_Sq(&amp;L); GetLength(&amp;L);&#125; 优点 存储量大 可以随机读取表中的元素 缺点 增删要移动大量元素 浪费存储空间 静态 4线性表的链式 结点：数据元素的存储映像。由数据域和指针域 链表：N个结点由指针域组成链表 它是线性表的链式存储映像名称为线性表的链性存储 1.单链表结点只有一个指针域的链表 特点 结点在存储器的位置是任意的，即逻辑上相邻的数据元素，在物理上不一定 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后，寻找第一个和最后一个结点 栈与队列栈与队列是两个常用的 栈与队列是限定插入和删除只能在表的端点进行的线性表 12Insert(S,n+1,x) Delete(S,n)Insert(Q,n+1,x) Delete(Q,1) 栈—后进先出 使得栈成为有用的工具，数据转换，表达式，函数调用，递归，括号 2队列—先进先出 解决排队问题 脱机打印 多用户系统 等 栈stack特殊的线性表，是限定在一段，通常是表尾，进行插入和删除操作的线性表 相关概念后进an top栈顶 表头a1为base 插入元素到栈顶叫入栈（压）push，反之为入栈（弹出）pop 栈的定义 定义：限定在表的一端进行插入和删除的运算线性表 逻辑结构：通线性表一对一的关系 存储结构：顺序表更常见 只能在栈顶运算 入栈和出栈函数 案例进制转换十进制N想其他进制数d（二八十六） 法则为：除以d倒取余 n=（n div d）*d + n mod d div为整除运算 mod为求余 例子十进制159转八进制 1234159/8=19...719/8=2...32/8=0..2（237）8 括号匹配的验证表达式求值操作数和运算符和界限符 为了实现表达式求值设置两个栈 OPTR寄存运算符 操作数栈OPND用于寄存运算数和运算结果 栈的表示和操作1234567ADK Stack&#123;数据对象D=&#123;ai|ai属于ElemSet&#125;数据关系R1=&#123;&lt;ai-1,ai&gt;&#125;an端为栈顶，a1为栈底初始化 进栈出栈 取栈顶等&#125;ADT Stack 1234567891011121314151617InitStack(&amp;S)初始化操作 构造一个空栈SDestoryStack(&amp;S) 销毁栈操作初始条件S存在，结果销毁StackEmpty 判断是否为空S存在 空true 否为falseStackLength(S)求栈的长度S存在 返回S的个数，即栈长度GetTop(S,&amp;e)去栈顶S存在且为空用e返回S的栈顶元素ClearStack清空Push(&amp;S,e)入栈 顺序栈的实现，同一般线性表的顺序存完全相同 123456#define MAXSIZE 100typedef struct&#123; SElemType *base; SElemType *top; int stacksize&#125;Sqstack; 初始化1234567Status InitStack(SqStack &amp;S)&#123; S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType)); if(!S.base)exiu(OBERFLOW); S.top=S.base; S.stacksize=MAXSIZE; return OK;&#125; 判断是否为空 12345Status StackEmpty(SqStack S)&#123; if(S.top==S.base)return TRUE; else return FALSE;&#125; 顺序栈长度 123int StackLength(SqStack S)&#123;return S.top-S.base;&#125; 清空 1234Status ClearStack(Sqstack &amp;S)&#123;if(S.base)S,top=S.base;return OK;&#125; 销毁 12345678Status DestroyStack(Sqstack &amp;S)&#123; if(S.base)&#123; delete S.base; S.stacksize=; S.base=S.top=NULL; &#125; return OK;&#125; 入栈 123456Status Push (SqStack &amp;S,SElemType e)&#123; if(S.top-S.base==S.stacksize)return ERROR; *S.top=e; S.top++; return OK;&#125; 出栈 12345Status Ppo(SqStack &amp;S,SElemType&amp;e)&#123; if(S.top==S.base)return ERROEL; E=*--s.TOP; return OK;&#125; 链栈123456typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStack;LinkStack S; 链表的初始化 1234void InitStack(LinkStack &amp;S)&#123; S=NULL; return ok;&#125; 入栈 1234567Status Push(LinkStack &amp;S,SElemType e)&#123; p=new stacknoode; p-&gt;data=e; p-&gt;newt=S; S=p; return OK;&#125; 出栈 12345678Status Pop(LinkStack&amp;S,SElemTyoe &amp;e)&#123; if(S==NULL)return ERROE; e=s-&gt;data; p=S; S=S-&gt;next; delete p; &#125; 栈与递归递归定义的函数 递归数据结构 递归解法 队列queue先进先出FiFO 表一插入，在另一端表头删除 队列的相关概念 定义 头删尾插 逻辑结构 一对一先信标 循环和链队 之恶能在对手和队尾 入和出 队 树树的定义Tree是由包括零，多个结点的有限集，分为空树","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"C++学习笔记","slug":"CPP学习笔记","date":"2022-01-12T11:52:47.000Z","updated":"2022-04-19T15:09:27.630Z","comments":true,"path":"2022/01/12/CPP学习笔记/","link":"","permalink":"http://example.com/2022/01/12/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"C++的学习笔记，恐怕要22年暑假才能学完吧","text":"C++的学习笔记，恐怕要22年暑假才能学完吧 1.C++认识1.1123456789101112#include&lt;iostream&gt;using namespace std:int main()&#123; cout&lt;&lt;&quot;hello world&quot;&lt; system(&quot;pause&quot;); return 0;&#125;cin&gt;&gt;a&gt;&gt;b;&lt; 因为一些事情，突然有了这样的创意。两人之间如果只用手机而且对方不看手机，来通过震动来传递简单的信息，我想到了用摩斯密码的短长可以用震动来代替，因此可以传达简单的信息，比如说测视力上下左右，就可以用摩斯密码来表示出来。目前我打算学习java，先了解安卓的程序语言基础，然后再研究下。2022/2/21","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"},{"name":"cpp","slug":"编程/cpp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/tags/cpp/"}]},{"title":"通信学院期末C复习题","slug":"期末考试C语言复习题","date":"2021-12-16T08:12:14.000Z","updated":"2022-04-19T15:08:55.114Z","comments":true,"path":"2021/12/16/期末考试C语言复习题/","link":"","permalink":"http://example.com/2021/12/16/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E9%A2%98/","excerpt":"BISTU 通信学院2021C语言期末考试题 每道题一定有多个写法，碍于时间我不能全部写出来，也没有这个能力，所以这些答案仅仅用于参考 因为写的时间紧所以可能有些小的错误请多见谅","text":"BISTU 通信学院2021C语言期末考试题 每道题一定有多个写法，碍于时间我不能全部写出来，也没有这个能力，所以这些答案仅仅用于参考 因为写的时间紧所以可能有些小的错误请多见谅 A易A阶段中大多数都是简单的题 12345主要的知识点为if，math.h里面的函数ASCII%d %fint char float等类型 1.温度转换 12345678910#include&lt;stdio.h&gt;int main()&#123; float f,c; printf(&quot;请输入华氏温度:&quot;); scanf(&quot;%f&quot;,&amp;f); c=(5.0/9)*(f-32); printf(&quot;转换成摄氏度是:%f\\n&quot;,c); return 0;&#125; 2.BMl计算输入身高（米）和体重（千克）计算 BMI 值，其中 BMI 值计算公式为，BMI = 体 重/身高^2。（实验一题目） 12345678#include&lt;stdio.h&gt;int main()&#123; float bmi, h, w; scanf_s(&quot;%f %f&quot;, &amp;h, &amp;w); bmi = w / (h * h); printf(&quot;%f&quot;, bmi);&#125; 3.大写转小写给定一个大写字母，要求用小写字母输出。提示：大写字母比小写字母的 ASCII 码 小 32。（第 3 章例题 123456789#include&lt;stdio.h&gt;int main()&#123; char a; scanf(&quot;%c&quot;,&amp;a); a=a+32;//ASCii中大写在前面 printf(&quot;%c&quot;,a); &#125; 4.由小到大排列输入两个实数，按由小到大的顺序输出这两个数。（第 4 章例题 12345678910#include&lt;stdio.h&gt;int main()&#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); if(a&lt;b) printf(&quot;%d&lt;%d&quot;,a,b); else printf(&quot;%d&lt;%d&quot;,b,a);&#125; 5.一元二次方程求 ax2+bx+c=0 方程的根。a,b,c 由键盘输入。需要在程序中进行判别，如果 b2- 4ac≥0，就计算并输出方程的两个实根，如果 b2-4ac&lt;0，就输出“此方程无实根” 的信息。（第 4 章例题 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;math.h&gt;//提供sqrt函数int main()&#123; float a, b, c; scanf_s(&quot;%f %f %f&quot;, &amp;a, &amp;b, &amp;c); float data; data = (b * b - 4 * a * c); if (data &lt; 0) &#123; printf(&quot;没有实数根&quot;); &#125; else if (data == 0) &#123; printf(&quot;x=%f&quot;, ((-b) / 2 * a)); &#125; else &#123; printf(&quot;x1=%f x2=%f&quot;, (sqrt(data)) - b / 2 * a, (-sqrt(data)) - b / 2 * a); &#125; &#125; 6.计算三角形面积给出三角形的三边长，求三角形面积。这题可以通过海伦公式快速解题 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; float a, b, c; float p; scanf_s(&quot;%f %f %f&quot;, &amp;a, &amp;b, &amp;c); p = (a + b + c) / 2; if (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) &#123; printf(&quot;%f&quot;, sqrt(p * (p - a) * (p - b) * (p - c))); &#125; else printf(&quot;三角形不存在\\n&quot;);&#125; 7.判断是否为大写输入一个字符，判别它是否为大写字母，如果是，将它转换成小写字母；如果不是， 不转换。然后输出最后得到的字符。（第 4 章例题 12345678910111213// 输入一个字符，判断它是否为大写字母，如果是，将它转换成小写字母，如果不是不转换 #include &lt;stdio.h&gt; int main()&#123; char ch; scanf(&quot;%c&quot;,&amp;ch); if(ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) ch = ch + 32; printf(&quot;%c\\n&quot;,ch);&#125; 8.成绩等级输入一个学生的成绩，使用 if else 语句输出该同学的成绩属于以下哪个等级。（实 验二） 60 分以下：不及格 60-70 分：及格 70-90 分：良好 90-100 分：优秀 123456789101112#include &lt;stdio.h&gt;int main()&#123; int score; scanf_s(&quot;%d&quot;, &amp;score); if (score &gt;= 90) printf(&quot;优\\n&quot;); if (score &gt;= 80 &amp;&amp; score &lt;= 89) printf(&quot;良\\n&quot;); if (score &gt;= 70 &amp;&amp; score &lt;= 79) printf(&quot;中\\n&quot;); if (score &gt;= 60 &amp;&amp; score &lt; 69) printf(&quot;及格\\n&quot;); if (score&lt;60) printf(&quot;不及格\\n&quot;);&#125; 9国民生产假如我国国民生产总值的年增长率为 7%，计算 10 年后我国国民生产总值与现在 相比增长多少百分比。计算公式为p=(1+r)^n n为年 r为增长率 1234567891011#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; float p,r,n; r=0.07; n=10; p=pow(1+r,n); //pow(a,b)a的b次幂 printf(&quot;p=%f\\n&quot;,p);&#125; 10.破解密码请编程序将“China”译成密码，密码规律是：用原来的字母后面的第 4 个字 母代替原来的字母。例如，字母“A”后面第 4 个字母是“E”，用“E”代替“A”。 字母表最后四个字母“WXYZ”，替代为“ABCD”。因此，“China”应译为“Glmre”。 （第 3 章课后习题 123456789101112#include&lt;stdio.h&gt;int main()&#123; char c1=&#x27;C&#x27;,c2=&#x27;h&#x27;,c3=&#x27;i&#x27;,c4=&#x27;n&#x27;,c5=&#x27;a&#x27;; c1 = c1 + 4; c2 = c2 + 4; c3 = c3 + 4; c4 = c4 + 4; c5 = c4 + 4; printf(&quot;%c%c%c%c%c\\n&quot;, c1, c2, c3, c4, c5);&#125; B中12到这里就开始出现if while for switch等函数 11.闰年典中典的题了 判断分两种情况，一个是能被400整除，一个是能被4整数但不能被100整除四年一闰,百年不闰 四百年再闰 1if(a%400==0||a%4==0&amp;&amp;a%100!=0) 12.阶乘用 C 语言求 12!，并画出流程图。（第 5 章课后习题） 123456789#include&lt;stdio.h&gt;int main()&#123; int n, sum = 1; for (int i = 1; i &lt;= 12; i++) sum = sum * i; printf(&quot;%d&quot;, sum);&#125; 13.判断位数使用循环结构设计一个程序，用户从终端输入一个整数，输出其是几位整数。 （实验二） 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int n = 0, a; scanf_s(&quot;%d&quot;, &amp;a); while (a &gt; 0) &#123; a = a / 10; n++; &#125; printf(&quot;%d&quot;, n);&#125; 14.逆转数字从键盘输入一个四位的整数 num，将其个、十、百、千位倒序生成一个数字输 出。例如：输入 1234，输出 4321。（第 4 章课后习题） 123456789101112#include&lt;stdio.h&gt;int main()&#123; int a,b=0; scanf_s(&quot;%d&quot;, &amp;a); while (a&gt;0) &#123; b = b * 10 + a % 10; a = a / 10; &#125; printf(&quot;%d&quot;, b);&#125; 15.分段函数y=x (x","categories":[],"tags":[{"name":"考试","slug":"考试","permalink":"http://example.com/tags/%E8%80%83%E8%AF%95/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Python基础","slug":"Python基础","date":"2021-12-04T07:22:31.000Z","updated":"2022-04-19T15:17:39.963Z","comments":true,"path":"2021/12/04/Python基础/","link":"","permalink":"http://example.com/2021/12/04/Python%E5%9F%BA%E7%A1%80/","excerpt":"学习笔记","text":"学习笔记 1.Python的基本语法1Python的交互和脚本式交互式是不创建脚本文件，通过解释器的交互模式来编写代码脚本式，为创建.py格式进行执行 2标识符在 Python 里，标识符由字母、数字、下划线组成。 在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。 Python 中的标识符是区分大小写的。 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。 Python 可以同一行显示多条语句，方法是用分号 ; 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ `\\ ` 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` =`^= &gt;&gt;= &lt;&lt;= （复合）赋值运算符 3.保留字 and exec not assert finally or break for pass class from print continue global raise def if return del import try elif in while else is with except lambda yield 2数据类型1整数python可以写任意大的整数 如果出现很大的数比如说10000000可以写成10000_000 2浮点数浮点数可以用科学计数法来表示比如说1.23*10七次幂可以写1.23e9, 0.0015等于1.5e-3 数值运算函数round12round(11.111,2)这个函数是四舍五入round(x[,d])d为保留位数默认为0// 11.11 abs1abs（x）绝对值 pow1234pow(x,y[,z])幂余pow(2,3,3)//2 divmod123商余divmod(10，3）//（3，1） 3.字符串字符串是以单引号或者双引号写出来的 字符串内部中有”或者‘可以通过\\来表示 12345678910111213141516171819202122232425262728293031323334353637&#x27;I\\&#x27;m \\&quot;OK\\&quot;!&#x27;I&#x27;m &quot;OK&quot;!str1 = &#x27;hello, world!&#x27;# 通过内置函数len计算字符串的长度print(len(str1)) # 13# 获得字符串首字母大写的拷贝print(str1.capitalize()) # Hello, world!# 获得字符串每个单词首字母大写的拷贝print(str1.title()) # Hello, World!# 获得字符串变大写后的拷贝print(str1.upper()) # HELLO, WORLD!# 从字符串中查找子串所在位置print(str1.find(&#x27;or&#x27;)) # 8print(str1.find(&#x27;shit&#x27;)) # -1# 与find类似但找不到子串时会引发异常# print(str1.index(&#x27;or&#x27;))# print(str1.index(&#x27;shit&#x27;))# 检查字符串是否以指定的字符串开头print(str1.startswith(&#x27;He&#x27;)) # Falseprint(str1.startswith(&#x27;hel&#x27;)) # True# 检查字符串是否以指定的字符串结尾print(str1.endswith(&#x27;!&#x27;)) # True# 将字符串以指定的宽度居中并在两侧填充指定的字符print(str1.center(50, &#x27;*&#x27;))# 将字符串以指定的宽度靠右放置左侧填充指定的字符print(str1.rjust(50, &#x27; &#x27;))str2 = &#x27;abc123456&#x27;# 检查字符串是否由数字构成print(str2.isdigit()) # False# 检查字符串是否以字母构成print(str2.isalpha()) # False# 检查字符串是否以数字和字母构成print(str2.isalnum()) # Truestr3 = &#x27; jackfrued@126.com &#x27;print(str3)# 获得字符串修剪左右两侧空格之后的拷贝print(str3.strip()) 字符串函数 find返回从左边第一个指定的字符索引，找不到返回-1 index返回从左边第一个字符索引，找不到报错 123456str = &quot;abcde&quot;print(str.find(&#x27;c&#x27;))//2str = &quot;hello world&quot;a = str.index(&#x27;w&#x27;)print(a)//6 sqlit字符串的拆分 12str = &quot;hello world&quot;print(str.split(&#x27; &#x27;))//[&#x27;hello&#x27;, &#x27;world&#x27;] chr(x) ord(x) 字符串的方法方法必须用.方式 八种重要字符串的方法 str.lower str.upper() 返回字符串的副本，全部为大小写 str.split(sep=None)返回一个列表，由str根据sep被分割的部分组成 12&quot;a,b,c&quot;.split(&quot;,&quot;)# [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] str.count(sub)返回子串sub在str中中出现个数 12&quot;aabbaa&quot;,count(&quot;a&quot;)# 4 str.replace(old,new)返回str的副本，所以old子串被替换为new 12“python&quot;.replace(&quot;n&quot;,&quot;n123.io&quot;)# python123.io 字符串的格式化python用于槽方式以及format方式 1&quot;&#123;&#125;是世界上最好用的语言之一，而&#123;&#125;是效率最高的语言&quot;.format(&quot;python&quot;,&quot;c++&quot;) 4布尔值只有两个True和False 布尔值可以tong过and or not表达 123456789101112&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not FalseTrue 5.空值用None表示，不能单纯理解为0 6变量重点python中 1a=&#x27;abc&#x27; python解释器干了两个事情 在内存中创建了‘abc’的字符串 在内存中创建a的变量指向‘abc’ 7.常量8.listlist是一种有序的集合，可以进行修改或者删除 1classmates=[&#x27;song&#x27;,&#x27;wang&#x27;,&#x27;zhang&#x27;] 使用len可获取list元素的个数 12&gt;&gt;&gt; len(classmates)3 索引 切片[start: end:step]用索引可以访问list的元素 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; classmates[0]&#x27;song&#x27;&gt;&gt;&gt; classmates[1]&#x27;wang&#x27;&gt;&gt;&gt; classmates[2]&#x27;zhang&#x27;&gt;&gt;&gt; classmates[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range list1 = [1, 3, 5, 7, 100]print(list1) # [1, 3, 5, 7, 100]# 乘号表示列表元素的重复list2 = [&#x27;hello&#x27;] * 3print(list2) # [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]# 计算列表长度(元素个数)print(len(list1)) # 5# 下标(索引)运算print(list1[0]) # 1print(list1[4]) # 100# print(list1[5]) # IndexError: list index out of rangeprint(list1[-1]) # 100print(list1[-3]) # 5list1[2] = 300print(list1) # [1, 3, 300, 7, 100]# 通过循环用下标遍历列表元素for index in range(len(list1)): print(list1[index])# 通过for循环遍历列表元素for elem in list1: print(elem)# 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值for index, elem in enumerate(list1): print(index, elem) 当然我们也可以通过负数来索引 12&gt;&gt;&gt; classmates[-1]&#x27;zhang&#x27; 增删因为list为可变的有序表 append 123&gt;&gt;&gt; classmates.append(&#x27;zhao&#x27;)&gt;&gt;&gt; classmatesclassmates=[&#x27;song&#x27;,&#x27;wang&#x27;,&#x27;zhang&#x27;,&#x27;zhao&#x27;] 元素想插入到指定的位置中.insert 12345&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)&gt;&gt;&gt; classmates&gt;&gt;&gt; classmates.append(&#x27;zhao&#x27;)classmates=[&#x27;song&#x27;,&#x27;jack&#x27;,&#x27;wang&#x27;,&#x27;zhang&#x27;,&#x27;zhao&#x27;] 删除末尾用 pop() 1234&gt;&gt;&gt; classmates.pop()&#x27;zhao&#x27;&gt;&gt;&gt; classmates[&#x27;song&#x27;,&#x27;jack&#x27;,&#x27;wang&#x27;,&#x27;zhang&#x27;] 想删除指定的位置用pop(i) 1234&gt;&gt;&gt; classmates.pop(1)&#x27;Jack&#x27;&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;] 12345678910111213141516171819202122list1 = [1, 3, 5, 7, 100]# 添加元素list1.append(200)list1.insert(1, 400)# 合并两个列表# list1.extend([1000, 2000])list1 += [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]print(len(list1)) # 9# 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1: list1.remove(3)if 1234 in list1: list1.remove(1234)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]# 从指定的位置删除元素list1.pop(0)list1.pop(len(list1) - 1)print(list1) # [400, 5, 7, 100, 200, 1000]# 清空列表元素list1.clear()print(list1) # [] 生成式和生成器1234f = [x for x in range(1, 10)]print(f)f = [x + y for x in &#x27;ABCDE&#x27; for y in &#x27;1234567&#x27;]print(f) list中可以有不同类型的甚至list 123&gt;&gt;&gt; s = [22141, True, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;]&gt;&gt;&gt; len(s)4 9.tuple有序的列表叫tuple，tuple不能被修改 不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 123&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2) 如果tuple中出现list也是可以修改的 12345&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;&gt;&gt;&gt; t(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;]) 10dict（dictionary）其他的语言叫map 使用key-value dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下： 123&gt;&gt;&gt; d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;&gt;&gt;&gt; d[&#x27;Michael&#x27;]95 必须要有key才能读取value一个key只能有一个valuekey不存在报错 如果想删除只要删除key就可以了 11.setset和dict类型 是存放key的但是不存放value key不能重复 set具有数学上的set性质 比如无序，没有重复元素 1234567891011121314&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125; 3.基本函数1.判断和c语言基本相似 注意不要少写了冒号 1234567age = 3if age &gt;= 18: print(&#x27;your age is&#x27;, age) print(&#x27;adult&#x27;)else: print(&#x27;your age is&#x27;, age) print(&#x27;teenager&#x27;) 12345678910111213141516age = 3if age &gt;= 18: print(&#x27;adult&#x27;)elif age &gt;= 6: #elif等于else if print(&#x27;teenager&#x27;)else: print(&#x27;kid&#x27;) if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 2.循环python中的循环分为for in依次将list或者tuple中元素迭代 12345678names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]for name in names: print(name) //MichaelBobTracy 3.输出1234567891011121314print(&quot;hello world&quot;)# 可以输出字符串# 含有运算符的表达式print(88 * 88 - 55)# 将数据输出文件中 主要盘符要存在 使用file=p a+以读写状态，没有就新建fp = open(&#x27;E:/编程/python/text.txt&#x27;, &#x27;a+&#x27;)print(&#x27;hello world&#x27;, file=fp)# 输出到这个文件夹fp.close()# 关闭a, b = 5, 10print(f&#x27;&#123;a&#125; * &#123;b&#125; = &#123;a * b&#125;&#x27;) 4.针对数据类型的特征1.Slice在list或者tuple取元素 range函数 12345678&gt;&gt;&gt;list(range(0, 30, 5))[0, 5, 10, 15, 20, 25]&gt;&gt;&gt; list(range(0, 10, 2))[0, 2, 4, 6, 8]&gt;&gt;&gt; list(range(0, -10, -1))[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 12345678list中可以通过for来切片&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;] python有更简单的方法实现切片操作 12345678910111213141516171819&gt;&gt;&gt; L[0:3][&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]&gt;&gt;&gt; L[:3][&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]&gt;&gt;&gt; L[1:3][&#x27;Sarah&#x27;, &#x27;Tracy&#x27;]如果0-99提取前十&gt;&gt;&gt; L=list(rang(100))&gt;&gt;&gt; l[0,1,2....99]&gt;&gt;&gt; l[:10]l [0,1,...9]前十个，每两个取一个l[:10:2]l[::5] 2.lteration在python中通过for循环遍历list或者tuple叫迭送 3.列表生成式5基本库1time库time11648043734.0478468 ctime1Wed Mar 23 21:57:29 2022 gmtine1time.struct_time(tm_year=2022, tm_mon=3, tm_mday=23, tm_hour=13, tm_min=58, tm_sec=1, tm_wday=2, tm_yday=82, tm_isdst=0) 2022天天向上的力量一年365进步与退步千分之一365中工作五天进步百分之一，周末退步百分之一你和365天都在进步百分之一的卷仙一起工作，你工作日学习，但是休息日两天下降百分之一，那么你至少要在工作日学习百分之多少呢？ 123456789101112131415# daydayup.pydef dayUp(df): dayup = 1 for i in range(365): if i % 7 in[6,0]: dayup=dayup*(0.99) else: dayup =dayup*(1+df) return dayupdayfactor = 0.01while dayUp(dayfactor) &lt; 37.78: dayfactor+=0.001print(&quot;他工作日努力参数为&#123;:.3f&#125;&quot;.format(dayfactor))//0.019 文本进度条1234567891011# TextProBar1.pyimport timescale = 10print(&quot;........执行开始........&quot;)for i in range(scale+1): a=&#x27;*&#x27;*i b = &#x27;.&#x27;*(scale-i) c = (i/scale)*100 print(&quot;\\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c,a,b)) time.sleep(0.1)print(&quot;........结束........&quot;)","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Python","slug":"编程/Python","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"CSS基础","slug":"CSS基础","date":"2021-12-03T06:46:59.000Z","updated":"2022-04-19T15:09:58.416Z","comments":true,"path":"2021/12/03/CSS基础/","link":"","permalink":"http://example.com/2021/12/03/CSS%E5%9F%BA%E7%A1%80/","excerpt":"CSS前端三剑客的老二","text":"CSS前端三剑客的老二 1.CSS简介1html自身的局限性2CSS选择器css的规则主要由两个部分组成的 选择器和一条或者多条声明 12&lt;选择器 属性 值 coor red这句话是声明&gt;h1 &#123;color:red; font-size:25px;&#125; 简单来说，选择标签用的 选择器分为 基础选择器和复合选择器 基础又分为 标签选择器 类选择器 id选择器 通配符选择器 1.标签选择器html标签名词作为选择器 语法 123标签名&#123;属性1：属性值1；&#125; 123456789&lt;style&gt; p &#123;color: burlywood;&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;/body&gt; 优点为快速为同类型的标签同意设置样态 但是如果是出现多个相同的属性，会一同全部修改 2.类选择器 （常用）1.使用123.类名&#123;属性1:属性值；&#125; 123456789101112&lt;style&gt; p &#123;color: burlywood;&#125; .red&#123; color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;div class=&quot;red&quot;&gt;我想变成红色&lt;/div&gt;&lt;/body&gt; 盒子 1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .red&#123; width: 100px; height: 100px; /*背景颜色*/ background-color: red; &#125; .green&#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;red&quot;&gt;hong&lt;/div&gt; &lt;div class=&quot;green&quot;&gt;绿色&lt;/div&gt; &lt;div class=&quot;red&quot;&gt;hong&lt;/div&gt;&lt;/body&gt; 2.多类名在标签中class文件属性中写多个类名但是类名中间必须要用空格 123456789101112 &lt;style&gt; .red&#123; color:red; &#125; .font35&#123; font-size: 30px; &#125; &lt;/style&gt;&lt;body&gt; &lt;div class=&quot;red font35&quot;&gt;神乐同学&lt;/div&gt;&lt;/body&gt; 3.ID选择器id可以选择特定的属性 123456789 &lt;style&gt; #pink&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;pink&quot;&gt;dsadasda&lt;/div&gt;&lt;/body&gt; id选择用#定义 只能调用一次 二者区别在于使用次数id选择器一般用于页面唯一的元素，所以一般和JavaScript使用 4通配符选择器用*号定义，它可以表示所有的元素 2属性1.文字1font-family字体可用网络字体等 1234567891011 &lt;style&gt; h2&#123; font-family: &#x27;宋体&#x27;,&#x27;微软雅黑&#x27;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;我是来自北京信息科技大学的神乐&lt;/h2&gt; &lt;p&gt;我是来自北京信息科技大学的神乐&lt;/p&gt; &lt;p&gt;我是来自北京信息科技大学的神乐&lt;/p&gt;&lt;/body&gt; 2.font-size123&lt;style&gt;font-size:20px;&lt;/style&gt; px像素大小是网页中最常用的单位 谷歌浏览器默认字体问=为16px 不同浏览器字号大小不相同 body指定整个页面字体大小 3.font-weightcss中使用font-weight修改粗细程度 1234&lt;style&gt; .bold&#123;font-weight: bold;&#125;&lt;/style&gt;&lt;p class=&quot;bold&quot;&gt;神乐&lt;/p&gt; bold就是相当于加粗效果 相当于number700属性值 为400等于默认 700等于加粗 4font-style1234&lt;style&gt; .bold&#123;font-style: normal;&#125;&lt;/style&gt;&lt;p class=&quot;bold&quot;&gt;神乐&lt;/p&gt; 属性值中 normal为默认 italic为显示斜体如果em标签和属性为italic的会变正 5.font的复合用法比如说div字体斜体 加粗 字号16 微软雅黑 1234567891011&lt;style&gt; div&#123; font-size:16px; font-family:&#x27;Microsoft yahei&#x27;; font-weight:700; font-style:italic; &#125;&lt;/style&gt;&lt;div&gt; 古道西风瘦马&lt;/div&gt; 或者 位置严格要求不能换 除了size和family不能省略 1234567/*font: font-style font-weight font-size/font-height font-family;*/ 类 粗 大 家div&#123;font: itailc 700 16px &quot;微软雅黑&quot;;&#125; 2.文本文本属性分为 颜色 对齐 装饰文本 缩进 行间距 1.color颜色表示方法分为三种 预定义颜色值 十六进制 RGB代码 123456div&#123;color: deeppink;color: #ff0000;color: rgb(200,0,0);&#125; 2.text-align样态文本属性值分为：left默认,center居中,right右对齐 3.text-decoration属性值为none默认,underline下划线,overlines上划线,line-through删除线 4text-indent文本缩进 通常是首行的缩进 123text-indent:10px;text-indent:2em;/*em的意思为相对单位*/ 5line-height控制行间距离的高度 文本高度默认为16px 所以line-height:16px；就是没有行间距 3.css引入方式1内部样态表单独放在style中 方便 没有完全分离 2.行内样态表直接在标签内部使用 1&lt;p style=&quot;color:red;&quot;&gt;我是内容&lt;/p？ style就是属性 写法要符合css规范 3外部样态表1234这是文件名字为：style.css div&#123;color:red;&#125; 123456&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;syy.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是内容&lt;/div&gt;&lt;/body&gt; 4chrome调试工具点我查看 5.Emmet语法6.CSS复合选择器后代选择器,子选择器,并集选择器, 1.后代选择器 主要元素1 元素2{} 1234567891011 &lt;style&gt; ol li a &#123;color:pink&#125; .name li&#123;color: seagreen;&#125; &lt;/style&gt;&lt;ol&gt; &lt;li&gt;我是后代&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是孙子&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;name&quot;&gt; &lt;li&gt;我是神乐&lt;/li&gt;&lt;/ol&gt; 2.子选择器 重要3,并集选择器用逗号分隔开了 123456789div,p&#123;&#125;&lt;div&gt; &lt;/div&gt;&lt;p&gt; &lt;/p&gt; 4.伪类选择器用：表示 1.链接伪类有很多种链接伪类 link visited hover active 1234a:hover&#123;color:gray;&#125;鼠标经过显示gray颜色 1234567a&#123;color:gray;&#125;a:hover&#123;color:red;&#125; 2.:focus伪类选择器123input:focus&#123;background-color:yellow;&#125; 7.CSS元素显示模式（重点)html元素分为块元素和行内元素两类型 1.块元素h p div ul ol li等是最常见的div是最典型的 特点独占一行 高度宽度外内边距等可以控制 宽度默认为容器（父级宽度）100% 是一个容器以及盒子 可以放行内以及块级元素 文字类的元素不能使用块级元素 p里面只能放文字 2.行内元素a strong b em i del s ins u span span是最典型的行内元素 高宽无效 一行可以显示多个 默认宽度就是本身内容宽度 3.行内块元素img input td 两个特点都有比较特殊 总结 4.元素显示模式转换display:block;转换块元素 display:inline;转换行内元素 display:inline-block行内块元素 12345&lt;style&gt; a&#123; display:block; &#125;&lt;/style&gt; 5.实例简洁版本侧边档123456789101112131415161718192021&lt;style&gt; a&#123; display: block; height: 20px; width: 100px; background-color: darkgray; font-size: 14px ; color: #fff; text-indent: 2em; text-decoration: none; &#125; a:hover&#123; background-color: coral; &#125;&lt;/style&gt;&lt;body&gt; &lt;a href=&quot;#&quot;&gt;手机&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;电视&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;盒子&lt;/a&gt;&lt;/bod》 6单行文字垂直居中可以通过文字的行高等于盒子的高度，就可以垂直居中 8CSS的背景小图片或者logo大图片 背景颜色图片 平铺 位置 固定等等 1.background-colorbackground-color一般默认为transparent 2.background-image使用方法为 background-image:url (); 123456789101112&lt;head&gt; &lt;style&gt; div&#123; width: 5000px; height: 1500px; background-image: url(![](https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/202112101445712.png)); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 3.background-repeat123456background-repeat:;/*默认平铺*/no-repeatrepeatrepeat-xrepeat-y 4.background-position可以修改图片位置 12345678910111213background-position:x y;/*参数分为两种length 百分数position 方位名词 top center bottom left center right如果都是方位名词，与前后无关如left top和top left在一些情况下 想要精准也可以通过精确坐标 d*/ 5.background-attachment背景固定 背景附着 这个设置设置背景图片是否固定还是滚动 scroll为滚动fixed为固定 6背景属性混合写法前五个复合写法可以像font一样节约代码量 一般没有要求但是，一般习惯写为一下 background:背景颜色 背景图片 背景平铺 背景滚动 位置 1background: red url() no-repeat fixed top; 7.背景色半透明1background:(0,0,0,alpht) 7.综合案例 五彩导航12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;综合案例-五彩导航&lt;/title&gt; &lt;style&gt; .nav a&#123; display:inline-block; width: 120px; height: 58px; background-color: pink; text-align: center; color: #fff; text-decoration: none; line-height: 48px; &#125; .nav .bg1&#123; background-image: url(images/bg1.png); &#125; .nav .bg2&#123; background-image: url(images/bg2.png); &#125; .nav .bg1:hover&#123; background-image: url(images/bg11.png); &#125; .nav .bg2:hover&#123; background-image: url(images/bg22.png); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;bg1&quot;&gt;五彩导航&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bg2&quot;&gt;五彩导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;五彩导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;五彩导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;五彩导航&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9.CSS三大特征1.层叠性123456789101112131415161718 &lt;style&gt; div&#123; color:red; &#125; div&#123; color: royalblue; font-size: 50px; &#125; div&#123; color:seagreen &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; 大江东去 &lt;/div&gt;&lt;/body&gt; 这里div有三个选择 但是只执行的只有fintsize和最后一个color 就近原则，哪个近就执行哪个 样态不冲突 不会重叠 2.继承性现实的继承 我们继承了父亲的姓 123456789101112 &lt;style&gt; div &#123; color: pink; font-size: 14px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;龙生龙,凤生凤,老鼠生的孩子会打洞&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; p继承了父div的性质 继承性就是简化代码 降低复杂性text font line 行高的继承123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;行高的继承&lt;/title&gt; &lt;style&gt; body &#123; color: pink; /* font: 12px/24px &#x27;Microsoft YaHei&#x27;; */ font: 12px; &#125; div &#123; /* 子元素继承了父元素 body 的行高 1.5 */ /* 这个1.5 就是当前元素文字大小 font-size 的1.5倍 所以当前div 的行高就是21像素 */ font-size: 14px; &#125; p &#123; /* 1.5 * 16 = 24 当前的行高 */ font-size: 16px; &#125; /* li 么有手动指定文字大小 则会继承父亲的 文字大小 body 12px 所以 li 的文字大小为 12px 当前li 的行高就是 12 * 1.5 = 18 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;粉红色的回忆&lt;/div&gt; &lt;p&gt;粉红色的回忆&lt;/p&gt; &lt;ul&gt; &lt;li&gt;我没有指定文字大小&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 3.优先性 选择器相同 则执行层叠层 不同 根据选择器权重决定 12345678910111213141516 &lt;style&gt; .test &#123; color: red; &#125; div &#123; color: pink!important; &#125; #demo &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test&quot; id=&quot;demo&quot; style=&quot;color: purple&quot;&gt;你笑起来真好看&lt;/div&gt;&lt;/body&gt; 10.盒子模型（超重点）Box Model学习页面布局有三大模型 盒子 浮动 定位 12345盒子中要有border边框content内容padding内边距margin外边距 1.border边框border中有 宽度 边框样态 颜色 123456789101112131415&lt;style&gt; div&#123; width: 300px; height: 200px; border-style: solid;/*solib实线 dashed 虚线 dotted点线边框*/ border-width: 20px; border-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617边框的复合写法 没有顺序 &lt;style&gt; div &#123; width: 300px; height: 200px; /* border-width: 5px; border-style: solid; border-color: pink; */ /* 边框的复合写法 简写: */ /* border: 5px solid pink; */ /* 上边框 */ border-top: 5px solid pink; /* 下边框 */ border-bottom: 10px dashed purple; border:red 5px solid; &#125; &lt;/style&gt; 2.padding内边距padding控制内边距 12345678div &#123; width: 300px; height: 160px; background-color: pink; padding-top: 20px; padding-left: 22px; padding-right: 22px; &#125; padding影响了盒子的大小 会撑大盒子 1234567891011121314151617.nav &#123; height: 41px; border-top: 3px solid red; border-bottom: 1px solid beige; background-color: #fcfcfc; line-height: 41px;&#125;.nav a &#123; display: inline-block; font-size: 12px; color: blue; text-decoration: none; padding: 0 20px; height: 41px;&#125; 3.margin外边距两个盒子的距离 还是和内边距相似 top right bottom left 外边距作用为水平居中 指定宽度 盒子左右外边距为auto 123margin-left:auto;margin-right:auto;margin:auto;margin:0 auto; 行内和行内块用text-alignLcenter 11.浮动float传统网页布局三种方式 普通流 浮动 定位 标准流（普通 文档）按照标签规定默认排序 块单独一行 从上香下排序又div hr h1-h6 ui ol form table 行内按照左右排序如 span a i em 3浮动元素具有行内吧块元素特征 123456789101112131415161718192021222324252627282930313233343536 &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; &#125; .box &#123; width: 1226px; height: 285px; background-color: pink; margin: 0 auto; &#125; .box li &#123; width: 296px; height: 285px; background-color: purple; float: left; margin-right: 14px; &#125; .box .last &#123; margin-right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;box&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li class=&quot;last&quot;&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 清除浮动 12定位有些效果无法用标准流和浮动，这时候要用定位 浮动可以让多个块级元素在一行没有空袭 定位用于自由控制盒子 1static静态定位没有边偏移 2relative相对定位 3absolute绝对定位子绝父相","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"编程/前端","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"编程/前端/CSS","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"JavaScript入门","slug":"JavaScript入门","date":"2021-12-01T11:19:12.000Z","updated":"2022-04-19T15:11:22.372Z","comments":true,"path":"2021/12/01/JavaScript入门/","link":"","permalink":"http://example.com/2021/12/01/JavaScript%E5%85%A5%E9%97%A8/","excerpt":"前端三剑客的大哥捏","text":"前端三剑客的大哥捏 1.关于JavaScript1.JavaScript是什么？ HTML 定义了网页的内容 CSS 描述了网页的布局 JavaScript 控制了网页的行为 浏览器不会执行js，通过js解释器 js的引入有三种 行内式的内嵌式 输入输出语句12345678JavaScript 显示数据JavaScript 可以通过不同的方式来输出数据：使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 字面量和变量js是一种弱类型或者动态的语言，不用提前声明类型，类型被自动确定 数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e)。 1isNaN来判断是否为非数字，并返回一个值 如果是数字返回false，反之true 字符串（String）字面量 可以使用单引号或双引号:表达式字面量 用于计算： 数组（Array）字面量 定义一个数组： [40, 100, 1, 5, 25, 10] 对象（Object）字面量 定义一个对象： {firstName:”John”, lastName:”Doe”, age:50, eyeColor:”blue”} 函数（Function）字面量 定义一个函数： function myFunction(a, b) { return a * b;} 在编程语言中，变量用于存储数据值。 JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值： JavaScript 数据类型JavaScript 有多种数据类型：数字，字符串，数组，对象等等： 12345var length = 16; // Number 通过数字字面量赋值var points = x * 10; // Number 通过表达式字面量赋值var lastName = &quot;Johnson&quot;; // String 通过字符串字面量赋值var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; // Array 通过数组字面量赋值var person = &#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;&#125;; // Object 通过对象字面量赋值 var cars = new Array();cars[0] = “Saab”;cars[1] = “Volvo”;cars[2] = “BMW”; 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： var person={firstname:”John”, lastname:”Doe”, id:5566}; 上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 var person={firstname : “John”,lastname : “Doe”,id : 5566}; 12345678var person=&#123; firstname : &quot;John&quot;, lastname : &quot;Doe&quot;, id : 5566&#125;;document.write(person.lastname + &quot;&lt;br&gt;&quot;);document.write(person[&quot;lastname&quot;] + &quot;&lt;br&gt;&quot;); 语句 描述 break 用于跳出循环。 catch 语句块，在 try 语句块执行出错时执行 catch 语句块。 continue 跳过循环中的一个迭代。 do … while 执行一个语句块，在条件语句为 true 时继续执行该语句块。 for 在条件语句为 true 时，可以将代码块执行指定的次数。 for … in 用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 function 定义一个函数 if … else 用于基于不同的条件来执行不同的动作。 return 退出函数 switch 用于基于不同的条件来执行不同的动作。 throw 抛出（生成）错误 。 try 实现错误处理，与 catch 一同使用。 var 声明一个变量。 while 当条件语句为 true 时，执行语句块。 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。 函数匿名函数123var fun =funtion()&#123;console.log(&quot;hello world&quot;);&#125; 面向对象创建方法1利用对象字面量创建对象123456789var obj-&#123;uname: &quot;songyuran&quot;,age: 18,sayhi: funtion()&#123;console.log(&quot;log&quot;);&#125;&#125; 利用new object创建对象1234var obj=new Object();obj,uname=&#x27;songyiran&#x27;; 构造函数因为一上只能创建一个对象，有了构造函数可以让相同的属性和方法抽象出来封装出来到函数里面 123456funtion Star(uname,age,sex)&#123;this.name=uname;this.age=age;this,sex=sex;&#125;var ldh=new Star(&quot;songyuran&quot;,18,&#x27;nan&#x27;); 遍历对象1234for(var k in obj)&#123;console.log(k);console.log(obj[k]);&#125; 内置对象Mathrandom()*(max-min+1)+min0《=x《1 date DOMDOM树获取元素获取ID1234getElementByld()get element by idconsole.dir打印返回的元素对象，更好查看里面的属性和方法 根据标签名12getElementByTagNameelement.getElementByTagName 根据类名1getElementByClassName 返回指定选择器第一个元素对象1querySelector 返回指定所有的选择器所以元素对象1query.SelectorAll 获取特殊元素body1document.body html1document.documentElemnt 事件基础事件源 事件类型 事件处理程序 三要素 12345var btn =document.getElemnent.byId(&#x27;btn&#x27;)btn.onclick =funtion()&#123;alert(&quot;hello world&quot;)&#125; 修改元素","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"编程/前端","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"编程/前端/javascript","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"美化博客出现的问题","slug":"美化博客出现的问题","date":"2021-11-25T09:00:41.000Z","updated":"2022-04-19T15:08:47.117Z","comments":true,"path":"2021/11/25/美化博客出现的问题/","link":"","permalink":"http://example.com/2021/11/25/%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"总结hexo错误的原因和措施","text":"总结hexo错误的原因和措施 我今天在美化我的博客的时候本地启动的时候出现了奇怪的问题，导致不能添加新的Md文章。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647INFO Validating configINFO Start processingERROR &#123; err: TypeError: Cannot read properties of null (reading &#x27;utcOffset&#x27;) at exports.timezone (E:\\kagura blog\\myblog\\1125错误\\node_modules\\hexo\\lib\\plugins\\processor\\common.js:56:42) at E:\\kagura blog\\myblog\\1125错误\\node_modules\\hexo\\lib\\plugins\\processor\\post.js:81:38 at tryCatcher (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:544:35) at Promise._settlePromise (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:604:18) at Promise._settlePromise0 (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:649:10) at Promise._settlePromises (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:729:18) at Promise._fulfill (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:673:18) at PromiseArray._resolve (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:127:19) at PromiseArray._promiseFulfilled (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:145:14) at PromiseArray._iterate (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:115:31) at PromiseArray.init [as _init] (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:79:10) at Promise._settlePromise (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:601:21) at Promise._settlePromise0 (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:649:10) at Promise._settlePromises (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:729:18) at Promise._fulfill (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:673:18) at PromiseArray._resolve (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:127:19) at PromiseArray._promiseFulfilled (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:145:14) at Promise._settlePromise (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:609:26) at Promise._settlePromise0 (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:649:10) at Promise._settlePromises (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:729:18) at _drainQueueStep (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\async.js:93:12)&#125; Process failed: %s _posts/111.mdERROR &#123; err: TypeError: Cannot read properties of null (reading &#x27;utcOffset&#x27;) at exports.timezone (E:\\kagura blog\\myblog\\1125错误\\node_modules\\hexo\\lib\\plugins\\processor\\common.js:56:42) at E:\\kagura blog\\myblog\\1125错误\\node_modules\\hexo\\lib\\plugins\\processor\\post.js:81:38 at tryCatcher (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:544:35) at Promise._settlePromise (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:604:18) at Promise._settlePromise0 (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:649:10) at Promise._settlePromises (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:729:18) at Promise._fulfill (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:673:18) at PromiseArray._resolve (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:127:19) at PromiseArray._promiseFulfilled (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:145:14) at PromiseArray._iterate (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:115:31) at PromiseArray.init [as _init] (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:79:10) at Promise._settlePromise (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:601:21) at Promise._settlePromise0 (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:649:10) at Promise._settlePromises (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:729:18) at Promise._fulfill (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:673:18) at PromiseArray._resolve (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:127:19) at PromiseArray._promiseFulfilled (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise_array.js:145:14) at Promise._settlePromise (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:609:26) at Promise._settlePromise0 (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:649:10) at Promise._settlePromises (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\promise.js:729:18) at _drainQueueStep (E:\\kagura blog\\myblog\\1125错误\\node_modules\\bluebird\\js\\release\\async.js:93:12)&#125; Process failed: %s _posts/博客记录.md 幸亏有备份将我的源文件备份好了，否则恐怕就要重新去配置了。 为了防止下次再出现这种情况 源文件必须要在GitHub备份 历史更新记录描述一定要描述清楚了","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"问题","slug":"个人博客/问题","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://example.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}]},{"title":"Html基础","slug":"html基础","date":"2021-11-23T15:49:10.000Z","updated":"2022-04-19T15:10:14.788Z","comments":true,"path":"2021/11/23/html基础/","link":"","permalink":"http://example.com/2021/11/23/html%E5%9F%BA%E7%A1%80/","excerpt":"前端三剑客的弟弟","text":"前端三剑客的弟弟 [TOC] 1.HTML入门​ html是创建网页的标准标记语言。网页有很多的格式,html,jsp,asp等 ，html并不是编程语言，因为编程语言具有逻辑能力，html超越了传统的txt文本，具有超文本性，是一种标记语言。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;//这是文档的声明，声明文档为html&lt;html lang=&quot;zh-CN&quot;&gt;//en zh-CN&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;这是网页标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;a href=&quot;http://c.biancheng.net/&quot;&gt;这个一个超链接&lt;/a&gt; &lt;ul&gt; &lt;li&gt;HTML教程&lt;/li&gt; &lt;li&gt;CSS教程&lt;/li&gt; &lt;li&gt;JavaScript教程&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入内容&quot; /&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt;//h1-h6 &lt;p&gt;这是一个段落&lt;/p&gt; &lt;p&gt;这是另一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 以上这个就是最基本的网页格式，每个html标签(Tag)都有不同的含义 &lt;.html&gt;当作所有的html代码，可以把它当作外壳 &lt;.head&gt; 标签表示网页的头部，用来设置一些网页的参数 &lt;.meta charset=”UTF-8”&gt; 指明当前网页编码格式 UTF-8； &lt;.title&gt; 网页的标题，它会显示在浏览器的标题栏。&lt;./head&gt; &lt;.body&gt;表示正文 &lt;.p&gt;表示段落，能容纳一段文字 &lt;.a&gt;用来表示一个超链接&lt;.ul&gt;表示一个列表，里面的是子标签 HTML语言中最推荐vscode写 &lt;!DOCTYPE&gt; html小白入门 这是文本标题，下面是一张图片 按钮 d ​ 1234567891011121314&lt;!DOCTYPE&gt;&lt;!--html标记--&gt;&lt;html&gt; &lt;!--html总标记--&gt; &lt;head&gt;&lt;!--头信息标签--&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--utf-8编码--&gt; &lt;title&gt;html小白入门&lt;/title&gt;&lt;!--页面标题--&gt; &lt;head&gt; &lt;body&gt;&lt;!--网页显示标签，body标签内的信息都会在页面中显示--&gt; &lt;h1&gt;这是文本标题，下面是一张图片&lt;/h1&gt;&lt;!--文本标题标签--&gt; &lt;h2 href=&quot;baidu.com&quot;&gt;点我百度搜索&lt;/a&gt;&lt;!--超链接--&gt; &lt;imgsrc=&quot;tupian.jpg&quot;&gt;&lt;br&gt;&lt;!--图片标签，br是换行标签--&gt; &lt;input type=&quot;text&quot; value=&quot;这是输入框，请输入内容！&quot;&gt;&lt;br&gt;&lt;!--输入框标签--&gt; &lt;button type=&quot;submit&quot; &gt;按钮&lt;/button&gt;&lt;!--按钮标签--&gt; &lt;/body&gt;&lt;/html&gt; 这个就是最基本的使用方法 2.HMTL的语法1.html标签的语法格式(请忽略.)&lt;.div class=”foo”&gt;我是内容&lt;/div.&gt;foo为属性 前后div为开始结束标签 开始标签可以写除了class的比如id title等 html标签是成对出现的，称之为双标签有些特殊的比如说 div为内容划分元素 是出现最高的 2.标签关系HTML标签包含关系1234567891011 &lt;h1&gt;神楽の魂&lt;font size=&quot;4&quot; color=&quot;#666&quot;&gt;自我介绍&lt;/font&gt;&lt;/h1&gt; &lt;p&gt; 这是北京普通的双非&lt;b&gt;大学生&lt;/b&gt;的个人博客，目前 &lt;font color=&quot;red&quot;&gt;18岁&lt;sup&gt;①&lt;/sup&gt;&lt;/font&gt;，&lt;a href=&quot;https://kaguranotamashii.github.io/&quot; target=&quot;_blank&quot;&gt;猛击这里&lt;/a&gt;查看我的博客&lt;i&gt;C语言&lt;/i&gt;、&lt;i&gt;python&lt;/i&gt;、&lt;i&gt;html&lt;/i&gt; &lt;i&gt;css&lt;/i&gt; &lt;hr /&gt; &lt;small&gt;03年出生&lt;/small&gt; &lt;/p&gt;&lt;!包含关系&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;/html&gt; 对代码的说明 &lt;.font&gt; size改变大小 clor改变颜色 &lt;.b&gt;加粗 &lt;.sup&gt;上方的小标 &lt;.i&gt;斜 &lt;.hr&gt;分割线，它是自闭和标签 &lt;.a&gt;为打开超链接 其中&lt;.target&gt;为打开方式 ——blank表示在新标签打开 并列关系(兄弟关系)&lt;.head&gt;&lt;/.head&gt; 基本标签 html标签 根标签 头部 在head中我们必须要设计的标签是title 标题 属于自己的网页标题 主体 元素包含的所有内容，页面内容基本都是放在body中的 3.HTML属性1.属性1attr=&quot;value&quot; attr为属性名字 value表示属性值 1.专用属性有些属性适合大部分 叫通用属性有些只适合小部分 叫专用属性比如说img中src和alt就是专用属性 a中href和target也是专用属性 1&lt;img src=&quot;xxxx.png&quot; alt=&quot;xxxxx&quot; width=&quot;100&quot; height=&quot;50&quot;&gt; 2.通用属性如id,title,class,style 1.idid属性是用来赋值给某个标签名字，当使用css或者js时候，可以通过id来找到这个标签。 id可以快速找到定位，id可以方便区分，id具有唯一性 123&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;&lt;div id=&quot;content&quot;&gt;我的博客&lt;/div&gt;&lt;p id=&quot;url&quot;&gt;kaguranotamashii.github.io/&lt;/p&gt; 2.classclass与id不同在于，class可以定义多个相同值 class=” “ 123&lt;div class=&quot;className1 className2 className3&quot;&gt;&lt;/div&gt;&lt;p class=&quot;content&quot;&gt;神楽の魂的博客&lt;/p&gt;&lt;div class=&quot;content&quot;&gt;kaguranotamashii.github.io&lt;/div&gt; 3.titletitle属性是用来标签内容的描述说明 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;演示文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;http://c.biancheng.net/html/&quot; title=&quot;HTML教程&quot;&gt;HTML教程&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4.stylestyle属性我们可以在html标签内部定义css样态，比如颜色，字体等等 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;演示文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p style=&quot;color:red;&quot;&gt;kaguranotamashii,github.io&lt;/p&gt; &lt;img src=&quot;./logo.png&quot; style=&quot;height:50px;&quot; alt=&quot;C语言中文网LOGO&quot;&gt; &lt;div style=&quot;padding:10px;border:2px solid #999;text-align:center;&quot;&gt;C语言中文网&lt;/div&gt;&lt;!这里做个批注padding表示内边距，内容区与边框之间的区域 border表示设置元素的边框--&gt; &lt;/body&gt;&lt;/html&gt; 4.HTML标题1.&lt;.h1&gt;到&lt;.h6&gt;（head)123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML标题标签演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;h1 标题&lt;/h1&gt; &lt;h2&gt;h2 标题&lt;/h2&gt; &lt;h3&gt;h3 标题&lt;/h3&gt; &lt;h4&gt;h4 标题&lt;/h4&gt; &lt;h5&gt;h5 标题&lt;/h5&gt; &lt;h6&gt;h6 标题&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 标题标签的使用只能用于定义标签，不能加粗 5.HTML段落标签&lt;.p&gt;paragraph 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是神楽の魂的博客网站为&lt;a href=&quot;kaguranotamashii.github.io&quot;&gt;点我&lt;/a&gt;&lt;/p&gt; &lt;p&gt;我的博客会写一些技术向的内容&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 1.&lt;.p&gt;的用法段落标签由开始标签&lt;p&gt;和结束标签&lt;/p&gt;组成，开始和结束标签之间的内容会被视为一个段落。段落标签是一个非常基本的标签，我们在网页上发布文章时就会用到 2.段落中的空白符123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML段落中的空白符&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;神 楽の魂 的 博 客&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 如果想要在段落中换行，需要使用专门的换行标签&lt;br /&gt;，&lt;br /&gt;标签属于自闭和标签，因此不需要对应的结束标签`&lt; /br&gt; 文本在一个段落中会根据浏览器窗口大小自动换行 段落与段落有空隙 6.HTML文本格式化突出重要性 比普通文字更重要 标签 描述 &lt; b&gt;…&lt;/b&gt; 加粗标签中的字体 &lt; em&gt;…&lt;/em&gt; 强调标签中的内容，并使标签中的字体倾斜 &lt; i&gt;…&lt;/i&gt; 定义标签中的字体为斜体 &lt; small&gt;…&lt;/small&gt; 定义标签中的字体为小号字体 &lt; strong&gt;…&lt;/strong&gt; 强调标签中的内容，并将字体加粗（推荐） &lt; sub&gt;…&lt;/sub&gt; 定义下标文本 &lt; sup&gt;…&lt;/sup&gt; 定义上标文本 &lt; ins&gt;…&lt;/ins&gt; 下划线 &lt; del&gt;…&lt;/del&gt; 在文本内容上添加删除线 &lt; code&gt;…&lt;/code&gt; 定义一段代码 &lt; kbd&gt;…&lt;/kbd&gt; 用来表示文本是通过键盘输入的(不建议使用) &lt; samp&gt;…&lt;/samp&gt; 定义程序的样本 &lt; var&gt;…&lt;/var&gt; 定义变量 &lt; pre&gt;…&lt;/pre&gt; 定义预格式化的文本，被该标签包裹的文本会保留所有的空格和换行符，字体也会呈现为等宽字体 &lt; abbr&gt;…&lt;/abbr&gt; 用来表示标签中的内容为缩写形式 &lt; address&gt;…&lt;/address&gt; 用来定义文档作者的联系信息，被该标签包裹的文本通常会以斜体呈现，并在文本前面换行 &lt; bdo&gt;…&lt;/bdo&gt; 定义标签中的文字方向 &lt; blockquote&gt;…&lt;/blockquote&gt; 定义一段引用的文本，例如名人名言，文本会换行输出，并在左右两边进行缩进 &lt; q&gt;…&lt;/q&gt; 定义一段短的引用，浏览器会将引用的内容使用双引号包裹起来 &lt; cite&gt;…&lt;/cite&gt; 表示对某个文献的引用，例如书籍或杂志的名称，文本会以斜体显示 &lt; dfn&gt;…&lt;/dfn&gt; 用来定义一个术语，标签中的文本会以斜体呈现 几个相似的格式化文本1.strong和b前者表示加重语气,后者只是单纯的加粗,在无障碍模式中strong会比b的声音更特殊. 2.em和iem也是加重处理,i仅仅是单纯的斜体 7div和span标签两者没有语义，他们就是一个盒子，用来放内容 div division表示分割 分区span表示跨度 跨距 div用来布局 但是一行只能有一个div 大盒子span相反 一行可以放多个span 小盒子 8.特殊的字符 123&amp;nbsp;空格&amp;lt;小于&amp;gt;大于 7.HTML超链接&lt;.a&gt;1.用法1&lt;a href=&quot;url&quot; target=&quot;opentype&quot;&gt;链接文本&lt;/a&gt; 2href的属性anchor 瞄 href 属性指定链接的目标，也就是要跳转到什么位置。href 可以有多种形式，例如： href 可以指向一个网页（.html、.php、.jsp、.asp 等格式），这也是最常见的形式，例如 href=”http://c.biancheng.net/view/1719.html&quot;； href 可以指向图片（.jpg、.gif、.png 等格式）、音频（.mp3、.wav等格式）、视频（.mp4、.mkv格式）等媒体文件，例如 href=”/uploads/allimg/181221/134I32557-0.jpg”； href 可以指向压缩文件（.zip、.rar 等格式）、可执行程序（.exe）等，一些下载网站的链接就可以写成这种形式，例如 href=”./../uploads/data_package/ComputerFoundation.zip”； href 甚至还可以指向本机的文件，只是很少这样使用，例如 href=”D:/Program Files/360/360safe/360Safe.exe”。 你看，href 本质上就是指向一个文件，这个文件几乎可以是任意格式的。如果浏览器支持这种格式，那么它就可以在浏览器上显示，比如常见的图片、音频、视频等，如果浏览器不支持这种格式，那么就提示用户下载。 3.target的属性 属性值 说明 _self 默认，在现有窗口中打开新页面，原窗口将被覆盖。 _blank 在新窗口中打开新页面，原窗口将被保留。 _parent 在当前框架的上一层打开新页面。 _top 在顶层框架中打开新页面。 如果不设置默认为_self 4.href的本地网页跳转1234567&lt;a href=&quot;#sakura&quot;&gt;点我跳转&lt;/a&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p id=&quot;sakura&quot;&gt;我是sakura&lt;/p&gt; 点我跳转 忽略我 忽略我 忽略我 忽略我 忽略我 我是sakura 8HTML插入图片&lt;.img&gt;1.用法1&lt;img src=&quot;url alt=&quot;text&quot;&gt; src(source)为必选属性,用来指明图片的地址和目录,支持多种图片类型 alt为可选属性,如果遇到图片加载不了,会显示alt的信息 123456&lt;body&gt; &lt;!-- 使用绝对路径插入网络图片 --&gt; &lt;img src=&quot;http://c.biancheng.net/cpp/templets/new/images/logo.jpg?v=3.994&quot; alt=&quot;C语言中文网Logo&quot;&gt; &lt;br&gt; &lt;!-- 在当前 HTML 文档的上层目录中有一个 images 文件夹，该文件夹下有一张图片 html5.png --&gt; &lt;img src=&quot;../images/html5.png&quot; alt=&quot;HTML5 Logo&quot;&gt;&lt;/body&gt; 2.设置图片的宽高度​ 比如这张图片渚薰被吃 1234&lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot; alt=&quot;渚薰被吃了&quot;title=&quot;渚薰被吃&quot; style=&quot;width: 200px; height: 100px;&quot;&gt;&lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot; alt=&quot;渚薰被吃了&quot; style=&quot;width: 200px; height: 150px;&quot;&gt;&lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot; alt=&quot;渚薰被吃了&quot; style=&quot;width: 100px; height: 200px;&quot;&gt;&lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot; alt=&quot;渚薰被吃了&quot; style=&quot;width: 150px; height: 200px;&quot;&gt; 3图片映射1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;HTML图片映射&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;logo.png&quot; usemap=&quot;#objects&quot; alt=&quot;C语言中文网Logo&quot;&gt; &lt;map name=&quot;objects&quot;&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0,0,82,126&quot; href=&quot;http://c.biancheng.net/html/&quot; alt=&quot;HTML教程&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;90,58,3&quot; href=&quot;http://www.biancheng.net/css3/&quot; alt=&quot;CSS教程&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;124,58,8&quot; href=&quot;http://www.biancheng.net/js/&quot; alt=&quot;JavaScript教程&quot;&gt; &lt;/map&gt;&lt;/body&gt;&lt;/html&gt; &lt;.map&gt;标签的name属性对应的是&lt;.img&gt;标签的usemap属性,&lt;.area&gt;用于定义点击图片的坐标shape 和 coords 属性 在 &lt;.area&gt; 标签中可以通过 shape 属性来定义可点击区域的形状，并通过 coords 属性来定义形状所对应的坐标。其中 shape 属性的可选值有三个，分别是 rect（矩形）、circle（圆形）和 poly（多边形），coords 属性中坐标的值则取决于可点击区域的形状。 假如定义一个矩形的可点击区域，示例代码如下： 1&lt;area shape=&quot;rect&quot; coords=&quot;x1, y1, x2, y2&quot; href=&quot;http://c.biancheng.net/&quot; alt=&quot;&quot;&gt; 其中 x1、y1 代表矩形的左上角坐标，x2、y2 代表矩形的右下角坐标。 假如定义一个圆形的可点击区域，示例代码如下： 1&lt;area shape=&quot;circle&quot; coords=&quot;x, y, radius&quot; href=&quot;&quot; alt=&quot;&quot;&gt; 其中 x、y 代表圆心的坐标，而 radius 则是圆的半径。 假如定义一个多边形的可点击区域，示例代码如下： 1&lt;area shape=&quot;poly&quot; coords=&quot;x1, y1, x2, y2, x3, y3, ..., xn, yn&quot; href=&quot;http://c.biancheng.net/&quot; alt=&quot;&quot;&gt; 其中每对 x 和 y 的值都代表一个多边形的顶点坐标。 注意：所有坐标都是相对于图片的左上角来计算的。 属性 属性值 说明 src 图片路径 必须属性 alt 文字 图片显示不出 title 文字 鼠标放在图片上后显示的文字 width 像素 宽度 height 像素 高度 border 像素 边框粗细 1234&lt;a href=&quot;http://baidu.com&quot;&gt; &lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot;&gt;&lt;/a&gt; 9HTML&lt;.table&gt;表格1.表格使用代码12345678910111213141516171819202122&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;官网&lt;/th&gt; &lt;th&gt;性质&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;b站&lt;/td&gt; &lt;td&gt;bilibili.com&lt;/td&gt; &lt;td&gt;综合&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;百度&lt;/td&gt; &lt;td&gt;http://www.baidu.com/&lt;/td&gt; &lt;td&gt;搜索&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;当当&lt;/td&gt; &lt;td&gt;http://www.dangdang.com/&lt;/td&gt; &lt;td&gt;图书&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 在里面中出现了新的单词table tr td th tr表示table row 表示行数 td表示table datacell 表示表格的单元格 th表示table heading表示表头 2.表格的边框合并如果不进行修改会显示双层边框这时候利用css的border-collapse的属性为collapse 1&lt;table border=&quot;1&quot; style&quot;border-collapse:collapse&quot; 3.表格的标题&lt;.caption&gt;12&lt;table border=&quot;1&quot; style=&quot;border-collapse:collapse;&quot;&gt;&lt;caption&gt;这是标题&lt;/caption&gt; 第一行并且居中显示 4.合并rowspan跨行合并单元格colspan跨列合并单元格 1234567891011121314151617181920&lt;table border=&quot;1&quot; style=&quot;border-collapse: collapse;&quot;&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;官网&lt;/th&gt; &lt;th&gt;性质&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C语言中文网&lt;/td&gt; &lt;td&gt;http://c.biancheng.net/&lt;/td&gt; &lt;td&gt;教育&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;百度&lt;/td&gt; &lt;td&gt;www.baidu.com&lt;/td&gt; &lt;td&gt;搜索&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;http://www.dangdang.com/&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 5.表格的属性 10.HTML列表标签&lt;.ul&gt;&lt;.ol&gt;&lt;.dl&gt; html为我们提功了三个列表表达方式 1.有序列表123456789&lt;body&gt; &lt;p&gt;煮米饭的步骤：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;将水煮沸&lt;/li&gt; &lt;li&gt;加入一勺米&lt;/li&gt; &lt;li&gt;搅拌均匀&lt;/li&gt; &lt;li&gt;继续煮10分钟&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt; ol为order list的意思为有序列表li为 list item的意思为每一项 2.无序列表123456789&lt;body&gt; &lt;p&gt;早餐的种类：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;鸡蛋&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;面包&lt;/li&gt; &lt;li&gt;生菜&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;.ul&gt; 是 unordered list 的简称，表示无序列表。 &lt;..ul&gt; 和 &lt;.ol&gt; 中的 &lt;.li&gt; 一样，都表示列表中的每一项。默认情况下，无序列表的每一项都使用●符号表示。 3.自定义列表定义如下 12345678&lt;dl&gt; &lt;dt&gt;标题1&lt;dt&gt; &lt;dd&gt;描述文本2&lt;dd&gt; &lt;dt&gt;标题2&lt;dt&gt; &lt;dd&gt;描述文本2&lt;dd&gt; &lt;dt&gt;标题3&lt;dt&gt; &lt;dd&gt;描述文本3&lt;dd&gt;&lt;/dl&gt; dl为定义列表 dt为定义术语 dd为定义描述 12345678910&lt;body&gt; &lt;dl&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;HTML 是一种专门用来开发网页的标记语言，您可以转到《&lt;a href=&quot;http://c.biancheng.net/html/&quot; target=&quot;_blank&quot;&gt;HTML教程&lt;/a&gt;》了解更多。&lt;/dd&gt; &lt;dt&gt;CSS&lt;/dt&gt; &lt;dd&gt;CSS 层叠样式表可以控制 HTML 文档的显示样式，用来美化网页，您可以转到《&lt;a href=&quot;http://c.biancheng.net/css3/&quot; target=&quot;_blank&quot;&gt;CSS教程&lt;/a&gt;》了解更多。&lt;/dd&gt; &lt;dt&gt;JavaScript&lt;/dt&gt; &lt;dd&gt;JavaScript 简称 JS，是一种用来开发网站（包括前端和后台）的脚本编程语言，您可以转到《&lt;a href=&quot;http://c.biancheng.net/js/&quot; target=&quot;_blank&quot;&gt;JS教程&lt;/a&gt;》了解更多。&lt;/dd&gt; &lt;/dl&gt;&lt;/body&gt; 4.列表的默认样态1234567891011121314 &lt;ol style=&quot;margin:0px auto; padding-left:20px; list-style:upper-latin;&quot;&gt; &lt;li&gt;将水煮沸&lt;/li&gt; &lt;li&gt;加入一勺米&lt;/li&gt; &lt;li&gt;搅拌均匀&lt;/li&gt; &lt;li&gt;继续煮10分钟&lt;/li&gt; &lt;/ol&gt;对 CSS 样式的说明：margin:0px auto;将上下外边距设置为 0 像素，将左右外边距设置为自动。margin-bottom:0px;将下方外边距设置为 0 像素。margin:auto auto 10px 0px;将上方和右侧外边距设置为自动，将下方外边距设置为 10 像素，将左侧外边距设置为 0 像素。padding-left:20px;将左侧内边距设置为 20 像素。list-style:upper-latin;将列表项标记设置为大写拉丁字母。list-style:square;将列表项标记设置为实心方块。 11.⛤⛤⛤&lt;.form&gt;标签如果想通过网页交互可以通过form实现 123&lt;form action=&quot;URL&quot; method=&quot;GET|POST&quot;&gt; 表单中的其它标签&lt;/form&gt; action属性表示表单交到哪里 method属性表示使用什么方式提交数据 表单属于 HTML 文档的一部分，其中包含了如输入框、复选框、单选按钮、提交按钮等不同的表单控件，用户通过修改表单中的元素（例如输入文本，选择某个选项等）来完成表单，通过表单中的提交按钮将表单数据提交给后端程序。 除了type以外input还有其它的属性 注意这个name，如果说没有name属性，在这里如果没有name属性比如上例，点击male和female都可以单选和复选name应该是相同的值 checked这个是默认勾选的，比如说用户同意这种的 1文字域 账号 密码 1234&lt;form&gt;账号&lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br&gt;密码&lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;/form&gt; 2密码字段如果想输入密码的话 input type=”password”修改password 这样就输入字符串，会变成星号 123&lt;form&gt;Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/form&gt; Password: 3.按钮1234&lt;form&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; checked=&quot;checked&quot;&gt;Female&lt;/form&gt; Male Female 4.复选框checkboxes1234&lt;form&gt;&lt;input type=&quot;checkbox&quot; value&quot;男&quot;&gt;男&lt;br&gt; &lt;input type=&quot;checkbox&quot; value&quot;女&quot;&gt;女&lt;/form&gt; 男 女 5提交按钮1234&lt;form name=&quot;input&quot; action=&quot;html_form_action.php&quot; method=&quot;get&quot;&gt;Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; Username: Username: 假如您在上面的文本框内键入几个字母，然后点击确认按钮，那么输入数据会传送到 “html_form_action.php” 的页面。该页面将显示出输入的结果。 6.简单的下拉列表1234567&lt;p&gt;你喜欢吃什么&lt;/p&gt;&lt;form&gt;&lt;select name=&quot;cars&quot;&gt;&lt;option value=&quot;volvo&quot;&gt;洋芋&lt;/option&gt;&lt;option value=&quot;saab&quot; selected=&quot;selected&quot;&gt;土豆&lt;/option&gt;&lt;/select&gt;&lt;/form&gt; 你喜欢吃什么 洋芋 土豆 ![mark](https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/202112051307064.png) ## 7重置reset 123&lt;form&gt; &lt;input type=&quot;reset&quot; value=&quot;点我重新填写&quot;&gt;&lt;/form&gt; 8定义点击按钮1&lt;input type=&quot;button&quot; value=&quot;点我&quot;&gt; 9上传文件1&lt;input type=&quot;file&quot; value=&quot;点我&quot;&gt; 10.label标签12&lt;input type=&quot;radio&quot;name=&quot;sex&quot; id=&quot;nan&quot;&gt;&lt;label for=&quot;nan&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot;name=&quot;sex&quot; id=&quot;nv&quot;&gt;&lt;label for=&quot;nv&quot;&gt;女&lt;/label&gt; 11.表单元素textarea表单元素 当用户输入过多的元素的时候不用单纯的text了 1234&lt;form&gt;今日反馈 &lt;textarea cols=&quot;5&quot; rows=&quot;1&quot;&gt; &lt;/textarea&gt;&lt;/form&gt; 今日反馈 13.html综合学习1注册界面","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"编程/前端","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"编程/前端/HTML","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"我对程序员的再认知","slug":"我对程序员的再认识","date":"2021-11-22T16:08:12.000Z","updated":"2021-12-05T05:08:33.375Z","comments":true,"path":"2021/11/23/我对程序员的再认识/","link":"","permalink":"http://example.com/2021/11/23/%E6%88%91%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%86%8D%E8%AE%A4%E8%AF%86/","excerpt":"1.接触在高三的时候，和同学讨论志愿报名的时候，一些学物理的男生就表示计算机挣钱多。“我的亲戚学历不高，就自学前端什么什么的，在北京挣了多多少钱”。","text":"1.接触在高三的时候，和同学讨论志愿报名的时候，一些学物理的男生就表示计算机挣钱多。“我的亲戚学历不高，就自学前端什么什么的，在北京挣了多多少钱”。 后来高考考上了信息科大的通信学院的电子信息工程（EE），没有考中我想去的CS（Computer Science），虽然很失望，但是可以尝试转专业。转专业的想法在我心中愈来愈强烈。因此从开始那天到Iflab社团招新那一段时候，我犯了很严重的错误。 2.反思程序员的灵魂是什么？算法？代码？直到加入了iflab社团，导师为新生推荐的书籍中，部分都是哲学类的书籍，一时让我有了进入了文艺社的感觉。后来才明白，我用VS2019写出来的代码虽然有1G大，但是它没有思想，没有灵魂，没有‘生命力’的躯壳。 翁PJ学长的‘做一个天马行空的人’这封给新生的一封信。让我反思起从这几周我的盲目性，单纯为学习而学习的思维是非常不正确的，Hr不会听你的大学当过什么什么，这个感觉太像我在高考后，渴望着明明考不上的大学听到我的故事，而破例录取，但现实是残酷的。 编程是为了什么？钱？自由？其实都有一定的存在。用代码创造出自己的世界。最近在学习前端语言的时候我注意到了一系列课叫应用无障碍。与此同时B站也推出了对聋人帮助的实时字幕。这就是编程给特殊群体带来的便利。再比如苹果以及安卓手机的无障碍模式，都是用代码来为特殊人群的帮助。 3.继续行走自己也是其中之一，我也感受到了代码的”温暖”，计算机中的代码不再是冷冰冰的英文字母和符号了，它变成了照亮迷路的旅途者的灯塔。 大一上半年的我，继续探索吧，寻找属于自己的灯塔吧，自己的方向吧。","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"http://example.com/tags/%E6%80%9D%E8%80%83/"}]},{"title":"博客的搭建记录.","slug":"博客常用的记录","date":"2021-11-22T06:35:49.000Z","updated":"2022-04-30T01:59:20.925Z","comments":true,"path":"2021/11/22/博客常用的记录/","link":"","permalink":"http://example.com/2021/11/22/%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%B0%E5%BD%95/","excerpt":"对hexo的记录","text":"对hexo的记录 1.hexo的一些指令本地预览 hexo s 配置文件和主题 hexo g清空 hexo g 生成的内容hexo clean 标题名称 hexo new post 标题名称 123categories: -cover: 图标 2.Typora和Hd的使用方法typora的快捷键 1.段落 标题：Ctrl+1/2/3/4/5 段落：Ctrl+0 增大标题级别：Ctrl+= 减少标题级别：Ctrl+- 表格：Ctrl+T 代码块：Ctrl+Shift+K 公式块：Ctrl+Shift+M 引用：Ctrl+Shift+Q 有序列表：Ctrl+Shift+[ 无序列表：Ctrl+Shift+] 增加缩进：Ctrl+] 减少缩进：Ctrl+[ 2.格式 加粗：Ctrl+B 斜体：Ctrl+I 下划线：Ctrl+U 代码：Ctrl+Shift+` 删除线：Alt+Shift+5 超链接：Ctrl+K 图像：Ctrl+Shift+I 清除样式：Ctrl+ 3.部分常用的标题：Ctrl+1、2、3…对应一、二、三…级标题（光标定位到需要设置为标题的行，按快捷键）加粗：Ctrl+B（选中要加粗的文本，按快捷键）斜体：Ctrl+I（选中要设置斜体的文本，按快捷键）下划线：Ctrl+U（选中要加下划线的文本，按快捷键）删除线：Alt+Shift+5（选中要加删除线的文本，按快捷键）代码片段：Ctrl+Shift+`（选中要设置为代码片段的文本，按快捷键）代码块：Ctrl+Shift+K（任意位置按快捷键，选择编程语言然后在代码块中输入代码）切换到下一行：Ctrl+Enter（任意位置按快捷键，在代码块中可以跳出代码块另起一行）链接：Ctrl+K（先复制链接，然后选中要加链接的文本，按快捷键。Ctrl+左键点击文本可跳转到对应链接）取消格式：再次按相同的快捷键即可有序列表：数字+点+空格任务列表：加号或减号+空格切换到列表下一行：Space+Enter嵌套列表：按Tab键退出列表：按 Shift+Tab插入表格：Ctrl+T引用：输入&gt;后面加空格，或者Ctrl+Shift+Q 3.yilia的美化和修改（已经换蝴蝶主题）标签 123456tags: - 小工具 - hexo - yilia---或者tags: [xx,xxxx] 截断点12# 在博客md文件中，设置截断位置&lt;!--more--&gt; 图标1`theme/yilia/source`目录下添加`favicon.ico`图片 文章点击量1234567891011121314themes/yilia/layout/_partial/article.ejs中&lt;%- partial(&#x27;post/title&#x27;, &#123;class_name: &#x27;article-title&#x27;&#125;) %&gt;后面加入&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;br/&gt; &lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 阅读数: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt;&lt;% &#125; %&gt;&lt;!--显示阅读次数完毕--&gt; 插入图片1npm install hexo-asset-image –save 打开blog的_cofig.yml修改 1post_asset_folder: true 新建文章的时候自动生成文章名字.filenname，将图片放入 总文章数123456789将*themes\\yilia\\layout_partial*left-col.ejs文件的&lt;nav class=&quot;header-menu&quot;&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt; 不蒜子12在 themes\\yilia\\layout_partial\\after-footer.ejs最后添加&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 1234567891011修改 themes\\yilia\\layout\\_partial\\footer.ejs，包括访客数和站点访问总量# PV方式，单个用户连续点击 n 篇，记录 n 次记录值&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;# UV方式，单个用户连续点击 n 篇，记录 1 次记录值&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;单篇# 使用 pv 记录方式，每访问一次，记录一次&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 4蝴蝶主题12345678npm install hexo-generator-index-pin-top --save安装置顶md文件内部的配置top: 1000//数字越大置顶在前面//这个也是zsticky:comments: true 添加上这个，如果这篇文章不需要评论改为false，默认开启 Butterfly主题美化日记 | Akilarの糖果屋 Hexo+Butterfly主题美化 | 唐先森の博客 (tzy1997.com) Hexo 博客之 butterfly 主题优雅魔改系列 | 小康博客 (antmoe.com) Butterfly主题外挂标签（个人常用） | Hassan’s Blog (hassanwong.top) Search | Font Awesome 图标网站11","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"个人博客/hexo","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo/"}],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"http://example.com/tags/%E6%8C%87%E4%BB%A4/"},{"name":"记录","slug":"记录","permalink":"http://example.com/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"最初のBlog「神楽の魂という意味は？」","slug":"神楽の魂という意味は？","date":"2021-11-22T04:57:13.000Z","updated":"2022-04-19T15:18:58.003Z","comments":true,"path":"2021/11/22/神楽の魂という意味は？/","link":"","permalink":"http://example.com/2021/11/22/%E7%A5%9E%E6%A5%BD%E3%81%AE%E9%AD%82%E3%81%A8%E3%81%84%E3%81%86%E6%84%8F%E5%91%B3%E3%81%AF%EF%BC%9F/","excerpt":"关于我的网名","text":"关于我的网名 1.ゲームから初中的时候玩阴阳师，自动推荐的名字就是神乐之魂「かぐらのたましい」，也不知道怎么的就喜欢上了这个网名。 2.激しい后来，高二的时候买了日语网课(因为我是小语种考生),一开始我在群名批注就改为神乐之魂。 那时候我还以为乐这个字读为le，后来小王子老师叫我网名的时候就是读yue，当时我也经常读错。不过随着日语水平的提高我叫它为かぐら。 后来和群友混熟了，他们都叫我神乐老弟（现在退群了），我也习惯了神乐之魂这个网名。 我的GitHub就是以神乐之魂的假名为基础命名的，但是太过于长了（kaguranotamashii），待考虑改为kagura。 3.新しいミライから我的博客主要打算写我的对计算机的学习，以及我的一些思考。 ボクノミライハマダ始まったバカリ！(我的未来才刚开始！)","categories":[],"tags":[]}],"categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"},{"name":"cpp","slug":"编程/cpp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/cpp/"},{"name":"Python","slug":"编程/Python","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/Python/"},{"name":"前端","slug":"编程/前端","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"编程/前端/CSS","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"javascript","slug":"编程/前端/javascript","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/javascript/"},{"name":"个人博客","slug":"个人博客","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"问题","slug":"个人博客/问题","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%97%AE%E9%A2%98/"},{"name":"HTML","slug":"编程/前端/HTML","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"hexo","slug":"个人博客/hexo","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://example.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"黑苹果","slug":"黑苹果","permalink":"http://example.com/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"闲谈","slug":"闲谈","permalink":"http://example.com/tags/%E9%97%B2%E8%B0%88/"},{"name":"swift","slug":"swift","permalink":"http://example.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"http://example.com/tags/ios/"},{"name":"年度总结","slug":"年度总结","permalink":"http://example.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"cpp","slug":"cpp","permalink":"http://example.com/tags/cpp/"},{"name":"考试","slug":"考试","permalink":"http://example.com/tags/%E8%80%83%E8%AF%95/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"思考","slug":"思考","permalink":"http://example.com/tags/%E6%80%9D%E8%80%83/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"http://example.com/tags/%E6%8C%87%E4%BB%A4/"},{"name":"记录","slug":"记录","permalink":"http://example.com/tags/%E8%AE%B0%E5%BD%95/"}]}