{"meta":{"title":"神楽の魂の小窝","subtitle":"","description":null,"author":"神楽の魂の小窝","url":"https://kaguranotamashii.github.io","root":"/"},"pages":[{"title":"about","date":"2021-12-07T16:06:22.000Z","updated":"2022-07-17T04:38:25.409Z","comments":true,"path":"about/index.html","permalink":"https://kaguranotamashii.github.io/about/index.html","excerpt":"","text":""},{"title":"categories |分类 |归档","date":"2021-11-27T05:46:32.000Z","updated":"2022-04-29T15:51:52.679Z","comments":false,"path":"categories/index.html","permalink":"https://kaguranotamashii.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-27T05:46:37.000Z","updated":"2022-04-30T12:22:11.827Z","comments":false,"path":"tags/index.html","permalink":"https://kaguranotamashii.github.io/tags/index.html","excerpt":"","text":""},{"title":"我的相册","date":"2022-08-14T13:51:50.210Z","updated":"2022-08-14T13:51:50.210Z","comments":true,"path":"gallery/index.html","permalink":"https://kaguranotamashii.github.io/gallery/index.html","excerpt":"","text":"我的世界 和老朋友联机1.18截的风景... 我的世界 和老朋友联机1.18截的风景..."},{"title":"link","date":"2022-02-16T16:04:18.000Z","updated":"2022-04-19T14:10:30.578Z","comments":true,"path":"link/index.html","permalink":"https://kaguranotamashii.github.io/link/index.html","excerpt":"","text":""},{"title":"gallery","date":"2022-05-07T02:56:02.804Z","updated":"2022-05-07T02:56:02.804Z","comments":true,"path":"gallery/2022/wdsj/index.html","permalink":"https://kaguranotamashii.github.io/gallery/2022/wdsj/index.html","excerpt":"","text":"废旧矿洞的冒险 世界最高峰! 雨林小家 雪山冒险 被追杀后，转角遇到了最美风景"},{"title":"乱七八糟的内容","date":"2022-08-14T13:39:53.000Z","updated":"2022-11-15T08:12:02.909Z","comments":true,"path":"pingce/index.html","permalink":"https://kaguranotamashii.github.io/pingce/index.html","excerpt":"","text":"游戏 青い空のカミュ 青空下的加缪简评 旅行 拜访李卓吾墓 8月16日拜访李贽墓"},{"title":"拜访李卓吾墓","date":"2022-08-16T13:58:05.000Z","updated":"2022-11-15T08:13:30.436Z","comments":true,"path":"pingce/旅行/李卓吾墓/index.html","permalink":"https://kaguranotamashii.github.io/pingce/%E6%97%85%E8%A1%8C/%E6%9D%8E%E5%8D%93%E5%90%BE%E5%A2%93/index.html","excerpt":"","text":"今天有个人私事请假一天去外面办事了，办完后，突然心血来潮想去看看自己最喜欢的位古代哲人李卓吾先生的墓，毕竟今年是李卓吾先生去世的420年。 在西海子公园里面，屹立一座名人之墓，墓碑上面写这李卓吾之墓，这就是明代非常知名的离经叛道的思想家李贽。他可以说之为东方的尼采，当尼采说出上帝已死，早在三百年的大明，狂生李贽就说出“孔子非圣”。 读李贽，常心有戚戚焉。他如一个盗火者，以离经叛道的形象出现在中国的思想史、文化史中，他批道学，扬人性；倡导男女平等，支持婚姻自由；他把孔子拉下神坛，痛斥那些身着儒衣满嘴道德却行着假仁假义之事的道学家……有人说，李贽是穿越到明朝的现代人，他的思想太超前，以至为当世所不容，哪里有什么穿越者，他不过是葆守了内心的那团火，求真之火，他卓卓然立于世，绝不与这个世界行什么“讲和”之事，他宁肯抢刀自戕，也不愿在大明王朝的狱中“污己面目”，其悲壮惨烈，有几个“中庸”之人能做到？如果说李贽是穿越者，我宁肯相信，他并非是由现在穿越过去的，而是在不知多少年之后的未来穿越，若他活在现在，那些“精致的利己主义者”，和他痛斥的道学家，又有何分别？ 李贽（1527—1602），明代卓越的思想家、哲学家，反对封建正统思想，批判程朱理学，著作有《藏书》、《焚书》等。 李卓吾是福建的泉州人，因为自己对儒家的批判使得他被押入京师，在狱中不久就剃刀自刎，临死前引用王维的诗说的“七十老翁何所求”，两天后他在痛苦挣扎中才真正的脱离了苦海。死后老朋友冒着极大的风险和政治压力托他的遗愿，将他葬身于通州的迎福寺。后来解放后他的墓又搬迁到其他地方，最后在改革开放后搬迁到西海子公园，老先生他应该终于能安静下来了吧，从泉州到通州整整两千千米的路，很难想象老先生都经历了什么。葬身他乡，对于古人来说很不好受。 墓地周围载满了白杨树，据说是世人按照他的遗愿来建的，刺破青天魂未锷未残的大丈夫气概。 李贽是一个孤独的思想者，他的思想以及超越了他所在的年代，对真理的追求，对人生的目标的思考，对虚伪的儒学进行无情批判，使他得到褒贬不一的评价。之后的四百年，每一位统治者对他深恶痛觉，稍有风吹草动，就颁布查禁李贽的书籍命令。 当一个人口众多的国家，每个人的行动，如果只凭借儒家思想思想这种原则作为约束和规则，社会的发展也必然会受到限制。 在程序员里面有一个梗叫屎山代码，最初的代码是由大佬写完的，简洁好用，但是在不断的使用中，不断的有程序员对他进行加工，让这个好用简洁的代码编程了屎山。最初的儒家强调的是仁义礼智信温良恭俭让,简短的十个字，实际上给后人制定了，一个及其高的圣人标准，希望每个人都成为良民，但实际上，儒家自从被创造出来变成了统治者统治世人的工具，皇权工具，核心从头到尾都再强调阶级，围绕阶级在两千年的发展过程中，皇权以及高层不断添油加醋，对思想进行进一步过分解读。让人什么君君夫夫子子，就是在告诉世人，不要跨过自己的阶级，底层的黎民百姓在乖乖按照儒家思维，严于律己，但是统治者和高层却在贪污腐败，男盗女娼的事情。但是世人又不完全是傻子，他就是其中之一。从封建社会到建国后，四百二十年过去了，他惊世骇俗，不需要崇拜，他只是需要理解，而这恰恰是我们该做的。 孤独的漂泊者已经倒下，他的影子却笼罩了整整一个时代"},{"title":"香山","date":"2022-08-16T13:58:05.000Z","updated":"2022-11-15T08:15:41.628Z","comments":true,"path":"pingce/旅行/西山/index.html","permalink":"https://kaguranotamashii.github.io/pingce/%E6%97%85%E8%A1%8C/%E8%A5%BF%E5%B1%B1/index.html","excerpt":"","text":"2022年十二月又看到了我写的这篇，emm关于这篇纯属是我中二病意淫写的一堆狗屎。 怀念故友，在这枫叶尚未变红的九月，但是故人回学校了。突然心血来潮想去看看西边的山， 又一次看见熟悉的西郊线，骑过四季青长长的轨道，那便是香山。 爬山去吧，去窥视在鬼见愁长眠的战士吧，重力的精灵如是说。 我不是一位剑豪，诗人，哲学者，音乐家，我也是位普通人，如同德廉美修道院的信徒们。我持着理性和生命力双重宝剑又一次杀死了重力的精灵，直至爬到鬼见愁。 我在这蓝星上目睹你们从猿猴类到生而荒谬的人类上，更久远的物语我也基本都忘记了，你凭什么杀死我？重力的精灵如是说。 因为我们人类的头脑，比天空辽阔。我是一个人类，渺小的，衰弱的，死亡的。 我在数千年就见到一位叫西西弗斯的国王，既出于他的激情，也出于他的困苦。他蔑视诸神，憎恨死亡，却热爱生命。这是你的战利品，拿去吧。精灵们，出来吧，来服侍远方的旅者吧，让他洗净都市的尘土，魂归于心，让他做最真实的自我。他既便肉体功能不完善，即便有时候也会被A.T. フィールド所伤，他的身体是一种伟大的理性，是只有一种意义与一种虚无，是一场战争与一次和平，是一个牧群与一个牧羊人。去到达超人的桥梁吧。重力的精灵如是说。"},{"title":"乱七八糟的内容","date":"2022-08-14T13:39:53.000Z","updated":"2022-12-05T11:58:36.291Z","comments":true,"path":"pingce/日常随笔/index.html","permalink":"https://kaguranotamashii.github.io/pingce/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/index.html","excerpt":"","text":"关于尼采 健全的生命本能，超越的精神追求。本能和超越。生命哲学发挥了前者，存在主义发挥了后者。在人生这棵树上，尼采欣赏的是茁壮的根和美丽的花朵。他之所以厌恶现代文明，是因为现代文明使根萎缩，使花朵凋谢，本能和精神的双重退化，人变得衰弱而平庸。 王：（现代文明怎么阻碍生命和精神了（？ 如果结合尼采的时代来说，现代文明正在发挥它的积极作用，但是消极作用也渐渐暴露了，资本主义先天的弊端(精神被资本奴役，生命被资本控制）让乐观的哲学家们再次思考起来，于是马克思主义便诞生。 如果是当今的时代，尼采自嘲为“时代的早产儿”，可惜即便是现在他期待的社会依然没有到来，反而愈来愈严重了，大资本变成财阀，财阀控制社会舆论，舆论进一步控制每个人的思想，思想自由的人，被控制，这才是可怕的事情。也就是生命与精神的双重退化。 关于老人与海和西西弗斯 西西弗的故事在我们看来可能是悲剧的，但是对于西西弗来说就不一定了。西西弗的荒谬过程是由法国作家阿尔贝加缪的《西西弗神话》这本书表现出来的，加缪称西西弗为荒谬的英雄。众神认为对他下的惩罚是极为痛苦的极为严厉的，但是他依然藐视纵神，仇恨死亡，对生活充满了激情，西西弗用他那行动也即反抗，让这个沉默而沉重的世界，听到了最无声而有力的反抗声。命运是属于西西弗的，沉重而无尽的苦役中，西西弗向他自己的存在而致敬。 应该认为，西西弗是幸福的。-《西西弗神话》 老人与海的剧情内容不就是将西西弗的对众神的反抗代替为神秘而残暴的自然，明知与鲨鱼搏斗是没有任何意义的，疲惫到极点，在大洋中漂流，最后在床上疲惫睡去，众人看着那奇迹般的鱼架，在那一刻老人便向荒谬的世界，发出自己反抗。海的荒诞性在于欣喜若狂和功亏一篑的结果。虽然老人可以在一瞬间的死中，得到解脱，但是他依然直面未知的荒谬向“鲨鱼”和“自然”经历80多天的战斗，这也是生命庄严的存在的证据。 值得一提的是《西西弗神话》开篇是&quot;真正严肃的哲学问题只有一个，那便是自杀&quot;,而海明威却选择了自杀… 关于法语的起升降落 完全病态的，未启动就毁灭一切（大概就是只要有一点不完美就毁掉所有打算重开，一直都处在一种“准备过程中”但是就是不开始，就是想等天时地利人和，有一点不和就绝对不开始，继续往下等。其实是一种不自量力的幻觉与空想：到了合适的时候我一定能开始。 幻想为看不清自己的现实情况和能力，一厢情愿式的认为：只要到了某个时刻做了某件事，自己就能怎么怎么样。幻想导致了这种高估自己实力的想法，而实际上只会导致虚假的等待，对成功的期望则完全建立在空想的废墟上。 这样的完美主义不能允许一点差池，是病态中的病态，因为再深入导致这种毁灭式完美主义的则是人对事物过度的掌控欲…（差不多 解决方案就是：落地，睁开现实的眼睛看世界，不要过度沉浸在自我世界里，破解幻想，认识到自己是“人 关于我的拖延症 怎么说呢，我觉得自从上了大学后，我也患上了这中严重的拖延症。无论是在学习还是对待事情的看法，我都出现了严重对停滞。其实我现在都不去上课了，除了英语以外的课。这学期我入坑了很多的坑，但是都仅仅是一脚踏入佛门。我记得你半年前和我提到过“手舞足蹈”，所以我把我这种拖延症称之为手舞足蹈式拖延症。脑干控制四肢，但是手舞足蹈的四肢是没有规律可言的，但是脑干依然以微弱的电信号控制仅有的意识 喝完啤酒后 去厕所我还挺喜欢这种感觉的，手臂仅有葳蕤的感觉被脑子控制，肌肉全身放松，走路像位酒疯子，虽然很不形象，但是这种放飞自我式对手舞足蹈让我感到很欣然自若。我向来是反感排斥酒精的，因为我本身就是对酒精就很敏感，因此很容易醉(指一杯)，但是最近自从朋友买酒厚剩余对都会送我喝，我喜欢星期五或者星期六的晚上，喝上一杯酒精可乐，都会忘记这一周的烦恼，虽然这种感觉是短暂的神经麻痹，但是很满足带给我的安慰和放松感。 王（指正）：确实（不过脑干不控制四肢，脑干控制最基本的生命体征比如呼吸 比如心脏的跳动 我：用极乐迪斯科的话描述脑干是远古的爬虫脑 ”古老爬虫脑就是负责人体基本生命活动的部分，剧情里也说过了，主角能活着得谢谢它。边缘系统就是多巴胺分泌的奖惩机制，你会发现边缘系统大部分时候比较毒舌，因为主角这两天确实过的很糟，被边缘系统批评了。神经皮质就是你的那些技能呆的地方，负责天马行空，逻辑推理等等各种复杂高级的思维。想来人的大脑好像确实是这么工作的。“ 关于近期带给我的沉重历史感 近日自新疆大火后，全国各地都有游行示威行为，从上海到北京，从市民到学生，在示威过程也出现了一些很糟糕的情况。与此同时，没过几天的11月30日江泽民同志去世了，享年96岁。只是近期发生的事情让我觉得心烦意乱，从未有过如此参与历史的感觉。他的身体很早就很不行了，理论上，何日何时逝世，都很正常。但是在这个时间点上，他的逝世，正好成为了这个多事之秋最大的事，确实很难没法让我、让大家过度联想，在巴比伦塔上留下的咒语。借用江泽民同志生前的书法写下的**“思源致远”**，我简要分析近日的看法。 抗议游行的本质是为了维护个人集体国家的利益，本意是好的，通过合法的游行，使得政府所做的不当行为，得以反思及改变。但是示威途中如果出现 但是在游行示威途中一旦出现合理诉求之外的事情，那么示威本质就会发生变化。比如上海的示威就出现了一些危险发言。这种示威以及违背了初心，会导致其他严重的后果。但是民主和自身的权力仍然要争取，拒绝忽悠。比如历史的某事件，他们参与的是反贪污和官倒，后来声音变成都是gcd搞的鬼，要团结起来对抗军队，再后来在那里欢呼“shanghai宣布独立”，“hubei宣布独立”，变成分裂分子。民意达成后，应该撤离广场，但是有些人仍然呆在广场聚集，再后来的结果就是核心成员提前跑到海外了，有些无辜被忽悠的学生成为了纪念碑的一道弹孔。运动和游行是能参与的，支持群众表达合理的意见，声音。但是必须保持自己的头脑清醒，不能被轻易忽悠成为炮灰。 局外人 我常常想，如果让我住在一棵枯树干里，除了抬头看看天上的流云之外无事可干，久而久之，我也会习惯的。何况，认真想想，我并不在一棵枯树干里。还有比我更不幸的人。不过，这是妈妈的一个观念，她常常说，到头来，人什么都能习惯。"},{"title":"青空下的加缪","date":"2022-08-14T13:58:05.000Z","updated":"2022-08-15T14:57:11.445Z","comments":true,"path":"pingce/游戏/青空下的加缪/index.html","permalink":"https://kaguranotamashii.github.io/pingce/%E6%B8%B8%E6%88%8F/%E9%9D%92%E7%A9%BA%E4%B8%8B%E7%9A%84%E5%8A%A0%E7%BC%AA/index.html","excerpt":"","text":"加缪说：“真正严肃的哲学问题只有一个，那就是——自杀。” 青空下的加缪 - 萌娘百科 万物皆可萌的百科全书 (moegirl.org.cn) 《青空下的加缪》是KAI-SOFT制作的以阿尔贝·加缪的哲学为主题思想，同时也融入宫泽贤治《银河铁道之夜》元素的双女主视觉小说，于2019年3月29日发布 ―――纵使世界错乱了、纵使迷失了世界――― 这是两个少女联结羁绊的三日物语。 仅仅是完美的日常中扭曲的不合理。 天空蔚蓝无尽，澄澈地如同毫无意义。 Qui a tué fille(是谁杀死了少女) 只想知道那件事情。 在疫情上网课期间我读了几本关于加缪的书籍的代表作《局外人》，《西西弗的神话》。在一次偶然的机会下，知道了这部被称之为“小素晴日”的青空下的加缪，画风也很符合胃口，以废萌的心态去玩了这部游戏。游戏的流程不长，仅仅五小时就能玩明白剧情大概。 故事的背是萤的家乡对座敷童子“仪式”，通过子嗣传承的方式来将“气运”这一不具有实体的概念作为“座敷童子”的实体概念来维系与留存，以此来将这一区域的气运变得高于周围，并且通过座敷童子的一代代“传承”来将这一气运保持在该地区。 了解过故事背景的读者应该明白，这种行为是一种不能为我们所接受的行为，因为我们不可以接受为了更多人的利益而去放弃一个人的行为。然而，这个地区却因为所谓地区发展的需要这样的借口，以及在此之上的强化认识的行为，即所谓“仪式”。初代座敷童子“大本大人”也在此时，因为和来自城市的青年相遇，但是缘于年幼等原因，而错过了向他表达自己心中感情的机会，最终青年离去，大本大人只在匆匆之间，制造了这一遗憾。 故事的下一段时间，是关于燐的小时候的经历的，燐小的时候，曾经过过一段十分幸福的生活，家庭的和睦让她快乐，感受到了来自家人的关怀与爱，体会到了家庭的温暖氛围。而来自哥哥聪的关心则让她获得了更多的爱，甚至在此基础上发展出了燐对聪的爱恋之情，后来，燐与从一起在外远足时，路过了羊胡子花田。 在那里，她体会到了自己最幸福的一段时光，并且和聪的关系也更近一步，后来，在另一次和聪一起因在外游玩而在外过夜时，燐尝试去将两人的关系更进一步的拉近，于是选择了向聪提出请求。此时的聪因为自身心中爱恋与欲望的两重心理状态的纠结，而险些迈出一步，但是最终，聪还是保持了自身的理智，没有回应燐的请求。但是在聪的心中，他仍然持续因为自己对于燐竟然有着欲望的不纯洁思想而感到愧疚与自责，这一矛盾持续在他心中凝结，并且最终将引发一场大变动。 至此，背景铺设完毕，故事开始正式展开。聪因为工作原因，来到萤家乡附近的森林调查，被正在寻找外乡人的仪式主持者找到，软禁在野外的旅馆，然后在软禁过程中，被小时候的大本大人留下的残像影响，准备直面自身的矛盾。另一方面，燐与萤乘坐火车，因为在火车上睡着，而来到萤的家乡站。此时，聪的决绝引动了世界的变动，造成了世界对这一地区的扭曲与修复。 燐与萤在车上醒来，发现所有人都失去响应，在与村民们化成的怪物交战以后，惊险逃脱。两人商议以后，决定前往萤的家里，在路上，他们在分化为狗的聪的帮助下，从分化为猩猩的聪手中逃脱，到达了萤的家里，经过探索，发现了小时候的大本大人所经历的“仪式”，随后逃到萤的房间，进行休息。睡梦之中，两人被唤到了蓝白房子的世界，在那里遇到了大人状态的大本大人，在她的指引下，懂得了回到房间的方法。两人醒来以后，发现此时的世界处于永夜状态。月亮收敛以后，怪物闯进了萤的家，并且在家中大肆翻找破坏，所幸两人躲在阁楼逃过一劫。见门已被打开，认为呆在原地没有意义的两人决定去寻找仪式主持者询问缘由，却在路上发现来了已经变身怪物，失去理智只剩下邪恶思想与欲望的主持者。两人决定去萤初中的校图书馆自己寻找资料，但是在那里被变身怪物的老师堵在墙角。随着萤极度恐惧的求救期望，两人再度被召唤到了蓝白房子的世界，与大本大人交流以后，萤在此处了解了自己的家族背景，以及自己身为座敷童子的身世，甚至是未来本应就要进行“仪式”的所谓事实，也大致了解了现在这个世界的状态，了解要尽快离开这个区域。两人于是经过一番波折，在突然下起的大雨下开着车冲破怪物的阻拦，在巨大的脚的巧合帮助下逃离了怪物聚集的城镇，前往该地区的边界。在路上，两人通过收音机，收到了一个叫DJ戈多的电台的电台节目，在电台中，主持人似乎在描述这两人的行动轨迹，并且在说话中不时掺杂这一些哲学意义的话。萤与燐也以此为契机，讨论起了自己以往听过的，关于《等待戈多》，加缪的《局外人》等具有哲学色彩的内容 回到故事，两人骤降的大雨下，经历的汽车之旅中，慢慢深刻的认识到自己的一切，萤对自己的身世有了了解，甚至突然意识到自己没有父母，没有亲近的人，在和燐相遇相识之前甚至好像一个仅仅只是或者的空壳，而她在此之前甚至没有自觉。这一点与加缪观点所强调的，人在异己世界的孤独不谋而合，短短的几段对话就让我们认识到了萤一直以来的艰苦和不易。而燐则在思考大本大人给自己的提示中，渐渐感受到了自己的残缺不全。两人同样也在聊天中，感受到了对方对于自己的意义所在。两人到达地区边界时，却被临时生成的树挡住了去路，一筹莫展的两人决定先回到城镇，在路上，两人遇到了一个临时收拾过的疗养所，其实根据剧情我们知道这个疗养院其实也就是燐的哥哥聪被软禁的地方。在此处，她们遭遇了猩猩，并且在聪的帮助下暂时击退了猩猩。燐拿起了从猩猩身上掉落的指南针，意识到了什么，决定前往风车探寻哥哥隐藏起来的事情。在风车那里，燐了解到了哥哥正是被居民们软禁来要求完成仪式的外乡人。两人再次来到蓝白房子的世界，降落在了一群风车的顶上，在这里，她们和大本大人一同，整理了世界的本质，明白了世界因为聪对自己的决绝导致了这片区域的转变，燐也见解认识到，聪已经很难和她一起安然的回去了。最后，她们在这片永恒的蓝白色世界，放飞了不会降落的纸飞机。回归到现实，两人决定从另一条荒废的轨道上，向外面走去，尝试远离这个区域。在路上，他们面临了驶来的火车，面临了发狂的伐木机，被怪物追赶。 在此期间，大本大人也终于回忆起了自己儿时的想法，向着相似于曾经那个青年的聪，表达了自己的爱恋之情。两人在劳累之时，回到了蓝白房子的世界，和大本大人进行了最后的讨论，此处蓝白色房子的世界尤其描述了一个概念“蜗牛壳”，翻开它，只剩下空空的一具躯壳，属于它的悲伤与记忆已经消失，属于它的历史与经历也已经被人淡忘。我觉得此处的蜗牛壳应该是大本大人在暗示自己，暗示蓝白房子，正如最后蓝白房子失去了蓝色的门和窗户一样，它也像蜗牛壳一样，只是证明着一些东西的存在，证明那些已经画作回忆的希望，失望，经历，情感。 两人休息结束，穿过树林环绕的铁轨，到达了一个转车台，即用于调整火车行进轨道的一个大型设备。在这里，聪与燐和猩猩展开了最后的决斗。萤为了帮助燐，选择尝试去扭动转车台的方向，在他成功的部分扭动转车台后，月亮现身照相了大地，那些原来在外围觊觎着萤与燐的怪物化为了光电，在萤的请求下，回复一定理智的他们选择了帮助萤将转车台转回了原本的位置。随着转车台回归正轨，聪和猩猩的决战也落下帷幕，两者互相打出了致命的一击，只留下燐在两者之间。随着事情的解决，永夜的天空化作了碎片，失去生机的怪物上，慢慢飘散出了一个个灯烛，他们填满了天空。 见证着萤与燐回到蓝天与白云下的蓝白房子世界，但是不同的是，蓝白房子失去了窗户与门，大本大人也不见所踪。萤感慨着劫后余生，燐还因为哥哥离去的事实而没有彻底回过神来。此时，两人发现一直以来空荡荡的轨道正有一辆列车开过。萤登上了列车，但是回过神来，却发现燐已经被抛下，燐尝试去追逐列车，萤也努力的尝试抓住燐的手，然而，最终燐还是没有搭上这辆车，独自一人，在这一片消散中的蓝白中看着萤的远去。回过神的萤发觉自己和燐一起躺在列车的铁轨上，在稍远处，萤的家乡因为大雨而被彻底淹没，连带着在这片土地上一直以来的种种，消逝在了深水之下。庆幸于燐的所在的萤，决心与萤一直在一起，然而，牵着手走在铁轨上的燐，却在几句话语之中，消失在了光芒里，只留下独自捡起落下的纸飞机，留下眼泪的萤… 本作中时刻在体现的加缪哲学，甚至是作品名“青空下的加缪”，我想，也许就是作者对于萤的一种寄托吧，希望她，可以像加缪所追求的那样，在孤独中寻找自身的意义，最终，带着对燐的思念，幸福的生活下去。 这样的结局，难免让人心痛，毕竟萤好不容易寻得了自己的珍宝，但是回头却发现，珍宝已经是支离破碎的样子了，但是此刻，请让我用聪的那句话，或者说，萨特的那句话，来为这篇长评做结吧： 毫无道理的出生，因软弱而延续，因偶然而死亡。 这样结尾也太寂寞了，再添句话吧：在荒诞中奋起反抗，在绝望中坚持真理和正义。最后祝愿，三人在其他的世界可以不用经历痛苦，在平静中享受属于自己的幸福。"},{"title":"thinking","date":"2022-08-03T17:05:28.000Z","updated":"2022-08-03T17:22:35.186Z","comments":true,"path":"thinking/index.html","permalink":"https://kaguranotamashii.github.io/thinking/index.html","excerpt":"","text":"关于旅行 出自2017年12月jlpt n2考试短篇阅读理解 ？篇阅读理解"},{"title":"关于自驾游","date":"2022-06-28T09:11:08.000Z","updated":"2022-08-03T17:10:11.683Z","comments":true,"path":"thinking/关于自驾游.html","permalink":"https://kaguranotamashii.github.io/thinking/%E5%85%B3%E4%BA%8E%E8%87%AA%E9%A9%BE%E6%B8%B8.html","excerpt":"","text":"出自2017年12月jlpt n2考试短篇阅读理解 ？篇阅读理解"},{"title":"","date":"2022-11-14T09:29:26.565Z","updated":"2022-11-14T09:29:26.565Z","comments":true,"path":"gulpfile.js","permalink":"https://kaguranotamashii.github.io/gulpfile.js","excerpt":"","text":"var gulp = require(\"gulp\"); var fontmin = require(\"gulp-fontmin\"); function minifyFont(text, cb) { gulp .src(\"source/fontmax/*.woff\") //原字体所在目录 .pipe( fontmin({ text: text, }) ) .pipe(gulp.dest(\"/font/\")) //压缩后的输出目录 .on(\"end\", cb); } gulp.task(\"mini-font\", (cb) => { var buffers = []; gulp .src([\"./public/**/*.html\"]) //HTML文件所在目录请根据自身情况修改 .on(\"data\", function (file) { buffers.push(file.contents); }) .on(\"end\", function () { var text = Buffer.concat(buffers).toString(\"utf-8\"); minifyFont(text, cb); }); }); gulp.task(\"default\", gulp.parallel(\"mini-font\"));"},{"title":"说说","date":"2023-04-08T09:13:49.804Z","updated":"2023-04-08T09:13:49.804Z","comments":true,"path":"speaks/index.html","permalink":"https://kaguranotamashii.github.io/speaks/index.html","excerpt":"","text":"new Artitalk({ appId: 'uglz6tnJasD6sm9qHMVU1oJk-MdYXbMMI', appKey: 'UYbIjFxE6uFOHkNjLCUxHf6R' })"}],"posts":[{"title":"","slug":"[main]CS/[main]web/node,js笔记","date":"2023-10-03T06:27:49.982Z","updated":"2023-10-03T06:15:53.700Z","comments":true,"path":"posts/0/","link":"","permalink":"https://kaguranotamashii.github.io/posts/0/","excerpt":"","text":"node.js Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 ① 浏览器是 JavaScript 的前端运行环境。 ② Node.js 是 JavaScript 的后端运行环境。 ③ Node.js 中无法调用 DOM 和 BOM 等 浏览器内置 API。 Node.js 可以做什么 Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大 的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位： ① 基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用 ② 基于 Electron 框架（https://electronjs.org/），可以构建跨平台的桌面应用 ③ 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目 ④ 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc… 总之：Node.js 是大前端时代的“大宝剑”，有了 Node.js 这个超级 buff 的加持，前端程序员的行业竞争力会越来越强！ 浏览器中的 JavaScript 学习路径： JavaScript 基础语法 + 浏览器内置 API（DOM + BOM） + 第三方库（jQuery、art-template 等） Node.js 的学习路径： JavaScript 基础语法 + Node.js 内置 API 模块（fs、path、http等）+ 第三方 API 模块（express、mysql 等） fs 文件系统模块 fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。 例如： ⚫ fs.readFile() 方法，用来读取指定文件中的内容 ⚫ fs.writeFile() 方法，用来向指定的文件中写入内容 如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它： 1const fs=require(&#x27;fs&#x27;) 1234567891011121314151617// 1. 导入 fs 模块，来操作文件const fs = require(&#x27;fs&#x27;)// 2. 调用 fs.readFile() 方法读取文件// 参数1：读取文件的存放路径// 参数2：读取文件时候采用的编码格式，一般默认指定 utf8// 参数3：回调函数，拿到读取失败和成功的结果 err dataStrfs.readFile(&#x27;./files/11.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr) &#123; // 2.1 打印失败的结果 // 如果读取成功，则 err 的值为 null // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined console.log(err) console.log(&#x27;-------&#x27;) // 2.2 打印成功的结果 console.log(dataStr)&#125;) http模块 http模块是Node.js 官方提供的、用来创建 web服务器的模块。通过 http模块提供的 http.createServer()方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。 服务器和普通电脑的区别在于，服务器上安装了web服务器软件，例如:IIS、Apache等。通过安装这些服务器软件,就能把一台普通的电脑变成一台web服务器。 在Node.js 中，我们不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于Node,js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务。 基本四步 导入http模块 创建web服务器实例 为服务器实例绑定request事件，监听客户端请求 启动服务器 导入模块 12ini复制代码const http = require(&#x27;http&#x27;) 创建web服务器实例 12ini复制代码const server = http.createServer() 为服务器绑定request事件 1234567891011121314javascript复制代码server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; console.log(&#x27;Someone visit our web server.&#x27;) const url = req.url // 请求地址 const method = req.method // 请求url // 根据路径判断返回不同内容 let content = &#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27; if(url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;) &#123; content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27; &#125; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;) // 设置响应头 res.end(content) // 向客户端响应内容&#125;) 启动服务器 123javascript复制代码server.listen(80, () =&gt; &#123; console.log(&#x27;http server running at http://127.0.0.1&#x27;)&#125;) 模块化 npm与包 包 概念 Node.js 中的第三方模块又叫做包。 就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。 来源 不同于Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。 Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。 为什么需要包 由于Node.js 的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发的时，效率很低。 包是基于内置模块封装出来的，提供了更高级、更方便的API，极大的提高了开发效率。 包和内置模块之间的关系，类似于jQuery和浏览器内置API之间的关系。 从哪里下载包 国外有一家IT公司，叫做npm, Inc.这家公司旗下有一个非常著名的网站: www.npmjs.com/，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心! npm, Inc.公司提供了一个地址为registry.npmjs.org/的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。 如何下载包 npm, Inc.公司提供了一个包管理工具，我们可以使用这个包管理工具，从registry.npmjs.org/服务器把需要的包下载到本地使用。 这个包管理工具的名字叫做Node Package Manager (简称npm包管理工具)，这个包管理工具随着Node.js的安装包一起被安装到了用户的电脑上。 npm npm是Nodejs官方的包管理工具。 初次装包完成后，在项目文件夹下多一个叫做node_ modules的文件夹和package-lockjson的配置文件。 node_modules 文件夹用来存放所有已安装到项目中的包。require()导入第三方包时，就是从这个目录中查找并加载包。 package-lockjson 配置文件用来记录node modules目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。 123456789101112131415csharp复制代码# 初始化npm配置文件# -y表示使用配置默认选项# 执行后出现 package.json 文件npm init -y# 下载包npm install &lt;包名称&gt;# 删除包npm uninstall &lt;包名称&gt;# 切换镜像源加速下载npm config set registry=https://registry.npm.taobao.org/# 在执行npm install命令时，如果提供了-g参数，则会把包安装为全局包。# 全局包会被安装到C:\\Users\\用户目录VAppData\\RoamingInpm\\node_modules目录下。npm install &lt;包名称&gt; -g 上述命令只能在英文的目录下成功运行!所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。 运行npm install命令安装包的时候，npm包管理工具会自动把包的名称和版本号，记录到package.json 中。 12345678910111213javascript复制代码// packge.json&#123; &quot;name&quot;: &quot;nodeNpm&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo &quot;Error: no test specified&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 发布包 新建itheima-tools文件夹，作为包的根目录 在itheima-tools文件夹中，新建如下三个文件: package.json(包管理配置文件) index.js(包的入口文件) README.md(包的说明文档) 1234567891011121314151617181920javascript复制代码// packge.json&#123; &quot;name&quot;: &quot;myTool&quot;, // 包名称 &quot;version&quot;: &quot;1.0.0&quot;, // 包版本 &quot;description&quot;: &quot;&quot;, // 包的描述 &quot;main&quot;: &quot;index.js&quot;, // 包的入口文件 &quot;scripts&quot;: &#123; // 包的可执行指令 &quot;test&quot;: &quot;echo &quot;Error: no test specified&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], // 搜索关键字，使用那些关键字可以搜索到该作者 &quot;author&quot;: &quot;&quot;, // 包的作者 &quot;license&quot;: &quot;ISC&quot; // 包遵循的开源协议&#125;css复制代码// main.jsmodule.export = &#123; add(a, b)&#123; return a+b &#125;&#125; 包根目录中的README.md文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以 markdown的格式写出来，方便用户参考。 README文件中具体写什么内容，没有强制性的要求;只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。我们所创建的 这个包的 README.md文档中，会包含以下6项内容: 安装方式、导入方式、格式化时间、转义HTML中的特殊字符、还原HTML中的特殊字符、开源协议 npm发布 注册npm账号 访问www.npmjs.com/网站，点击 sign up按钮，进入注册用户界面 填写账号相关的信息:Full Name、Public Email、Username、Password 点击Create an Account按钮，注册账号 登录邮箱,点击验证链接，进行账号的验证 登录npm账号 npm账号注册完成后，可以在终端中执行npm login命令，依次输入用户名、密码、邮箱后，即可登录成功。 注意：在运行npm login命令之前，必须先把下包的服务器地址切换为npm的官方服务器。否则会导致发布包失败! 12bash复制代码# 输入账号密码后即可成功登录npm login 发布 12345bash复制代码# 将包发布在npm上npm publish# 删除发布的包npm unpublish &lt;包名&gt; --force npm unpublish命令只能删除72小时以内发布的包。 npm unpublish 删除的包，在24小时内不允许重复发布发布包的时候要慎重。 尽量不要往npm上发布没有意义的包! express的使用 这里是express中文使用说明书 在使用学习时可以参考一下。","categories":[],"tags":[]},{"title":"云服务器","slug":"[main]CS/[main]web/云服务器","date":"2023-08-15T12:41:35.000Z","updated":"2023-09-29T02:56:09.082Z","comments":true,"path":"posts/1364342007/","link":"","permalink":"https://kaguranotamashii.github.io/posts/1364342007/","excerpt":"","text":"简单来说，网站是一种沟通工具，网站的构建者可以通过网站来发布自己想要公开的内容，包括文章、视频、图片等等，或者利用网站来提供相关的网络服务，包括游戏、在线会议、网盘等等。用户可以通过网页浏览器来访问网站，获取自己需要的内容或者享受网络服务。 网站本身是构建在一台或多台主机中，并通过互联网对外提供在线的Web服务，这里的一台或多台主机一般被称为服务器或服务器集群，服务器具有独立的计算能力，用以运行网站的应用程序；同时服务器也拥有独立的存储空间，网站构建者可以提前将要发布的内容准备好并上传到服务器的存储空间中，当然这些存储空间也可以单独提供给用户来使用，比如网盘服务或抖音等短视频应用；服务器还需要稳定可靠的网络连接，方便用户能够随时随地连接服务器。 什么是云服务器ECS？ 如果把物理服务器比作房子，往往用户需要通过购买才能拥有，且需要花费大量的精力和费用去“装修维护”。 云服务器ECS是一种虚拟服务器，用户通过租赁方式使用云服务器ECS，阿里云作为“管家”负责搭建和维护ECS，用户只需要付租金即可**“拎包入住”，且在不需要的时候，可随时“退租”（释放资源）**，灵活且节约成本。 云服务器用途非常广泛，小云要搭建的个人网站只是其中的一种。下面列举了一些常见的云服务器使用场景： 网站建设 搭建个人应用：博客、论坛、网盘 搭建企业门户网站 搭建游戏私服 测试学习 Linux操作系统学习 应用软件开发、部署与测试 数据管理 存储、共享和管理数据 数据开发、数据分析等大数据场景 制图渲染 搭建 AIGC 应用 实时渲染云端游戏画面 实时渲染AR/VR图像 购买云服务器ECS实例 您可以访问云服务器ECS产品页面：https://www.aliyun.com/product/ecs 点击“立即购买” ，即可进入ECS购买页面。购买配置说明： 付费类型：包年包月、按量付费、抢占式实例三种，其中： 包年包月模式为先付费后使用，相较于按量付费价格较低，适合搭建网站长期使用； 按量付费模式为先使用后付费，按需开通和释放资源，本教程作为教学演示选择此付费类型； 抢占式实例操作与按量付费实例相同，在实例保护期外市场价格超过了个人出价，将被释放，相对于按量付费实例价格有一定的折扣； 提示：如果您的实例用于web服务，中国内地必须完成ICP备案，备案实例（含续费）时长需在3个月及以上（仅支持包年包月类型）。 地域：云服务器所在的城市，选择靠近访问者的地域可以有效提升访问速度。 网络及可用区：指定专有网络、可用区、交换机，选择默认即可，如有自定义需求，可以点击“创建专有网络”和“创建交换机”进行快速创建。 提示1：专有网络VPC（Virtual Private Cloud）是您基于阿里云创建的自定义私有网络，不同的专有网络之间二层逻辑隔离，您可以完全掌控自己的专有网络，例如选择IP地址范围、配置路由表和网关等，可以在自己创建的专有网络内创建和管理云产品实例。 提示2：交换机是组成专有网络的基础网络设备，用来连接不同的云资源。创建专有网络后，您可以通过创建交换机为专有网络划分一个或多个子网。同一专有网络内的不同交换机之间内网互通。 实例：实例是能够为您的业务提供计算服务的最小单位，不同的实例规格可以提供的计算能力不同。本例通过筛选购买1 vCPU、2 GiB内存的ECS实例。 提示：实例规格包含了vCPU核心数、内存大小和对应的芯片架构。同时，实例规格族名称上带有数字，一般来说，数字越大代表该实例规格使用的芯片越新，性价比越高。 镜像：云服务器ECS的“装机盘”，为ECS实例提供操作系统、初始化应用数据、预装的软件。其中公共镜像为阿里云官方提供的操作系统镜像，皆是正版授权，并通过了阿里云官方的安全和稳定性测试。本例镜像选择“公共镜像-CentOS-CentOS 7.9 64位” 系统盘：用于安装操作系统的存储，为必选项，只能随实例创建，生命周期与挂载的ECS实例相同。本例系统盘选择高效云盘，40GiB。 数据盘：为可额外增加的存储，用于存储应用数据，可选，可以与ECS实例同时创建，也可以单独创建。本例不添加数据盘。 快照服务：能定时对云盘进行备份，可应对病毒感染、数据误删等风险。本例不选择快照策略。 公网IP：勾选“分配公网IPv4地址”选项后，系统会为ECS实例分配公网IP，并出现“带宽计费模式”和“带宽峰值”配置项，可按需进行配置。本例配置为按使用流量计费 5Mbps带宽峰值。 带宽计费模式为“按固定带宽”时，按指定的带宽值收费，实际的出网带宽不会高于指定的带宽值，适用于对网络带宽要求比较稳定的业务场景。 带宽计费模式为“按使用流量”时，按实际产生的网络流量进行收费，且可设置出网带宽峰值，适用于对网络带宽需求变化较大的业务场景。 安全组：一种虚拟防火墙，用于控制ECS实例出/入方向流量，保障ECS安全。本例选择新建安全组，并开放**HTTP（80）**端口，此端口用于后续网站搭建使用。 登录凭证：为用户登录ECS实例的方式方法，本例选择自定义密码，登录名勾选root，并设置登录密码。 提示：root用户权限是Linux系统中特定用户拥有的最高权限，它可以让用户访问和修改操作系统的核心资源，修改系统文件时不会遇到权限问题，但也不能滥用，因为这种权限可能会导致系统的破坏，因此要慎重使用root权限。本例为教学测试使用。 小云要使用什么工具“远程连接”ECS实例？ 云服务器ECS支持通过多种方式连接实例，包括阿里云提供的连接工具（如Workbench、VNC等）和第三方客户端工具（PuTTY、Xshell、SecureCRT等）。 当实例的状态是运行中，表示实例已经开始通电运行，因为操作系统有短暂的启动时间，所以如果你的ECS实例是刚创建或刚启动，此时Workbench和第三方客户端工具可能暂时无法远程连接，这种情况下，用户只能通过VNC的方式登录实例查看操作系统的启动进展。 管理云服务器ECS——网站选型和搭建 小云发现市面有较多的个人网站系统软件，其中 WordPress 是使用非常广泛的一款，而且也可以把 WordPress 当作一个内容管理系统（CMS）来使用，很多初创的企业也是通过 WordPress 构建自己公司的主页，于是他决定使用 WordPress 来构建自己的自媒体平台，但是他要如何搭建呢？ 搭建准备 WordPress是使用PHP语言开发的内容管理平台，WordPress运行的基础环境一般为“LAMP/LNMP”，其中： “L”为Linux的缩写，是操作系统软件，是服务器中其它软件运行的基础，常见的CentOS、Ubuntu等； “A/N”为Apache/Nginx的缩写，是Web服务器软件，用来运行网站页面以及响应处理用户请求； “M”为MySQL的缩写，是数据库软件，用来存放网站运行必要的系统数据和用户数据； “P”为PHP的缩写，是编程软件，用来运行WordPress软件的代码。 对外发布个人网站 为网站配置域名","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"后端","slug":"编程/后端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/"},{"name":"云服务器","slug":"编程/后端/云服务器","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://kaguranotamashii.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"云服务器","slug":"云服务器","permalink":"https://kaguranotamashii.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"c#学习笔记","slug":"c-学习笔记","date":"2023-04-10T09:33:45.000Z","updated":"2023-04-10T15:15:12.858Z","comments":true,"path":"posts/58424f87/","link":"","permalink":"https://kaguranotamashii.github.io/posts/58424f87/","excerpt":"","text":"c#基础 c#语言特点 C#是微软公司发布的一种面向对象的、运行于.NET Framework和.NET Core（完全开源，跨平台）之上的高级程序设计语言 C#是一种安全的、稳定的、简单的、优雅的，由C和C衍生出来的面向对象的编程语言。它在继承C和C强大功能的同时去掉了一些它们的复杂特性 C#是面向对象的编程语言 什么是 .NET? .NET 是由 Microsoft 创建的开源开发人员平台，用于生成许多不同类型的应用程序。 可以使用 C#、F# 或 Visual Basic 编写 .NET 应用。 C# 是一种简单、现代、面向对象和类型安全的编程语言。 F# 是一种编程语言，利用它可轻松编写简洁、可靠且性能出色的代码。 Visual Basic 是一种易于使用的语言，简单语法便于生成类型安全、面向对象的应用。 c#语法基础 cs文件结构 结构展示 程序的第一行using System; using关键字用于在程序中包含System命名空间。一个程序一般有多个using语句 下一行是namespace声明。一个namespace是一系列的类。 WebApplication1 命名空间包含了类Program。 下一行是class声明。类Program包含了程序使用的数据和方法声明。类-般包含多个方法。 方法定义了类的行为。在这里，Program类只有一 个Main方法。 下一行定义了Main方法，是所有C#程序的入口点。Main方法说明当执行时类将做什么动作。 Main方法通过方法体中的语句指定它的行为。 注意: C#大小写敏感的。 所有的语句和表达式必须以分号;结尾。 与Java不同的是，文件名可以不同于类的名称。 C#是一种面向对象的编程语言。在面向对象的程序设计方法中，程序由各种对象组成。相同种类的对象通常具有相同的类型。 案例: 以人类为例，从人类中诞生出的具体对象“C罗”和“梅西”，同属人类，故俩人类型相同。 关键字 关键字，是对编译器有特殊意义的预定义保留标示符，它们不能在程序中用作标示符 using关键字 在任何C#程序中的第一条语句都是: using System; using关键字用于在程序中包含命名空间。一个程序可以包含多个using语句。 class关键字 class关键字用于声明一个类。 C#的注释方式 // 单行注释 /**/ 多行注释 /// 文档注释 注释的作用: 解释:说明代码作用 注销:将暂时不需要的代码注销 铭记: 不写注释是流氓 名字瞎起是扯淡 相比注销，注释意义更大 要做到别人一看就能看懂 变量 变量是一个供程序存储数据盒子。在C#中，每个变量都有一个特定的类型，不同类型的变量其内存大 小也不尽相同。 C# 中提供的基本类型大致分为以下几类： 类型 举例 整数类型 byte、short、int、long 浮点型 float、double 十进制类型 decimal 布尔类型 bool 字符类型 string、char 空类型 null 表达式 表达式由**操作数(operand)和运算符(operator)**构成。运算符的示例包括+、-、\\*、/和new。操作数的示例包括文本、字段、局部变量和表达式。 当表达式包含多个运算符时，运算符的优先级(precedence)控制各运算符的计算顺序。例如，表达式x + y * z按x + (y * z)计算，因为*运算符的优先级高于+运算符。 (了解)大多数运算符都可以重载(overload)。运算符重载允许指定用户定义的运算符实现来执行运算，这 些运算的操作数中至少有一个，甚至所有操作数都属于用户定义的类类型或结构类型。 下表总结了C#简单常用的运算符，并按优先级从高到低的顺序列出各运算符类别。同类别中的运算符 优先级相同。 类别 表达式 说明 基本 x.m 成员访问 x(...) 方法和委托调用 x[...] 数组和索引器访问 newT(...) 对象和委托创建 newT(...)&#123;...&#125; 使用初始值设定项创建对象 new&#123;...&#125; 匿名对象初始值设定项 newT[...] 数组创建 一元 +x 恒等 -x 求相反数 !x 逻辑求反 ~x 按位求反 ++x 前增量 --x 前减量 x++ 后增量 x-- 后减量 (T)x 将x显示转换为类型T 二元 x * y 乘法 x / y 除法 x % y 取余 x + y 加法，字符串串联 x - y 减法 x &lt;&lt; y 位左移 x &gt;&gt; y 位右移 x &lt; y 小于 x &gt; y 大于 x &lt;= y 小于或等于 x &gt;= y 大于或等于 x is T 如果 x 位 T ，返回true，否则false x as T 返回转换为类型 T 的 x ,如果 x 不是 T 则返回null x == y 等于 x != y 不等于 x &amp; y 整形按位与 ,布尔逻辑AND `x y` x &amp;&amp; y 且，当 x 为true时，才对 y 求值 `x x ?? y 如果 x 为null，则计算结果为 y，否则为 x 三元 x ? y : z 如果 x 为true,对 y 求值，x 为false，对 z 求值 赋值或匿名函数 x = y 赋值 x = x + y 复合赋值 (T x) =&gt; y 匿名函数（lambda表达式） 数组 数组 数组是一组相同类型的数据。 数组中的数据需要通过数字索引来访问。 数组的声明 数组的声明需要使用new关键字。 在声明数组时，可以使用&#123;&#125;来初始化数组中的元素。 如果在数组声明之初没有使用大括号来初始化数组中的元素，则需要指定数组的大小。 在声明初始化有元素的数组时，也可以指定数组大小。 123456//声明没有元素的数组 int[] ints = new int[6] //声明初始化有元素的数组 int[] ints = new int[]&#123;1, 3, 4, 5&#125; //在声明初始化有元素的数组时，也可以指定数组大小 string[] strings = new int[5]&#123;&quot;H&quot;， “E&quot;， &quot;L&quot;，“L&quot;,&quot;0&quot;&#125; 通过索引获取数组中的元素。 给数组指定长度时，数组准备存放多少元素，长度就设置为多少。 用索引获取数组内的元素时，索弓|从0开始获取。 所以数组中最大的索引数字，比指定数组长度小1。 123456//声明初始化有元素的数组 int[] ints = new int[]&#123;1, 3，4，5&#125; //获取数组中第1个的元素。int i1 = ints[0]; //给数组内的元素赋值ints[0] = 1 C#面向对象 类与对象 类和对象的概念 类和对象的关系 类的设计 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象 类只有一个， 而对象可以有很多个 不同的对象之间属性的具体内容可能各不相同 类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少 集合 ArrayList的使用 ArrayList是.NET Framework提供的用于数据存储和检索的专用类 它是命名空间System.Collections下的一部分 ArrayList arrayList=new ArrayList(); arrayList.Add(123); //将数据新增到集合结尾处 arrayList.Add(“abc”); //将数据新增到集合结尾处 arrayList[2]=345; //修改指定索引的数据 arrayList.RemoveAT(0); //移除指定索引处的数据 arrayList.Remove(123); //移除内容为123的数据 arrayList.Insert(0,“hello world”); //再指定索引处插入数据 List list = new List(); // 第一种初始化方式 list.Add(123); // 新增数据到结尾处 List intList = new List // 第二种初始化方式 { 123, 456, 789 }; intList[2] = 345; intList.RemoveAt(0); // 删除指定索引处的数据 intList.Remove(123); // 删除内容为123的数据 intList.Insert(0, 6688); Dictionary字典的使用 在声明Dictionary字典时，需要同事为其声明Dictionary字典内的键与值的类型 示例：Dictionary&lt;int, string&gt; dictionary = new Dictionary&lt;int, string&gt;(); 键与值可以是任何类型，但是键必须在设置时是唯一的，而值可以不唯一，就好比每个学生的学号必须是唯一的，而所有的成绩可以不唯一。 12345678910111213141516Dictionary&lt;int, string&gt; dictionary = new Dictionary&lt;int, string&gt;();//两种赋值方式 // 方 式 一 ：Add 方 法 赋 值 dictionary.Add(1, &quot;98分&quot;); dictionary.Add(2, &quot;92分&quot;); dictionary.Add(3, &quot;89分&quot;); dictionary.Add(1, &quot;88分&quot;); //系统会报错 //方式二：索引器赋值 dictionary[1] = &quot;88分&quot;; //系统不会报错dictionary[4] = &quot;99分&quot;; //方式三：对象初始化器 Dictionary&lt;string, string&gt; dictionary2 = new Dictionary&lt;string, string&gt;() &#123; &#123;&quot;A&quot;,&quot;aa&quot; &#125;, &#123;&quot;B&quot;,&quot;BB&quot; &#125;, &#123;&quot;C&quot;,&quot;CC&quot; &#125; &#125;; 注意dictionary[1]方式既可以赋新值可以修改原来已键有的值，类似于数组索引器的使用, 所以可以使用之前已使用过的键。但是Add方法不可以添加已有键的值。 12345678910//获取键为1的值 //方式一：索引器取值 string value = dictionary[1]; //方式二：foreach遍历取值 foreach (KeyValuePair&lt;string, string&gt; item in dictionary) &#123; int key = item.Key; string value = item.Value; &#125; //移除键为1的键值对dictionary.Remove(1); 总结 foreach的使用 foreach就是传说中的增强for循环或者称作foreach循环 foreach对遍历字典或集合具备天然优势，效率高过for循环 3.1 foreach操作数组 12int[] ints= &#123;1，2，3，4，5，6&#125;;foreach (int item in ints)&#123; //每次循环，其item都是整型数组中的一个元素 &#125; 3.2 foreach操作集合 12List&lt;int&gt; intList = new List&lt;int&gt;() &#123; 1, 2，3, 4，5, 6 &#125;; foreach (int item in ints)&#123; //每次循环，其item都是List集合中的一个元素 &#125; 3.3 foreach操作字典 123456789Dictionary&lt;string, string&gt; dictionary = new Dictionary&lt;string, string&gt;() &#123; &#123; &quot;A&quot;,&quot;aa&quot;&#125;, &#123; &quot;B&quot;,&quot;bb&quot;&#125;, &#123; &quot;C&quot;,&quot;cc&quot;&#125;，&#125;; foreach (KeyValuePair&lt;int, string&gt; item in dictionary) &#123; int key = item.Key; string value = item.Value; &#125; c#和SqlServer连接","categories":[],"tags":[]},{"title":"linux学习笔记","slug":"linux学习笔记","date":"2023-03-16T08:12:10.000Z","updated":"2023-03-21T08:56:13.507Z","comments":true,"path":"posts/9dafd965/","link":"","permalink":"https://kaguranotamashii.github.io/posts/9dafd965/","excerpt":"","text":"Linux的目录结构 /，根目录是最顶级的目录了 Linux只有一个顶级目录：/ 路径描述的层次关系同样适用/来表示 /home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt Linux的命令入门 无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式： 1command [-options] [parameter] •command： 命令本身 •-options：[可选，非必填]命令的一些选项，可以通过选项控制命令的行为细节 •parameter：[可选，非必填]命令的参数，多数用于命令的指向目标等 语法中的[]，表示可选的意思 下面，让我们学习第一个Linux命令：ls命令 并通过它，去理解命令的基础格式 ls命令","categories":[],"tags":[]},{"title":"建筑史","slug":"architectural/建筑史","date":"2023-01-28T13:10:57.000Z","updated":"2023-02-09T14:05:09.494Z","comments":true,"path":"posts/2966b8a6/","link":"","permalink":"https://kaguranotamashii.github.io/posts/2966b8a6/","excerpt":"","text":"建筑史 西方建筑史 从伊甸园到雅典学堂-文明的开端 终有一天，历史会变为传说，而传说会成为神话。 ​ 历史研究的乐趣之一就在于，我们研究得越深入，就会发现我们对于过去的了解越肤浅。有人说：“时间久远的历史会因为逐渐被人淡忘而变成传说，而更加久远的传说则只留下神话被人铭记。”这话实在是很有哲理。美国作家撒迦利亚·西琴（Z.Sitchin）（去世于 2010年10月9日（90歲））写的《地球编年史》，讲述了第十大行星的故事，尼比鲁星（Nibiru）诞生的故事，他们帮助了地球人进化，以及文明的演进，在临走之前，他们中的一位科学家帮助位于哥贝克力附近尚处原始状态的人类躲避了大洪水，然后又教会他们种植庄稼、驯养家畜。在我们对西琴的观点嗤之以鼻之前，不妨稍稍想一想，今天被我们理所当然视之为神话传说的东西，会不会真的有哪怕一丝一毫的确实之处呢？比如中国古代的“烂柯”传说，“山中方一日，世上已千年”，这分明是爱因斯坦（A.Einstein）赖以成名的相对论思想，难道说我们的老祖宗两千年前就已经发现了？他们从何得知呢？ 撒迦利亞·西琴 - 维基百科，自由的百科全书 (wikipedia.org) 古代西亚 苏美尔文明-文明的摇篮 苏美尔 - 维基百科，自由的百科全书 (wikipedia.org) ​ 苏美尔人是不属于生活在美索不达米亚平原的种群，至今也没有研究出来是哪里来的民族流浪到这里的，其中的某个邻居将这个绰号读作“Shumer”，这个发音以后被大家普遍接受，就成为这个民族的正式称呼，叫作“苏美尔人”（Sumerians）。苏美尔人发现了这里的埋藏的秘密，这是片非常肥沃的土地，粮食收成大增，人口大量增长同时，部分人群脱离农业生产，转向城市的手工艺人或者管理者。 ​ 城市管理者面对交换其他民族稀有物品带来的语言问题，发明了记录符号-文字，随后不仅可以表示计数还能传递思想，知识，以独特的形式获得了“楔形文字”（Cuneiform Script）的称号，成为中东多个文明的共同文字祖先。 面对捉摸不定的老天爷，苏美人是充满了感恩恐惧，敬畏之情，他们建设宏伟的神庙，创造神话来表达对世界的认知，他们创造了伊甸园 ​ 早期的苏美尔人社会是相互独立的城邦国家，像中国的春秋五霸一样。 ​ 埃利都（Eridu）是苏美尔地区建立的第一座城市，位于当时的幼发拉底河入海口附近。后来随着幼发拉底河改道和河口淤积，埃利都失去了地理上的优势，逐渐被废弃。原本用泥砖修建的巍峨的神庙建筑因为无人养护而风化瓦解，千百年后只剩下一摊摊的泥堆与沙漠为伴。 ​ 乌鲁克（Uruk）也是早期苏美尔人的主要城邦之一。苏美尔史诗《吉尔伽美什》的主人公吉尔伽美什（Gilgamesh，约前2700年前后在位）就是这座城邦的统治者。这部《吉尔伽美什》是目前所知人类最早的文学作品，其最初的版本发现于公元前21世纪。史诗中所描绘的半神半人的英雄及其传奇般的故事给予了包括西琴在内的后人无尽的遐想。差不多就在吉尔伽美什生活的时代，乌鲁克城邦发展达到鼎盛，城市面积约6平方公里，四周城墙耸立，城内有两处主要的神庙建筑群，人口最多时超过50000人，是当时最大的城市。 吉尔伽美什 - 维基百科，自由的百科全书 (wikipedia.org) ​ 大约在公元前2334年左右，位于苏美尔北方由闪米特族建立的阿卡德（Agade，其具体位置目前尚无法确定）城邦，在首领萨尔贡（Sargon，意思是“真正的王”，前2334—前2279年在位）的带领下征服了整个美索不达米亚地区。之后他的孙子纳拉姆辛（Naram-Suen，前2254—前2218年在位）又率军征服了阿卡德北方的马里（Mari）和埃布拉（Ebla）两大城邦，将波斯湾与地中海之间的各个文明区域全部统一在一个政权之下，从而建立了人类历史上的第一个帝国，改变了两河流域城邦相争长期分裂的局面。 ​ 位于今日叙利亚东部的马里古城最早建于公元前2900年，在被阿卡德帝国征服前，就已经是一个十分繁荣的城邦国家。阿卡德帝国解体后，马里重新恢复独立，控制了幼发拉底河中游的大片土地。公元前18世纪，马里城被巴比伦国王汉穆拉比占领并摧毁。 ​ 公元前2112年，苏美尔地区最古老的城邦之一乌尔（Ur）的首领乌尔纳姆（Ur-Nammu，前2112—前2095年在位）再次统一了苏美尔各城邦，历史上称之为乌尔第三王朝（Third Dynasty of Ur，前2112—前2004）。 ​ 在苏美尔人的世界里，天地万物是由一个以安努（Anu）为首的神族来主宰的，安努之子恩利尔（Enlil）是地球的主神。在恩利尔的主持下，这个家族的每一个主要成员都居住在不同的城市，成为每座城市的守护神。这些神灵间常常相互争斗，其结果往往决定了各个城邦的兴盛衰亡。乌尔城的守护神是恩利尔的长子月神南纳（Nanna）。在乌尔纳姆统治时代，乌尔人为南纳神修建了一座宏伟的神庙。这座神庙被较为完整地保存下来，成为苏美尔文明的见证。 ​ 乌尔第三王朝在乌尔纳姆的孙子阿马尔辛（Amar-Sin，前2046—前2038年在位）在位的时候达到鼎盛。但在他去世之后不多久，盘踞在两河上游的阿摩利人（Amorites）就侵入苏美尔地区。乌尔王作战失利，地方总督趁乱割据自立。这之后，位于今天伊朗境内的埃兰人（Elam）给了乌尔王朝最后一击，公元前2004年，乌尔第三王朝灭亡。乌尔城在战乱中遭到破坏，虽然以后还继续存在了大约1500年，但已彻底失去了政治上的重要地位，最终由于幼发拉底河改道（现位于遗址以东约10公里）而被废弃。 ​ 乌尔第三王朝是苏美尔人建立的最后一个政权。就像他们曾经神秘地到来一样，他们也同样神秘地离开这片土地，从此再也没有在历史舞台上露面（有一种极有争议的说法，说是一部分苏美尔人在这个时期离开西亚，一路来到中国。中国的第一个文明夏朝正好就是在那个时代建立的。），只有他们所创造的文化通过后继者巴比伦和亚述继续发扬光大。 巴比伦和亚述 “以牙还牙，以眼还眼。&quot;——汉穆拉比法典 ​ 初中听到的这首jay写的《爱在西元前》，我便爱上了巴比伦文明，如同汉穆拉比法典那句，以牙还牙，以眼还眼，一度让我想亲眼去看看现如今破败不堪的美索不达米亚平原，那曾经辉煌的过往岁月史诗。 古巴比伦 ​ 公元前1763年，汉穆拉比从巴比伦出发，只用了不到10年时间就再次统一了苏美尔—阿卡德地区，建立了古巴比伦王国。在他的有力统治下，巴比伦一跃成为未来1000多年美索不达米亚和整个中东地区最重要的权力中枢之一。汉穆拉比时代留下的最重要的遗物是一座雕刻着世界现存最古老的成文法典之一的玄武岩石碑，“以牙还牙，以眼还眼”是其基本纲领。汉穆拉比去世后不久，他的帝国就瓦解了。在随后的岁月中，加喜特人（Kassites）成为巴比伦的主人，使之继续保持繁荣发展。 亚述 正当巴比伦在两河下游崛起的同时，位于上游的闪米特族亚述人（Assyrians）也开始兴盛起来，成为美索不达米亚地区新兴的强大力量。公元前9世纪，亚述国王亚述纳西尔帕二世（Ashurnasirpal II，前883—前859年在位）将都城迁往亚述城北部不远处的尼姆鲁德（Nimrud）。 1845年，英国人A.H.莱亚德（A.H.Layard）发现了这座城市的遗址。其平面呈不规则的矩形，东西约2.2公里，南北约2公里，东、南、西三面临河。宫殿区位于西南角的高地上。 宫殿的大门都用成对出现的带翼人面牛身或者人面狮身石像来进行装饰。其中人面牛身的被称为舍杜（Shedu），人面狮身的被称为拉玛苏（Lamassu），两者的区别主要在脚爪的造型上。其面部据说是按照亚述国王的样貌雕刻的。宫殿的墙面则装饰着表现亚述征服战争以及国王猎狮场景的浮雕。这样的猎狮活动往往具有礼仪的性质，用来彰显国王的勇气和责任。 公元前671年，辛赫那里布之子阿萨尔哈东（Esarhaddon，前681—前669年在位）征服埃及。亚述帝国达到极盛。有道是盛极必衰。公元前626年，迦勒底人再次发动起义。他们与伊朗高原的米底人（Medes）组成联军，于公元前612年攻陷亚述首都尼尼微。作为报复，尼尼微就像当年被亚述摧毁的古巴比伦城一样被夷为平地。 一位犹太先知描述说：“这是素来欢乐安然居住的城，心里说，唯有我，除我以外再没有别的。现在何竟荒凉，成为野兽躺卧之处。凡经过的人都必摇手，嗤笑她。”（《旧约全书·西番雅书》第二章） 迦勒底人所建立的新巴比伦王国第二任国王尼布甲尼撒二世（Nebuchadnezzar II，前605—前562年在位）是一位有为的帝王。在他的领导下，新巴比伦王国成为美索不达米亚地区的新霸主，古老的巴比伦城再次焕发活力，成为当时世界上面积最大、人口最多和经济最繁荣的城市。 这座焕然一新的巴比伦城由两道城墙环绕。其外城位于幼发拉底河东岸。内外城之间的大片空地主要用作农田，以应付被敌方围城的紧急状况下的粮食供应。内城平面近似方形，四周有护城河环绕，幼发拉底河穿城而过。除了沿着幼发拉底河两岸的城墙只是一道单墙之外，内外城城墙均为双重结构，内侧较外侧更高，以加强防御。 城市的正门是北面的伊什塔门（Ishtar，爱神和战神）。这是一座十分高大雄伟的双重拱形大门。大门及两边夹持的塔楼表面均饰以华丽饰边的蓝色琉璃砖，其中还镶嵌有许多动物图案。 ​ 号称古代世界七大奇迹之一的空中花园（Hanging Gardens）可能就位于伊什塔门西侧。它是由尼布甲尼撒为其来自伊朗山区米底国的王后阿米娣斯（Amytis）修筑的。据推测这是一座边长超过120米、高23米的大型台地园，用一系列筒形石拱支撑，上铺厚土，栽植大树，并用机械水车从幼发拉底河引水浇灌。 位于巴比伦城市中心的大塔庙，据信就是《圣经》中所说的通天塔（Tower of Babel）。 在《旧约全书·创世记》第十一章中这样写道：“那时，天下人的口音言语都是一样。他们往东边迁移的时候，在示拿地（Land of Shinar，即美索不达米亚地区）遇见一片平原，就住在那里。他们彼此商量说，来吧，我们要……建造一座城，和一座塔，塔顶通天，为要传扬我们的名，免得我们分散在全地上。耶和华降临要看看世人所建造的城和塔。耶和华说，看呐，他们成为一样的人民，都是一样的言语，如今既做起这事来，以后他们所要做的事，就没有不成就的了。我们下去，在那里变乱他们的口音，使他们的言语彼此不通。于是耶和华使他们从那里分散在全地上，他们就停工不造那城了。因为耶和华在那里变乱天下人的言语，使众人分散在全地上，所以那城名叫巴别 [[2]](javascript:void(0)) 。” 不论这段记载依据何在，这座塔庙至迟在汉穆拉比最早建造巴比伦城时就已经建造起来，并在尼布甲尼撒时代得以完善。它的边长约91米，高度据信超过100米。 公元前539年，新巴比伦王国被东邻波斯帝国灭亡。宏伟的巴比伦城墙以及通天塔都在后来一次未遂叛乱后被波斯人彻底拆毁。美索不达米亚文明在持续了3000年之后终于走到了尽头。 以色列 “有些人的心是石头做的，但这堵墙是由长着人心的石头做的。“ 一块在地图上看起来微不足道的地方，却成为世界三大宗教的圣地，对大半个世界的历史进程产生无可比拟的重大影响，这个地方就是以色列（Israel），以前叫作迦南（Canaan），后来叫作巴勒斯坦（Palestine）。 以色列王国 然而，真正为这片土地带来永恒魅力的却不是建造耶利哥的那些原始居民，而是很久很久以后才从美索不达米亚地区迁来的希伯来人（Hebrewes）。 按照希伯来人自己的说法，他们的祖先名叫亚伯拉罕（Abraham），大约在公元前21世纪，差不多就是乌尔第三王朝时代，先是跟着父亲从乌尔搬迁到幼发拉底河上游的哈兰（Harran），而后在父亲去世后带领一家人最终迁移到迦南。亚伯拉罕有两个儿子，长子以实玛利（Ishmael）是亚伯拉罕妻子的女仆夏甲（Hagar）所生，他的后代后来繁衍成为阿拉伯人。 [[1]](javascript:void(0)) 亚伯拉罕的妻子撒拉（Sara）生下了次子以撒（Isaac）。以撒的次子名叫雅各（Jacob），上帝赐名为“以色列”（Israel），意为“与神较力取胜者”。后来他的子孙就自称为以色列人。 雅各的一个儿子由于受到父亲宠爱而被嫉妒的哥哥们卖到埃及做奴隶，因为聪明伶俐得到法老赏识，后来居然成了埃及宰相，于是以色列人就都迁去埃及住了。几百年后，以色列人失势，埃及法老强迫以色列人做苦役。公元前13世纪左右，以色列人在摩西（Moses，约前14—前13世纪）的带领下逃离埃及，重返迦南。在埃及与迦南之间的西奈半岛，摩西说服以色列人信奉上帝为唯一的神，并代他们与上帝立了十诫约法。 以色列人重回迦南后，面临原本就生活在这里的迦南人以及新来者非利士人（Philistines）的威胁，大约于公元前1050年建立了统一的王国。其最初三位国王分别是扫罗（Saul，前1050—前1012年在位）、大卫（David，前1010—前970年在位）和所罗门（Solomon，前970—前931年在位）。所罗门为以色列人在耶路撒冷（Jerusalem）建造了一座圣殿，以存放摩西与上帝的约法。这是以色列人的第一座圣殿，也是以色列最重要的一座建筑。 由于不堪所罗门的穷奢极欲，以色列北部的10个支族在他死后宣布独立，仍称为以色列王国。而所罗门之子所领导的南部两个支族则称为犹大王国（Judah），以其中一个支族犹大族为名，其国民以后被称为犹太人（Jews）。 公元前722年，北方的以色列国被亚述灭亡，其国民大都被驱散，从此湮没在西亚各民族相互融合的汪洋之中。而南方的犹大国也在公元前586年被尼布甲尼撒的新巴比伦王国灭亡。耶路撒冷的圣殿被摧毁，大批犹太人被掳往巴比伦。在流放期间，先知们向犹太人许诺，只要他们恪守摩西法典，上帝就会派一位弥赛亚（Messiah）来拯救他们。 公元前539年，波斯人击败新巴比伦王国。犹太人获准再次回到迦南，并重建了圣殿。 耶路撒冷 公元134年，犹太人再次发动对希腊人和罗马人起义。起义失败之后，犹太人被驱离耶路撒冷，耶路撒冷的圣殿被再次摧毁。罗马人随后更将犹太行省更名为巴勒斯坦（Palestine），意思是非利士人居住的地方，而非利士人正是早期以色列人的死敌。 很久以后，犹太人才获得罗马当局允许，在每年的圣殿被毁日返回故里，在圣殿山前墙垣遗址追思哀泣。该段城墙由此得名“哭墙”（Wailing Wall）。 又过了一段时间，阿拉伯穆斯林军队占领了耶路撒冷，在圣殿山上相传是穆罕默德（Muhammad，570—632）登霄的地方修建起了圣石清真寺。从此，这座圣殿山又成为伊斯兰教的圣地。 在后来的历史上，犹太人与穆斯林之间时常因为这堵哭墙的主权发生争议。在近代英国人管理巴勒斯坦期间，曾经有一位英国总督建议犹太人在别处另造一堵墙来代替哭墙，他说：“那毕竟只是一些石头而已。”犹太拉比惊讶地看着英国总督，回答说：“有些人的心是石头做的，但这堵墙却是由长着人心的石头做的。” 古埃及 我是纯洁的莲花, 拉神的气息养育了我, 辉煌地发芽。 我从黑暗的地下升起 进入阳光的世界, 在田野开花。 ——《亡灵书》 早王朝时期 公元前3100年左右，位于南方狭窄河谷地带的上埃及（Upper Egypt）法老 [1] 纳尔迈（Narmer，或称美尼斯Menes）顺流而下征服了位于北方宽阔三角洲地区的下埃及（Lower Egypt），初步建立了统一的埃及王国，首都定于上、下埃及交汇处的孟菲斯（Memphis）。 这个统一的时间不仅比两河流域的统一早了大约700年，而且统一状态所持续的时间特别长，到公元前1000年以前只有两次中断。这既要归功于埃及易守难攻的天然地理优势，其东西两面都是沙漠，北方是大海，南方则是茂密的丛林，同时也要归功于在其紧邻的周边地区相当长一段时间之内都没有足够强大的竞争势力。正是这样的一些特点，使得埃及文明的发展具有独特的风格，并且极为安宁持久。 孟菲斯位于埃及首都开罗南方二十千米，在城市的中心，纳尔迈还为城市建造了最早的卜塔神庙（Great Temple of Ptah）。卜塔是孟菲斯地区最受信仰的造物神。在两千多年后埃及历史学家曼涅托（Manetho，约生活于前4世纪末—前3世纪初）的笔下，孟菲斯被称为“Hut-ka-Ptah”，意思是“卜塔灵魂之所在”。这个单词几经演绎，最终演变为“Egypt”，埃及。 埃及人都相信，法老是神的化身，是活着的神，他的灵魂是永恒存在的。法老活着的时候只是灵魂在躯体所做的短暂停留。他死了之后，灵魂将在伴随尸体度过一个极为漫长的岁月后升入极乐世界开始新生。由于存在这样的信仰，埃及人认为，只要他们能倾尽全力为法老修建一个特别的陵墓，让法老顺利升天成神而永享极乐天国，那么神就会保佑人间的繁荣。对于普通人来说，死亡之后如果能够继续追随服侍神圣的统治者，也能获得永生。因而，是陵墓，而不是其他任何一种类型的建筑（比如宫殿），成为古埃及，尤其是早期埃及最重要、最值得耗尽心血和最有代表性的建筑类型。 古希腊 希腊时代 对于很多处于专制社会的民族——比如埃及人——来说，人活着的目的就是为神建造庙宇和奉献祭品，只有把神伺候满意了，人才能过上安稳的日子。但在崇尚自由个性的希腊人眼中，神并不是神神秘秘、高高在上、不食人间烟火，相反，希腊人认为神也像人一样有七情六欲，也有爱恨情仇。希腊神话中的主神宙斯（Zeus）就是一个最典型的例子。在他的性格中，一方面是残忍坚毅，联合兄弟姐妹打败自己的父亲，毫不留情地将叔叔伯伯和堂兄弟们关进地狱；而另一方面又是多情善感，一次又一次地爱上人间女子，整日苦恼于与善嫉的妻子赫拉（Hera）周旋斗法。希腊诸神的故事与人间的故事没有什么不同，区别只是在于他们比人更有力量、更长寿、更美丽，或许形容他们为“超人”更合适。像荷马这样的黑暗时代吟游诗人们，更是将米诺斯人、迈锡尼人、特洛伊人和多利安人这些先人的传说与神联系在一起，编织出一个美丽的神人共生的世界。 公元前776年，第一届古代奥林匹克运动会在希腊圣地奥林匹亚（Olympia）举行，已经持续了400余年的黑暗时代到此终于宣告结束，希腊文明的崭新阶段开始到来。就像一个经历了伤筋动骨大手术的人一样，输入了新鲜血液的希腊民族经历过一段不适，但随后不仅恢复了体力，并且迸发出空前旺盛的活力，创造了一种与古代世界任何一个民族截然不同的文明。 希腊神庙柱式 希腊神庙在造型方面的主要特征就是外面的那一圈柱廊。从柱廊所采用的柱子造型——也就是所谓“柱式”——来区分，希腊神庙主要有三种柱式：多立克式（Doric order）、爱奥尼克式（Ionic order）和科林斯式（Corinthian order）。其中多立克式和爱奥尼克式出现较早，而科林斯式可以看成是爱奥尼克式的变体。从柱式（Order）这个单词的选择来看，柱式不仅仅只是反映柱子本身的造型样式，更是用来体现整个神庙的组织结构，体现一座神庙的各部分之间以及各部分与整体之间的比例、节奏和秩序。 一个典型的多立克柱式由台基、柱子、檐部和山花四个部分组成。 台基一般做成三层台阶，环绕神庙一周。 雅典的帕提农神庙 公元前447年，在雕塑家菲狄亚斯（Phidias，前480—前431）的主持下，由建筑家伊克蒂诺斯（Ictinus）和卡利克拉提斯（Callicrates）共同设计的新神庙——人们称之为“帕提农神庙”（Parthenon，意为少女，此处特指雅典娜）——开始在雅典卫城动工兴建。公元前438年，神庙的主体部分落成，剩下的局部雕刻于公元前432年完成。 这是一座象征了150年来希腊神庙建设最高成就的杰出建筑，是希腊本土所建造的最大的神庙。它的外表极为富丽堂皇，几乎全部是采用高贵的白色大理石建成，在山花和陇间壁等处的浮雕上原本都作有鲜艳的色彩。 [[6]](javascript:void(0)) 作为希腊胜利的象征，这座神庙虽然采用多立克柱式，但在宽30.88米的正面上却采用了具有爱奥尼克特点的8柱式，而非希腊本土常用的6柱式。它的侧面长69.50米，按照侧面柱数为正面柱数的2倍+1柱的典型模式，共有17柱，柱高均为10.43米。 柱廊内的矩形殿身被划分为前后两部分，每一部分的入口前方都有一排6根小一号的多立克柱廊。殿身的前半部分为神堂，开口朝向东方，内有双层多立克式柱廊环绕，中央立着的由菲狄亚斯创作的用黄金和象牙包裹着的高约12米的雅典娜神像。后半部分是国库，雅典同盟的金银财物就存放在这里，由一群少女负责管理，叫作少女室——“帕提农”神庙即由此得名。少女室里面用了四根具有少女般优雅气质的爱奥尼克柱。这是希腊本土首次引入爱奥尼克柱式。它的美丽形态打动了本土的希腊人，从此就成为希腊世界的最爱。 帕提农神庙是公认的世界上最美的建筑物之一。对于这个称号，它是当之无愧的。在古希腊人眼中，任何美的东西都是由度量和秩序所组成的。毕达哥拉斯（Pythagoras，前570—前495）就认为“数是万物的本原”。意大利文艺复兴时期的建筑大师帕拉第奥（Palladio，1508—1580）则说：“（建筑的）美得之于形式，亦得之于统一，即从整体到局部，从局部到局部，再从局部到整体，彼此相呼应，如此，建筑可成为一个完美的整体。在这个整体之中，每个组成部分彼此呼应，并具备了组成你所追求的形式的一切条件。”[31] 帕提农神庙就是这样的一座建筑，它的每一项尺寸，从总长、总宽、总高到局部的长、宽、高，从总体的比例到局部的比例，相互之间都有相当严密的度量关系，从而使它成为一件有着高度秩序的完美的作品。 但仅仅只是这些相对死板的数字，还不足以就使帕提农神庙被称为世界上最美的神庙。帕提农神庙所体现出来的无与伦比的美还需要另外一组完全不同的数字才能加以说明。1845年，英国考古学家潘罗斯（Penrose）对神庙进行了首次准确测量。他发现神庙身上存在着许多精细入微的变化。前面介绍过柱身存在卷杀是多立克柱式的特点之一，但帕提农神庙多立克柱子的卷杀非常细微，柱身边线在柱高的2/5处凸出于上下端边沿连线仅有0.017米，仅相当于柱高的1.6‰。如此微细的卷杀肉眼几乎难以辨别，既可避免那些没有卷杀的柱身中央会产生内凹的不良错觉，又不至于因为卷杀过度而带来臃肿之感，使柱子看起来更加庄严挺拔。 法国历史学家H.丹纳（H.Taine，1828—1893）对希腊人有一个极为精彩的评价：“他们是世界上最伟大的艺术家。 ——首先是感觉的精细，善于捕捉微妙的关系，分辨细微的差别。 ——其次是力求明白，懂得节制，喜欢明确而固定的轮廓：这就能使艺术家把意境限制在一个容易为想象力和感官所捕捉的形式之内，使作品能为一切民族一切时代所了解，而且因为人人了解，所以能垂之永久。 ——最后是对现世生活的爱好与重视，对于人的力量的深刻的体会，力求恬静和愉快。 ……在他们面前，我们好像一个普通的听众面对着一个天赋独厚、经过特别培养的音乐家；他的演奏有细腻的技术，精纯的音色，丰满的和弦，微妙的用意，完美的表情；但是一个普通的听众天赋平常，训练不够，对那些妙处只能断断续续领略一个大概。……希腊建筑是健全的，不是兴奋过度的幻想的产物，而是清明的理智的产物。 ……庙堂的各个部分都有一种持久的平衡，眼睛看了比例和谐的线条感到愉快，理智由于那些线条可能永存而感到满足。 ……它舒展，伸张，挺立，给眼睛的感觉完全是一种天真的、健全的、南国风光的快乐，给人看到刚强的力，完美的体育锻炼，尚武的精神，朴素与高尚的气息，清明恬静的心境，达到如何美满的地步。á 罗马，从共和国到帝国，从凯撒到基督 凡世的荣光 从璀璨的中世纪建筑 哥特时代 『不要碰巴黎圣母院。』 12世纪开始在西欧兴起的哥特建筑（Gothic Architecture）谱写了人类建筑史上光辉灿烂的篇章。 “哥特”（Goths）原是参加灭亡西罗马帝国的北方日耳曼民族的名称。15世纪的时候，意大利文艺复兴运动提倡复兴古罗马文化，试图从种族和历史角度贬低先前“蛮族”统治时代的艺术成就，就把这时期的建筑风格称为“中世纪”风格，后来又进一步称之为“哥特式”（Gothic），意思就是“野蛮的、非希腊、非罗马的建筑风格”。当然，今天这个词已经不带有任何贬义了，特别是英国、德国和法国这些由日耳曼民族后代所建立的国家更是将哥特风格视为他们真正的民族风格。 圣丹尼教堂歌坛 哥特建筑首先兴起于法国王室领地“法兰西岛”中 1135年，法国国王路易六世（LouisⅥ，1108—1137年在位）的权臣、修道院院长絮热（Suger，1081—1151）开始主持位于巴黎市北郊圣丹尼教堂（Basilica of Saint-Denis）的重建工作。圣丹尼（Saint Denis）是公元3世纪时的首任巴黎主教，后被罗马当局处死。传说他被斩首后捧着自己的头颅走了几千步才倒下。法国的基督徒们将圣丹尼视为是法国和巴黎的守护神，在他死去的地方建起教堂以示纪念。从墨洛温王朝开始，除了三位国王之外，其他的法国国王去世后都安葬在这座教堂里。 作为路易六世的老友和重臣，絮热决心以重建圣丹尼教堂为契机，提振已经衰微的国王权威。在担任圣丹尼修道院院长之后不久，他就开始着手对这座重要建筑的改造。工程首先从歌坛和西端入口立面做起。 在歌坛部分，絮热准备新增一圈小礼拜室。按照罗马风时代法国已经形成的传统做法，比如左图所示的克吕尼修道院教堂，这些向外突出的小礼拜室的顶部一般是用半穹顶覆盖，通常支撑穹顶的墙体比较厚实，不会开大窗。而现在，絮热要换一种方式来做。 絮热是第一个认识到这种变化所可能蕴藏着的空间塑造潜力的人。他创造性地在歌坛后部十分复杂的环形平面上，应用交叉肋骨尖拱来作为穹顶骨架。由于认识到支撑肋骨拱的立柱间的墙体已经不再具有受荷作用，于是他将墙面全部打开，然后做成大面积的窗子。他将这些窗子用彩色玻璃进行装饰。这些彩色玻璃是一小块一小块地镶嵌在铅条形成的小格子上，然后再镶嵌在铁框上。就像过去做在墙上的马赛克镶嵌画一样，这些小块的彩色玻璃在窗户上拼出一幅幅无字的圣经。当太阳从东方升起，基督徒们走进教堂面朝东方做礼拜的时候，阳光从这些五彩的窗子中照射进来，就像伊波利特·丹纳形容的那样，在教堂内部普遍的冰冷惨淡的阴影笼罩下，“从彩色玻璃中透入的光线变做血红的颜色，变做紫石英与黄玉的华彩，成为一团珠光宝气的神秘的火焰，奇异的照明，好像开向天国的窗户” [22] ，如同神的启迪和天国的荣耀，让教堂沐浴在奇妙的光的仙境中，为那些迷惘在现实的苦难和黑暗中的信徒指引出一条通向天堂的光明之路。这样一来，原本是物质的建筑构造忽然间被精神化了，被赋予了神秘的含义。这正是由此开始形成的哥特风格的精髓所在。 巴黎圣母院 这座被维克多·雨果（Victor Hugo，1802—1885）称之为“巴黎的头脑、心脏和骨髓”的建筑坐落在塞纳河（Seine）上的西岱岛（Ile de la Cité）上。这座岛是巴黎的发源地。 作为塞纳河上的重要渡口，巴黎第一次被载入史册是在恺撒征服高卢期间。当时生活在这一带的一支高卢部落巴黎希人（Parisii）加入了反抗罗马统治的起义队伍。恺撒在他所著的《高卢战记》里面记录了他的副将在这座岛上同巴黎希人的战斗，他称这里为卢泰西亚（Lutetia）。 [23]","categories":[{"name":"建筑史","slug":"建筑史","permalink":"https://kaguranotamashii.github.io/categories/%E5%BB%BA%E7%AD%91%E5%8F%B2/"}],"tags":[{"name":"西方建筑","slug":"西方建筑","permalink":"https://kaguranotamashii.github.io/tags/%E8%A5%BF%E6%96%B9%E5%BB%BA%E7%AD%91/"},{"name":"东方建筑","slug":"东方建筑","permalink":"https://kaguranotamashii.github.io/tags/%E4%B8%9C%E6%96%B9%E5%BB%BA%E7%AD%91/"}]},{"title":"骑行","slug":"骑行","date":"2023-01-04T10:42:48.000Z","updated":"2023-01-04T10:42:48.823Z","comments":true,"path":"posts/undefined/","link":"","permalink":"https://kaguranotamashii.github.io/posts/undefined/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"2022年度总结","slug":"[main]summary/2022年度总结","date":"2022-12-30T15:15:44.000Z","updated":"2023-01-28T13:12:27.432Z","comments":true,"path":"posts/622a5765/","link":"","permalink":"https://kaguranotamashii.github.io/posts/622a5765/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"骑行日记","slug":"[main]summary/骑行日记","date":"2022-12-11T15:31:54.000Z","updated":"2023-01-11T15:16:55.652Z","comments":true,"path":"posts/be77f331/","link":"","permalink":"https://kaguranotamashii.github.io/posts/be77f331/","excerpt":"","text":"题外话- ​ 2019年盛夏，和父母去了趟辽宁旅行，我没想到这竟然成为我这几年来最后一次出京。随后我被一笼巨大的电子牢笼所囚禁，我的眼界和格局便困在家附近那重重叠叠的山脉里，我活在2019年。 ​ 2020年疫情爆发那时候和老友讨论过，幻想过，将来的异国旅行，凭借着我那ぺらぺら的口语，我在中古屋和奸商砍价，在秋叶原疯狂，站立于新宿的中央，我就是那样疯癫的人。不过我更想去东京为明代大儒朱舜水的墓地去扫墓，因为葬身异国他乡这很不是滋味，等等等等，我有太多想做的事情了，真的太多了，太多了。想去余姚拜访四位德高望重的古代先贤。想去橘子洲头拜访伟人的故居，又幻想读大学时候在12月26亲自去橘子洲头和充满激情的人民，共唱共产之歌，恰同学少年。 ​ 已经快三年了，至今为止，我发现疫情三年对自己造成最大影响的是失去了学会去爱人的能力。爱？朋友的爱！父母的爱！情侣的爱！我在渐渐丧失作为人的资格与能力，头脑简单，没有深度思考能力，极为敏感。那是因为我不懂去爱人，在大一期间以及高考前一个月犯了很多的错误。高考前的几个月的爱，那是懦弱的爱，导致心态崩塌，在晃眼间我来到了信🧱。大一这一年对于爱，我是扭曲的爱，站在制高点的角度，使得我依然在无尽的内耗中虚度光阴。我时常在思考我为什么会变成了这样？这是患时非常长而至死的病，我今年才意识到，原来自己已经死了，精神上的死亡，躯体上的单调驱动，就想老旧的发条卡住了，我需要我的润滑油和维修工具。 ​ 疫情三年，性格变得懦弱带给我太多的遗憾了，旧爱，老友，因我糟糕的性格离我远去，而我呆呆着愣在原点。在一个静悄悄的夜里，梦里最深处的恶魔在我耳边说道，这样的生活你还将会再次持续性经历。我会恐惧，害怕，埋怨，哭泣。但是或许是我生内心最深处在呼唤着我对荒谬反抗，我想终结父母那样对西西弗斯式生活，我想终结疼痛，我想获得爱。 ​ 大二军训期间，我很幸运能在军训期间逃训去通州大运河拜访明代离经叛道的思想家李贽，我在老先生的墓碑中看到那位反抗四书五经，三纲五常的老顽童李贽的一生。虽然也买过他的焚书，但是奈何能力并没有读下去，很对不起老先生。坐在通州线上的我跟感觉自己身在遥远的福建泉州，老先生的故居。那时候一颗叛逆的种子便种植在我心中，向天举起叛逆之剑。 ​ 我渴望书，我渴望与他们交流或者她，谈笑风生，而我更像是玩偶似的躯体。今年读的书中就主要集中在加缪和尼采的书，我从书中，亲手拿到活在我心中过往的灵魂，但是我心中的火焰还是太小了，我读的书还是太少了，我需要更多理性和感性知识量，我需要更多的观点与见解，我需要更多的深度思考，我不愿再被大数据浅陋的数据蛊惑。我的困惑便在这里，我的火焰小火花需要时间去变成烈火。随后我才能去学会爱人，自己不被伤到的。 ​ 大二我认识了很多有思想，有趣的人，我喜欢和他们讨论不同的思想。我也认识到了男女思维方式的不同点，女性（可能仅限她）独特的见解和思维方式，我很欣赏她。在感性和理性思想的混合中，我睁开眼，发觉到我依旧活在2019年盛夏在海边上，那是16岁的我。昨夜梦中的我渴望咬断仇恨的衔尾蛇的首尾，终结轮回。我想反抗，我想体验生命中独特每一天。我想和独特的人一同在大路上行走，交流。 ​ 2022年12月13日，通信行程码终于要下线了，那北京健康宝下线要什么时候呢，我想估计也不远了。我崇敬24岁的切格瓦拉，他与朋友骑着摩托车环游南美洲，他的勇气和胆量是我要学习的。在家骑行时，每当我想去南骑，有道检查站我始终不敢骑进去，大数据在凝视着我，智子在观察着我，我还是没有勇气骑向燕郊和蓟州这两片未知的区域。明天它们再也不会控制老子了，老子的电子手铐终将被解开，老子再也不会被牢笼囚禁了，老子那不可战胜的夏天会回来。 失去的三年。可能需要一辈子来弥补。但不后悔。那个自已死了就死了，反正很难找回来，慢慢改变自已，成为自已梦想中的那个英雄。 2022年我入坑了骑行圈，是由于多种原因，其中对我影响最大的还是切格瓦拉写的摩托日记，以及他在南美洲和兄弟骑着Norton摩托车。他们于1951年12月29日出发，决定的线路为：**沿着安第斯山脉穿越整个南美洲，经阿根廷、智利、秘鲁、哥伦比亚，到达委内瑞拉。**在路途中他们的摩托车坏掉了。格瓦拉还在秘鲁的一个麻风病人村作了几个月的义工。在这次旅行中，格瓦拉开始真正了解拉丁美洲的贫穷与苦难，他的国际主义思想也在这次旅行中渐渐产生。 出于对共产主义亲自考察实际的崇尚，以及自己对身边发生的人和事，抱有强烈的疑问和不满，作为北京远郊区人，凭借我对儿时在朝阳城中村的印象以及现在如今在北京上学的种种困惑，我决定像24岁的格瓦拉那样去环游“美洲”。 奥德修斯变成了衣衫褴褛的乞丐 ​ 从2022年1月考完试后，至8月开学军训，疫情原因大一下学期的课都是在线上，面对线上轻松的学习环境，我不禁开始战战兢兢追忆过往的时光，以及当下现实的经历，上至高深的哲学，下肢一顿简单的午饭。我并不是一位愤世嫉俗的愤青，也不是彻底躺平的过客，我的立场至今也不足够清晰，我需要看，需要听，需要写。 ​ 时而幻想起灿烂美丽的的未来，但是在单纯又愚蠢的精神内耗中被别人拒绝了自己投入的第一次情感中，人生第一次被拒绝，在巨大的恐惧与悲伤下，我选择了骑自行车去放松自己，释放自己脑内的多巴胺，使自己糟糕的情绪恢复正常，我上瘾与此运动了。 ​ 我无力眺望极远的云海波澜， ​ 在期末考试结束后，第一次长途骑行是平谷县城到顺义区俸伯地铁站（80km），一路上从，北京远郊区的到作为北京教郊区经济二当家的顺义区，从平谷县城到顺义这条路上从充满裂缝的水泥路到建设相对完备的顺义路面，摩擦阻力减小部分，骑起来也更轻松了。 ​ 当时唐山打人案，刚激化没多久。我就在俸伯附近发现了这座村庄“河北村”，被称之为“北京最美乡村”，慢慢的讽刺感。 关于顺义区经济情况如下表 2076.8亿元2021年GDP数据 第5在北京GDP排名 132.4万七人普人口数据 ​ 让我感到诡异的是作为郊区中顺义却比南城丰台以及副中心的经济实力更强，因为缺少对顺义地区实地考察的经历，虽然顺义线也偶尔做，但是当顺义线奔向地上的轨道的时，顺义的只剩下了光秃秃的植被，抬头向黄昏的地平线望去，边沿依然是一片一片看不到边的植被…以及张镇和杨镇破旧的农村生活，与我想象中的第五位截然相反。 ​ 我只知道一点，在起起落落的航班仿佛苍穹间一道道耀眼的光芒，温暖了红尘中的城市，也照亮了人们的视野，承载飞翔，必有高地。 ​ 每一座城市都有它的“上东区”，北京版的上东区可能就是在顺义的中央别墅区吧。我知道的仅仅这么多。","categories":[],"tags":[]},{"title":"关于自制galgame的日记","slug":"[main]CS/Creation/关于自制galgame的日记","date":"2022-11-29T07:10:56.000Z","updated":"2022-11-29T16:14:55.051Z","comments":true,"path":"posts/19af2057/","link":"","permalink":"https://kaguranotamashii.github.io/posts/19af2057/","excerpt":"","text":"11月 29日 一直以来受日式电波系作品的影响，所以我一直以来想自制属于自己的galgame，而且我还想将那有趣的的故事写给特殊的她。 剧本 （素晴日 心跳文学俱乐部 电波三部曲 去人tachi 主播女孩重度依赖） 程序 （基于renpy） 美术 （AI生成 现实的风景油画化） 音乐 （暂时无） 故事大概内容，我的构思是围绕着尼采的永恒轮回思想去创作，永恒轮回思想是哲学中非常有趣的假设，当时间无限长，时间无限宏大，那么过去发生的事情，日后都会不断重现。 在《快乐的科学》中，尼采把这一思想称作&quot;最大的重负&quot;，并且让一个魔鬼在你最孤寂的寂寞中向你说出它来：“这人生，如你现在经历和曾经经历的，你必将再一次并无数次地经历它；其中没有任何新东西，却是每种痛苦和每种快乐，每y种思想和每种叹息，以及你生涯中一切不可言说的渺小和伟大，都必对你重现，而且一切皆在这同一的排列和次序中–一如这蜘蛛和林间月光，一如这顷刻和你自己。生存的永恒沙漏将不断重新流转，而你这微尘的微尘与它相随!”《快乐的科学》第341节。《尼采全集》，第5卷，第265页。 尼采提出永恒轮回后，提出了打破永恒轮回的命运之爱，正是出于&quot;命运之爱&quot;，尼采愈来愈把永恒轮回的思想同酒神精神和强力意志结合起来。 这个论据能否站住脚，且不去说，重要的是他本想藉此逃避人生虚无的阴影，结果却又陷入了更可怕的梦魇。为了摆脱这个梦魇，尼采诉诸他的&quot;命运之爱&quot;。他勉励自己，不但不逃避必然，而且接受必然，爱命运，如此永远做一个肯定者。参看《快乐的科学》第276节。又参看《看哪这人》：《我为何如此聪明》第10节。 当然尼采的永恒轮回思想确实影响了一些gal，比如说你和她和她的恋爱。 - 萌娘百科 万物皆可萌的百科全书 (moegirl.org.cn) 游戏中有什么让你感受到设计者满满恶意的瞬间？ - 鸢寒的回答 - 知乎 https://www.zhihu.com/question/40987399/answer/90090128 今天干的就是写文本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758with pixellatekami &quot;假如某个白天或者某个黑夜，&#123;alt&#125;heart&#123;/alt&#125;一个恶魔潜入你最孤独的寂寞之中并对你说&quot;scene 1with pixellatekami &quot;这种生活如你眼下正在经历，往日曾经度过的生活，就是你将来还不得不无数次重复的生活&quot;scene 3with dissolvekami &quot;&#123;size=45&#125;其中的每一种&#123;/size&#125;&quot;&quot;痛苦&quot;&quot;快乐&quot;&quot;每一个念头或叹息&quot;&quot;以及你生命中无法言传的大大小小的事体&quot;&quot;都必将在你身上重现而且一切都以相同的顺序排列着&quot;&quot;同样是这蜘蛛，同样是这林间的月光，同样是这个时刻以及我自己。&quot;scene 4with fade&quot;存在的永恒沙漏将反复转动&quot;&quot;而你与它相比&quot;scene 5&quot;只不过是一粒微不足道的尘埃罢了&quot;&quot;那会怎么样呢？....&quot;with zoomout&quot;出自尼采\\&quot;快乐的科学\\&quot;&quot;&quot;...&quot;&quot;星期五的下午...&quot;&quot;正因为是一周的结束,这个下午是最繁忙&quot;scene ditie&quot;在人挤人的晚高峰交通果然是如此拥挤&quot;&quot;既然这样,我还是在学校呆着吧&quot;&quot;和繁华的街道相比,这里非常安静&quot;&quot;我喜欢孤独的感觉...&quot;&quot;倒不如说是我一直在和孤独为伴&quot;&quot;就这样在学校不同角落溜达了一下午.....&quot;&quot;天空渐渐暗下来了&quot;&quot;管理人员经常犯疏忽,学校的天台时而不锁&quot;&quot;很幸运，这一次天台的大门能打开&quot;&quot;日落的暮光照在我的视角膜上&quot;&quot;一时的恍惚使我分不清自己在何处&quot;&quot;时间顿时变得飞快&quot;&quot;恍惚间，看到一位长发少女，她站在天台的边界&quot;&quot;她仿佛随时都会被风吹下，坠楼而死&quot;&quot;也许...?&quot;&quot;不好的念头出现在我的脑海里&quot;&quot;自杀？&quot;&quot;自杀？？&quot;&quot;由于学校是市里最好的高中之一，所以学生们的心理负担和压力并不小，每年都有接受不了沉重的负担，而选择离开这个世界的人们&quot;&quot;去人たち&quot;&quot;[不要跳下去...]&quot;&quot;&quot;","categories":[],"tags":[]},{"title":"《悲剧的诞生》读书笔记","slug":"[mian]Book/Nietzsche/《悲剧的诞生》读书笔记","date":"2022-10-24T15:24:06.000Z","updated":"2022-11-22T12:20:58.993Z","comments":true,"path":"posts/4081569272/","link":"","permalink":"https://kaguranotamashii.github.io/posts/4081569272/","excerpt":"","text":"1 简介 尼采的悲剧的诞生是他的处女作，也是他的哲学诞生地。尼采用日神阿波罗和酒神狄奥尼索斯的象征来说明艺术的起源，本质和功用乃至人生意义。弄清这两个概念后乃是理解尼采全部美学和哲学前提。 希腊悲剧艺术 希腊有三大悲剧艺术作家和他的作品，埃斯库罗斯（之父）的普罗米修斯，索福克勒斯的俄狄浦斯，欧里庇德斯的美狄亚。在艺术的演唱团中都有乐队，乐队们酒神古典希腊戏剧的根源，是为了祭祀狄奥尼索斯的一种祭祀。歌队固定在舞台上，选中两位主人公，赋予他们英雄的身份和史诗的情节，人开始有了象征性的意义，也就是人成为了艺术品。 前言 一 阿波罗 和狄奥尼索斯这两个名词，我们是从希腊人那里借用来的；希腊人虽然没有用概念、但却用他们的诸神世界透彻而清晰的形象，让明智之士感受到他们的艺术观深邃而隐秘的信条。 在希腊世界里存在着一种巨大的对立，按照起源和目标来讲，就是造型艺术（即阿波罗艺术）与非造型的音乐艺术（即狄奥尼索斯艺术）之间的巨大对立。（阿提卡悲剧的艺术作品） 为了更细致地了解这两种本能，让我们首先把它们设想为由**梦 （Traum ）与醉 （Rausch ）**构成的两个分离的艺术世界 庄严的诸神形象首先是在梦中向人类心灵显现出来的，伟大的雕塑家是在梦中看到超凡神灵的迷人形体的 在这些圣约翰节和圣维托节舞者 (33) 身上，我们重又见出希腊人的酒神歌队，其前史可溯源于小亚细亚，直到巴比伦和放纵的萨卡人 (34) 。如今有些人，由于缺乏经验或者由于呆头呆脑， (35) 感觉自己是健康的，便讥讽地或者怜悯地躲避 (36) 此类现象，有如对待“民间流行病”：这些可怜虫当然不会知道，当狄奥尼索斯的狂热者的炽热生命从他们身旁奔腾而过时，恰恰他们这种“健康”显得多么苍白、多么阴森。 (37) 在狄奥尼索斯的魔力之下，不仅人与人之间得以重新缔结联盟 人不再是艺术家，人变成了艺术品：在这里，在醉的战栗中，整个自然的艺术强力得到了彰显，臻至“太一”最高的狂喜满足。人这种最高贵的陶土，这种最可珍爱的大理石，在这里得到捏制和雕琢，而向着狄奥尼索斯的宇宙艺术家的雕凿之声，响起了厄琉西斯 (39) 的秘仪呼声：“万民啊，你们倒下来了？宇宙啊，你能预感到造物主吗？","categories":[],"tags":[]},{"title":"JavaWeb笔记","slug":"[main]CS/[main]web/JavaWeb","date":"2022-09-15T12:41:35.000Z","updated":"2022-10-25T11:58:51.425Z","comments":true,"path":"posts/1364342167/","link":"","permalink":"https://kaguranotamashii.github.io/posts/1364342167/","excerpt":"","text":"java网络编程 JDBC 1 JDBC 就是使用Java语言操作关系型数据库的一套API 全称：( Java DataBase Connectivity ) Java 数据库连接 官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口 各个数据库厂商去实现这套接口，提供数据库驱动jar包 我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类 各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发 可随时替换底层数据库，访问数据库的Java代码基本不变 以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包。如下图就是MySQL驱动包 快速入门 第一步：编写Java代码 第二步：Java代码将SQL发送到MySQL服务端 第三步：MySQL服务端接收到SQL语句并执行该SQL语句 第四步：将SQL语句执行的结果返回给Java代码 创建工程，导入驱动jar包 注册驱动 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 获取连接 1Connection conn = DriverManager.getConnection(url, username, password); Java代码需要发送SQL给MySQL服务端，就需要先建立连接 定义SQL语句 1String sql = “update…” ; 获取执行SQL对象 执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象 1Statement stmt = conn.createStatement(); 执行SQL 1stmt.executeUpdate(sql); 处理返回结果 释放资源 Maven Maven是专门用于管理和构建Java项目的工具，它的主要功能有： 提供了一套标准化的项目结构 提供了一套标准化的构建流程（编译，测试，打包，发布……） 提供了一套依赖管理机制 我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 插件(Plugin) Maven 坐标详解 什么是坐标？ Maven 中的坐标是资源的唯一标识 使用坐标来定义项目或引入项目中需要的依赖 Maven 坐标主要组成 groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） version：定义当前项目版本号 如下图就是使用坐标表示一个项目： 依赖管理 使用坐标引入jar包 使用坐标引入jar包的步骤： 在项目的 pom.xml 中编写 标签 在 标签中 使用 引入坐标 定义坐标的 groupId，artifactId，version 快速入门 创建模块，导入坐标 在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;!--mybatis 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加slf4j日志api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-classic依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-core依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意：需要在项目的 resources 目录下创建logback的配置文件 目录下创建mybatis的配置文件 编写 MyBatis 核心配置文件 – &gt; 替换连接信息 解决硬编码问题 在模块下的 resources 目录下创建mybatis的配置文件 mybatis-config.xml，内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写 SQL 映射文件 --&gt; 统一管理sql语句，解决硬编码问题 在模块的 resources 目录下创建映射配置文件 UserMapper.xml，内容如下 编写 SQL 映射文件 统一管理sql语句，解决硬编码问题 在模块的 resources 目录下创建映射配置文件 UserMapper.xml，内容如下 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 编码 在 com.itheima.pojo 包下创建 User类 123456789public class User &#123; private int id; private String username; private String password; private String gender; private String addr; //省略了 setter 和 getter&#125; 在 com.itheima 包下编写 MybatisDemo 测试类 1234567891011121314151617public class MyBatisDemo &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 解决SQL映射文件的警告提示： 在入门案例映射配置文件中存在报红的情况。问题如下： 产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。 解决方式：在Idea中配置MySQL数据库连接。 IDEA中配置MySQL数据库连接 点击IDEA右边框的 Database ，在展开的界面点击 + 选择 Data Source ，再选择 MySQL 在弹出的界面进行基本信息的填写 点击完成后就能看到如下界面 而此界面就和 navicat 工具一样可以进行数据库的操作。也可以编写SQL语句 Mapper代理开发 在 com.itheima.mapper 包下创建 UserMapper接口，代码如下： 1234public interface UserMapper &#123; List&lt;User&gt; selectAll(); User selectById(int id);&#125; 在 resources 下创建 com/itheima/mapper 目录，并在该目录下创建 UserMapper.xml 映射配置文件 123456789&lt;!-- namespace:名称空间。必须是对应接口的全限定名--&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 在 com.itheima 包下创建 MybatisDemo2 测试类，代码如下： 123456789101112131415161718192021222324/** * Mybatis 代理开发 */public class MyBatisDemo2 &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql //3.1 获取UserMapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAll(); System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 注意： 如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为 123456&lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt; &lt;!--Mapper代理方式--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt;&lt;/mappers&gt; TOMCAT Tomcat Maven插件 在IDEA中使用本地Tomcat进行项目部署，相对来说步骤比较繁琐，所以我们需要一种更简便的方式来替换它，那就是直接使用Maven中的Tomcat插件来部署项目，具体的实现步骤，只需要两步，分别是: 在pom.xml中添加Tomcat插件 12345678910&lt;build&gt; &lt;plugins&gt; &lt;!--Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 使用Maven Helper插件快速启动项目，选中项目，右键–&gt;Run Maven --&gt; tomcat7:run 注意: 如果选中项目并右键点击后，看不到Run Maven和Debug Maven，这个时候就需要在IDEA中下载Maven Helper插件，具体的操作方式为: File --&gt; Settings --&gt; Plugins --&gt; Maven Helper —&gt; Install,安装完后按照提示重启IDEA，就可以看到了。 Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用 使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml 1234567891011121314151617181920&lt;build&gt; &lt;plugins&gt; &lt;!--Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt;&lt;!--访问端口号 --&gt; &lt;!--项目访问路径 未配置访问路径: http://localhost:80/tomcat-demo2/a.html 配置/后访问路径: http://localhost:80/a.html 如果配置成 /hello,访问路径会变成什么? 答案: http://localhost:80/hello/a.html --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 小结 通过这一节的学习，大家要掌握在IDEA中使用Tomcat的两种方式，集成本地Tomcat和使用Maven的Tomcat插件。后者更简单，推荐大家使用，但是如果对于Tomcat的版本有比较高的要求，要在Tomcat7以上，这个时候就只能用前者了。 jsp 在 dependencies 标签中导入 JSP 的依赖，如下 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 该依赖的 scope 必须设置为 provided，因为 tomcat 中有这个jar包了，所以在打包时我们是不希望将该依赖打进到我们工程的war包中。 JSP 脚本有如下三个分类： &lt;%…%&gt;：内容会直接放到_jspService()方法之中 &lt;%=…%&gt;：内容会放到out.print()中，作为out.print()的参数 &lt;%!…%&gt;：内容会放到_jspService()方法之外，被类直接包含 mvc模式喝三层架构 MVC 是一种分层开发的模式，其中： M：Model，业务模型，处理业务 V：View，视图，界面展示 C：Controller，控制器，处理请求，调用模型和视图 控制器（serlvlet）用来接收浏览器发送过来的请求，控制器调用模型（JavaBean）来获取数据，比如从数据库查询数据；控制器获取到数据后再交由视图（JSP）进行数据展示。 MVC 好处： 职责单一，互不影响。每个角色做它自己的事，各司其职。 有利于分工协作。 有利于组件重用 三层架构是将我们的项目分成了三个层面，分别是 表现层、业务逻辑层、数据访问层。 三层架构是将我们的项目分成了三个层面，分别是 表现层、业务逻辑层、数据访问层。 数据访问层：对数据库的CRUD基本操作 业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能。例如 注册业务功能 ，我们会先调用 数据访问层 的 selectByName() 方法判断该用户名是否存在，如果不存在再调用 数据访问层 的 insert() 方法进行数据的添加操作 表现层：接收请求，封装数据，调用业务逻辑层，响应数据 Cookie和Session Cookie：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问。 Cookie的基本使用 对于Cookie的使用，我们更关注的应该是后台代码如何操作Cookie，对于Cookie的操作主要分两大 类，本别是发送Cookie和获取Cookie,对于上面这两块内容，分别该如何实现呢? 创建Cookie对象，并设置数据 发送Cookie到客户端：使用response对象 介绍完发送Cookie对应的步骤后，接下面通过一个案例来完成Coo 3.1 发送Cookie 创建Cookie对象，并设置数据 1Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;); 发送Cookie到客户端：使用response对象 1response.addCookie(cookie); 介绍完发送Cookie对应的步骤后，接下面通过一个案例来完成Cookie的发送，具体实现步骤为: 需求:在Servlet中生成Cookie对象并存入数据，然后将数据发送给浏览器 1.创建Maven项目,项目名称为cookie-demo，并在pom.xml添加依赖 2.编写Servlet类，名称为AServlet 3.在AServlet中创建Cookie对象，存入数据，发送给前端 4.启动测试，在浏览器查看Cookie对象中的值 (1)创建Maven项目cookie-demo，并在pom.xml添加依赖 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; (2)编写Servlet类，名称为AServlet 123456789101112@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; (3)在Servlet中创建Cookie对象，存入数据，发送给前端 12345678910111213141516@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(&quot;username&quot;,&quot;zs&quot;); //2. 发送Cookie，response response.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; （4）启动测试，在浏览器查看Cookie对象中的值 访问http://localhost:8080/cookie-demo/aServlet chrome浏览器查看Cookie的值，有两种方式,分布式: 3.2 获取Cookie 获取客户端携带的所有Cookie，使用request对象 1Cookie[] cookies = request.getCookies(); 遍历数组，获取每一个Cookie对象：for 使用Cookie对象方法获取数据 12cookie.getName();cookie.getValue(); 介绍完获取Cookie对应的步骤后，接下面再通过一个案例来完成Cookie的获取，具体实现步骤为: 需求:在Servlet中获取前一个案例存入在Cookie对象中的数据 1.编写一个新Servlet类，名称为BServlet 2.在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值 3.启动测试，在控制台打印出获取的值 (1)编写一个新Servlet类，名称为BServlet 123456789101112@WebServlet(&quot;/bServlet&quot;)public class BServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; （2）在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值 12345678910111213141516171819202122232425@WebServlet(&quot;/bServlet&quot;)public class BServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) &#123; //3. 获取数据 String name = cookie.getName(); if(&quot;username&quot;.equals(name))&#123; String value = cookie.getValue(); System.out.println(name+&quot;:&quot;+value); break; &#125; &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; （3）启动测试，在控制台打印出获取的值 访问http://localhost:8080/cookie-demo/bServlet 在IDEA控制台就能看到输出的结果: ==思考:==测试的时候 在访问AServlet和BServlet的中间把关闭浏览器,重启浏览器后访问BServlet能否获取到Cookie中的数据? 这个问题，我们会在Cookie的使用细节中讲，大家可以动手先试下。 小结 在这节中，我们主要讲解了Cookie的基本使用,包含两部分内容 发送Cookie: 创建Cookie对象，并设置值:Cookie cookie = new Cookie(“key”,“value”); 发送Cookie到客户端使用的是Reponse对象:response.addCookie(cookie); 获取Cookie: 使用Request对象获取Cookie数组:Cookie[] cookies = request.getCookies(); 遍历数组 获取数组中每个Cookie对象的值:cookie.getName()和cookie.getValue() Session的基本使用 介绍完Cookie的基本使用之后，那么Cookie的底层到底是如何实现一次会话两次请求之间的数据共享呢? Session：服务端会话跟踪技术：将数据保存到服务端。 Session是存储在服务端而Cookie是存储在客户端 存储在客户端的数据容易被窃取和截获，存在很多不安全的因素 存储在服务端的数据相比于客户端来说就更安全","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"后端","slug":"编程/后端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/"},{"name":"JavaWeb","slug":"编程/后端/JavaWeb","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/JavaWeb/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://kaguranotamashii.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"https://kaguranotamashii.github.io/tags/Java/"}]},{"title":"ssm笔记","slug":"[main]CS/[main]web/黑马ssm笔记","date":"2022-08-15T12:41:35.000Z","updated":"2023-10-03T06:14:51.973Z","comments":true,"path":"posts/1104342167/","link":"","permalink":"https://kaguranotamashii.github.io/posts/1104342167/","excerpt":"","text":"Spring核心技术 spring 5 从使用和占有率看 Spring在市场的占有率与使用率高 Spring在企业的技术选型命中率高 所以说,Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;90% 说明:对于未使用Spring的项目一般都是些比较老的项目，大多都处于维护阶段。 从专业角度看 随着时代发展，软件规模与功能都呈几何式增长，开发难度也在不断递增，该如何解决? Spring可以简化开发，降低企业级开发的复杂性，使开发变得更简单快捷 随着项目规模与功能的增长,遇到的问题就会增多，为了解决问题会引入更多的框架，这些框架如何协调工作? Spring可以框架整合，高效整合其他技术，提高企业级应用开发与运行效率 综上所述，Spring是一款非常优秀而且功能强大的框架，不仅要学，而且还要学好。 从上面的介绍中，我们可以看到Spring框架主要的优势是在简化开发和框架整合上，至于如何实现就是咱们要学习Spring框架的主要内容: 简化开发: Spring框架中提供了两个大的核心技术，分别是: IOC AOP 事务处理 框架整合: Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如: MyBatis MyBatis-plus Struts Struts2 Hibernate …… 这些框架中，我们目前只学习了MyBatis，所以在Spring框架的学习中，主要是学习如何整合MyBatis。 综上所述，对于Spring的学习，主要学习四块内容: (1)IOC,(2)整合Mybatis(IOC的具体应用)，(3)AOP,(4)声明式事务(AOP的具体应用) spring 核心概念 这节比较重要，重点要理解什么是IOC/DI思想、什么是IOC容器和什么是Bean： (1)什么IOC/DI思想? IOC:控制反转，控制反转的是对象的创建权 DI:依赖注入，绑定对象与对象之间的依赖关系 (2)什么是IOC容器? Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器 (3)什么是Bean? 容器中所存放的一个个对象就叫Bean或Bean对象 IOC（Inversion of Control）控制反转 (1)什么是控制反转呢？ 使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。 业务层要用数据层的类对象，以前是自己new的 现在自己不new了，交给别人[外部]来创建对象 别人[外部]就反转控制了数据层对象的创建权 这种思想就是控制反转 别人[外部]指定是什么呢?继续往下学 (2)Spring和IOC之间的关系是什么呢? Spring技术对IOC思想进行了实现 Spring提供了一个容器，称为IOC容器，用来充当IOC思想中的&quot;外部&quot; IOC思想中的别人[外部]指的就是Spring的IOC容器 (3)IOC容器的作用以及内部存放的是什么? IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象 被创建或被管理的对象在IOC容器中统称为Bean IOC容器中放的就是一个个的Bean对象 (4)当IOC容器中创建好service和dao对象后，程序能正确执行么? 不行，因为service运行需要依赖dao对象 IOC容器中虽然有service和dao对象 但是service对象和dao对象没有任何关系 需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系 像这种在容器中建立对象与对象之间的绑定关系就要用到DI: DI（Dependency Injection）依赖注入 (1)什么是依赖注入呢? 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入 业务层要用数据层的类对象，以前是自己new的 现在自己不new了，靠别人[外部其实指的就是IOC容器]来给注入进来 这种思想就是依赖注入 (2)IOC容器中哪些bean之间要建立依赖关系呢? 这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系 介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:充分解耦，具体实现靠: 使用IOC容器管理bean（IOC) 在IOC容器内将有依赖关系的bean进行关系绑定（DI） 最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系. IOC相关 bean基础配置 对于bean的基础配置，在前面的案例中已经使用过: 1&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt; 其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下 SpringMVC 浏览器发送一个请求给后端服务器，后端服务器现在是使用Servlet来接收请求和数据 如果所有的处理都交给Servlet来处理的话，所有的东西都耦合在一起，对后期的维护和扩展极为不利 将后端服务器Servlet拆分成三层，分别是web、service和dao web层主要由servlet来处理，负责页面请求和数据的收集以及响应结果给前端 service层主要负责业务逻辑的处理 dao层主要负责数据的增删改查操作 servlet处理请求和数据的时候，存在的问题是一个servlet只能处理一个请求 针对web层进行了优化，采用了MVC设计模式，将其设计为controller、view和Model controller负责请求和数据的接收，接收后将其转发给service进行业务处理 service根据需要会调用dao对数据进行增删改查 dao把数据处理完后将结果交给service,service再交给controller controller根据需求组装成Model和View,Model和View组合起来生成页面转发给前端浏览器 这样做的好处就是controller可以处理多个请求，并对请求进行分发，执行不同的业务操作。 因为SpringMVC是一个Web框架，将来是要替换Servlet,所以先来回顾下以前Servlet是如何进行开发的? 1.创建web工程(Maven结构) 2.设置tomcat服务器，加载web工程(tomcat插件) 3.导入坐标(Servlet) 4.定义处理请求的功能类(UserServlet) 5.设置请求映射(配置映射关系) SpringMVC的制作过程和上述流程几乎是一致的，具体的实现流程是什么? 1.创建web工程(Maven结构) 2.设置tomcat服务器，加载web工程(tomcat插件) 3.导入坐标(SpringMVC+Servlet) 4.定义处理请求的功能类(UserController) 5.设置请求映射(配置映射关系) 6.将SpringMVC设定加载到Tomcat容器中 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/save&quot;) public void save()&#123; System.out.println(&quot;user save ...&quot;); &#125;&#125; 知识点1：@Controller 名称 @Controller 类型 类注解 位置 SpringMVC控制器类定义上方 作用 设定SpringMVC的核心控制器bean 知识点2：@RequestMapping 名称 @RequestMapping 类型 类注解或方法注解 位置 SpringMVC控制器类或方法定义上方 作用 设置当前控制器方法请求访问路径 相关属性 value(默认)，请求访问路径 知识点3：@ResponseBody 名称 @ResponseBody 类型 类注解或方法注解 位置 SpringMVC控制器类或方法定义上方 作用 设置当前控制器方法响应内容为当前返回值，无需解析 知识点1：@ComponentScan 名称 @ComponentScan 类型 类注解 位置 类定义上方 作用 设置spring配置类扫描路径，用于加载使用注解格式定义的bean 相关属性 excludeFilters:排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes)includeFilters:加载指定的bean，需要指定类别(type)和具体项(classes) 知识点1：@RequestParam 名称 @RequestParam 类型 形参注解 位置 SpringMVC控制器方法形参定义前面 作用 绑定请求参数与处理器方法形参间的关系 相关参数 required：是否为必传参数 defaultValue：参数默认值 知识点2：@RequestBody 名称 @RequestBody 类型 形参注解 位置 SpringMVC控制器方法形参定义前面 作用 将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次 @RequestBody与@RequestParam区别 区别 @RequestParam用于接收url地址传参，表单传参【application/x-www-form-urlencoded】 @RequestBody用于接收json数据【application/json】 应用 后期开发中，发送json格式数据为主，@RequestBody应用较广 如果发送非json格式数据，选用@RequestParam接收请求参数 知识点1：@DateTimeFormat 名称 @DateTimeFormat 类型 形参注解 位置 SpringMVC控制器方法形参前面 作用 设定日期时间型数据格式 相关属性 pattern：指定日期时间格式字符串","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"后端","slug":"编程/后端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/"},{"name":"JavaWeb","slug":"编程/后端/JavaWeb","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/JavaWeb/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://kaguranotamashii.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"https://kaguranotamashii.github.io/tags/Java/"}]},{"title":"MySql基础","slug":"[main]CS/[main]computer-language/MySql基础","date":"2022-07-13T02:55:52.000Z","updated":"2022-09-21T11:20:40.519Z","comments":true,"path":"posts/16977/","link":"","permalink":"https://kaguranotamashii.github.io/posts/16977/","excerpt":"","text":"数据库应用 数据库能存储大量 Database 数据库 Database Management System DBMS数据库管理系统 SQL 结构化查询语言 RDBMS and 非RDBMS rdbms是最古老的数据类型 把复杂的数据类型归纳为简单的二元关系 以row coumn的形式组成的 非rdbms 查找速度快 Mysql数据库基本操作-DDL 功能 sql 查看所有数据库 show databases; 创建数据库 create database [if not exists] mydb1 [charset=utf8]; 切换数据库 use mydb1; 删除数据库 drop database [if exists] mydb1; 修改数据库编码 alter databse mydb1 character set utf8; 12345678910-- 1.DDL操作数据库操作-- 查看所有数据库show DATABASES;-- 创建数据库-- CREATE DATABASE mydb1;CREATE DATABASE if NOT EXISTS mydb1;-- 选择数据库use mydb1;-- 删除数据库DROP DATABASE mydb1; 创建表 123456789101112-- 创建表-- 选择mydb1use mydb1create table if not exists student(sid int,name varchar(20),gender varchar(2),age int,birth data,address varchar(20),score double); 其他操作 1234567891011121314151617-- 创建表-- 选择mydb1use sqldb1;create table if not exists student(name1 char(22),sid int,score double);-- 查看所有的表show tables;-- 查看指定表的创建语句show create table student;-- 查看表结构desc student;-- 删除表drop table student; 修改表结构 1alter table name add 列名 type 约束 123456789101112131415161718-- 查看所有的表show tables;-- 查看指定表的创建语句show create table student;-- 删除表-- drop table student;-- 创建新的列alter table student add dept varchar(22);-- 修改alter table student dept department VARCHAR(33);-- 删除表列alter table student drop deparment;-- 修改表名rename table student to stu;desc student; DML data manipulation language 用来对数据库表中的元素进行增删改 插入insert 删除delete 更新update 美*/ɪnˈsɜːrt/ 美/dɪˈliːt/* 美*/*ˌʌpˈdeɪt/ DML是指着数据操作语言 insert 123insert into 表(列名1，列名2...) values (值1，值2....)；insert into 表 values (值1，值2....); update 12update 表名 set 字段名=值,。。。。。。update 表明 set 字段名=值。。。。。。 where 条件 123update student set sid =0000;--update student set score =100 where name1=&#x27;zhangziyu&#x27;; delete 123delete from 表名 [where 条件] -- 不加条件全部删除或者truncate table 表名 where条件 1创建employee表，id name gender salary DQL data query language 数据查询语言 用来查找 select 123456789101112131415161718192021222324252627282930313233create table emp( id int comment &#x27;编号&#x27;, workno varchar(10) comment &#x27;工号&#x27;, name varchar(10) comment &#x27;姓名&#x27;, gender char(1) comment &#x27;性别&#x27;, age tinyint unsigned comment &#x27;年龄&#x27;, idcard char(18) comment &#x27;身份证号&#x27;, workaddress varchar(50) comment &#x27;工作地址&#x27;, entrydate date comment &#x27;入职时间&#x27;) comment &#x27;员工表&#x27;;insert into emp(id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (1, &#x27;1&#x27;, &#x27;柳岩&#x27;, &#x27;女&#x27;, 20, &#x27;123456789012345678&#x27;, &#x27;北京&#x27;, &#x27;2000-01-01&#x27;), (2, &#x27;2&#x27;, &#x27;张无忌&#x27;, &#x27;男&#x27;, 18, &#x27;123456789012345670&#x27;, &#x27;北京&#x27;, &#x27;2005-09-01&#x27;), (3, &#x27;3&#x27;, &#x27;韦一笑&#x27;, &#x27;女&#x27;, 38, &#x27;123456789012345670&#x27;, &#x27;上海&#x27;, &#x27;2005-08-01&#x27;), (4, &#x27;4&#x27;, &#x27;赵敏&#x27;, &#x27;女&#x27;, 18, &#x27;123456789012345670&#x27;, &#x27;北京&#x27;, &#x27;2009-12-01&#x27;), (5, &#x27;5&#x27;, &#x27;小昭&#x27;, &#x27;女&#x27;, 16, &#x27;123456789012345678&#x27;, &#x27;上海&#x27;, &#x27;2007-07-01&#x27;), (6, &#x27;6&#x27;, &#x27;杨逍&#x27;, &#x27;男&#x27;, 28, &#x27;12345678901234567X&#x27;, &#x27;北京&#x27;, &#x27;2006-01-01&#x27;), (7, &#x27;7&#x27;, &#x27;范瑶&#x27;, &#x27;男&#x27;, 40, &#x27;123456789012345670&#x27;, &#x27;北京&#x27;, &#x27;2005-05-01&#x27;), (8, &#x27;8&#x27;, &#x27;黛绮丝&#x27;, &#x27;女&#x27;, 38, &#x27;123456789012345670&#x27;, &#x27;天津&#x27;, &#x27;2015-05-01&#x27;), (9, &#x27;9&#x27;, &#x27;范凉凉&#x27;, &#x27;女&#x27;, 45, &#x27;123456789012345678&#x27;, &#x27;北京&#x27;, &#x27;2010-04-01&#x27;), (10, &#x27;10&#x27;, &#x27;陈友谅&#x27;, &#x27;男&#x27;, 53, &#x27;123456789012345670&#x27;, &#x27;上海&#x27;, &#x27;2011-01-01&#x27;), (11, &#x27;11&#x27;, &#x27;张士诚&#x27;, &#x27;男&#x27;, 55, &#x27;123456789012345670&#x27;, &#x27;江苏&#x27;, &#x27;2015-05-01&#x27;), (12, &#x27;12&#x27;, &#x27;常遇春&#x27;, &#x27;男&#x27;, 32, &#x27;123456789012345670&#x27;, &#x27;北京&#x27;, &#x27;2004-02-01&#x27;), (13, &#x27;13&#x27;, &#x27;张三丰&#x27;, &#x27;男&#x27;, 88, &#x27;123456789012345678&#x27;, &#x27;江苏&#x27;, &#x27;2020-11-01&#x27;), (14, &#x27;14&#x27;, &#x27;灭绝&#x27;, &#x27;女&#x27;, 65, &#x27;123456789012345670&#x27;, &#x27;西安&#x27;, &#x27;2019-05-01&#x27;), (15, &#x27;15&#x27;, &#x27;胡青牛&#x27;, &#x27;男&#x27;, 70, &#x27;12345678901234567X&#x27;, &#x27;西安&#x27;, &#x27;2018-04-01&#x27;), (16, &#x27;16&#x27;, &#x27;周芷若&#x27;, &#x27;女&#x27;, 18, null, &#x27;北京&#x27;, &#x27;2012-06-01&#x27;);-- 1查询 name workno ageselect name ,workno,age from emp; 1select name ,workno,age from emp; 条件查询 12345678-- 1.查询 name workno age select name ,workno,age from emp;-- 2.查询 所有字段此返回 select *from emp;-- 3.查询所有员工的地址和起别名 select workaddress as &#x27;工作地址&#x27;from emp;-- 4 查询去除重复select distinct workaddress &#x27;工作地址&#x27; from emp; 12345678910111213141516171819202122232425262728293031323334353637383940-- 1.查询 name workno age-- select name ,workno,age from emp;-- 2.查询 所有字段此返回-- select *from emp;-- 3.查询所有员工的地址和起别名-- select workaddress as &#x27;工作地址&#x27;from emp;-- 4 查询去除重复-- select distinct workaddress &#x27;工作地址&#x27; from emp;-- select 字段列表 from 表名 where 条件列表-- 条件select *from emp where age=88;-- 13,13,张三丰,男,88,123456789012345678,江苏,2020-11-01select *from emp where age&lt;20;/*2,2,张无忌,男,18,123456789012345670,北京,2005-09-014,4,赵敏,女,18,123456789012345670,北京,2009-12-015,5,小昭,女,16,123456789012345678,上海,2007-07-0116,16,周芷若,女,18,,北京,2012-06-01*/-- select *from emp where idcard is null;-- select *from emp where idcard is not null;-- select *from emp where age!=88;-- select *from emp where age&gt;=15 and age&lt;=20;/*select *from emp where age&lt;25 and gender = &#x27;女&#x27;;select *from emp where age in(18,20,40);-- 两个字的select *from emp where name like &#x27;__&#x27;;*/-- 最后身份证是x的select *from emp where idcard like &#x27;%x&#x27;; 聚合函数 count 统计数量 max 最大 min avg 平均数 sum 求和 123select count(*) from emp;select max(age) from emp; 分组查询 1select 字段列表 from 表名 where group by 分组字段名 having 1select gender ,avg(age) from emp group by gender; 1234select gender ,count(*) from emp group by gender;select gender ,avg(age) from emp group by gender;select workaddress ,count(*) address_count from emp where age&lt;45 group by workaddress having address_count&gt;=3 排序查询 group up 123select 字段列表 from 表名 order by 字段1 排序方式1...../*asc升序 desc降序*/ 12345select * from emp order by age asc;select * from emp order by age desc;select *from emp order by age asc,entrydate desc; 分页查询 12select 字段列表 from 表名 limt 起始索引，查询记录数;0,10; 12345678910-- 查询年龄为20212223女性select *from emp where gender=&#x27;女&#x27; and age in(20,21,22,23);-- 查男性 年龄在20-40 名字为3个字的select *from emp where gender=&#x27;男&#x27; and age between 20 and 40 and name like &#x27;___&#x27;;-- 小于60 男女总人数select gender ,count(*) from emp where age&lt;60 group by gender;-- 年龄小于35 员工年龄和姓名 对年龄升序 相同年龄降序select name,age from emp where age&lt;=35 order by age asc,entrydate desc ;-- 性别男 20-40岁 的前五个员工 年龄升序 相同年龄降序select *from emp where gender=&#x27;男&#x27; and age between 20 and 40 order by age asc,entrydate asc limit 5; DCL data control language 数据控制语言 查询用户 123456create user &#x27;itcast&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;create user &#x27;heima&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;alter user &#x27;heima&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123&#x27;;drop user &#x27;itcast&#x27;@&#x27;localhost&#x27;; 函数 字符串函数 12update emp set workno = lpad(workno,5,0);-- 补充五位 数值函数 日期函数 12345678910select curdate();select curtime();select year(now());select month(now());select date_add(now(),INTERVAL 70 YEAR );select datediff(&#x27;2000-10-3&#x27;,now());select name,datediff(curdate(),entrydate) as &#x27;entrydays&#x27; from emp order by entrydays asc ; 流程控制函数 1 123456select ifnull(null,111231);select name, (case workaddress when &#x27;北京&#x27; then &#x27;一线城市&#x27; when &#x27;上海&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;from emp; 约束 约束演示 用于作用于表中字段的规则，用于限制在表中的数据 保证数据库中的数据正确 有效性和完整性 多表查询","categories":[],"tags":[]},{"title":"算法基础笔记","slug":"[main]CS/[main]Leetcode/算法基础笔记","date":"2022-07-07T07:03:07.000Z","updated":"2022-07-26T07:51:37.909Z","comments":true,"path":"posts/46395/","link":"","permalink":"https://kaguranotamashii.github.io/posts/46395/","excerpt":"","text":"基础 位运算 1234567891011public class bit_operation &#123; public static void print(int num) &#123; for (int i = 31; i &gt;= 0; i--) &#123; System.out.print((num &amp; (1 &lt;&lt; i)) == 0 ? &quot;0&quot; : &quot;1&quot;); &#125; &#125; public static void main(String[] args) &#123; print(-12); &#125;&#125; 选择排序 12345678910111213public static void selectSort(int[] arr) &#123; if (arr == null || arr.length == 1) &#123; return; &#125; int N = arr.length; for (int i = 0; i &lt; N; i++) &#123; int minValueIndex = i; for (int j = i + 1; j &lt; N; j++) &#123; minValueIndex = arr[j] &lt; arr[minValueIndex] ? j : minValueIndex; &#125; swap(arr, i, minValueIndex); &#125; &#125; 1234567891011121314public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length == 1) &#123; return; &#125; int N = arr.length; for (int end = N - 1; end &gt;= 0; end--) &#123; for (int second = 1; second &lt;= end; second++) &#123; if (arr[second - 1] &gt; arr[second]) &#123; swap(arr, second - 1, second); &#125; &#125; &#125;&#125; } &#125; 12 数组 链表 跳表 数组是在内存中开辟出一段连续的空间 跳表是为了解决链表的缺点 空间换时间","categories":[],"tags":[]},{"title":"大一下学期总结","slug":"[main]summary/大一下学期总结","date":"2022-07-06T16:37:29.000Z","updated":"2022-08-07T02:46:38.338Z","comments":true,"path":"posts/3942644093/","link":"","permalink":"https://kaguranotamashii.github.io/posts/3942644093/","excerpt":"","text":"没想到2022年就这样过去了一半，感叹时光飞逝之余，也回头回顾今年上半年的光阴是否虚度，遗憾固然存在，但也又一点点可以聊以自慰的成绩。 回顾 学习 学习了vue框架和javase，在学习前端的同时彻底爱上了vscode，以及有意思的开源插件。四月学前端的时候用原生js写了页love-letter，虽然被拒绝了，但是认识到了原生js的不方便之处后，又简单学习了jQuery，才意识到了js框架的便利之处。 这八个月只能说是大摆烂了 读书 这八个月读了几本有趣的书 自己目前最喜欢的是法国作家**阿尔贝·加缪** “ 今天，妈妈死了。也可能是昨天，我不知道。” ”现在我面对这个充满了星光与默示的夜，第一次向这个冷漠的世界敞开了我的心扉“ -----加缪《局外人》 当在这八个月以来压抑的网课以及疫情防控的影响下，烦躁的内心终于静了下来，总能去做一些有艺术的事情，比如说，思考，读书，学习等。这本局外人是我读的印象最深刻的一本书。文章情节不复杂一个下午便能读完。 这本书的主人公叫默尔索，他因为做了很多世人无法理解的行为，而被法兰西法官判为死刑，关于细节可以在网上随便就能搜索到。 默尔索的行为真的是荒诞的吗？我想肯定有些部分是荒诞的，但是面对群众以及神职人员对于洗礼罪恶的喋喋不休，他并没有所打动，坚持用自己的语言表达对生活的热爱。他们虽然清醒地认识到人的脆弱和局限，以及世界和人生必然的荒谬，但他们却并没有被击垮，而是勇敢地面对，并努力地克服这种悲剧和荒谬，最终让自己获得了幸福。 我认为在这一点上，加缪的思想，要远比很多传统的宗教和哲学，有价值得多。因为对于人生的荒谬，虽然它们也有认识，但给出的答案，要么就是放弃今生祈求来世，要么就是过于宏大，什么爱、什么美、什么善。却唯独忘了干！ 加缪曾说：不要走在我的后面，我可能不会引路；不要走在我的前面，我可能不会跟随；请走在我的身边，做我的朋友！ 骑行 有些路，没有路过，这是我的遗憾，很多人不理解骑行是为了什么？曾经的当然我也是这样认为的，自己在北京的远郊区经常会有骑行爱好者，因此便产生这个疑问。 因为健康骑的方式让我爱上了骑行这项运动，让我心中久违的梦再次点燃。最初从骑10千米都困难到一口气骑了80km，配速从不到20km/h到现在的25km/h这是我四个月骑行来的变化。 太阳西下，总会给人一种遐想，是渴望心灵与大自然的碰撞，也许是对生活和理想的不满，梦与实际的不解。四个月来的晚上，我带着余霞，骑着初中买的UCC山地车出发了…下一次我会骑向哪里呢？ 小玩意 都是在四月前完成的，都是为了向心爱的女孩去表达自己的心意，一项是自己写的情书网页，在GitHub上已经设置为private了，因为代码写的太羞耻了，内容写的也很“螺旋马太”。 还有一项是用单片机arduino和面包板焊接锡线做出来的爱心流水灯，学习了不少关于焊接的知识，但是都不如用pcb板方便。 图片就不太想放了，技术力太低了。 日语 今年在北大考点参加了七月的jlpt n2等级的考试，可惜摆烂了很长时间，甚至只花了两周的时间去备考n2。我想我未来后应该迟早会去日本生活，或者旅行，所以日语依然要继续保持能力。很想去亚洲第一大城市东京去看看，去北海道，名古屋… 世界那麽大，我想去看看。 博客 这半年来并没有写多少博客相关的内容，甚至花不少时间痴迷于博客的美化和魔改博客的搭建记录. | これは神楽の魂のブログ (kaguranotamashii.github.io) 下半年我想在我的博客写一些关于游戏或者影视的评测，提高我的写作水平，比如我最近正在玩的一部gal 青い空のカミュ 关于下半年的期望 写更好的代码 读有趣的书 拥有BMI为28以下的身体 最后用[まごころを、君に] 落幕的台词作为这半年来的结束。我现在所经历的社会环境和这部剧当时的历史环境有着惊人的相似之处，我和上世纪90年代的他们有着深刻的话题。妄图从它中得以治愈… なに？ 夢って何かな？ 夢？ そう 夢 分からない 現実が よく分からないんだ 他人の現実と自分の真実との溝が 正確に把握できないのね 幸せがどこにあるのか 分からないんだ 夢の中にしか 幸せを見いだせないのね だから これは現実じゃない 誰もいない世界だ そう 夢 だから ここには僕がいない 都合のいい 作り事で 現実の復讐(しゅう)をしていたのね いけないのか 虚構に逃げて 真実をごまかしていたのね 僕 一人の夢を見ちゃいけないのか それは夢じゃない ただの現実の埋め合わせよ 〜♪ （観衆のざわめき） じゃあ 僕の夢はどこ？ それは 現実の続き 僕の現実はどこ？ それは 夢の終わりよ ♪","categories":[{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/categories/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://kaguranotamashii.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/tags/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"}]},{"title":"LeetcodeNotes","slug":"[main]CS/[main]Leetcode/LeetcodeNotes","date":"2022-07-04T05:41:15.000Z","updated":"2022-07-16T15:37:41.046Z","comments":true,"path":"posts/44870/","link":"","permalink":"https://kaguranotamashii.github.io/posts/44870/","excerpt":"","text":"d 第二天 字符串 字符串的遍历 「 字符串 」 是一种特殊的 字符数组，字符数组需要有一个长度字段来表示这个数组中的元素个数。而字符串不需要，字符串一定是以\\0结尾的，在 C语言中，字符串的表示如下： 12char c[6] = &quot;Hello&quot;; // (1)char d[5] = &#123; &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27; &#125;; // (2) 其中 ( 1 ) (1)(1) 表示字符串，它虽然只有五个字符，但是需要有一个结尾字符\\0（它的 ASCII 码值为 0）进行占位，所以字符串长度为 5，但是实际需要 6 个字节的存储空间。 而 ( 2 ) (2)(2) 代表的是一个数组，它的每个元素是一个字符，理解成一个长度为 5 的数组即可。 字符串的长度 12char c[6] = &quot;Hello&quot;; printf(&quot;%d\\n&quot;, strlen(c)); 字符串的遍历 12345678910111213int len = strlen(s);for(i = 0; i &lt; len; ++i) &#123; // TODO ...&#125;for(i = 0; s[i] != &#x27;\\0&#x27;; ++i) &#123; // TODO ...&#125;for(i = 0; s[i]; ++i) &#123; // TODO ...&#125; 大小写转换 1234if(s[i]&gt;=&#x27;A&#x27;&amp;&amp;s[i]&lt;=&#x27;Z&#x27;)&#123; s[i]=s[i]-&#x27;A&#x27;+&#x27;a&#x27;;&#125;//首先，我们可以利用 ASCII 码值的关系比较来确定它是大写字母，还是小写字母，如果是大写字母转成小写字母，可以通过先减去A再加上a，从而转换成小写字母。实现如下： 字符串拷贝 123char src[10] = &quot;Hello&quot;;char tar[10];strcpy(tar, src); 字符串比较 1234char src[10] = &quot;Hello&quot;;char tar[10] = &quot;hello&quot;;int x = strcmp(tar, src);//！=0int y = strcmp(tar, &quot;hello&quot;);//0 字符串分割 12345char str[9] = &quot;I love U&quot;;//变成char str[][5] = &#123; &quot;I&quot;, &quot;love&quot;, &quot;U&quot;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://kaguranotamashii.github.io/categories/Leetcode/"},{"name":"基础知识","slug":"Leetcode/基础知识","permalink":"https://kaguranotamashii.github.io/categories/Leetcode/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kaguranotamashii.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"vue.js的学习笔记","slug":"[main]CS/[main]web/vue笔记","date":"2022-05-27T13:17:15.000Z","updated":"2023-08-01T14:36:11.190Z","comments":true,"path":"posts/42133/","link":"","permalink":"https://kaguranotamashii.github.io/posts/42133/","excerpt":"","text":"vue.js开发环境 关于作者 尤雨溪是Vue.js框架的作者，他是我最佩服的华人程序员之一，他的编码经历深深的激励着我。 程序员最讲究的就是作品，光说没用，代码要拿出来溜溜！所以现在程序员都得有自己的GitHub。 Vue作者尤雨溪：以匠人的态度不断打磨完善Vue（图灵访谈） - 百度文库 (baidu.com) 他还是位老二次元哈哈哈，不同版本都用经典动漫和小说作为版本名称 版本 发布日期 版本名称 3.2 2021年8月5日 Quintessential Quintuplets[12] 3.1 2021年6月7日 Pluto[13] 3.0 2020年9月18日 One Piece[14] 2.6 2019年2月4日 Macross[15] 2.5 2017年10月13日 Level E[16] 2.4 2017年7月13日 Kill la Kill[17] 2.3 2017年4月27日 JoJo’s Bizarre Adventure[18] 2.2 2017年2月26日 Initial D[19] 2.1 2016年11月22日 Hunter X Hunter[20] 2.0 2016年9月30日 Ghost in the Shell[21] 1.0 2015年10月27日 Evangelion[22] 0.12 2015年6月12日 Dragon Ball[23] 0.11 2014年11月7日 Cowboy Bebop[24] 0.10 2014年3月23日 Blade Runner[25] 0.9 2014年2月25日 Animatrix[26] 0.8 2014年1月27日 不适用 [27] 0.7 2013年12月24日 不适用 [28] 0.6 2013年12月8日 VueJS [29] 关于vscode 123Vue 3 Snippets:快速生成Vue3代码的插件Vetur 的特性: 语法高亮, 代码片段 (emmet 给我的感觉是一个写好了的 snippet), 质量提示 &amp; 错误、格式化 / 风格、智能提示等。&lt;script src=&quot;https://cdn.staticfile.org/vue/2.7.0/vue.min.js&quot;&gt; 1Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示。 认识vue 1234567891011121314&lt;div id=&quot;root&quot;&gt; &lt;h1&gt;Hello,宋宇然&lt;/h1&gt; &lt;h1&gt;我的年龄为：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; //const x = new Vue(&#123; el: &#x27;#root&#x27;,//element data: &#123; name: &#x27;a&#x27; &#125; &#125; ) &lt;/script&gt; 想让vue工作要先创建vue实例，root容器代码依然符合html规范只不过里面引入了特殊的vue语法而已，root里面的代码称之为vue模板 插值语法 v-on 绑定事件 1234567891011121314151617181920&lt;div id=&quot;root&quot;&gt; &lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot;&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt; d点我&lt;/button&gt; &lt;button @click=&quot;sayHi&quot;&gt; d点我&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &quot;#root&quot;, data: &#123; url: &quot;../&quot; &#125;, methods: &#123; sayHi() &#123; alert(&quot;hello&quot;) &#125; &#125;, &#125;)&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot;&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt; d点我&lt;/button&gt; &lt;button @click=&quot;changImg&quot;&gt; d点我&lt;/button&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &quot;#root&quot;, data: &#123; url: &quot;1.png&quot; &#125;, methods: &#123; sayHi() &#123; alert(&quot;hello&quot;) &#125;, changImg() &#123; this.url = &quot;2.png&quot; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-on绑定方法 v-bind 绑定属性 绑定文本 123npm install -g cnpm --registry=https://registry.npm.taobao.org 脚手架 123npm install -g @vue/cli使用vue项目 vue create hello启动服务器 npm run serve 创建vue项目 创建项目 执行:vue create xxxx xxxx是项目名,不要大写和特殊符号 数据双向绑定 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;input v-model=&quot;formData.username&quot;&gt;&lt;br&gt; &lt;input v-model=&quot;formData.password&quot;&gt; &lt;button v-on:click=&quot;subit&quot;&gt;提交&lt;/button&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; number: 0, message: &quot;hello&quot;, formData: &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, &#125; &#125;, methods: &#123; subit() &#123; console.log(this.formData) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 条件和循环 控制切换一个元素是否显示也相当简单： 123456789&lt;div id=&quot;app-3&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;var app3 = new Vue(&#123; el: &#x27;#app-3&#x27;, data: &#123; seen: true &#125;&#125;) 现在你看到我了 继续在控制台输入 app3.seen = false，你会发现之前显示的消息消失了。 1 外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用过渡效果。 还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表： 1234567891011121314151617&lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;var app4 = new Vue(&#123; el: &#x27;#app-4&#x27;, data: &#123; todos: [ &#123; text: &#x27;学习 JavaScript&#x27; &#125;, &#123; text: &#x27;学习 Vue&#x27; &#125;, &#123; text: &#x27;整个牛项目&#x27; &#125; ] &#125;&#125;) 学习 JavaScript 学习 Vue 整个牛项目 在控制台里，输入 app4.todos.push(&#123; text: '新项目' &#125;)，你会发现列表最后添加了一个新项目。 Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。 12345678910&lt;div id=&quot;app-6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app6 = new Vue(&#123; el: &#x27;#app-6&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) 事件修饰符 prevent 阻止默认事件 stop 阻止事件冒泡 once 事只能触发一次 键盘事件 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;欢迎来学习&lt;/h2&gt; &lt;input type=&quot;text&quot; placeholder=&quot;回车后提示输入 &quot; @keyup.enter=&quot;a&quot;&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; a(e) &#123; console.log(e.target.value) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 计算属性computed 1234567conputed&#123;fullname:&#123;get()&#123;//get 当读取fullname时get就会被调用作为返回值&#125;&#125;&#125; 监视 1234567watch: &#123; isHot: &#123; handler() &#123; console.log(&quot;修改了&quot;) &#125; &#125; &#125; 123vm.$watch&#123;&#125; 条件渲染 v-show 12345678&lt;div id=&quot;app&quot;&gt; &lt;h2 v-show=&quot;false&quot;&gt;aaaaa&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27; &#125;)&lt;/script&gt; 1234v-if &lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;11==1&quot;&gt;aaaaa&lt;/h2&gt; &lt;/div&gt; 列表渲染 12345678910111213141516171819202122&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;ui&gt; &lt;li v-for=&quot;person in persons&quot; :key=&quot;person.id&quot;&gt;&#123;&#123;person.name&#125;&#125;-&#123;&#123;person.age&#125;&#125;&lt;/li&gt; &lt;/ui&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; persons: [ &#123; id: &#x27;01&#x27;, name: &#x27;宋宇然&#x27;, age: 17 &#125;, &#123; id: &#x27;02&#x27;, name: &#x27;市政厅&#x27;, age: 19 &#125;, &#123; id: &#x27;03&#x27;, name: &#x27;虞美人&#x27;, age: 15 &#125;, ] &#125; &#125;) &lt;/script&gt; &lt;!-- key要写--&gt; 关于key为什么要写 如果是在这种情况下li里面夹着input，add一个新的列表，会改变input的值，无法同步，这时候key就又存在的必要性了 (99条消息) Vue中key的作用及原理_纸照片的博客-CSDN博客_vue中的key 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(p,index) of filPerons&quot; :key=&quot;index&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.13/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; keyWord: &#x27;&#x27;, persons: [ &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 19, sex: &#x27;女&#x27; &#125;, &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 20, sex: &#x27;女&#x27; &#125;, &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 21, sex: &#x27;男&#x27; &#125;, &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 22, sex: &#x27;男&#x27; &#125; ], filPerons: [] &#125;, watch: &#123; keyWord: &#123; immediate: true, handler(val) &#123; this.filPerons = this.persons.filter((p) =&gt; &#123; return p.name.indexOf(val) !== -1 &#125;) &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; vue更新的问题 1234567updateMei() &#123; // this.persons[0].name = &#x27;马老师&#x27; //奏效 // this.persons[0].age = 50 //奏效 // this.persons[0].sex = &#x27;男&#x27; //奏效 // this.persons[0] = &#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,sex:&#x27;男&#x27;&#125; //不奏效 this.persons.splice(0, 1, &#123; id: &#x27;001&#x27;, name: &#x27;马老师&#x27;, age: 50, sex: &#x27;男&#x27; &#125;)&#125; 1234addSex()&#123; // Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;) this.$set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;)&#125; ​ &lt;!– ​ Vue监视数据的原理： ​ \\1. vue会监视data中所有层次的数据。 ​ \\2. 如何监测对象中的数据？ ​ 通过setter实现监视，且要在new Vue时就传入要监测的数据。 ​ (1).对象中后追加的属性，Vue默认不做响应式处理 ​ (2).如需给后添加的属性做响应式，请使用如下API： ​ Vue.set(target，propertyName/index，value) 或 ​ vm.$set(target，propertyName/index，value) ​ \\3. 如何监测数组中的数据？ ​ 通过包裹数组更新元素的方法实现，本质就是做了两件事： ​ (1).调用原生对应的方法对数组进行更新。 ​ (2).重新解析模板，进而更新页面。 ​ 4.在Vue修改数组中的某个元素一定要用如下方法： ​ 1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse() ​ 2.Vue.set() 或 vm.$set() ​ ​ 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！ ​ --&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!-- 收集表单数据： 若：&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的就是value值。 若：&lt;input type=&quot;radio&quot;/&gt;，则v-model收集的是value值，且要给标签配置value值。 若：&lt;input type=&quot;checkbox&quot;/&gt; 1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值） 2.配置input的value属性: (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值） (2)v-model的初始值是数组，那么收集的的就是value组成的数组 备注：v-model的三个修饰符： lazy：失去焦点再收集数据 number：输入字符串转为有效的数字 trim：输入首尾空格过滤 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;form @submit.prevent=&quot;demo&quot;&gt; 账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt; &lt;br/&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br/&gt;&lt;br/&gt; 年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt; &lt;br/&gt;&lt;br/&gt; 性别： 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt; 女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt; &lt;br/&gt;&lt;br/&gt; 爱好： 学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt; 打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt; 吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt; &lt;br/&gt;&lt;br/&gt; 所属校区 &lt;select v-model=&quot;userInfo.city&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt; &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt; &lt;/select&gt; &lt;br/&gt;&lt;br/&gt; 其他信息： &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受&lt;a href=&quot;http://www.atguigu.com&quot;&gt;《用户协议》&lt;/a&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; userInfo:&#123; account:&#x27;&#x27;, password:&#x27;&#x27;, age:18, sex:&#x27;female&#x27;, hobby:[], city:&#x27;beijing&#x27;, other:&#x27;&#x27;, agree:&#x27;&#x27; &#125; &#125;, methods: &#123; demo()&#123; console.log(JSON.stringify(this.userInfo)) &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; v-text 12345678910111213141516171819202122&lt;body&gt; &lt;!-- 我们学过的指令： v-bind : 单向绑定解析表达式, 可简写为 :xxx v-model : 双向数据绑定 v-for : 遍历数组/对象/字符串 v-on : 绑定事件监听, 可简写为@ v-if : 条件渲染（动态控制节点是否存存在） v-else : 条件渲染（动态控制节点是否存存在） v-show : 条件渲染 (动态控制节点是否展示) v-text指令： 1.作用：向其所在的节点中渲染文本内容。 2.与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。 --&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;div&gt;你好，&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt; &lt;div v-text=&quot;str&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; v-html 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;!-- v-html指令： 1.作用：向指定节点中渲染包含html结构的内容。 2.与插值语法的区别： (1).v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;则不会。 (2).v-html可以识别html结构。 3.严重注意：v-html有安全性问题！！！！ (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。 (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！ --&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;div&gt;你好，&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt; &lt;div v-html=&quot;str2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;尚硅谷&#x27;, str:&#x27;&lt;h3&gt;你好啊！&lt;/h3&gt;&#x27;, str2:&#x27;&lt;a href=javascript:location.href=&quot;http://www.baidu.com?&quot;+document.cookie&gt;兄弟我找到你想要的资源了，快来！&lt;/a&gt;&#x27;, &#125; &#125;)&lt;/script&gt; 以上为旧笔记 vue常用的指令 内容渲染指令（v-html、v-text） 12345678910111213- v-text（类似innerText）- - 使用语法：`&lt;p v-text=&quot;uname&quot;&gt;hello&lt;/p&gt;`，意思是将 uame 值渲染到 p 标签中 - 类似 innerText，使用该语法，会覆盖 p 标签原有内容- v-html（类似 innerHTML）- - 使用语法：`&lt;p v-html=&quot;intro&quot;&gt;hello&lt;/p&gt;`，意思是将 intro 值渲染到 p 标签中 - 类似 innerHTML，使用该语法，会覆盖 p 标签原有内容 - 类似 innerHTML，使用该语法，能够将HTML标签的样式呈现出来。 条件渲染指令（v-show、v-if、v-else、v-else-if） 123456789101. v-show 1. 作用： 控制元素显示隐藏 2. 语法： v-show = &quot;表达式&quot; 表达式值为 true 显示， false 隐藏 3. 原理： 切换 display:none 控制显示隐藏 4. 场景：频繁切换显示隐藏的场景2. v-if 1. 作用： 控制元素显示隐藏（条件渲染） 2. 语法： v-if= &quot;表达式&quot; 表达式值 true显示， false 隐藏 3. 原理： 基于条件判断，是否创建 或 移除元素节点 4. 场景： 要么显示，要么隐藏，不频繁切换的场景 事件绑定指令（v-on） 1234- &lt;button v-on:事件名=&quot;内联语句&quot;&gt;按钮&lt;/button&gt;- &lt;button v-on:事件名=&quot;处理函数&quot;&gt;按钮&lt;/button&gt;- &lt;button v-on:事件名=&quot;处理函数(实参)&quot;&gt;按钮&lt;/button&gt;- `v-on:` 简写为 **@** 属性绑定指令 （v-bind） 1231. **作用：**动态设置html的标签属性 比如：src、url、title2. **语法**：**v-bind:**属性名=“表达式”3. **v-bind:**可以简写成 =&gt; **:** 双向绑定指令（v-model） 12345678910111213所谓双向绑定就是：1. 数据改变后，呈现的页面结果会更新2. 页面结果更新后，数据也会随之而变**作用：** 给**表单元素**（input、radio、select）使用，双向绑定数据，可以快速 **获取** 或 **设置** 表单元素内容**语法：**v-model=&quot;变量&quot;**需求：**使用双向绑定实现以下需求1. 点击登录按钮获取表单中的内容2. 点击重置按钮清空表单中的内容 列表渲染指令（v-for） 1234567891011121314151617181920212223**语法：** key=&quot;唯一值&quot;**作用：**给列表项添加的**唯一标识**。便于Vue进行列表项的**正确排序复用**。**为什么加key：**Vue 的默认行为会尝试原地修改元素（**就地复用**）实例代码：```js&lt;ul&gt; &lt;li v-for=&quot;(item, index) in booksList&quot; :key=&quot;item.id&quot;&gt; &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; item.author &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;del(item.id)&quot;&gt;删除&lt;/button&gt; &lt;/li&gt;&lt;/ul&gt;```注意：1. key 的值只能是字符串 或 数字类型2. key 的值必须具有唯一性3. 推荐使用 id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应） 指令是 vue 开发中最基础、最常用、最简单的知识点。","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"编程/前端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"},{"name":"vue框架","slug":"编程/前端/vue框架","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/vue%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"vue框架","slug":"vue框架","permalink":"https://kaguranotamashii.github.io/tags/vue%E6%A1%86%E6%9E%B6/"}]},{"title":"git出现的问题","slug":"[main]hexo/git出现的问题","date":"2022-04-11T15:22:08.000Z","updated":"2022-07-16T15:37:41.539Z","comments":true,"path":"posts/58072/","link":"","permalink":"https://kaguranotamashii.github.io/posts/58072/","excerpt":"今天学习使用vscode的源代码管理时候同步时出现了fatal: unable to access 'xxxx: Failed to connect to github.com port 443 after 21098 ms: Timed out这个错误。","text":"今天学习使用vscode的源代码管理时候同步时出现了fatal: unable to access 'xxxx: Failed to connect to github.com port 443 after 21098 ms: Timed out这个错误。 提示含义是通过443端口连接github.com错误。 解决办法为 123git config --global --unset http.proxy#删除配置git config --global http.proxy 127.0.0.1:xxxx#根据自己的代理插件设置全局端口git config --local http.proxy 127.0.0.1:xxxx #为某个 git 项目单独设置代理 比如我用某个小猫默认的7080 om/20220411232828.png)","categories":[{"name":"git","slug":"git","permalink":"https://kaguranotamashii.github.io/categories/git/"}],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://kaguranotamashii.github.io/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"name":"git","slug":"git","permalink":"https://kaguranotamashii.github.io/tags/git/"}]},{"title":"Java SE","slug":"[main]CS/[main]computer-language/java基础学习笔记 (2)","date":"2022-02-21T05:47:24.000Z","updated":"2022-07-16T15:37:41.547Z","comments":true,"path":"posts/19402/","link":"","permalink":"https://kaguranotamashii.github.io/posts/19402/","excerpt":"","text":"DOS 12345cd testcopy nul a.txtecho 123&gt;a.txtdel a.txt 变量 constant 常量 1final type barName=valie; 变量的分类 局部变量 成员变量 静态变量 局部变量在方法语句块 成员变量 对象 类内部，方法外面 从属对象 会自动默认初始化 静态变量 类内部 static修饰 从属类 primitive data type 整数 byte 一字节 -127-127 short 2字节 -215-215-1 int 4字节 231-232-1 long 8字节 -2^63 十进制 八进制以0开头 十六进制以0x 0X 二进制0b oB开头 floating point number float四字节 double八字节 字符型 boolean true false 一个字节或者四个字节 运算符 强制转换类 cast （type）var Scanner处理键盘输入 1234567891011121314import java.util.Scanner;public class Scanner1 &#123; public static void main(String[] args) &#123; Scanner s =new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String uname =s.nextLine(); System.out.println(&quot;输入你的年龄&quot;); int age=s.nextInt(); System.out.println(&quot;用户名&quot;+uname); System.out.println(&quot;年龄&quot;+age); &#125;&#125; 控制语句 API string 123456String name=new string(&quot;name&quot;);String name=&quot;name&quot;;char[]value=&#123;&#x27;a&#x27;,&#x27;b,&#x27;c&#125;;String s3=new String(value);byte[]bytes=&#123;97,98,99,100&#125;;String s4=new String(bytes); 统计单词数量 123456789101112131415161718192021222324import java.util.Arrays;import java.util.Scanner;public class HelloWorld &#123; public static void main(String[] args) &#123; String str=&quot;hello world abc hello hello hello hello hello&quot;; System.out.println(); HelloWorld he=new HelloWorld(); int count=he.wordCount(str,&quot;hello&quot;); System.out.println(count);; &#125; public int wordCount(String art,String word)&#123; //1先把文章打散成数组 String[] words = art.split(&quot; &quot;); int res=0; for (int i = 0; i &lt; words.length; i++) &#123; if(words[i].equalsIgnoreCase(word))&#123; res++; &#125; &#125; return res; &#125;&#125; scanner equals 1234if(name.equals(name_1)&amp;&amp;password_1.equals(password))&#123; System.out.println(&quot;成功&quot;); break; &#125; 遍历charAt 123for (int i = 0; i &lt; line.length(); i++) &#123; System.out.println(line.charAt(i)); &#125; stringBuilder的添加和反转 StringBuffer 线程安全效率低 StringBuilder相反 append和reverse 12345678910111213 StringBuilder sb=new StringBuilder(); sb.append(&quot;hello&quot;); sb.append(&quot;java&quot;); System.out.println(sb); sb.reverse(); System.out.println(sb);//hellojava//avajollehstringbuilder转为string string s =sb.tostring（）； string转为stringbuilder StringBuilder sb=new StringBuilder(s); IDEA 1234567891011121314快捷和补全单行ctrl+/多行ctrl+shitft+/CTRL+alt+L格式化快速生成main（）方法 psvm输入语句sout内容辅助CTRL+shifr+space\\自动生成构造器insert+alt查看错误alt+enter看源码ctrl+左键 数组Array 数组必须初始化使用 数组的遍历 1234567[0,length-1] int []a=&#123;2,2,2,2&#125;; Arrays.sort(a); //二分查找索引 System.out.println(Arrays.binarySearch(a,2)); //数组填充 Arrays.fill(a,0,3,55); foe-each 1234567//用于数组或者容器读取public static void main(String[] args)&#123; String []ss=&#123;&quot;12321&quot;,&quot;123&quot;&#125;; for(String temp:ss)&#123; sout(temp); &#125;&#125; arraycopy 1234567891011arraycopy(object,int srcpos,object,int destpos,intlenght)public class string &#123; public static void main(String[] args) &#123; String[] s=&#123;&quot;阿里&quot;,&quot;尚学堂&quot;,&quot;东京&quot;&#125;; String []sBak=new String[4]; System.arraycopy(s,0,sBak,0,s.length); System.out.println(Arrays.toString(sBak)); &#125;&#125; 静态 type name = new type【length】 123int a[] =new int [5];int [] arr =new int [5];int []arr=&#123;551,2,377&#125;; 数组的扩容 12345678910int[] a=&#123;1,2,3&#125;;int[] temp=new int [a.length*2];for (int i = 0; i &lt; a.length; i++) &#123; temp[i]=a[i];&#125;a=temp;a[a.length-2]=11;for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]);&#125; Comparalbe 12 双指针思想 12345678910111213141516171819202122int a[]=&#123;12,231,3421,33,3131,234&#125;;int b[]=&#123;321,31,345,23,54,7676&#125;; while (i&lt;a.length||j&lt;b.length)&#123; if(i==a.length)&#123; c[i+j]=b[j]; j++;continue; &#125; if(j==b.length)&#123; c[i+j]=a[i]; i++;continue; &#125; if(a[i]&gt;b[j])&#123; c[i+j]=b[j]; j++; &#125;else&#123; c[i+j]=a[i]; i++; &#125;&#125; arrayList 集合（超级数组） 123456789101112 ArrayList&lt;String&gt; array =new ArrayList&lt;&gt;(); System.out.println(array); array.add(&quot;hello world&quot;); array.add(&quot;java&quot;);array.add(&quot;java good&quot;); System.out.println(array); array.add(1,&quot;syr&quot;); System.out.println(array); [][hello world, java, java good][hello world, syr, java, java good] arraylist基本常用方法 public boolean remove(obiect o) 删除指定元素 public E remove(int index) 删除索引元素，返回被删元素 public E set(int index,E element) 修改，返回被修改的元素 public E get（int index） 返沪索引元素 public int size（） 返回集合的元素 链表 方法method Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 1234定义 public static type name()&#123; &#125; 方法重载overload 多个方法在一个类 方法具有相同的方法名 返回类型或者数量不同 一个类中定义多个名称相同，但是参数泪飙不同的的方法 123456789101112131415161718192021public class fangfa &#123; public static void main(String[] args) &#123; System.out.println(sum(123,2131)); System.out.println(sum(12.1,23.1)); System.out.println(sum(123,231,32)); &#125; //int add public static int sum(int a,int b)&#123; return a+b; &#125; public static double sum(double a,double b)&#123; return a+b; &#125; public static int sum(int a,int b,int c)&#123; return a+b+c; &#125;&#125;//225435.2386 可变参数 12345public class Text&#123; public int plus(int...nums)&#123; return &#125;&#125; 递归 StackOverflowError 大量占用系统堆栈 包装类和自动拆装箱 1 类和对象（Object Oriented Programing） 类是java基本的组成结构 类的定义 123456public class car&#123; //每个文件必须有一个public class，名字与文件名相同&#125;class tyre&#123;&#125;//可以定义多个classclass engine&#123;&#125;class seat&#123;&#125; 对于一个类来说有三种成员 field属性 成员变量 属性用于定义这个类或者更类对象包含的数据或者静态特征 修饰符 type name=默认 method方法 方法从属于类和对象 修饰符 返回类型 name（）{ 构造方法 构造器 constructor 构造器能用于对象的初始化，而不是创建对象 构造器用new关键字调用 构造器虽然没有返回值，但不能定义返回值类型 如果没有定义构造器，则编译器会自动定义一个无参的构造方法，如果一定义的则编译器不会自动添加 构造器的方法名必须与类名字相同 课堂练习可以生成具有特定坐标的点对象 提供可以计算点到另外一点距离的方法 12345678910111213141516171819package 第五章面向对象.构造器.点;public class Point &#123; double x,y; Point (double _x,double _y)&#123; x=_x;y=_y; &#125; public double getDistance(Point p)&#123; return Math.sqrt((x-p.x)*(y-p.y)+(y-p.y)*(y-p.y)); &#125; public static void main(String[] args) &#123; Point p1=new Point(3.0,4.0); Point origin =new Point(0.0,0.0); System.out.println(p1.getDistance(origin)); &#125;&#125; 构造方法的重载 jvm虚拟机 栈的特点 堆的特点 Garbage Collection垃圾回收机制 垃圾回收过程 发现无用的对象 回收无用对象占用内存空间 无用对象为没有任何引用 算法 1引用计数法 通用的分代垃圾回收机制 内存泄漏 创建大量的无用对象 1234string str=&quot;&quot;;for(int i=0;i&lt;11000:i++)&#123;str+=i;//相当于产生了11000个string对象&#125; 静态集合类的使用 hassomap vector list等这些最容易出现，这些静态变量的生命周期 各种连接对象 监听器使用不当 可以用system.gc()但是只是通知jvm object可以用finalize方法，是java给程序员的 this关键词 就是当前对象的地址 this用法 普通方法中 this总是指向调用该方法的对象 构造方法中，this总是指向正要初始化的对象 static 静态初始化块 构造方法用于对象的普通属性的初始化 静态初始快中，用于初始化类，初始化静态属性 静态初始化快中不能直接访问非static成员 变量分类 包机制package import 相当于文件夹对文件的作用，用于管理类，解决类的重名问题 面向对象三大特征 继承extends 代码复用，方便建模 1234567891011121314151617181920212223242526272829package 第五章面向对象.extends1;public class text &#123; public static void main(String[] args) &#123; Student s1 =new Student(&quot;songyuran&quot;,11,&quot;CS&quot;); s1.xuexi(); &#125;&#125;class Persin&#123; String name; int height; public void rest()&#123; System.out.println(&quot;xiuxi&quot;); &#125;&#125;class Student extends Persin&#123; String major; public void xuexi()&#123; System.out.println(&quot;xuexi&quot;); rest(); System.out.println(this.name); &#125; public Student(String name,int height,String major)&#123; this.name=name; this.height=height; this.major=major; &#125;&#125; instanceof判断类型 12s1 instanceof Person//trues1 instanceof Student//true 父类 又叫超类 基类 子类：派生类 接口有多继承 方法重写override 子类重写父亲的方法，替换父类行为，重写是实现多态的必要条件 == 方法名字 形参列表 《=返回值类型和声明异常类型，子类小于等于父类 》=子类大于父类 final关键词 修饰变量 修饰方法 不可被子类重写，但是可以重载，final class a{} 修饰类 不可被继承 组合 组合比较灵活，继承只能有一个父类，组合可以有多个属性 封装 三大特征之一 提高安全 复用 高内聚低耦合 封装的实现关键词访问限制修饰符 1234567891011package text.b;public class Test &#123; public static void main(String[] args) &#123; User u=new User(99,&quot;宋宇然&quot;,true); System.out.println(u.getId()); System.out.println(u.getName()); System.out.println(u.isMan()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package text.b;public class User &#123; private int id; private String name; private boolean man; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isMan() &#123; return man; &#125; public void setMan(boolean man) &#123; this.man = man; &#125; public void printUserInfo()&#123; System.out.println(id); System.out.println(man); System.out.println(name); &#125; public User(int id, String name, boolean man) &#123; this.id = id; this.name = name; this.man = man; &#125;&#125; 多态polymorphism 同一种方法调用 不同对象行为完全不同 123456789101112131415161718public class Animal&#123; public void shout()&#123; System.out.println(&quot;叫了一声&quot;); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println(&quot;wangwang&quot;); &#125; public void seeDoor()&#123; System.out.println(&quot;see door&quot;); &#125;&#125;class Cat extends Animal&#123; public void shout()&#123; System.out.println(&quot;miaomiao&quot;); &#125;&#125; 123456789public class TestPolym&#123; public static void main(String[] args)&#123; animaCry(new DOg()); animalCry(new Cat()); &#125; static void animalCry(Animal a)&#123; a.shout(); &#125;&#125; 对象的转型casting 父类引用指向子类叫向上转型，属于自动 反之 123456789101112public class TestPolym&#123; public static void main(String[] args)&#123; Animal animal=new Dog(); animal.shout(); //不能运行animal.seeDoor();需要强制转换 Dog d =(Dog)animal; d.seeDoor(); &#125; static void animalCry(Animal a)&#123; a.shout(); &#125;&#125; Object类 所有类是Object的子类 hashCode 1 toString返回地址 1234567891011121314public class tosting &#123; String name; String pwd; @Override public String toString() &#123; return &quot;用户名&quot;+name+&quot;密码&quot;+pwd; &#125; public static void main(String[] args)&#123; tosting to=new tosting(); System.out.println(to.toString()); &#125;&#125; equals和== ==代表对方是否相同，type和地址 equals()比较内容相同 equals()默认比较两个对象的hashcode 可以重写equals 重写equals() 1234567891011121314151617181920212223public class TestObject extends Object&#123; int id; String name; String pwd; public TestObject(int id,String name,String pwd)&#123; this.name=name; this.pwd=pwd; this.id=id; &#125; @Override public boolean equals(Object o)&#123; if(this==o)return true; if(o==null||getclass()!=o.getClass())return false; return id==that.id; &#125; public String toString()&#123;return &quot;用户名:&quot; +name+&quot;密码:&quot;+pwd;&#125; public static void main(String[] args)&#123; TestObject t= new TestObject(1001,&quot;zhangshan,&quot;123456); TestObject t2=new TestObject(1001,&quot;zhangwu,&quot;123123123); System.out.println(t.equals(t2)); &#125;&#125; super super可以看作直接父类对象的引用 在一个类中，若是构造方法第一行没有第哦啊用super或者this java默认调用 在子类的方法中，访问父类的成员变量 在子类的成语方法中，访问父亲的成员方法 在子类的构造方法中访问父类的构造方法 12public class test 抽象类和接口 抽象方法和抽象类 抽象方法 **** 使用abstract修饰方法 没有方法体 只有声明 定义是一种规范 就是告诉子类必须要给抽象方法具体实现 抽象类 包含抽象方法的类叫抽象类 通过抽象类可以严格限制子类的设计，使得子类之间梗通用 接口interface 是一组规范，所以类要遵守 1 内部类 inner 123456public class Outer&#123; private int age=19; public void show&#123; System.out.println(&quot;ss&quot;); &#125;&#125; l类 包装类 字符串类 时间处理相关类 其他类 基本数据类型 wrapper class 12Integer i=Integer.valueOf(100);//java9推荐用法Integer j=new Integer(100);//不推荐 异常 error 程序无法处理错误比较严重 异常2声明异常 throws子句 正则表则语法规则 内容限定 123456789101112String regex=&quot;[a]&quot;; String regex1=&quot;[a-z]&quot;; String regex2=&quot;[a-zA-Z0-9]&quot;; //取反 String regex3=&quot;^ab&quot;; String content=&quot;a&quot;; String content1=&quot;A&quot;; String content2=&quot;c&quot;; System.out.println(content.matches(regex1));//true System.out.println(content1.matches(regex1));//false System.out.println(content1.matches(regex2));//true System.out.println(content2.matches(regex3));//true 长度限定 12345//正则中通过&#123;&#125;表示长度//[a-z]&#123;5&#125;表示小写a-z而且长度必须为5//[a-z]&#123;5，8&#125;表示小写a-z而且长度必须为5到8包括5，8//[a-z]&#123;2,&#125;表示小写a-z而且长度最小长为2//[a-z]&#123;5&#125;表示小写a-z而且长度必须为5 长度限定符号 123?&#123;0,1&#125;+&#123;1,&#125;*&#123;0,&#125; 预定义字符 1 正则表达式中组合定义 12345//电话号码的正则\\\\d&#123;3,4&#125;-//必须字母开头 最少4最长8[a-z]&#123;1&#125;\\\\w&#123;3,8&#125;//电话号码的正则\\\\d&#123;3,4&#125;- 集合 stack 先进后出 � stack 先进后出","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"java","slug":"编程/java","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://kaguranotamashii.github.io/tags/java/"}]},{"title":"日常分享","slug":"[main]summary/日常分享","date":"2022-02-16T12:35:32.000Z","updated":"2022-07-17T15:49:22.385Z","comments":true,"path":"posts/54547/","link":"","permalink":"https://kaguranotamashii.github.io/posts/54547/","excerpt":"","text":"虽然说折磨黑苹果是快乐的事情，但是你选择了淘宝120元的服务。说实话，我这台黑苹果 是一体机戴尔optiplex5260，我高中的时候也试过很多个EFI，也没有成功，无奈选择了淘宝的黑苹果服务，师傅花了三四小时换EFI，最后终于弄成半完美。 123456戴尔optiplex5260i58500uhd630三星DDR4 2666hz目前还有麦克风不能用，耳机只能用蓝牙以外都没有太大的问题了，xcode完美使用 链接：https://pan.baidu.com/s/1ofmjPTdfuhRmyOi2owbIyw 提取码：yhc1 在mac上敲代码和win的体检不太一样，mac的idea多了些功能比如说符号。 xcode是纯英文，使用起来有些困难。 02202162117482.png)","categories":[{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/categories/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://kaguranotamashii.github.io/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"}]},{"title":"数据库与java","slug":"[main]CS/[main]web/jdbc","date":"2022-02-15T12:41:35.000Z","updated":"2023-10-03T06:15:41.164Z","comments":true,"path":"posts/136435067/","link":"","permalink":"https://kaguranotamashii.github.io/posts/136435067/","excerpt":"","text":"Java与数据库 通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。 初识JDBC JDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。 我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。 准备工作 那么我们首先来进行一些准备工作，以便开始JDBC的学习： 将idea连接到我们的数据库，以便以后调试。 将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0） 向Jetbrians申请一个学生/教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。 教育授权申请地址：https://www.jetbrains.com/shop/eform/students 一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为jar，我们只需要导入这个jar作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。 使用JDBC连接数据库 **注意：**6.0版本以上，不用手动加载驱动，我们直接使用即可！ 1234567891011121314//1. 通过DriverManager来获得数据库连接try (Connection connection = DriverManager.getConnection(&quot;连接URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); //2. 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement())&#123; //注意前两步都放在try()中，因为在最后需要释放资源！ //3. 执行SQL语句，并得到结果集 ResultSet set = statement.executeQuery(&quot;select * from 表名&quot;); //4. 查看结果 while (set.next())&#123; ... &#125;&#125;catch (SQLException e)&#123; e.printStackTrace();&#125;//5. 释放资源，try-with-resource语法会自动帮助我们close 其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序） 了解DriverManager 我们首先来了解一下DriverManager是什么东西，它其实就是管理我们的数据库驱动的： 123456789101112131415public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(&quot;registerDriver: &quot; + driver);&#125; 我们可以通过调用getConnection()来进行数据库的链接： 1234567891011121314@CallerSensitivepublic static Connection getConnection(String url, String user, String password) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); if (user != null) &#123; info.put(&quot;user&quot;, user); &#125; if (password != null) &#123; info.put(&quot;password&quot;, password); &#125; return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现&#125; 我们可以手动为驱动管理器添加一个日志打印： 123static &#123; DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出&#125; 现在我们执行的数据库操作日志会在控制台实时打印。 了解Connection Connection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句： 1Statement createStatement() throws SQLException; 我们发现除了普通的Statement，还存在PreparedStatement： 12PreparedStatement prepareStatement(String sql) throws SQLException; 在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。 它还支持事务的处理，也放到后面来详细进行讲解。 了解Statement 我们发现，我们之前使用了executeQuery()方法来执行select语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！ Statement除了执行这样的DQL语句外，我们还可以使用executeUpdate()方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。 也可以通过excute()来执行任意的SQL语句，它会返回一个boolean来表示执行结果是一个ResultSet还是一个int，我们可以通过使用getResultSet()或是getUpdateCount()来获取。 执行DML操作 我们通过几个例子来向数据库中插入数据。 执行DQL操作 执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据： 1234//首先要明确，select返回的数据类似于一个excel表格while (set.next())&#123; //每调用一次next()就会向下移动一行，首次调用会移动到第一行&#125; 我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。 执行批处理操作 当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。 123456789101112public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(); Statement statement = connection.createStatement())&#123; statement.addBatch(&quot;insert into user values (&#x27;f&#x27;, 1234)&quot;); statement.addBatch(&quot;insert into user values (&#x27;e&#x27;, 1234)&quot;); //添加每一条批处理语句 statement.executeBatch(); //一起执行 &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 将查询结果映射为对象 既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类： 123456789101112131415public class Student &#123; Integer sid; String name; String sex; public Student(Integer sid, String name, String sex) &#123; this.sid = sid; this.name = name; this.sex = sex; &#125; public void say()&#123; System.out.println(&quot;我叫：&quot;+name+&quot;，学号为：&quot;+sid+&quot;，我的性别是：&quot;+sex); &#125;&#125; 现在我们来进行一个转换： 1234while (set.next())&#123; Student student = new Student(set.getInt(1), set.getString(2), set.getString(3)); student.say();&#125; **注意：**列的下标是从1开始的。 我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射： 12345678910111213141516private static &lt;T&gt; T convert(ResultSet set, Class&lt;T&gt; clazz)&#123; try &#123; Constructor&lt;T&gt; constructor = clazz.getConstructor(clazz.getConstructors()[0].getParameterTypes()); //默认获取第一个构造方法 Class&lt;?&gt;[] param = constructor.getParameterTypes(); //获取参数列表 Object[] object = new Object[param.length]; //存放参数 for (int i = 0; i &lt; param.length; i++) &#123; //是从1开始的 object[i] = set.getObject(i+1); if(object[i].getClass() != param[i]) throw new SQLException(&quot;错误的类型转换：&quot;+object[i].getClass()+&quot; -&gt; &quot;+param[i]); &#125; return constructor.newInstance(object); &#125; catch (ReflectiveOperationException | SQLException e) &#123; e.printStackTrace(); return null; &#125;&#125; 现在我们就可以通过我们的方法来将查询结果转换为一个对象了： 1234while (set.next())&#123; Student student = convert(set, Student.class); if(student != null) student.say();&#125; 实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。 实现登陆与SQL注入攻击 在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写： 1234567891011try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement(); Scanner scanner = new Scanner(System.in))&#123; ResultSet res = statement.executeQuery(&quot;select * from user where username=&#x27;&quot;+scanner.nextLine()+&quot;&#x27;and pwd=&#x27;&quot;+scanner.nextLine()+&quot;&#x27;;&quot;); while (res.next())&#123; String username = res.getString(1); System.out.println(username+&quot; 登陆成功！&quot;); &#125;&#125;catch (SQLException e)&#123; e.printStackTrace();&#125; 用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢： 123Test1111&#x27; or 1=1; -- # Test 登陆成功！ 1=1一定是true，那么我们原本的SQL语句会变为： 1select * from user where username=&#x27;Test&#x27; and pwd=&#x27;1111&#x27; or 1=1; -- &#x27; 我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。 使用PreparedStatement 我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决： 1234567891011121314151617public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); PreparedStatement statement = connection.prepareStatement(&quot;select * from user where username= ? and pwd=?;&quot;); Scanner scanner = new Scanner(System.in))&#123; statement.setString(1, scanner.nextLine()); statement.setString(2, scanner.nextLine()); System.out.println(statement); //打印查看一下最终执行的 ResultSet res = statement.executeQuery(); while (res.next())&#123; String username = res.getString(1); System.out.println(username+&quot; 登陆成功！&quot;); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用?作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么： 1com.mysql.cj.jdbc.ClientPreparedStatement: select * from user where username= &#x27;Test&#x27; and pwd=&#x27;123456&#x27;&#x27; or 1=1; -- &#x27;; 我们发现，我们输入的参数一旦出现'时，会被变为转义形式\\'，而最外层有一个真正的'来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！ 管理事务 JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false) 方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。 12345con.setAutoCommit(); //关闭自动提交后相当于开启事务。// SQL语句// SQL语句// SQL语句con.commit();或 con.rollback(); 一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行commit()来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用rollback()来手动回滚之前的全部操作！ 1234567891011121314public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement())&#123; connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;); statement.executeUpdate(&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;); statement.executeUpdate(&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;); connection.commit(); //如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效 &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 我们来接着尝试一下使用回滚操作： 123456789101112131415161718public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement())&#123; connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;); statement.executeUpdate(&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;); connection.rollback(); //回滚，撤销前面全部操作 statement.executeUpdate(&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;); connection.commit(); //提交事务（注意，回滚之前的内容都没了） &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 同样的，我们也可以去创建一个回滚点来实现定点回滚： 1234567891011121314151617181920public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement())&#123; connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;); Savepoint savepoint = connection.setSavepoint(); //创建回滚点 statement.executeUpdate(&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;); connection.rollback(savepoint); //回滚到回滚点，撤销前面全部操作 statement.executeUpdate(&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;); connection.commit(); //提交事务（注意，回滚之前的内容都没了） &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去： 123456789101112public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement())&#123; connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;); connection.setAutoCommit(true); //重新开启自动提交，开启时把之前的事务模式下的内容给提交了 statement.executeUpdate(&quot;insert into user values (&#x27;d&#x27;, 1234)&quot;); //没有commit也成功了！ &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; 通过学习JDBC，我们现在就可以通过Java来访问和操作我们的数据库了！为了更好地衔接，我们还会接着讲解主流持久层框架——Mybatis，加深JDBC的记忆。 使用Lombok 我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！ 通过使用Lombok（小辣椒）就可以解决这样的问题！ 我们来看看，使用原生方式和小辣椒方式编写类的区别，首先是传统方式： 1234567891011121314151617181920212223242526272829303132333435public class Student &#123; private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) &#123; this.sid = sid; this.name = name; this.sex = sex; &#125; public Integer getSid() &#123; //长！ return sid; &#125; public void setSid(Integer sid) &#123; //到！ this.sid = sid; &#125; public String getName() &#123; //爆！ return name; &#125; public void setName(String name) &#123; //炸！ this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 而使用Lombok之后： 12345678@Getter@Setter@AllArgsConstructorpublic class Student &#123; private Integer sid; private String name; private String sex;&#125; 我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！ 配置Lombok 首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download 然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。 重启IDEA Lombok是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理。 Java的编译过程可以分成三个阶段： 所有源文件会被解析成语法树。 调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。 最后，语法树会被分析并转化成类文件。 实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。 使用Lombok 我们通过实战来演示一下Lombok的实用注解： 我们通过添加 1@Getter 和 1@Setter 来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。 我们还可以使用@Accessors来控制生成Getter和Setter的样式。 我们通过添加@ToString来为当前类生成预设的toString方法。 我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。 我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。 我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。 使用 1@Data 能代表 1@Setter 、 1@Getter 、 1@RequiredArgsConstructor 、 1@ToString 、 1@EqualsAndHashCode 全部注解。 一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。 使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。 使用@SneakyThrows来自动生成try-catch代码块。 使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换） 使用 1@Builder 来快速生成建造者模式。 通过使用@Builder.Default来指定默认值。 通过使用@Builder.ObtainVia来指定默认值的获取方式。 认识Mybatis 在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。 **再次强调：**学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 我们依然使用传统的jar依赖方式，从最原始开始讲起，不使用Maven，有关Maven内容我们会在后面统一讲解！全程围绕官方文档讲解！ 这一块内容很多很杂，再次强调要多实践！ XML语言概述 在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;outer&gt; &lt;name&gt;阿伟&lt;/name&gt; &lt;desc&gt;怎么又在玩电动啊&lt;/desc&gt; &lt;inner type=&quot;1&quot;&gt; &lt;age&gt;10&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/inner&gt;&lt;/outer&gt; 如果你学习过前端知识，你会发现它和HTML几乎长得一模一样！但是请注意，虽然它们长得差不多，但是他们的意义却不同，HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。 一个XML文件存在以下的格式规范： 必须存在一个根节点，将所有的子标签全部包含。 可以但不必须包含一个头部声明（主要是可以设定编码格式） 所有的标签必须成对出现，可以嵌套但不能交叉嵌套 区分大小写。 标签中可以存在属性，比如上面的type=&quot;1&quot;就是inner标签的一个属性，属性的值由单引号或双引号包括。 XML文件也可以使用注释： 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!-- 注释内容 --&gt; 通过IDEA我们可以使用Ctrl+/来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件） 那如果我们的内容中出现了&lt;或是&gt;字符，那该怎么办呢？我们就可以使用XML的转义字符来代替： 如果嫌一个一个改太麻烦，也可以使用CD来快速创建不解析区域： 123&lt;test&gt; &lt;name&gt;&lt;![CDATA[我看你&lt;&gt;&lt;&gt;&lt;&gt;是一点都不懂哦&gt;&gt;&gt;]]&gt;&lt;/name&gt;&lt;/test&gt; 那么，我们现在了解了XML文件的定义，现在该如何去解析一个XML文件呢？比如我们希望将定义好的XML文件读取到Java程序中，这时该怎么做呢？ JDK为我们内置了一个叫做org.w3c的XML解析库，我们来看看如何使用它来进行XML文件内容解析： 12345678910111213141516171819202122// 创建DocumentBuilderFactory对象DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();// 创建DocumentBuilder对象try &#123; DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(&quot;file:mappers/test.xml&quot;); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(&quot;test&quot;); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 //节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i &lt; childNodes.getLength(); i++) &#123; Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + &quot;：&quot; +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点） &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的） 不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！ 初次使用Mybatis 那么我们首先来感受一下Mybatis给我们带来的便捷，就从搭建环境开始，中文文档网站：https://mybatis.org/mybatis-3/zh/configuration.html 我们需要导入Mybatis的依赖，Jar包需要在github上下载，如果卡得一匹，连不上可以在视频简介处从分享的文件中获取。同样地放入到项目的根目录下，右键作为依赖即可！（依赖变多之后，我们可以将其放到一个单独的文件夹，不然会很繁杂） 依赖导入完成后，我们就可以编写Mybatis的配置文件了（现在不是在Java代码中配置了，而是通过一个XML文件去配置，这样就使得硬编码的部分大大减少，项目后期打包成Jar运行不方便修复，但是通过配置文件，我们随时都可以去修改，就变得很方便了，同时代码量也大幅度减少，配置文件填写完成后，我们只需要关心项目的业务逻辑而不是如何去读取配置文件）我们按照官方文档给定的提示，在项目根目录下新建名为mybatis-config.xml的文件，并填写以下内容： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;驱动类（含包名）&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;数据库连接URL&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;用户名&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;密码&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容） 通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了（也可以不使用配置文件，这里不做讲解，还请各位小伙伴自行阅读官方文档） 配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个SqlSessionFactory对象： 123456public static void main(String[] args) throws FileNotFoundException &#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(&quot;mybatis-config.xml&quot;)); try (SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; //暂时还没有业务 &#125;&#125; 直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！那么现在我们来看看，SqlSessionFactory对象是什么东西： 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话，SqlSession对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的Statement对象，会话之间相互隔离，没有任何关联。 而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。 我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段，在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。首先编写实体类，，直接使用Lombok是不是就很方便了： 12345678import lombok.Data;@Datapublic class Student &#123; int sid; //名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失 String name; String sex;&#125; 在根目录下重新创建一个mapper文件夹，新建名为TestMapper.xml的文件作为我们的映射器，并填写以下内容： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;TestMapper&quot;&gt; &lt;select id=&quot;selectStudent&quot; resultType=&quot;com.test.entity.Student&quot;&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为Student类，然后就在标签中写入我们的查询语句即可。 编写好后，我们在配置文件中添加这个Mapper映射器： 1234&lt;mappers&gt; &lt;mapper url=&quot;file:mappers/TestMapper.xml&quot;/&gt; &lt;!-- 这里用的是url，也可以使用其他类型，我们会在后面讲解 --&gt;&lt;/mappers&gt; 最后在程序中使用我们定义好的Mapper即可： 1234567public static void main(String[] args) throws FileNotFoundException &#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(&quot;mybatis-config.xml&quot;)); try (SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; List&lt;Student&gt; student = sqlSession.selectList(&quot;selectStudent&quot;); student.forEach(System.out::println); &#125;&#125; 我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！ 配置Mybatis 在了解了Mybatis为我们带来的便捷之后，现在我们就可以正式地去学习使用Mybatis了！ 由于SqlSessionFactory一般只需要创建一次，因此我们可以创建一个工具类来集中创建SqlSession，这样会更加方便一些： 123456789101112131415161718192021public class MybatisUtil &#123; //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(&quot;mybatis-config.xml&quot;)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit)&#123; return sqlSessionFactory.openSession(autoCommit); &#125;&#125; 现在我们只需要在main方法中这样写即可查询结果了： 123456public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; List&lt;Student&gt; student = sqlSession.selectList(&quot;selectStudent&quot;); student.forEach(System.out::println); &#125;&#125; 之前我们演示了，如何创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过SqlSession来执行对应的方法，能不能再方便一点呢？ 现在，我们可以通过namespace来绑定到一个接口上，利用接口的特性，我们可以直接指明方法的行为，而实际实现则是由Mybatis来完成。 123public interface TestMapper &#123; List&lt;Student&gt; selectStudent();&#125; 将Mapper文件的命名空间修改为我们的接口，建议同时将其放到同名包中，作为内部资源： 12345&lt;mapper namespace=&quot;com.test.mapper.TestMapper&quot;&gt; &lt;select id=&quot;selectStudent&quot; resultType=&quot;com.test.entity.Student&quot;&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 作为内部资源后，我们需要修改一下配置文件中的mapper定义，不使用url而是resource表示是Jar内部的文件： 123&lt;mappers&gt; &lt;mapper resource=&quot;com/test/mapper/TestMapper.xml&quot;/&gt;&lt;/mappers&gt; 现在我们就可以直接通过SqlSession获取对应的实现类，通过接口中定义的行为来直接获取结果： 1234567public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); List&lt;Student&gt; student = testMapper.selectStudent(); student.forEach(System.out::println); &#125;&#125; 那么肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？我们可以通过调用getClass()方法来看看实现类是个什么： 12TestMapper testMapper = sqlSession.getMapper(TestMapper.class);System.out.println(testMapper.getClass()); 我们发现，实现类名称很奇怪，名称为com.sun.proxy.$Proxy4，它是通过动态代理生成的，相当于动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。 接下来，我们再来看配置文件，之前我们并没有对配置文件进行一个详细的介绍： 12345678910111213141516&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/study&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;test&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/test/mapper/TestMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 首先就从environments标签说起，一般情况下，我们在开发中，都需要指定一个数据库的配置信息，包含连接URL、用户、密码等信息，而environment就是用于进行这些配置的！实际情况下可能会不止有一个数据库连接信息，比如开发过程中我们一般会使用本地的数据库，而如果需要将项目上传到服务器或是防止其他人的电脑上运行时，我们可能就需要配置另一个数据库的信息，因此，我们可以提前定义好所有的数据库信息，该什么时候用什么即可！ 在environments标签上有一个default属性，来指定默认的环境，当然如果我们希望使用其他环境，可以修改这个默认环境，也可以在创建工厂时选择环境： 12sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(&quot;mybatis-config.xml&quot;), &quot;环境ID&quot;); 我们还可以给类型起一个别名，以简化Mapper的编写： 1234&lt;!-- 需要在environments的上方 --&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.test.entity.Student&quot; alias=&quot;Student&quot;/&gt;&lt;/typeAliases&gt; 现在Mapper就可以直接使用别名了： 12345&lt;mapper namespace=&quot;com.test.mapper.TestMapper&quot;&gt; &lt;select id=&quot;selectStudent&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 如果这样还是很麻烦，我们也可以直接让Mybatis去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名） 123&lt;typeAliases&gt; &lt;package name=&quot;com.test.entity&quot;/&gt;&lt;/typeAliases&gt; 也可以为指定实体类添加一个注解，来指定别名： 1234567@Data@Alias(&quot;lbwnb&quot;)public class Student &#123; private int sid; private String name; private String sex;&#125; 当然，Mybatis也包含许多的基础配置，通过使用： 123&lt;settings&gt; &lt;setting name=&quot;&quot; value=&quot;&quot;/&gt;&lt;/settings&gt; 所有的配置项可以在中文文档处查询，本文不会进行详细介绍，在后面我们会提出一些比较重要的配置项。 有关配置文件的介绍就暂时到这里为止，我们讨论的重心应该是Mybatis的应用，而不是配置文件，所以省略了一部分内容的讲解。 增删改查 在了解了Mybatis的一些基本配置之后，我们就可以正式来使用Mybatis来进行数据库操作了！ 在前面我们演示了如何快速进行查询，我们只需要编写一个对应的映射器既可以了： 12345&lt;mapper namespace=&quot;com.test.mapper.TestMapper&quot;&gt; &lt;select id=&quot;studentList&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 当然，如果你不喜欢使用实体类，那么这些属性还可以被映射到一个Map上： 123456&lt;select id=&quot;selectStudent&quot; resultType=&quot;Map&quot;&gt; select * from student&lt;/select&gt;public interface TestMapper &#123; List&lt;Map&gt; selectStudent();&#125; Map中就会以键值对的形式来存放这些结果了。 通过设定一个resultType属性，让Mybatis知道查询结果需要映射为哪个实体类，要求字段名称保持一致。那么如果我们不希望按照这样的规则来映射呢？我们可以自定义resultMap来设定映射规则： 12345&lt;resultMap id=&quot;Test&quot; type=&quot;Student&quot;&gt; &lt;result column=&quot;sid&quot; property=&quot;sid&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;sex&quot;/&gt;&lt;/resultMap&gt; 通过指定映射规则，我们现在名称和性别一栏就发生了交换，因为我们将其映射字段进行了交换。 如果一个类中存在多个构造方法，那么很有可能会出现这样的错误： 123456789### Exception in thread &quot;main&quot; org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]### The error may exist in com/test/mapper/TestMapper.xml### The error may involve com.test.mapper.TestMapper.getStudentBySid### The error occurred while handling results### SQL: select * from student where sid = ?### Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) ... 这时就需要使用constructor标签来指定构造方法： 123456&lt;resultMap id=&quot;test&quot; type=&quot;Student&quot;&gt; &lt;constructor&gt; &lt;arg column=&quot;sid&quot; javaType=&quot;Integer&quot;/&gt; &lt;arg column=&quot;name&quot; javaType=&quot;String&quot;/&gt; &lt;/constructor&gt;&lt;/resultMap&gt; 值得注意的是，指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值，有关resultMap的内容，后面还会继续讲解。 如果数据库中存在一个带下划线的字段，我们可以通过设置让其映射为以驼峰命名的字段，比如my_test映射为myTest 123&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 如果不设置，默认为不开启，也就是默认需要名称保持一致。 我们接着来看看条件查询，既然是条件查询，那么肯定需要我们传入查询条件，比如现在我们想通过sid字段来通过学号查找信息： 1234Student getStudentBySid(int sid);&lt;select id=&quot;getStudentBySid&quot; parameterType=&quot;int&quot; resultType=&quot;Student&quot;&gt; select * from student where sid = #&#123;sid&#125;&lt;/select&gt; 我们通过使用#&#123;xxx&#125;或是$&#123;xxx&#125;来填入我们给定的属性，实际上Mybatis本质也是通过PreparedStatement首先进行一次预编译，有效地防止SQL注入问题，但是如果使用$&#123;xxx&#125;就不再是通过预编译，而是直接传值，因此我们一般都使用#&#123;xxx&#125;来进行操作。 使用parameterType属性来指定参数类型（非必须，可以不用，推荐不用） 接着我们来看插入、更新和删除操作，其实与查询操作差不多，不过需要使用对应的标签，比如插入操作： 1234&lt;insert id=&quot;addStudent&quot; parameterType=&quot;Student&quot;&gt; insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)&lt;/insert&gt;int addStudent(Student student); 我们这里使用的是一个实体类，我们可以直接使用实体类里面对应属性替换到SQL语句中，只需要填写属性名称即可，和条件查询是一样的。 复杂查询 一个老师可以教授多个学生，那么能否一次性将老师的学生全部映射给此老师的对象呢，比如： 123456@Datapublic class Teacher &#123; int tid; String name; List&lt;Student&gt; studentList;&#125; 映射为Teacher对象时，同时将其教授的所有学生一并映射为List列表，显然这是一种一对多的查询，那么这时就需要进行复杂查询了。而我们之前编写的都非常简单，直接就能完成映射，因此我们现在需要使用resultMap来自定义映射规则： 1234567891011121314&lt;select id=&quot;getTeacherByTid&quot; resultMap=&quot;asTeacher&quot;&gt; select *, teacher.name as tname from student inner join teach on student.sid = teach.sid inner join teacher on teach.tid = teacher.tid where teach.tid = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;asTeacher&quot; type=&quot;Teacher&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;studentList&quot; ofType=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 可以看到，我们的查询结果是一个多表联查的结果，而联查的数据就是我们需要映射的数据（比如这里是一个老师有N个学生，联查的结果也是这一个老师对应N个学生的N条记录），其中id标签用于在多条记录中辨别是否为同一个对象的数据，比如上面的查询语句得到的结果中，tid这一行始终为1，因此所有的记录都应该是tid=1的教师的数据，而不应该变为多个教师的数据，如果不加id进行约束，那么会被识别成多个教师的数据！ 通过使用collection来表示将得到的所有结果合并为一个集合，比如上面的数据中每个学生都有单独的一条记录，因此tid相同的全部学生的记录就可以最后合并为一个List，得到最终的映射结果，当然，为了区分，最好也设置一个id，只不过这个例子中可以当做普通的result使用。 了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在Student新增了一个Teacher对象，那么现在又该如何去处理呢？ 1234567891011121314@Data@Accessors(chain = true)public class Student &#123; private int sid; private String name; private String sex; private Teacher teacher;&#125;@Datapublic class Teacher &#123; int tid; String name;&#125; 现在我们希望的是，每次查询到一个Student对象时都带上它的老师，同样的，我们也可以使用resultMap来实现（先修改一下老师的类定义，不然会很麻烦）： 12345678910111213&lt;resultMap id=&quot;test2&quot; type=&quot;Student&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;sid&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectStudent&quot; resultMap=&quot;test2&quot;&gt; select *, teacher.name as tname from student left join teach on student.sid = teach.sid left join teacher on teach.tid = teacher.tid&lt;/select&gt; 通过使用association进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。 事务操作 我们可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多： 123456789public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(false))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(&quot;男&quot;).setName(&quot;小王&quot;)); testMapper.selectStudent().forEach(System.out::println); &#125;&#125; 我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的，现在我们来试一下在最后提交事务： 1sqlSession.commit(); 在事务提交后，我们的内容才会被写入到数据库中。现在我们来试试看回滚操作： 123456789try (SqlSession sqlSession = MybatisUtil.getSession(false))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(&quot;男&quot;).setName(&quot;小王&quot;)); testMapper.selectStudent().forEach(System.out::println); sqlSession.rollback(); sqlSession.commit();&#125; 回滚操作也印证成功。 动态SQL 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 我们直接使用官网的例子进行讲解。 缓存机制 MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。 因此Mybatis内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。 Mybatis存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码： 12345678public static void main(String[] args) throws InterruptedException &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); &#125;&#125; 我们发现，两次得到的是同一个Student对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类： 123456789101112@Data@Accessors(chain = true)public class Student &#123; public Student()&#123; System.out.println(&quot;我被构造了&quot;); &#125; private int sid; private String name; private String sex;&#125; 我们通过前面的学习得知Mybatis在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。 结果显而易见，只创建了一次，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为第一次的结果已经被缓存了。 那么如果我修改了数据库中的内容，缓存还会生效吗： 123456789public static void main(String[] args) throws InterruptedException &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); testMapper.addStudent(new Student().setName(&quot;小李&quot;).setSex(&quot;男&quot;)); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); &#125;&#125; 我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。 也就是说，一级缓存，在进行DML操作后，会使得缓存失效，也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。 1234567891011121314public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true))&#123; TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); &#125; Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); &#125;&#125; **注意：**一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！ 一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加： 1&lt;cache/&gt; 可见二级缓存是Mapper级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置： 12345&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 我们来编写一个代码： 12345678910111213public static void main(String[] args) &#123; Student student; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); student = testMapper.getStudentBySid(1); &#125; try (SqlSession sqlSession2 = MybatisUtil.getSession(true))&#123; TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); Student student2 = testMapper2.getStudentBySid(1); System.out.println(student2 == student); &#125;&#125; 我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。 那么如果我不希望某个方法开启缓存呢？我们可以添加useCache属性来关闭缓存： 123&lt;select id=&quot;getStudentBySid&quot; resultType=&quot;Student&quot; useCache=&quot;false&quot;&gt; select * from student where sid = #&#123;sid&#125;&lt;/select&gt; 我们也可以使用flushCache=&quot;false&quot;在每次执行后都清空缓存，通过这这个我们还可以控制DML操作完成之后不清空缓存。 123&lt;select id=&quot;getStudentBySid&quot; resultType=&quot;Student&quot; flushCache=&quot;true&quot;&gt; select * from student where sid = #&#123;sid&#125;&lt;/select&gt; 添加了二级缓存之后，会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码： 1234567891011121314public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true))&#123; TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); &#125; Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); &#125;&#125; 得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。 读取顺序：二级缓存 =&gt; 一级缓存 =&gt; 数据库 虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在计算机组成原理中可能学习过缓存一致性问题，也就是说当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题，而Mybatis也会这样，我们来看看这个例子： 123456789public static void main(String[] args) throws InterruptedException &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); while (true)&#123; Thread.sleep(3000); System.out.println(testMapper.getStudentBySid(1)); &#125; &#125;&#125; 我们现在循环地每三秒读取一次，而在这个过程中，我们使用IDEA手动修改数据库中的数据，将1号同学的学号改成100，那么理想情况下，下一次读取将无法获取到小明，因为小明的学号已经发生变化了。 但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的，因此，如果存在多台服务器或者是多个程序都在使用Mybatis操作同一个数据库，并且都开启了缓存，需要解决这个问题，要么就得关闭Mybatis的缓存来保证一致性： 123456&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;&lt;select id=&quot;getStudentBySid&quot; resultType=&quot;Student&quot; useCache=&quot;false&quot; flushCache=&quot;true&quot;&gt; select * from student where sid = #&#123;sid&#125;&lt;/select&gt; 要么就需要实现缓存共用，也就是让所有的Mybatis都使用同一个缓存进行数据存取，在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。 使用注解开发 在之前的开发中，我们已经体验到Mybatis为我们带来的便捷了，我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。那么，能否实现无需xml映射器配置，而是直接使用注解在接口上进行配置呢？答案是可以的，也是现在推荐的一种方式（也不是说XML就不要去用了，由于Java 注解的表达能力和灵活性十分有限，可能相对于XML配置某些功能实现起来会不太好办，但是在大部分场景下，直接使用注解开发已经绰绰有余了） 首先我们来看一下，使用XML进行映射器编写时，我们需要现在XML中定义映射规则和SQL语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行： 1234&lt;insert id=&quot;addStudent&quot;&gt; insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)&lt;/insert&gt;int addStudent(Student student); 而现在，我们可以直接使用注解来实现，每个操作都有一个对应的注解： 12@Insert(&quot;insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)&quot;)int addStudent(Student student); 当然，我们还需要修改一下配置文件中的映射器注册： 1234&lt;mappers&gt; &lt;mapper class=&quot;com.test.mapper.MyMapper&quot;/&gt; &lt;!-- 也可以直接注册整个包下的 &lt;package name=&quot;com.test.mapper&quot;/&gt; --&gt;&lt;/mappers&gt; 通过直接指定Class，来让Mybatis知道我们这里有一个通过注解实现的映射器。 我们接着来看一下，如何使用注解进行自定义映射规则： 1234567@Results(&#123; @Result(id = true, column = &quot;sid&quot;, property = &quot;sid&quot;), @Result(column = &quot;sex&quot;, property = &quot;name&quot;), @Result(column = &quot;name&quot;, property = &quot;sex&quot;)&#125;)@Select(&quot;select * from student&quot;)List&lt;Student&gt; getAllStudent(); 直接通过@Results注解，就可以直接进行配置了，此注解的value是一个@Result注解数组，每个@Result注解都都一个单独的字段配置，其实就是我们之前在XML映射器中写的： 12345&lt;resultMap id=&quot;test&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;name&quot;/&gt;&lt;/resultMap&gt; 现在我们就可以通过注解来自定义映射规则了。那么如何使用注解来完成复杂查询呢？我们还是使用一个老师多个学生的例子： 123456789101112@Results(&#123; @Result(id = true, column = &quot;tid&quot;, property = &quot;tid&quot;), @Result(column = &quot;name&quot;, property = &quot;name&quot;), @Result(column = &quot;tid&quot;, property = &quot;studentList&quot;, many = @Many(select = &quot;getStudentByTid&quot;) )&#125;)@Select(&quot;select * from teacher where tid = #&#123;tid&#125;&quot;)Teacher getTeacherBySid(int tid);@Select(&quot;select * from student inner join teach on student.sid = teach.sid where tid = #&#123;tid&#125;&quot;)List&lt;Student&gt; getStudentByTid(int tid); 我们发现，多出了一个子查询，而这个子查询是单独查询该老师所属学生的信息，而子查询结果作为@Result注解的一个many结果，代表子查询的所有结果都归入此集合中（也就是之前的collection标签） 123456789&lt;resultMap id=&quot;asTeacher&quot; type=&quot;Teacher&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;studentList&quot; ofType=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 同理，@Result也提供了@One子注解来实现一对一的关系表示，类似于之前的assocation标签： 12345678910@Results(&#123; @Result(id = true, column = &quot;sid&quot;, property = &quot;sid&quot;), @Result(column = &quot;sex&quot;, property = &quot;name&quot;), @Result(column = &quot;name&quot;, property = &quot;sex&quot;), @Result(column = &quot;sid&quot;, property = &quot;teacher&quot;, one = @One(select = &quot;getTeacherBySid&quot;) )&#125;)@Select(&quot;select * from student&quot;)List&lt;Student&gt; getAllStudent(); 如果现在我希望直接使用注解编写SQL语句但是我希望映射规则依然使用XML来实现，这时该怎么办呢？ 123@ResultMap(&quot;test&quot;)@Select(&quot;select * from student&quot;)List&lt;Student&gt; getAllStudent(); 提供了@ResultMap注解，直接指定ID即可，这样我们就可以使用XML中编写的映射规则了，这里就不再演示了。 那么如果出现之前的两个构造方法的情况，且没有任何一个构造方法匹配的话，该怎么处理呢？ 12345678910111213141516@Data@Accessors(chain = true)public class Student &#123; public Student(int sid)&#123; System.out.println(&quot;我是一号构造方法&quot;+sid); &#125; public Student(int sid, String name)&#123; System.out.println(&quot;我是二号构造方法&quot;+sid+name); &#125; private int sid; private String name; private String sex;&#125; 我们可以通过@ConstructorArgs注解来指定构造方法： 123456@ConstructorArgs(&#123; @Arg(column = &quot;sid&quot;, javaType = int.class), @Arg(column = &quot;name&quot;, javaType = String.class)&#125;)@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)Student getStudentBySidAndSex(@Param(&quot;sid&quot;) int sid, @Param(&quot;sex&quot;) String sex); 得到的结果和使用constructor标签效果一致，这里就不多做讲解了。 我们发现，当参数列表中出现两个以上的参数时，会出现错误： 123456789101112131415@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)Student getStudentBySidAndSex(int sid, String sex);Exception in thread &quot;main&quot; org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;sid&#x27; not found. Available parameters are [arg1, arg0, param1, param2]### Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;sid&#x27; not found. Available parameters are [arg1, arg0, param1, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:153) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:145) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:76) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:87) at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86) at com.sun.proxy.$Proxy6.getStudentBySidAndSex(Unknown Source) at com.test.Main.main(Main.java:16) 原因是Mybatis不明确到底哪个参数是什么，因此我们可以添加@Param来指定参数名称： 12@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)Student getStudentBySidAndSex(@Param(&quot;sid&quot;) int sid, @Param(&quot;sex&quot;) String sex); **探究：**要是我两个参数一个是基本类型一个是对象类型呢？ 123System.out.println(testMapper.addStudent(100, new Student().setName(&quot;小陆&quot;).setSex(&quot;男&quot;)));@Insert(&quot;insert into student(sid, name, sex) values(#&#123;sid&#125;, #&#123;name&#125;, #&#123;sex&#125;)&quot;)int addStudent(@Param(&quot;sid&quot;) int sid, @Param(&quot;student&quot;) Student student); 那么这个时候，就出现问题了，Mybatis就不能明确这些属性是从哪里来的： 12345678910### SQL: insert into student(sid, name, sex) values(?, ?, ?)### Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;name&#x27; not found. Available parameters are [student, param1, sid, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:196) at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:181) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:62) at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86) at com.sun.proxy.$Proxy6.addStudent(Unknown Source) at com.test.Main.main(Main.java:16) 那么我们就通过参数名称.属性的方式去让Mybatis知道我们要用的是哪个属性： 12@Insert(&quot;insert into student(sid, name, sex) values(#&#123;sid&#125;, #&#123;student.name&#125;, #&#123;student.sex&#125;)&quot;)int addStudent(@Param(&quot;sid&quot;) int sid, @Param(&quot;student&quot;) Student student); 那么如何通过注解控制缓存机制呢？ 123456@CacheNamespace(readWrite = false)public interface MyMapper &#123; @Select(&quot;select * from student&quot;) @Options(useCache = false) List&lt;Student&gt; getAllStudent(); 使用@CacheNamespace注解直接定义在接口上即可，然后我们可以通过使用@Options来控制单个操作的缓存启用。 探究Mybatis的动态代理机制 在探究动态代理机制之前，我们要先聊聊什么是代理：其实顾名思义，就好比我开了个大棚，里面栽种的西瓜，那么西瓜成熟了是不是得去卖掉赚钱，而我们的西瓜非常多，一个人肯定卖不过来，肯定就要去多找几个开水果摊的帮我们卖，这就是一种代理。实际上是由水果摊老板在帮我们卖瓜，我们只告诉老板卖多少钱，而至于怎么卖的是由水果摊老板决定的。 那么现在我们来尝试实现一下这样的类结构，首先定义一个接口用于规范行为： 12345public interface Shopper &#123; //卖瓜行为 void saleWatermelon(String customer);&#125; 然后需要实现一下卖瓜行为，也就是我们要告诉老板卖多少钱，这里就直接写成成功出售： 12345678public class ShopperImpl implements Shopper&#123; //卖瓜行为的实现 @Override public void saleWatermelon(String customer) &#123; System.out.println(&quot;成功出售西瓜给 ===&gt; &quot;+customer); &#125;&#125; 最后老板代理后肯定要用自己的方式去出售这些西瓜，成交之后再按照我们告诉老板的价格进行出售： 123456789101112131415161718192021public class ShopperProxy implements Shopper&#123; private final Shopper impl; public ShopperProxy(Shopper impl)&#123; this.impl = impl; &#125; //代理卖瓜行为 @Override public void saleWatermelon(String customer) &#123; //首先进行 代理商讨价还价行为 System.out.println(customer + &quot;：哥们，这瓜多少钱一斤啊？&quot;); System.out.println(&quot;老板：两块钱一斤。&quot;); System.out.println(customer + &quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;); System.out.println(&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;); System.out.println(customer + &quot;：给我挑一个。&quot;); impl.saleWatermelon(customer); //讨价还价成功，进行我们告诉代理商的卖瓜行为 &#125;&#125; 现在我们来试试看： 123456public class Main &#123; public static void main(String[] args) &#123; Shopper shopper = new ShopperProxy(new ShopperImpl()); shopper.saleWatermelon(&quot;小强&quot;); &#125;&#125; 这样的操作称为静态代理，也就是说我们需要提前知道接口的定义并进行实现才可以完成代理，而Mybatis这样的是无法预知代理接口的，我们就需要用到动态代理。 JDK提供的反射框架就为我们很好地解决了动态代理的问题，在这里相当于对JavaSE阶段反射的内容进行一个补充。 123456789101112131415161718public class ShopperProxy implements InvocationHandler &#123; Object target; public ShopperProxy(Object target)&#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String customer = (String) args[0]; System.out.println(customer + &quot;：哥们，这瓜多少钱一斤啊？&quot;); System.out.println(&quot;老板：两块钱一斤。&quot;); System.out.println(customer + &quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;); System.out.println(&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;); System.out.println(customer + &quot;：行，给我挑一个。&quot;); return method.invoke(target, args); &#125;&#125; 通过实现InvocationHandler来成为一个动态代理，我们发现它提供了一个invoke方法，用于调用被代理对象的方法并完成我们的代理工作。现在就可以通过Proxy.newProxyInstance来生成一个动态代理类： 1234567public static void main(String[] args) &#123; Shopper impl = new ShopperImpl(); Shopper shopper = (Shopper) Proxy.newProxyInstance(impl.getClass().getClassLoader(), impl.getClass().getInterfaces(), new ShopperProxy(impl)); shopper.saleWatermelon(&quot;小强&quot;); System.out.println(shopper.getClass());&#125; 通过打印类型我们发现，就是我们之前看到的那种奇怪的类：class com.sun.proxy.$Proxy0，因此Mybatis其实也是这样的来实现的（肯定有人问了：Mybatis是直接代理接口啊，你这个不还是要把接口实现了吗？）那我们来改改，现在我们不代理任何类了，直接做接口实现： 1234567891011121314151617181920public class ShopperProxy implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String customer = (String) args[0]; System.out.println(customer + &quot;：哥们，这瓜多少钱一斤啊？&quot;); System.out.println(&quot;老板：两块钱一斤。&quot;); System.out.println(customer + &quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;); System.out.println(&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;); System.out.println(customer + &quot;：行，给我挑一个。&quot;); return null; &#125;&#125;public static void main(String[] args) &#123; Shopper shopper = (Shopper) Proxy.newProxyInstance(Shopper.class.getClassLoader(), new Class[]&#123; Shopper.class &#125;, //因为本身就是接口，所以直接用就行 new ShopperProxy()); shopper.saleWatermelon(&quot;小强&quot;); System.out.println(shopper.getClass());&#125; 我们可以去看看Mybatis的源码。 Mybatis的学习差不多就到这里为止了，不过，同样类型的框架还有很多，Mybatis属于半自动框架，SQL语句依然需要我们自己编写，虽然存在一定的麻烦，但是会更加灵活，而后面我们还会学习JPA，它是全自动的框架，你几乎见不到SQL的影子！ 使用JUnit进行单元测试 首先一问：我们为什么需要单元测试？ 随着我们的项目逐渐变大，比如我们之前编写的图书管理系统，我们都是边在写边在测试，而我们当时使用的测试方法，就是直接在主方法中运行测试，但是，在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目。 同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。 我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。 尝试JUnit 首先需要导入JUnit依赖，我们在这里使用Junit4进行介绍，最新的Junit5放到Maven板块一起讲解，Jar包已经放在视频下方简介中，直接去下载即可。同时IDEA需要安装JUnit插件（默认是已经捆绑安装的，因此无需多余配置） 现在我们创建一个新的类，来编写我们的单元测试用例： 1234567891011public class TestMain &#123; @Test public void method()&#123; System.out.println(&quot;我是测试用例1&quot;); &#125; @Test public void method2()&#123; System.out.println(&quot;我是测试用例2&quot;); &#125;&#125; 我们可以点击类前面的测试按钮，或是单个方法前的测试按钮，如果点击类前面的测试按钮，会执行所有的测试用例。 运行测试后，我们发现控制台得到了一个测试结果，显示为绿色表示测试通过。 只需要通过打上@Test注解，即可将一个方法标记为测试案例，我们可以直接运行此测试案例，但是我们编写的测试方法有以下要求： 方法必须是public的 不能是静态方法 返回值必须是void 必须是没有任何参数的方法 对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过！ 我们可以通过断言工具类来进行判定： 1234567public class TestMain &#123; @Test public void method()&#123; System.out.println(&quot;我是测试案例！&quot;); Assert.assertEquals(1, 2); //参数1是期盼值，参数2是实际测试结果值 &#125;&#125; 通过运行代码后，我们发现测试过程中抛出了一个错误，并且IDEA给我们显示了期盼结果和测试结果，那么现在我们来测试一个案例，比如我们想查看冒泡排序的编写是否正确： 1234567891011121314151617@Testpublic void method()&#123; int[] arr = &#123;0, 4, 5, 2, 6, 9, 3, 1, 7, 8&#125;; //错误的冒泡排序 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if(arr[j] &gt; arr[j + 1])&#123; int tmp = arr[j]; arr[j] = arr[j+1]; // arr[j+1] = tmp; &#125; &#125; &#125; Assert.assertArrayEquals(new int[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;, arr);&#125; 通过测试，我们发现得到的结果并不是我们想要的结果，因此现在我们需要去修改为正确的冒泡排序，修改后，测试就能正确通过了。我们还可以再通过一个案例来更加深入地了解测试，现在我们想测试从数据库中取数据是否为我们预期的数据： 123456789@Testpublic void method()&#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, &quot;男&quot;); Assert.assertEquals(new Student().setName(&quot;小明&quot;).setSex(&quot;男&quot;).setSid(1), student); &#125;&#125; 那么如果我们在进行所有的测试之前需要做一些前置操作该怎么办呢，一种办法是在所有的测试用例前面都加上前置操作，但是这样显然是很冗余的，因为一旦发生修改就需要挨个进行修改，因此我们需要更加智能的方法，我们可以通过@Before注解来添加测试用例开始之前的前置操作： 12345678910111213141516171819202122232425262728293031323334353637public class TestMain &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before()&#123; System.out.println(&quot;测试前置正在初始化...&quot;); try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(&quot;mybatis-config.xml&quot;)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;测试初始化完成，正在开始测试案例...&quot;); &#125; @Test public void method1()&#123; try (SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, &quot;男&quot;); Assert.assertEquals(new Student().setName(&quot;小明&quot;).setSex(&quot;男&quot;).setSid(1), student); System.out.println(&quot;测试用例1通过！&quot;); &#125; &#125; @Test public void method2()&#123; try (SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(2, &quot;女&quot;); Assert.assertEquals(new Student().setName(&quot;小红&quot;).setSex(&quot;女&quot;).setSid(2), student); System.out.println(&quot;测试用例2通过！&quot;); &#125; &#125;&#125; 同理，在所有的测试完成之后，我们还想添加一个收尾的动作，那么只需要使用@After注解即可添加结束动作： 1234@Afterpublic void after()&#123; System.out.println(&quot;测试结束，收尾工作正在进行...&quot;);&#125; 有关JUnit的使用我们就暂时只介绍这么多。 JUL日志系统 首先一问：我们为什么需要日志系统？ 我们之前一直都在使用System.out.println来打印信息，但是，如果项目中存在大量的控制台输出语句，会显得很凌乱，而且日志的粒度是不够细的，假如我们现在希望，项目只在debug的情况下打印某些日志，而在实际运行时不打印日志，采用直接输出的方式就很难实现了，因此我们需要使用日志框架来规范化日志输出。 而JDK为我们提供了一个自带的日志框架，位于java.util.logging包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单： 12345678public class Main &#123; public static void main(String[] args) &#123; // 首先获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); // 调用info来输出一个普通的信息，直接填写字符串即可 logger.info(&quot;我是普通的日志&quot;); &#125;&#125; 我们可以在主类中使用日志打印，得到日志的打印结果： 12十一月 15, 2021 12:55:37 下午 com.test.Main main信息: 我是普通的日志 我们发现，通过日志输出的结果会更加规范。 JUL日志讲解 日志分为7个级别，详细信息我们可以在Level类中查看： SEVERE（最高值）- 一般用于代表严重错误 WARNING - 一般用于表示某些警告，但是不足以判断为错误 INFO （默认级别） - 常规消息 CONFIG FINE FINER FINEST（最低值） 我们之前通过info方法直接输出的结果就是使用的默认级别的日志，我们可以通过log方法来设定该条日志的输出级别： 1234567public static void main(String[] args) &#123; Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.SEVERE, &quot;严重的错误&quot;, new IOException(&quot;我就是错误&quot;)); logger.log(Level.WARNING, &quot;警告的内容&quot;); logger.log(Level.INFO, &quot;普通的信息&quot;); logger.log(Level.CONFIG, &quot;级别低于普通信息&quot;);&#125; 我们发现，级别低于默认级别的日志信息，无法输出到控制台，我们可以通过设置来修改日志的打印级别： 1234567891011121314151617public static void main(String[] args) &#123; Logger logger = Logger.getLogger(Main.class.getName()); //修改日志级别 logger.setLevel(Level.CONFIG); //不使用父日志处理器 logger.setUseParentHandlers(false); //使用自定义日志处理器 ConsoleHandler handler = new ConsoleHandler(); handler.setLevel(Level.CONFIG); logger.addHandler(handler); logger.log(Level.SEVERE, &quot;严重的错误&quot;, new IOException(&quot;我就是错误&quot;)); logger.log(Level.WARNING, &quot;警告的内容&quot;); logger.log(Level.INFO, &quot;普通的信息&quot;); logger.log(Level.CONFIG, &quot;级别低于普通信息&quot;);&#125; 每个Logger都有一个父日志打印器，我们可以通过getParent()来获取： 1234public static void main(String[] args) throws IOException &#123; Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(logger.getParent().getClass());&#125; 我们发现，得到的是java.util.logging.LogManager$RootLogger这个类，它默认使用的是ConsoleHandler，且日志级别为INFO，由于每一个日志打印器都会直接使用父类的处理器，因此我们之前需要关闭父类然后使用我们自己的处理器。 我们通过使用自己日志处理器来自定义级别的信息打印到控制台，当然，日志处理器不仅仅只有控制台打印，我们也可以使用文件处理器来处理日志信息，我们继续添加一个处理器： 1234//添加输出到本地文件FileHandler fileHandler = new FileHandler(&quot;test.log&quot;);fileHandler.setLevel(Level.WARNING);logger.addHandler(fileHandler); 注意，这个时候就有两个日志处理器了，因此控制台和文件的都会生效。如果日志的打印格式我们不喜欢，我们还可以自定义打印格式，比如我们控制台处理器就默认使用的是SimpleFormatter，而文件处理器则是使用的XMLFormatter，我们可以自定义： 12345//使用自定义日志处理器(控制台)ConsoleHandler handler = new ConsoleHandler();handler.setLevel(Level.CONFIG);handler.setFormatter(new XMLFormatter());logger.addHandler(handler); 我们可以直接配置为想要的打印格式，如果这些格式还不能满足你，那么我们也可以自行实现： 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws IOException &#123; Logger logger = Logger.getLogger(Main.class.getName()); logger.setUseParentHandlers(false); //为了让颜色变回普通的颜色，通过代码块在初始化时将输出流设定为System.out ConsoleHandler handler = new ConsoleHandler()&#123;&#123; setOutputStream(System.out); &#125;&#125;; //创建匿名内部类实现自定义的格式 handler.setFormatter(new Formatter() &#123; @Override public String format(LogRecord record) &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); String time = format.format(new Date(record.getMillis())); //格式化日志时间 String level = record.getLevel().getName(); // 获取日志级别名称 // String level = record.getLevel().getLocalizedName(); // 获取本地化名称（语言跟随系统） String thread = String.format(&quot;%10s&quot;, Thread.currentThread().getName()); //线程名称（做了格式化处理，留出10格空间） long threadID = record.getThreadID(); //线程ID String className = String.format(&quot;%-20s&quot;, record.getSourceClassName()); //发送日志的类名 String msg = record.getMessage(); //日志消息 //\\033[33m作为颜色代码，30~37都有对应的颜色，38是没有颜色，IDEA能显示，但是某些地方可能不支持 return &quot;\\033[38m&quot; + time + &quot; \\033[33m&quot; + level + &quot; \\033[35m&quot; + threadID + &quot;\\033[38m --- [&quot; + thread + &quot;] \\033[36m&quot; + className + &quot;\\033[38m : &quot; + msg + &quot;\\n&quot;; &#125; &#125;); logger.addHandler(handler); logger.info(&quot;我是测试消息1...&quot;); logger.log(Level.INFO, &quot;我是测试消息2...&quot;); logger.log(Level.WARNING, &quot;我是测试消息3...&quot;);&#125; 日志可以设置过滤器，如果我们不希望某些日志信息被输出，我们可以配置过滤规则： 12345678910public static void main(String[] args) throws IOException &#123; Logger logger = Logger.getLogger(Main.class.getName()); //自定义过滤规则 logger.setFilter(record -&gt; !record.getMessage().contains(&quot;普通&quot;)); logger.log(Level.SEVERE, &quot;严重的错误&quot;, new IOException(&quot;我就是错误&quot;)); logger.log(Level.WARNING, &quot;警告的内容&quot;); logger.log(Level.INFO, &quot;普通的信息&quot;);&#125; 实际上，整个日志的输出流程如下： Properties配置文件 Properties文件是Java的一种配置文件，我们之前学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？我们可以使用Properties文件： 12name=Testdesc=Description 该文件配置很简单，格式为配置项=配置值，我们可以直接通过Properties类来将其读取为一个类似于Map一样的对象： 12345public static void main(String[] args) throws IOException &#123; Properties properties = new Properties(); properties.load(new FileInputStream(&quot;test.properties&quot;)); System.out.println(properties);&#125; 我们发现，Properties类是继承自Hashtable，而Hashtable是实现的Map接口，也就是说，Properties本质上就是一个Map一样的结构，它会把所有的配置项映射为一个Map，这样我们就可以快速地读取对应配置的值了。 我们也可以将已经存在的Properties对象放入输出流进行保存，我们这里就不保存文件了，而是直接打印到控制台，我们只需要提供输出流即可： 1234567public static void main(String[] args) throws IOException &#123; Properties properties = new Properties(); // properties.setProperty(&quot;test&quot;, &quot;lbwnb&quot;); //和put效果一样 properties.put(&quot;test&quot;, &quot;lbwnb&quot;); properties.store(System.out, &quot;????&quot;); //properties.storeToXML(System.out, &quot;????&quot;); 保存为XML格式&#125; 我们可以通过System.getProperties()获取系统的参数，我们来看看： 123public static void main(String[] args) throws IOException &#123; System.getProperties().store(System.out, &quot;系统信息：&quot;);&#125; 编写日志配置文件 我们可以通过进行配置文件来规定日志打印器的一些默认值： 1234# RootLogger 的默认处理器为handlers= java.util.logging.ConsoleHandler# RootLogger 的默认的日志级别.level= CONFIG 我们来尝试使用配置文件来进行配置： 123456789public static void main(String[] args) throws IOException &#123; //获取日志管理器 LogManager manager = LogManager.getLogManager(); //读取我们自己的配置文件 manager.readConfiguration(new FileInputStream(&quot;logging.properties&quot;)); //再获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.CONFIG, &quot;我是一条日志信息&quot;); //通过自定义配置文件，我们发现默认级别不再是INFO了&#125; 我们也可以去修改ConsoleHandler的默认配置： 123456# 指定默认日志级别java.util.logging.ConsoleHandler.level = ALL# 指定默认日志消息格式java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter# 指定默认的字符集java.util.logging.ConsoleHandler.encoding = UTF-8 其实，我们阅读ConsoleHandler的源码就会发现，它就是通过读取配置文件来进行某些参数设置： 123456789101112131415161718192021// Private method to configure a ConsoleHandler from LogManager// properties and/or default values as specified in the class// javadoc.private void configure() &#123; LogManager manager = LogManager.getLogManager(); String cname = getClass().getName(); setLevel(manager.getLevelProperty(cname +&quot;.level&quot;, Level.INFO)); setFilter(manager.getFilterProperty(cname +&quot;.filter&quot;, null)); setFormatter(manager.getFormatterProperty(cname +&quot;.formatter&quot;, new SimpleFormatter())); try &#123; setEncoding(manager.getStringProperty(cname +&quot;.encoding&quot;, null)); &#125; catch (Exception ex) &#123; try &#123; setEncoding(null); &#125; catch (Exception ex2) &#123; // doing a setEncoding with null should always work. // assert false; &#125; &#125;&#125; 使用Lombok快速开启日志 我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？ 前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter，同样的，Logger也是可以使用Lombok快速生成的。 1234567@Logpublic class Main &#123; public static void main(String[] args) &#123; System.out.println(&quot;自动生成的Logger名称：&quot;+log.getName()); log.info(&quot;我是日志信息&quot;); &#125;&#125; 只需要添加一个@Log注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。我们也可以手动指定名称： 1234567@Log(topic = &quot;打工是不可能打工的&quot;)public class Main &#123; public static void main(String[] args) &#123; System.out.println(&quot;自动生成的Logger名称：&quot;+log.getName()); log.info(&quot;我是日志信息&quot;); &#125;&#125; Mybatis日志系统 Mybatis也有日志系统，它详细记录了所有的数据库操作等，但是我们在前面的学习中没有开启它，现在我们学习了日志之后，我们就可以尝试开启Mybatis的日志系统，来监控所有的数据库操作，要开启日志系统，我们需要进行配置： 1&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt; logImpl包括很多种配置项，包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING，而默认情况下是未配置，也就是说不打印。我们这里将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台，我们编写一个测试案例来看看效果： 12345678910111213141516171819202122public class TestMain &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before()&#123; try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(&quot;mybatis-config.xml&quot;)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test()&#123; try(SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); System.out.println(mapper.getStudentBySidAndSex(1, &quot;男&quot;)); System.out.println(mapper.getStudentBySidAndSex(1, &quot;男&quot;)); &#125; &#125;&#125; 我们发现，两次获取学生信息，只有第一次打开了数据库连接，而第二次并没有。 现在我们学习了日志系统，那么我们来尝试使用日志系统输出Mybatis的日志信息： 1&lt;setting name=&quot;logImpl&quot; value=&quot;JDK_LOGGING&quot; /&gt; 将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低，因此我们需要设置一下logging.properties默认的日志级别： 123handlers= java.util.logging.ConsoleHandler.level= ALLjava.util.logging.ConsoleHandler.level = ALL 代码编写如下： 12345678910111213141516171819202122232425@Logpublic class TestMain &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before()&#123; try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(&quot;mybatis-config.xml&quot;)); LogManager manager = LogManager.getLogManager(); manager.readConfiguration(new FileInputStream(&quot;logging.properties&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test()&#123; try(SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); log.info(mapper.getStudentBySidAndSex(1, &quot;男&quot;).toString()); log.info(mapper.getStudentBySidAndSex(1, &quot;男&quot;).toString()); &#125; &#125;&#125; 但是我们发现，这样的日志信息根本没法看，因此我们需要修改一下日志的打印格式，我们自己创建一个格式化类： 12345678public class TestFormatter extends Formatter &#123; @Override public String format(LogRecord record) &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); String time = format.format(new Date(record.getMillis())); //格式化日志时间 return time + &quot; : &quot; + record.getMessage() + &quot;\\n&quot;; &#125;&#125; 现在再来修改一下默认的格式化实现： 1234handlers= java.util.logging.ConsoleHandler.level= ALLjava.util.logging.ConsoleHandler.level = ALLjava.util.logging.ConsoleHandler.formatter = com.test.TestFormatter 现在就好看多了，当然，我们还可以继续为Mybatis添加文件日志，这里就不做演示了。 使用Maven管理项目 **注意：**开始之前，看看你C盘空间够不够，最好预留2GB空间以上！ **吐槽：**很多电脑预装系统C盘都给得巨少，就算不装软件，一些软件的缓存文件也能给你塞满，建议有时间重装一下系统重新分配一下磁盘空间。 Maven 翻译为&quot;专家&quot;、“内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 通过Maven，可以帮助我们做： 项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。 依赖管理，项目使用到哪些依赖，可以快速完成导入。 我们之前并没有讲解如何将我们的项目打包为Jar文件运行，同时，我们导入依赖的时候，每次都要去下载对应的Jar包，这样其实是很麻烦的，并且还有可能一个Jar包依赖于另一个Jar包，就像之前使用JUnit一样，因此我们需要一个更加方便的包管理机制。 Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装（无IDEA也能使用Maven，但是配置过程很麻烦，并且我们现在使用的都是IDEA的集成开发环境，所以这里就不讲解Maven命令行操作了）我们直接创建一个新的Maven项目即可。 Maven项目结构 我们可以来看一下，一个Maven项目和我们普通的项目有什么区别： 那么首先，我们需要了解一下POM文件，它相当于是我们整个Maven项目的配置文件，它也是使用XML编写的： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 我们可以看到，Maven的配置文件是以project为根节点，而modelVersion定义了当前模型的版本，一般是4.0.0，我们不用去修改。 groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。 groupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。 artifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。 version 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号） properties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。 Maven依赖导入 现在我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？ 我们可以创建一个dependencies节点： 123&lt;dependencies&gt; //里面填写的就是所有的依赖&lt;/dependencies&gt; 那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：https://mvnrepository.com/ 进行查询（可能打不开，建议用流量，或是直接百度某个项目的Maven依赖），我们直接搜索lombok即可，打开后可以看到已经给我们写出了依赖的坐标： 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 我们直接将其添加到dependencies节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有： 123456789101112public class Main &#123; public static void main(String[] args) &#123; Student student = new Student(&quot;小明&quot;, 18); System.out.println(student); &#125;&#125;@Data@AllArgsConstructorpublic class Student &#123; String name; int age;&#125; 项目运行成功，表示成功导入了依赖。那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程： 通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个.m2文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题！ 在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。 可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到安装根目录/plugins/maven/lib/maven3/conf文件夹，找到settings.xml文件，打开编辑： 找到mirros标签，添加以下内容： 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了） Maven依赖作用域 除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性： type：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar scope：依赖的范围（作用域，着重讲解） optional：标记依赖是否可选 exclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok） 我们着重来讲解一下scope属性，它决定了依赖的作用域范围： compile ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。 provided ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。 runtime ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。 test ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖： 同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用： 123456789public class MainTest &#123; @Test public void test()&#123; System.out.println(&quot;测试&quot;); //Assert在JUnit5时名称发生了变化Assertions Assertions.assertArrayEquals(new int[]&#123;1, 2, 3&#125;, new int[]&#123;1, 2&#125;); &#125;&#125; 因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt; 我们发现，Maven还给我们提供了一个resource文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;JDK_LOGGING&quot; /&gt; &lt;/settings&gt; &lt;!-- 需要在environments的上方 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.test.entity&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/study&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;test&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.test.mapper.TestMapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 现在我们创建一下测试用例，顺便带大家了解一下Junit5的一些比较方便的地方： 123456789101112131415161718192021222324public class MainTest &#123; //因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件 private static SqlSessionFactory factory; //在JUnit5中@Before被废弃，它被细分了： @BeforeAll // 一次性开启所有测试案例只会执行一次 (方法必须是static) // @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次 @SneakyThrows public static void before()&#123; factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(&quot;mybatis.xml&quot;)); &#125; @DisplayName(&quot;Mybatis数据库测试&quot;) //自定义测试名称 @RepeatedTest(3) //自动执行多次测试 public void test()&#123; try (SqlSession sqlSession = factory.openSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getStudentBySid(1)); &#125; &#125;&#125; 那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域： system：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包： 1234567&lt;dependency&gt; &lt;groupId&gt;javax.jntm&lt;/groupId&gt; &lt;artifactId&gt;lbwnb&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;C://学习资料/4K高清无码/test.jar&lt;/systemPath&gt;&lt;/dependency&gt; 比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。 Maven可选依赖 当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖： 1&lt;optional&gt;true&lt;/optional&gt; 比如Mybatis的POM文件中，就存在大量的可选依赖： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; ... 由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。 Maven排除依赖 我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 我们这里演示了排除JUnit的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。 Maven继承关系 一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。 我们右键左侧栏，新建一个模块，来创建一个子项目： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;ChildModel&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的groupId，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签，我们来编写一个测试用例尝试一下: 12345678import lombok.extern.java.Log;@Logpublic class Main &#123; public static void main(String[] args) &#123; log.info(&quot;我是日志信息&quot;); &#125;&#125; 可以看到，子项目也成功继承了Lombok依赖。 我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将dependencies全部放入dependencyManagement节点，这样父项目就完全作为依赖统一管理。 1234567891011121314151617181920212223242526&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承： 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; ... Maven常用命令 我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如： clean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。 validate命令可以验证项目的可用性。 compile命令可以将项目编译为.class文件。 install命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用 verify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等） Maven测试项目 通过使用test命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求： 测试类的名称必须是以Test结尾，比如MainTest 测试方法上必须标注@Test注解，实测@RepeatedTest无效 这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5： 12345678910&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --&gt; &lt;version&gt;2.22.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 现在@RepeatedTest、@BeforeAll也能使用了。 Maven打包项目 我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行package命令就可以直接对项目的代码进行打包，生成jar文件。 当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们通过的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包： 123456789101112131415161718192021222324&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;mainClass&gt;com.test.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择执行Maven目标来手动执行Maven命令，输入mvn package -Dmaven.test.skip=true来以跳过测试的方式进行打包。 最后得到我们的Jar文件，在同级目录下输入java -jar xxxx.jar来运行我们打包好的Jar可执行程序（xxx代表文件名称） deploy命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。 site命令用于生成当前项目的发布站点，暂时不需要了解。 我们之前还讲解了多模块项目，那么多模块下父项目存在一个packing打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。 实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试） 项目需求： 在线录入学生信息和书籍信息 查询书籍信息列表 查询学生信息列表 查询借阅信息列表 完整的日志系统","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"后端","slug":"编程/后端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/"},{"name":"JavaWeb","slug":"编程/后端/JavaWeb","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/JavaWeb/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://kaguranotamashii.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"https://kaguranotamashii.github.io/tags/Java/"}]},{"title":"jQuery基础","slug":"[main]CS/[main]web/jQuery基础","date":"2022-02-11T16:30:17.000Z","updated":"2023-09-29T02:41:15.880Z","comments":true,"path":"posts/26/","link":"","permalink":"https://kaguranotamashii.github.io/posts/26/","excerpt":"","text":"Jquery概述 jquery没什么学的必要故性 jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！ 目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE 6、7、8的支持，因此2.x的代码更精简。选择哪个版本主要取决于你是否想支持IE 6~8。（什么老古董） 1234567&lt;script&gt; &lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt; //获取元素节点$(&quot;xuanzeqi&quot;) $(&quot;button&quot;).click(function () &#123; console.log(&quot;aaa&quot;) &#125;)&lt;/script&gt; 获取节点$(“xuanzeqi”) 操作节点$().method(); 设置元素样态$().css() Jquery常用的方法 123$(&quot;button&quot;).click(function () &#123; $(this).hide() &#125;)//隐藏当前元素 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload hover | jq对象和dom对象(重要) DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。 jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。 jQuery对象其实就是DOM对象的包装集包装了DOM对象的集合（伪数组） DOM对象与jQuery对象的方法不能混用。 DOM对象转换成jQuery对象：【联想记忆：花钱】 var $obj = $(domObj); // $(document).ready(function(){});就是典型的DOM对象转jQuery对象 1 2 3 jQuery对象转换成DOM对象： //第一种写法 $(document).ready(function() { }); //第二种写法 $(function() { }); jQuery对象转换成DOM对象： 123456var $li = $(&quot;li&quot;);//第一种方法（推荐使用）$li[0]//第二种方法$li.get(0)12345 jquery选择器 什么是jQuery选择器 jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。 注意：jQuery选择器返回的是jQuery对象。 jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多扩展性的选择器。 【查看jQuery文档】 jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。 所以我们平时真正能用到的只是少数的最常用的选择器。 基本选择器 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 总结：跟css的选择器用法一模一样。 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 总结：跟css的选择器用法一模一样。 过滤选择器 名称 用法 描述 :eq（index） $(“li:eq(2)”).css(“color”, ”red”); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(“li:odd”).css(“color”, ”red”); 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”).css(“color”, ”red”); 获取到的li元素中，选择索引号为偶数的元素 总结：这类选择器都带冒号 筛选选择器(方法) 名称 用法 描述 children(selector) (“ul”).children(“li”)相当于(“ul”).children(“li”) 相当于(“ul”).children(“li”)相当于(“ul&gt;li”)，子类选择器 find(selector) (“ul”).find(“li”);相当于(“ul”).find(“li”); 相当于(“ul”).find(“li”);相当于(“ul li”),后代选择器 siblings(selector) $(“#first”).siblings(“li”); 查找兄弟节点，不包括自己本身。 parent() $(“#first”).parent(); 查找父亲 eq(index) (“li”).eq(2);相当于(“li”).eq(2); 相当于(“li”).eq(2);相当于(“li:eq(2)”),index从0开始 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 总结：筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。 【案例：下拉菜单】 元素设置 样式设置 /*1.设置一个样式*/ //两个参数 设置的样式属性,具体样式 $('li').css('color','red'); //传入对象（设置的样式属性:具体样式） $('li').css(&#123;'color':'red'&#125;); /*2.设置多个样式*/ $('li').css(&#123; 'color':'green', 'font-size':'20px' &#125;); 类名设置 /*1.添加一个类*/ $('li').addClass('now'); /*2.删除一个类*/ $('li').removeClass('now'); /*3.切换一个类 有就删除没有就添加*/ $('li').toggleClass('now'); /*4.匹配一个类 判断是否包含某个类 如果包含返回true否知返回false*/ $('li').hasClass('now'); 动画 12345678910/*注意：动画的本质是改变容器的大小和透明度*/ /*注意：如果不传参数是看不到动画*/ /*注意：可传入特殊的字符 fast normal slow*/ /*注意：可传入数字 单位毫秒*/ /*1.展示动画*/ $(&#x27;li&#x27;).show(); /*2.隐藏动画*/ $(&#x27;li&#x27;).hide(); /*3.切换展示和隐藏*/ $(&#x27;li&#x27;).toggle(); 滑入滑出 12345678/*注意：动画的本质是改变容器的高度*//*1.滑入动画*/$(&#x27;li&#x27;).slideDown();/*2.滑出动画*/$(&#x27;li&#x27;).slideUp();/*3.切换滑入滑出*/$(&#x27;li&#x27;).slideToggle(); 淡入而出 123456789/*注意：动画的本质是改变容器的透明度*//*1.淡入动画*/$(&#x27;li&#x27;).fadeIn();/*2.淡出动画*/$(&#x27;li&#x27;).fadeOut();/*3.切换淡入淡出*/$(&#x27;li&#x27;).fadeToggle();$(&#x27;li&#x27;).fadeTo(&#x27;speed&#x27;,&#x27;opacity&#x27;); 节点操作 创建节点 12/*创建节点*/var $a = $(&#x27;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度1&lt;/a&gt;&#x27;); /*追加自身的最后面 传对象和html格式代码*/ $('#box').append('&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;'); $('#box').append($('a')); /*追加到目标元素最后面 传目标元素的选择器或者对象*/ $('&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;&lt;b&gt;百度3&lt;/b&gt;&lt;/a&gt;').appendTo($('#box')); $('a').appendTo('#box'); prepend(); prependTo(); after(); before(); 删除节点&amp;清空节点 123456/*1.清空box里面的元素*//* 清理门户 */$(&#x27;#box&#x27;).empty();/*2.删除某个元素*//* 自杀 */$(&#x27;#box&#x27;).remove(); jQuery特殊属性操作 val方法 val方法用于设置和获取表单元素的值，例如input、textarea的值 1234//设置值$(&quot;#name&quot;).val(&#x27;张三&#x27;);//获取值$(&quot;#name&quot;).val(); html方法与text方法 html方法相当于innerHTML text方法相当于innerText //设置内容 $('div').html('&lt;span&gt;这是一段内容&lt;/span&gt;'); //获取内容 $('div').html() //设置内容 $('div').text('&lt;span&gt;这是一段内容&lt;/span&gt;'); //获取内容 $('div').text() width方法与height方法 设置或者获取高度 1234//带参数表示设置高度$(&#x27;img&#x27;).height(200);//不带参数获取高度$(&#x27;img&#x27;).height(); 获取网页的可视区宽高 1234//获取可视区宽度$(window).width();//获取可视区高度$(window).height(); scrollTop与scrollLeft 设置或者获取垂直滚动条的位置 1234//获取页面被卷曲的高度$(window).scrollTop();//获取页面被卷曲的宽度$(window).scrollLeft(); offset方法与position方法 offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。 //获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125; $(selector).offset(); //获取相对于其最近的有定位的父元素的位置。 $(selector).position(); $符号 是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名： 1234window.jQuery; // jQuery(selector, context)window.$; // jQuery(selector, context)$ === jQuery; // truetypeof($); // &#x27;function&#x27; jQuery对象和DOM对象之间可以互相转化： 123var div = $(&#x27;#abc&#x27;); // jQuery对象var divDom = div.get(0); // 假设存在div，获取第1个DOM元素var another = $(divDom); // 重新把DOM包装为jQuery对象 通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用$(aDomObject)把它变成jQuery对象，这样就可以方便地使用jQuery的API了。 操作DOM jQuery的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了jQuery对象，到底要干什么？ 答案当然是操作对应的DOM节点啦！ 回顾一下修改DOM的CSS、文本、设置HTML有多么麻烦，而且有的浏览器只有innerHTML，有的浏览器支持innerText，有了jQuery对象，不需要考虑浏览器差异了，全部统一操作！ 修改Text和HTML jQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： 12345&lt;!-- HTML结构 --&gt;&lt;ul id=&quot;test-ul&quot;&gt; &lt;li class=&quot;js&quot;&gt;JavaScript&lt;/li&gt; &lt;li name=&quot;book&quot;&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 分别获取文本和HTML： 12$(&#x27;#test-ul li[name=book]&#x27;).text(); // &#x27;Java &amp; JavaScript&#x27;$(&#x27;#test-ul li[name=book]&#x27;).html(); // &#x27;Java &amp;amp; JavaScript&#x27; 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作，自己动手试试： jQuery对象的css()方法可以这么用： 1234var div = $(&#x27;#test-div&#x27;);div.css(&#x27;color&#x27;); // &#x27;#000033&#x27;, 获取CSS属性div.css(&#x27;color&#x27;, &#x27;#336699&#x27;); // 设置CSS属性div.css(&#x27;color&#x27;, &#x27;&#x27;); // 清除CSS属性 显示和隐藏DOM 要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现。不过，要显示这个DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的值。 考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供show()和hide()方法，我们不用关心它是如何修改display属性的，总之它能正常工作： 123var a = $(&#x27;a[target=_blank]&#x27;);a.hide(); // 隐藏a.show(); // 显示 注意，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。 事件 1234567891011/* HTML: * * &lt;a id=&quot;test-link&quot; href=&quot;#0&quot;&gt;点我试试&lt;/a&gt; * */// 获取超链接的jQuery对象:var a = $(&#x27;#test-link&#x27;);a.on(&#x27;click&#x27;, function () &#123; alert(&#x27;Hello!&#x27;);&#125;); on方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。 另一种更简化的写法是直接调用click()方法： 123a.click(function () &#123; alert(&#x27;Hello!&#x27;);&#125;); 两者完全等价。我们通常用后面的写法。 jQuery能够绑定的事件主要包括： 鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件 键盘事件仅作用在当前焦点的DOM上，通常是&lt;input&gt;和&lt;textarea&gt;。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发； submit：当&lt;form&gt;提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。 其中，ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个&lt;form&gt;表单绑定submit事件，下面的代码没有预期的效果： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;script&gt; // 代码有误: $(&#x27;#testForm&#x27;).on(&#x27;submit&#x27;, function () &#123; alert(&#x27;submit!&#x27;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;testForm&quot;&gt; ... &lt;/form&gt;&lt;/body&gt; 因为JavaScript在此执行的时候，&lt;form&gt;尚未载入浏览器，所以$('#testForm)返回[]，并没有绑定事件到任何DOM上。 所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化： 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;script&gt; $(document).on(&#x27;ready&#x27;, function () &#123; $(&#x27;#testForm).on(&#x27;submit&#x27;, function () &#123; alert(&#x27;submit!&#x27;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;testForm&quot;&gt; ... &lt;/form&gt;&lt;/body&gt; 这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。 由于ready事件使用非常普遍，所以可以这样简化： 123456$(document).ready(function () &#123; // on(&#x27;submit&#x27;, function)也可以简化: $(&#x27;#testForm).submit(function () &#123; alert(&#x27;submit!&#x27;); &#125;);&#125;); 甚至还可以再简化为： 123$(function () &#123; // init...&#125;); 上面的这种写法最为常见。如果你遇到$(function () &#123;...&#125;)的形式，牢记这是document对象的ready事件处理函数。 完全可以反复绑定事件处理函数，它们会依次执行： 123456789$(function () &#123; console.log(&#x27;init A...&#x27;);&#125;);$(function () &#123; console.log(&#x27;init B...&#x27;);&#125;);$(function () &#123; console.log(&#x27;init C...&#x27;);&#125;); 事件参数","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"编程/前端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"},{"name":"jquery","slug":"编程/前端/jquery","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://kaguranotamashii.github.io/tags/jquery/"}]},{"title":"swift学习笔记","slug":"[main]CS/[main]computer-language/swift学习笔记","date":"2022-01-21T13:16:51.000Z","updated":"2022-07-16T15:37:41.550Z","comments":true,"path":"posts/53084/","link":"","permalink":"https://kaguranotamashii.github.io/posts/53084/","excerpt":"乐，swift确实是一门好的语言，但是我恐怕没有时间学它","text":"乐，swift确实是一门好的语言，但是我恐怕没有时间学它 时间学它","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://kaguranotamashii.github.io/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://kaguranotamashii.github.io/tags/ios/"}]},{"title":"2021review","slug":"[main]summary/2021Review","date":"2022-01-17T15:35:02.000Z","updated":"2023-04-08T08:51:38.418Z","comments":true,"path":"posts/49840/","link":"","permalink":"https://kaguranotamashii.github.io/posts/49840/","excerpt":"创建了自己的博客这么久，对于大一上学期自己学习生活做一个简单的总结和记录学习和生活。","text":"创建了自己的博客这么久，对于大一上学期自己学习生活做一个简单的总结和记录学习和生活。 高考-&gt;被录取-&gt;入学-&gt;健翔桥两个月-&gt;沙河 高考 我在高中的时候最渴望的事情就是摆脱高中的各种约束和奇怪的规则，现在我确实离开了我的母校，但现在又有些怀念起我的母校了。 记得初入学的我是那么有朝气，对美好的高中生活有着很强烈的渴望。但是在疫情后被改变了。 后来疫情缓解后，再次回到母校，一些原因让我对它，有些失望。直到我毕业典礼那天，我知道以往后我不会再次来到这熟悉的教室和操场了，不仅仅有些怀念起来了，这或许就是斯德哥尔摩效应吧。 高考我是在西城护国寺考的老实说吧，这几天给我留下了相当深刻的印象，忘不掉我和父亲在老旧街道走行，他为我讲述过往的荣誉与血泪。忘不掉亲自看见北京四中长什么样子。忘不掉的是那 156 中学。说起来也巧，我隔壁班就一位和我一起在 156 中学考试的小语种考生。 录取 高考后等成绩是最焦虑的，老实说吧我看到成绩单那时候，真的傻了，考的是我我有史以来最差的一次（21 北京数学和化学历年最难，而且日语也出现了十年未有的书信类） 本来信息科大是我的铺底学校，但为了保护志愿不被调剂，被迫将信息科大放到了志愿置顶。等录取是很漫长焦虑，当我拿到录取通知书那天，就像碇シンジ和渚カヲル在海边相遇那天。我万分惊喜，珍惜地拿着属于我荣誉。高中的血与泪在那天化为灰烬。 我们的情人不过是随便借个名字，用幻想吹出来的肥皂泡…… 好了，收下吧！ 你可以假戏真做。 我本来是无病呻吟，漫无目的地吐露爱情……但你是可以让漂泊不定的鸟儿于此的人。 好了，收下吧。用毫无实际的雄辩 你总有一天也会明白的…… 《西哈诺 德 贝热拉克》 健翔桥 漫长的暑假过去了，我来到了健翔桥校区，它很小但是却很温馨。 我很喜欢盘古大厦，每当我迷失在北四环的时候永远是它，作为了我们回到学校指路的灯塔。有时候在浓雾中，盘古大厦若隐若现，就像随时崩塌的样子。 从学二走到教学楼，不到三两分钟。 我在健翔桥印象最深的是学哥学姐日日夜夜在阶梯教室奋斗自习，计算机学院拿着笔记本用着编译器敲代码的样子可以说是健翔桥的一道美丽的风景线了 后来我等到了心中早已期待很久的 iFlab 社团的招新，记得面试那天是北京入冬来第一场大雪!我是第一位面试的，面对学长的提问我确实慌张了，同时也对未来更加充满了期望。 入社后，我接触了不少厉害的 CS 大佬，以及各种新生 CS 卷王。我还编了个笑话，我在电信二班认识的人，还不如未来转入计科班人多。（现在我已经没有转 CS 的想法了） 2022/7/28 更新，反转了以及转专业到计科了哈哈哈哈哈 两个月很快就过去了，老实说吧，健翔桥虽然是八人间，但是我依然恋恋不舍，不想和优秀的学哥学姐离开。这一天还是来了。 沙河 昌平是神奇的地方，我姑姑在这里上学，我父亲第一份工作就在这里，未来几年我也继续在昌平上学，每天的龙泽地铁总是会被挤满北漂和上班族，还记得一次做昌 58 来的学校，经过某一站的时候，人突然满了，这是比在北四环座公交车从来没有的感觉。 我在沙河又认识到了不少专业的强者，以及有思想的人。 2021 年对我来说是挑战是机遇，虽然有很多失望的事情。 但是我希望我在 2022 年，尽量不让自己留下太多的遗憾。 2022 年我的期望的目标 交女朋友 自己用 ARDUINO 做个闹钟 学自己真正喜欢的 一定要学好英语！！！！ 2023年回来的我表示一下一个也没有实现。 我的朋友，如果你对 2021 年留有遗憾，对 2022 年充满期待，那么我会祝福你，在 2022 不留遗憾，成为自己所期待的那样。我们会在下一年的年终问题里，寻找你的答案。 人よ、幸福たれ！ ——《素晴らしき日々》 晴らしき日々*》","categories":[{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/categories/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://kaguranotamashii.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/tags/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"}]},{"title":"数据结构学习笔记","slug":"[main]CS/[main]Leetcode/数据结构","date":"2022-01-15T06:11:27.000Z","updated":"2022-07-16T15:37:41.555Z","comments":true,"path":"posts/63932/","link":"","permalink":"https://kaguranotamashii.github.io/posts/63932/","excerpt":"Algorithms + Data Structures = Programs","text":"Algorithms + Data Structures = Programs 数据结构与算法 严蔚敏 王卓_哔哩哔哩_bilibili 一.导论 1.基本概念和术语 Data 数据 Data Element 数据元素 node节点 Data Ltem 数据项 Data Object数据对象 2数据结构 Data Structure 数据结构包括以下三个部分 数据结构之间的逻辑关系 也叫逻辑结构 数据元素关系在计算机内存中的表示 也叫数据结构的物理结构或者数据的存储结构 数据的运算和实现 即对数据结构元素可以施加操作也i及在对应存储结构的实现 逻辑结构 3.数据类型 一些基本的数据结构可以用数据类型实现，如数组字符串等 而另一些常用的数据结构如栈队列 树图不能直接用数据类型表示 抽象数据类型 可以用DSP三元组表示出来 D是数据对象 S是D上的关系集 P是对D的基本操作集 定义格式 12345678910111213Abstract Data Type 抽象数据类型名&#123;数据对象数据关系基本操作&#125;Abstract Data Type抽象数据名基本操作定义格式为基本操作名（参数表）初始条件《初始条件描述》操作结果《操作结果描述》参数表：赋值参数 职位操作提供输入值 引入参数&amp;打头 除可提供输入值外 还将返回操作结果 4算法 有穷性 确定性 可行性 输入 输出 算法的设计和要求 正确性 可读性 健壮性 高效性（鲁棒性） 5.算法的分析 1.时间效率 算法的时间效率的度量 算法运行时间＝每条语句频度语句执行一次时间 123456789n*n矩阵相乘的算法for(i=1;i&lt;=n,i++)//n+1次 for(j=1;j&lt;=n;j++)//n（n+1） c[i][j]=0;//n*n for(k=0;k&lt;=n;k++)//n*n*（n+1） c[i][j]=c[i][j]+a[i][k]*b[k][j];//n*n*n执行n*n*n T（n）为2n^3+3n^2+2n+1 算法时间复杂度的渐进表示法 比较算法比较我们仅仅比较数量级 T1(n)=10*n2和T2(n)=5n3 O 前者好 有一个辅助的f（n）使得当n无限大，T(N)/F(N)极限为不同为零的常熟 则称f（n）是t（n）的同数级函数 记作T(n)=O（f(n)） 称O（f(n)）为算法的渐进时间复杂度简称为时间复杂度 F(n)=nm+nm-1…则T(N)=o(N^M) 算法基本操作次数也和问题输入而不同 12345678910比如说 for(i=0;i&lt;n,i++) if(a[i]==e)return i+1; return 0;最好只有一次执行最坏要执行n次 最坏时间复杂度：最坏情况下最好时间复杂度：最好情况下平均时间复杂度为O(n) 复杂的算法，可以分成几部分利用O的加乘法则 加法T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))) 乘法T(n)=T1(n)xT2(n)=O(f(n))xO(g(n))=O((f(n)xg(n)) 2空间复杂度 算法所要的存储空间度量 S（n）=O（f（n）） n为为问题的规模 123456789101112将一维数组a的n个数逆序放到元素组for(i=0;i&lt;n/2;i++)&#123; t=a[i]; a[i]=a[n-i-1]; a[n-1-i]=t;&#125;//空间复杂度为O（1）for(i=0;i&lt;n;i++)b[i]=a[n-1-i];for(i=0;i&lt;n;i++) a[i]=b[i];//空间复杂度为O（n） 二.线性表linear list 1线性表的定义和特点 例子 如26英文字母 数据元素都是字母为线性 线性表的逻辑特征 在非空中有且仅有一个开始或者终端的结点，他没有前趋而仅有一个后续a2 或者没有后趋，而仅有一个直接前趋an-1 案例引入 一元多项式 2.线性表的类型定义 基本操作 lnitlist（&amp;L）构造一个空的线性表L DestroyList（&amp;L）初始条件线性表已经有了 操作结果摧毁线性表 ClearList（&amp;L）初始条件线性表存在了 操作结果重置为空表 ListEmpty（L）初始条件 线性表存在 操作结果如果为空表为ture ListLength（L）初始条件 线性表存在 操作结果返回L中数据元素个数 GetElem（L，i，&amp;e）初始太久存在 操作结果用e返回L中第i哥元素值 LocateElem（L，e，compare（））初始线性表存在，compare是数据元素判定函数 操作结果返回L中第一个与e满足compare的数据元素的位序若这样的数据元素不存在返回0 PriorElem(L,cur_e,&amp;pre_e)初始为L存在 操作结果cur_e为L的元素，不是第一个，则pre_e返回他的前驱，否则操作失败 pre_e没有意义 NextElem(L,cur_e,&amp;next_e)初始L存在，如果cur存在返回后继 Listinsert（&amp;L，i，e）L存在 L在第i个位置之前插入新的元素e，L的长度加1 ListDelete（&amp;L，i，&amp;e）L存在 删除L的第i个元素，用e返回，L减一。 ListTraversr（&amp;L，visited（））L存在 操作结果依次对线性表中每个元素调用visited（） 3.线性表的顺序表示和实现 12345678910111213141516171819//顺序表的类型定义typedef struct&#123; ElemType data[];//*data为动态分配 int length;&#125;SqList;//SqList L;L.data=(ElemType*)malloc(sizeof(ElemTAype)*M)////#define LIST_INTI_SIZE 100typedef struct &#123; int elem[LIST_INTI_SIZE]; int length;&#125;Sqlist; 12345678910111213141516171819202122//多项式的顺序存储结构类型定义#define MAXSIZE 1000//最大长度typedef struct &#123; float p; int e;&#125;Polynomial;typedef struct &#123; Polynomial* elem;//存储基地址//数组 int length;//当前的项个数&#125;SqList;//图书表的顺序存储#define MAXSIZE 1000typedef struct &#123; char no[20]; char name[50]; float price;&#125;book;typedef struct &#123; book* elem; int length;&#125;SqList; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &quot;stdio.h&quot; #include &quot;stdlib.h&quot; #include &quot;math.h&quot; #include &quot;time.h&quot;#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0//#define OVERFLOW -2#define INFEASIBLE -1#define MAXSIZE 20 typedef char ElemType;typedef int Status;typedef struct&#123; ElemType *elem; int length;&#125;SqList;//1.线性表的初始化Status InitList_Sq(SqList* L)&#123; //分配空间 L-&gt;elem = (ElemType*)malloc(sizeof(ElemType) * MAXSIZE); //L-&gt;elem = new ElemType[MAXSIZE]; C++写法 if (!L-&gt;elem)exit(OVERFLOW);//分配失败 L-&gt;length = 0; return OK;//空表长度为零&#125;//2.摧毁线性表Lvoid DestroyList(SqList* L)&#123; if (L-&gt;elem) free(L-&gt;elem);//delete L-&gt;elem;释放空间&#125;//3.清空线性表void ClearList(SqList* L)&#123; L-&gt;length = 0;//将线性表长度为0&#125;int GetLength(SqList* L)&#123; return (L-&gt;length);&#125;//4判断线性表为空int IsEmpty(SqList L)&#123; if (L.length == 0) return 1; else return 0;&#125;//5顺序表的取值int GetElem(SqList L, int i, ElemType&amp; e)&#123; if (i&lt;1 || i&gt;L.length) return ERROR; e = L.elem[i - 1]; return OK;&#125;//6插入Status Listlnsert_Sq(SqList* L, int i, ElemType e)&#123; int j; if (i&lt;1 || i&gt;L-&gt;length + 1)return ERROR; if (L-&gt;length == MAXSIZE) return ERROR; for (j = L-&gt;length; j &gt;= i - 1; j--) L-&gt;elem[j+1] = L-&gt;elem[j]; L-&gt;elem[i - 1] = e; L-&gt;length++; return OK;&#125;//7删除Status ListDelete_Sq(SqList* L, int i)&#123; int j; if (i&lt;1 || i&gt;L-&gt;length) return ERROR; for (j = i; j &lt;= L-&gt;length; j++) L-&gt;elem[j - 1] = L-&gt;elem[j]; L-&gt;length--; return OK;&#125;int main()&#123; SqList L; InitList_Sq(&amp;L); GetLength(&amp;L);&#125; 优点 存储量大 可以随机读取表中的元素 缺点 增删要移动大量元素 浪费存储空间 静态 4线性表的链式 结点：数据元素的存储映像。由数据域和指针域 链表：N个结点由指针域组成链表 它是线性表的链式存储映像名称为线性表的链性存储 1.单链表 结点只有一个指针域的链表 特点 结点在存储器的位置是任意的，即逻辑上相邻的数据元素，在物理上不一定 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后，寻找第一个和最后一个结点 栈与队列 栈与队列是两个常用的 栈与队列是限定插入和删除只能在表的端点进行的线性表 12Insert(S,n+1,x) Delete(S,n)Insert(Q,n+1,x) Delete(Q,1) 栈–后进先出 使得栈成为有用的工具，数据转换，表达式，函数调用，递归，括号 2队列–先进先出 解决排队问题 脱机打印 多用户系统 等 栈stack 特殊的线性表，是限定在一段，通常是表尾，进行插入和删除操作的线性表 相关概念 后进an top栈顶 表头a1为base 插入元素到栈顶叫入栈（压）push，反之为入栈（弹出）pop 栈的定义 定义：限定在表的一端进行插入和删除的运算线性表 逻辑结构：通线性表一对一的关系 存储结构：顺序表更常见 只能在栈顶运算 入栈和出栈函数 案例 进制转换 十进制N想其他进制数d（二八十六） **法则为：**除以d倒取余 n=（n div d）*d + n mod d div为整除运算 mod为求余 例子十进制159转八进制 1234159/8=19...719/8=2...32/8=0..2（237）8 括号匹配的验证 表达式求值 操作数和运算符和界限符 为了实现表达式求值设置两个栈 OPTR寄存运算符 操作数栈OPND用于寄存运算数和运算结果 栈的表示和操作 1234567ADK Stack&#123;数据对象D=&#123;ai|ai属于ElemSet&#125;数据关系R1=&#123;&lt;ai-1,ai&gt;&#125;an端为栈顶，a1为栈底初始化 进栈出栈 取栈顶等&#125;ADT Stack 1234567891011121314151617InitStack(&amp;S)初始化操作 构造一个空栈SDestoryStack(&amp;S) 销毁栈操作初始条件S存在，结果销毁StackEmpty 判断是否为空S存在 空true 否为falseStackLength(S)求栈的长度S存在 返回S的个数，即栈长度GetTop(S,&amp;e)去栈顶S存在且为空用e返回S的栈顶元素ClearStack清空Push(&amp;S,e)入栈 顺序栈的实现，同一般线性表的顺序存完全相同 123456#define MAXSIZE 100typedef struct&#123; SElemType *base; SElemType *top; int stacksize&#125;Sqstack; 初始化 1234567Status InitStack(SqStack &amp;S)&#123; S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType)); if(!S.base)exiu(OBERFLOW); S.top=S.base; S.stacksize=MAXSIZE; return OK;&#125; 判断是否为空 12345Status StackEmpty(SqStack S)&#123; if(S.top==S.base)return TRUE; else return FALSE;&#125; 顺序栈长度 123int StackLength(SqStack S)&#123;return S.top-S.base;&#125; 清空 1234Status ClearStack(Sqstack &amp;S)&#123;if(S.base)S,top=S.base;return OK;&#125; 销毁 12345678Status DestroyStack(Sqstack &amp;S)&#123; if(S.base)&#123; delete S.base; S.stacksize=; S.base=S.top=NULL; &#125; return OK;&#125; 入栈 123456Status Push (SqStack &amp;S,SElemType e)&#123; if(S.top-S.base==S.stacksize)return ERROR; *S.top=e; S.top++; return OK;&#125; 出栈 12345Status Ppo(SqStack &amp;S,SElemType&amp;e)&#123; if(S.top==S.base)return ERROEL; E=*--s.TOP; return OK;&#125; 链栈 123456typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStack;LinkStack S; 链表的初始化 1234void InitStack(LinkStack &amp;S)&#123; S=NULL; return ok;&#125; 入栈 1234567Status Push(LinkStack &amp;S,SElemType e)&#123; p=new stacknoode; p-&gt;data=e; p-&gt;newt=S; S=p; return OK;&#125; 出栈 12345678Status Pop(LinkStack&amp;S,SElemTyoe &amp;e)&#123; if(S==NULL)return ERROE; e=s-&gt;data; p=S; S=S-&gt;next; delete p; &#125; 栈与递归 递归定义的函数 递归数据结构 递归解法 队列queue 先进先出FiFO 表一插入，在另一端表头删除 队列的相关概念 定义 头删尾插 逻辑结构 一对一先信标 循环和链队 之恶能在对手和队尾 入和出 队 树 树的定义 Tree是由包括零，多个结点的有限集，分为空树 �限集，分为空树","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kaguranotamashii.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://kaguranotamashii.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"C++学习笔记","slug":"[main]CS/[main]computer-language/CPP学习笔记","date":"2022-01-12T11:52:47.000Z","updated":"2023-03-21T08:40:03.482Z","comments":true,"path":"posts/16346/","link":"","permalink":"https://kaguranotamashii.github.io/posts/16346/","excerpt":"C++的学习笔记，恐怕要22年暑假才能学完吧","text":"C++的学习笔记，恐怕要22年暑假才能学完吧 1.C++认识 1.1 123456789101112#include&lt;iostream&gt;using namespace std:int main()&#123; cout&lt;&lt;&quot;hello world&quot;&lt; system(&quot;pause&quot;); return 0;&#125;cin&gt;&gt;a&gt;&gt;b;&lt; 初识输入输出 C++包含了一个全面的标准库（standard library）来提供IO机制（以及很多其他设施）。 iostream库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。 标准输入输出对象 标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为标准输入（standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为标准输出（standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为标准错误（standard error）。clog用来输出程序运行时的一般性 12345678910#include&lt;iostream&gt;int main() &#123; std::cout &lt;&lt; &quot;ënter two numbers&quot; &lt;&lt; std::endl; int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; &quot;the sum of&quot; &lt;&lt; v1 &lt;&lt; &quot;and&quot; &lt;&lt; v2 &lt;&lt; &quot;is&quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl; return 0;&#125; 这条语句执行了一个表达式（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了输出运算符（&lt;&lt;）。 &lt;&lt;运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。 &quot;Enter two numbers&quot;是一个字符串字面值常量（string literal），它是用一对双引号包围的字符序列。 endl是一个被称为操纵符（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。 前缀std::指出名字cout和endl是定义在名为std的命名空间（namespace）中的。 命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。 从流读取数据 首先定义两个名为v1和v2的变量（variable）来保存输入： 1int v1 = 0, v2 = 0; 这两个变量被定义为int类型，并初始化（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。 1std::cin &gt;&gt; v1 &gt;&gt; v2; 这条语句读入输入数据。输入运算符（&gt;&gt;）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。 变量和基本类型 基本类型 C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，如可作为函数的返回值。 要想定义一个名为units_sold的int变量并初始化为0，以下4条语句都可以做到这一点： 1234int units_sold = 0;int units_sold = &#123;0&#125;;int units_sold(0);int units_sold&#123;0&#125;; 作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。这种初始化的形式被称为列表初始化（list initialization）。 当用于内置类型的变量时，这种初始化形式有一个重要特点，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。 void*指针 void*是一种特殊的指针类型，可用于存放任意对象的地址。 利用void指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void指针。不能直接操作void*所指的对象。 字符串 数组 命名空间的using声明 有如下形式： 1using namespace::name; 使用完using声明（using declaration）后，就可以省略掉名字前的前缀了（如std::）。 1234567891011#include &lt;iostream&gt;using std::cin;int main()&#123; int i; cin &gt;&gt; i; cout &lt;&lt; i; // 错误，没有对应的using声明，必须使用完整的名字 return 0;&#125; 头文件不应包含using声明 这是因为头文件会被其它文件引用，从而使其它文件也使用了using声明，有可能造成命名冲突。 标准库类型string string表示可变长的字符序列。使用string类型需要包含string头文件。 初始化string对象的方式： 123456string s1; // 默认初始化，s1是一个空串string s2(s1); // s2是s1的副本string s2 = s1; // 等价于s2(s1)string s3(&quot;value&quot;); // s3是字面值&quot;value&quot;的副本，不包括最后的空字符string s3 = &quot;value&quot;; // 等价于s3(&quot;value&quot;)string s4(n, &#x27;c&#x27;); // 初始化为由n个字符c组成的串 直接初始化和拷贝初始化 如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是直接初始化（direct initialization）。 123string s5 = &quot;hiya&quot;; // 拷贝初始化string s6(&quot;hiya&quot;); // 直接初始化string s7(10, &#x27;c&#x27;); // 直接初始化 string对象上的操作 string对象上的操作 如： os &lt;&lt; s, 将s写入输出流os当中，返回os is &gt;&gt; s，从输入流中读取字符串赋值给s，字符串以空白分隔，返回is getline(is, s)，从输入流中读取一行赋值给s，返回is s.empty()，如果s为空，返回true s.size()，返回s中的字符数，与s.length()等价 s[n]，返回s中第n个字符的引用 s1 + s2，返回s1和s2连接后的结果 s1 = s2，用s2的副本代替s1 s1 == s2，s1 != s2，如果s1和s2完全一样，则相等 &lt;, &lt;=, &gt;, &gt;=，顺序比较字符大小，完全一致再比较长度 getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。 标准库类型vector vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。 vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。 vector是模板而非类型，由vector生成的类型必须包含元素的类型，如： 1vector&lt;int&gt; v; vector中存放的是对象，而引用不是对象，故不能存储引用。 定义和初始化vector对象 vector模板控制着初始化向量的方法。 定义vector对象的方法有： vector&lt;T&gt; v1，默认初始化，v1是一个空的vector vector&lt;T&gt; v2(v1)，v2中包含v1所有元素的副本 vector&lt;T&gt; v2 = v1，等价于v2(v1) vector&lt;T&gt; v3(n, val)，v3包含了n个重复的元素，每个元素的值都是val vector&lt;T&gt; v4(n)，v4包含了n个执行了值初始化的对象 vector&lt;T&gt; v5&#123;a,b,c...&#125;，v5里包含了用a,b,c…初始化的元素 vector&lt;T&gt; v5 = &#123;a,b,c...&#125;，等价于vector&lt;T&gt; v5&#123;a,b,c...&#125; 值初始化 值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。 vector&lt;T&gt;(n)中，所有元素将执行值初始化。 向vector中添加元素 push_back函数把一个元素压入vector对象的尾端。 vector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。 一定不能在遍历vector的时候改变vector对象的大小。 第七章 类 类的基本思想是数据抽象(data abstraction)和封装(encapsulation)。 数据抽象就是接口(interface)与实现(implementation)分离的技术。 接口就是暴露给用户的操作，比如公有的成员函数。 实现就是数据成员、接口的实现、私有的成员函数。 通过抽象数据类型(abstract data type)，来实现数据抽象和封装。","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"cpp","slug":"编程/cpp","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://kaguranotamashii.github.io/tags/cpp/"}]},{"title":"通信学院期末C复习题","slug":"[main]CS/[main]computer-language/期末考试C语言复习题","date":"2021-12-16T08:12:14.000Z","updated":"2022-07-16T15:37:41.549Z","comments":true,"path":"posts/37971/","link":"","permalink":"https://kaguranotamashii.github.io/posts/37971/","excerpt":"BISTU 通信学院2021C语言期末考试题 每道题一定有多个写法，碍于时间我不能全部写出来，也没有这个能力，所以这些答案仅仅用于参考 因为写的时间紧所以可能有些小的错误 请多见谅","text":"BISTU 通信学院2021C语言期末考试题 每道题一定有多个写法，碍于时间我不能全部写出来，也没有这个能力，所以这些答案仅仅用于参考 因为写的时间紧所以可能有些小的错误 请多见谅 A易 A阶段中大多数都是简单的题 12345主要的知识点为if，math.h里面的函数ASCII%d %fint char float等类型 1.温度转换 12345678910#include&lt;stdio.h&gt;int main()&#123; float f,c; printf(&quot;请输入华氏温度:&quot;); scanf(&quot;%f&quot;,&amp;f); c=(5.0/9)*(f-32); printf(&quot;转换成摄氏度是:%f\\n&quot;,c); return 0;&#125; 2.BMl计算 输入身高（米）和体重（千克）计算 BMI 值，其中 BMI 值计算公式为，BMI = 体 重/身高^2。（实验一题目） 12345678#include&lt;stdio.h&gt;int main()&#123; float bmi, h, w; scanf_s(&quot;%f %f&quot;, &amp;h, &amp;w); bmi = w / (h * h); printf(&quot;%f&quot;, bmi);&#125; 3.大写转小写 给定一个大写字母，要求用小写字母输出。提示：大写字母比小写字母的 ASCII 码 小 32。（第 3 章例题 123456789#include&lt;stdio.h&gt;int main()&#123; char a; scanf(&quot;%c&quot;,&amp;a); a=a+32;//ASCii中大写在前面 printf(&quot;%c&quot;,a); &#125; 4.由小到大排列 输入两个实数，按由小到大的顺序输出这两个数。（第 4 章例题 12345678910#include&lt;stdio.h&gt;int main()&#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); if(a&lt;b) printf(&quot;%d&lt;%d&quot;,a,b); else printf(&quot;%d&lt;%d&quot;,b,a);&#125; 5.一元二次方程 求 ax2+bx+c=0 方程的根。a,b,c 由键盘输入。需要在程序中进行判别，如果 b2- 4ac≥0，就计算并输出方程的两个实根，如果 b2-4ac&lt;0，就输出“此方程无实根” 的信息。（第 4 章例题 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;math.h&gt;//提供sqrt函数int main()&#123; float a, b, c; scanf_s(&quot;%f %f %f&quot;, &amp;a, &amp;b, &amp;c); float data; data = (b * b - 4 * a * c); if (data &lt; 0) &#123; printf(&quot;没有实数根&quot;); &#125; else if (data == 0) &#123; printf(&quot;x=%f&quot;, ((-b) / 2 * a)); &#125; else &#123; printf(&quot;x1=%f x2=%f&quot;, (sqrt(data)) - b / 2 * a, (-sqrt(data)) - b / 2 * a); &#125; &#125; 6.计算三角形面积 给出三角形的三边长，求三角形面积。 这题可以通过海伦公式快速解题 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; float a, b, c; float p; scanf_s(&quot;%f %f %f&quot;, &amp;a, &amp;b, &amp;c); p = (a + b + c) / 2; if (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) &#123; printf(&quot;%f&quot;, sqrt(p * (p - a) * (p - b) * (p - c))); &#125; else printf(&quot;三角形不存在\\n&quot;);&#125; 7.判断是否为大写 输入一个字符，判别它是否为大写字母，如果是，将它转换成小写字母；如果不是， 不转换。然后输出最后得到的字符。（第 4 章例题 12345678910111213// 输入一个字符，判断它是否为大写字母，如果是，将它转换成小写字母，如果不是不转换 #include &lt;stdio.h&gt; int main()&#123; char ch; scanf(&quot;%c&quot;,&amp;ch); if(ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) ch = ch + 32; printf(&quot;%c\\n&quot;,ch);&#125; 8.成绩等级 输入一个学生的成绩，使用 if else 语句输出该同学的成绩属于以下哪个等级。（实 验二） 60 分以下：不及格 60-70 分：及格 70-90 分：良好 90-100 分：优秀 123456789101112#include &lt;stdio.h&gt;int main()&#123; int score; scanf_s(&quot;%d&quot;, &amp;score); if (score &gt;= 90) printf(&quot;优\\n&quot;); if (score &gt;= 80 &amp;&amp; score &lt;= 89) printf(&quot;良\\n&quot;); if (score &gt;= 70 &amp;&amp; score &lt;= 79) printf(&quot;中\\n&quot;); if (score &gt;= 60 &amp;&amp; score &lt; 69) printf(&quot;及格\\n&quot;); if (score&lt;60) printf(&quot;不及格\\n&quot;);&#125; 9国民生产 假如我国国民生产总值的年增长率为 7%，计算 10 年后我国国民生产总值与现在 相比增长多少百分比。计算公式为p=(1+r)^n n为年 r为增长率 1234567891011#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; float p,r,n; r=0.07; n=10; p=pow(1+r,n); //pow(a,b)a的b次幂 printf(&quot;p=%f\\n&quot;,p);&#125; 10.破解密码 请编程序将“China”译成密码，密码规律是：用原来的字母后面的第 4 个字 母代替原来的字母。例如，字母“A”后面第 4 个字母是“E”，用“E”代替“A”。 字母表最后四个字母“WXYZ”，替代为“ABCD”。因此，“China”应译为“Glmre”。 （第 3 章课后习题 123456789101112#include&lt;stdio.h&gt;int main()&#123; char c1=&#x27;C&#x27;,c2=&#x27;h&#x27;,c3=&#x27;i&#x27;,c4=&#x27;n&#x27;,c5=&#x27;a&#x27;; c1 = c1 + 4; c2 = c2 + 4; c3 = c3 + 4; c4 = c4 + 4; c5 = c4 + 4; printf(&quot;%c%c%c%c%c\\n&quot;, c1, c2, c3, c4, c5);&#125; B中 12到这里就开始出现if while for switch等函数 11.闰年 典中典的题了 判断分两种情况，一个是能被400整除，一个是能被4整数但不能被100整除 四年一闰,百年不闰 四百年再闰 1if(a%400==0||a%4==0&amp;&amp;a%100!=0) 12.阶乘 用 C 语言求 12!，并画出流程图。（第 5 章课后习题） 123456789#include&lt;stdio.h&gt;int main()&#123; int n, sum = 1; for (int i = 1; i &lt;= 12; i++) sum = sum * i; printf(&quot;%d&quot;, sum);&#125; 13.判断位数 使用循环结构设计一个程序，用户从终端输入一个整数，输出其是几位整数。 （实验二） 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int n = 0, a; scanf_s(&quot;%d&quot;, &amp;a); while (a &gt; 0) &#123; a = a / 10; n++; &#125; printf(&quot;%d&quot;, n);&#125; 14.逆转数字 从键盘输入一个四位的整数 num，将其个、十、百、千位倒序生成一个数字输 出。例如：输入 1234，输出 4321。（第 4 章课后习题） 123456789101112#include&lt;stdio.h&gt;int main()&#123; int a,b=0; scanf_s(&quot;%d&quot;, &amp;a); while (a&gt;0) &#123; b = b * 10 + a % 10; a = a / 10; &#125; printf(&quot;%d&quot;, b);&#125; 15.分段函数 y=x (x&lt;1) 2x-1(1&lt;=x&lt;10) 3x-11(x=&gt;10) 123456789101112#include&lt;stdio.h&gt;int main()&#123; int x,y; scanf_s(&quot;%d&quot;,&amp;x); if (x &lt; 1) printf(&quot;%d&quot;,x); else if (1 &lt;= x &amp;&amp; x &lt; 10) printf(&quot;%d&quot;,2*x - 1); else if (x &gt;= 10) printf(&quot;%d&quot;,3*x - 11);&#125; 16.流程控制 用 switch 语句处理菜单命令。在许多应用程序中，用菜单对流程进行控制，例 如从键盘输入一个字符个’A’或’a’字符，就会执行 A 操作，输入一个’B’或’b’字符， 就会执行 B 操作。A 操作和 B 操作可以用自定义函数的形式实现，例如 A 操作是 执行加法计算，B 操作是执行减法计算。（第 4 章例题 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int add(int x,int y)&#123; return x+y;&#125;int min(int x,int y)&#123; return x-y;&#125;int main()&#123; char ch; scanf(&quot;%c&quot;,&amp;ch); int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); switch(ch) &#123; case &#x27;a&#x27;: case &#x27;A&#x27;:printf(&quot;%d&quot;,add(a,b));break; case &#x27;b&#x27;: case &#x27;B&#x27;:printf(&quot;%d&quot;,min(a,b));break; default:putchar(&#x27;\\a&#x27;); &#125;&#125; 17.高斯算法 1+2+3+…+100。并画出流程图。（第 5 章例题 12345678910#include&lt;stdio.h&gt;int main()&#123; int sum=0; for(int i=1;i&lt;=100;i++) &#123; sum=sum+i; &#125; printf(&quot;%d&quot;,sum);&#125; 18.pi 用公式 π/4≈1−1/3+1/5−1/7+⋯求 π 的近似值，直到发现某一项的绝对值小 于 10-6为止(该项不累加)。（第 5 章例题 1234567891011121314#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main()&#123; double a=0.0,b=1.0,t=1.0; for(int i=3;fabs(b)&gt;1e-6;i+=2)//fabs函数为double型的绝对值，1e-6表示1*10的-6次方 &#123; a=a+b; t=-t; b=t/i; &#125; printf(&quot;PI=%f\\n&quot;,4*a); return 0;&#125; 19.e 数学常量 e 的值可以用一个无穷级数表示：e = 1 + 1/1! + 1/2! + 1/3! +……。编写程序，用下面的公式计算 e 的近似值：1 + 1/1! +1/2! + 1/3! +……+ 1/n!，其中 n 是用户输入的整数。请给出 n=50 时，e 的近似值。（循环 嵌套，pi 值程序的提升 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int n; scanf_s(&quot;%d&quot;, &amp;n); double e=1,sum=1; for (int i = 1; i &lt;=n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; sum = sum * j; &#125; e = (1/sum) + e; sum = 1; &#125; printf(&quot;%lf&quot;, e);&#125; 20.百钱百鸡 百钱百鸡：中国古代数学家张丘建在他的《算经》中提出了一个著名的“百钱 百鸡问题”：一只公鸡值五钱，一只母鸡值三钱，三只小鸡值一钱，现在要用百钱 买百鸡，请问公鸡、母鸡、小鸡各多少只？（第 5 章例题） 123456789101112131415161718//穷举法#include&lt;stdio.h&gt;int main()&#123; for (int i = 0; i &lt;=100; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; for (int k = 0; k &lt; 100; k++) &#123; if (5 * i + 3 * j + k / 3 == 100 &amp;&amp; k % 3 == 0 &amp;&amp; i + k + j == 100) &#123; printf(&quot;公鸡%d 母鸡%d 小鸡%d\\n&quot;, i, j, k); &#125; &#125; &#125; &#125;&#125; 21.捐钱 在全系 1000 名学生中举行慈善募捐，当总数达到 10 万元时就结束，统计此 时捐款的人数以及平均每人捐款的数目。（第 5 章例题） 123456789101112131415#include&lt;stdio.h&gt;main()&#123; int sum = 0, a, counter = 0; printf(&quot;请输入每人捐款的钱数：\\n&quot;); while (1) &#123; scanf_s(&quot;%d&quot;, &amp;a); sum += a; counter++; if (sum &gt;= 100000) break; &#125; printf(&quot;%d\\n&quot;, counter);&#125; 22.整除 要求输出 100～200 之间的不能被 3 整除的数。（第 5 章例题 1234567891011#include&lt;stdio.h&gt;int main()&#123; for(int i=100;i&lt;=200;i++) &#123; if(i%3==0) &#123; printf(&quot;%d&quot;,i); &#125; &#125;&#125; 23.质数（素数） 判断是不是质数分两种情况 一个是1它不是质数 如果大于1不能被2到n-1整除它是素数 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int i, n; scanf_s(&quot;%d&quot;, &amp;n); if (n &lt;= 1) printf(&quot;不是\\n&quot;); else &#123; for (i = 2; i &lt; n; i++) &#123; if (n % i == 0) break; &#125; if (i == n) printf(&quot;是\\n&quot;); else printf(&quot;不是\\n&quot;); &#125; return 0;&#125; 24.阶乘 编程求 1！+2！+3！+4！+……+12！。（！为阶乘符号）（第 5 章课后习题 类似12题 25.水仙花数 输出所有的水仙水仙花数花数，所谓水仙花数就是一个 3 位数，其各位数字立方和等于 该数本身。例如 153 是水仙花数 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int a, b, c,i;//百位十位个位 for (i = 100; i &lt; 1000; i++) &#123; a = i / 100; b = i / 10 % 10; c = i % 10; if (i == a * a * a + b * b * b + c * c * c) &#123; printf(&quot;%d\\n&quot;, i); &#125; &#125;&#125; 26.一道数学题 一个球从 100 米高度落下，每次落地后跳回原高度的一半，再落下，编程求第 10 次落地时，球共经过的距离为多少米？第 10 次落地后的反C弹高度是多少米？ （第 5 章课后习题 123456789101112#include&lt;stdio.h&gt;int main()&#123; double gao=100.0; double sum; for(int i=0;i&lt;9;i++) &#123; gao=gao/2; sum=sum+gao*2; &#125; printf(&quot;%f %f&quot;,gao,sum);&#125; 27.依次找到最大数 编写程序，找出用户输入的一串数中的最大数。程序需要提示用户一个一个地 输入数。当用户输入 0 或者负数时，程序必须显示出已输入的最大非负数。（循环、 输入函数 1234例Enter a number:60 Enter a number:78.5 Enter a number:1203 Enter a number:100The largest number entered was 1203 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int max = 0, n = 1; do &#123; scanf_s(&quot;%d&quot;, &amp;n); if (max &lt; n) &#123; max = n; &#125; &#125; while (n &gt; 0); printf(&quot;%d&quot;, max);&#125; 28.杨辉三角形 12345611 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1 1234567891011121314151617181920212223//从第二行开始，每一个数=该数上面的数+该数上面数的前一个数，即：a[ i ][ j ]=a[ i-1 ][ j ]+a[ i-1 ][ j-1 ]#include &lt;stdio.h&gt;int main()&#123; int i, j, n; int a[100][100] = &#123; 0 &#125;; printf(&quot;请输入行数：&quot;); scanf_s(&quot;%d&quot;, &amp;n); for (i = 0; i &lt;= n; i++) a[i][0] = 1; //每一行第一个数为1 for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= i; j++) a[i][j] = a[i - 1][j - 1] + a[i - 1][j]; //从每一行第二个数开始循环 &#125; for (i = 0; i &lt;= n; i++) &#123; for (j = 0; j &lt;= i; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); //输出（每一行输出完换行） &#125; return 0;&#125; 29.四个数字空格 写一个函数，输入一个 4 位数字，要求输出这 4 个数字字符，但是每两个数字 间空一个空格。如输入 1990，应输出“1 9 9 0”。（第 7 章课后习题） 12345678910111213141516#include&lt;stdio.h&gt;void prnnum(int s)&#123; if(s==0) return; int n; n=s % 10; s/=10; prnnum(s);//递归 printf(&quot;%d %d %d %d&quot;,n);&#125;int main()&#123; prnnum(5432); return 0;&#125; 30.冒泡法 写一个函数，用“起泡法”对输入的 10 个字符按由小到大的顺序排序。（ 12345678910111213141516void qipaofa(int a[])&#123; for(int i=0;i&lt;9;i++) &#123; for(j=0;j&lt;10-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; int swap; swap=a[j]; a[j]=a[j+1]; a[j+1]=swap; &#125; &#125; &#125;&#125; 31.十六进制 写一个函数，输入一个十六进制数，输出相应的十进制数。（第 7 章课后习题 12345678910111213#include &lt;stdio.h&gt;void xtod(int x); int main()&#123; int i; scanf(&quot;%x&quot;, &amp;i); xtod(i); return 0;&#125;void xtod(int x)&#123; printf(&quot;%d\\n&quot;, x);&#125; C难 123**到这里后大多就接触到数组以及指针和函数结构体等重量级****难度比较大** 32.打印字符串 编写一个函数，接受 3 个参数：一个字符和两个整数。字符参数是待打印的字 符，第 1 个整数指定一行中打印字符的次数，第 2 个整数指定打印字符的行数。编 写一个调用此函数的程序。（函数、循环、字符变量） 123456示例：Enter a character (# to quit): sEnter number of columns and number of rows: 5 2ssssssssss 123456789101112131415161718192021#include&lt;stdio.h&gt;void hanshu(char c, int n, int m)&#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\\n&quot;); &#125;&#125;int main()&#123; char c; scanf_s(&quot;%c&quot;, &amp;c); int n, m; scanf_s(&quot;%d %d&quot;, &amp;n, &amp;m); hanshu(c, n, m);&#125; 33.最大小之差 编写一个函数，返回存储在 double 类型数组中的最大值和最小值的差值，并 在一个简单的程序中调用测试该函数。（函数、一维数组、数组作为函数参数 1234567891011121314151617181920212223#include&lt;stdio.h&gt;double max_min(double a[3])&#123; double min=9999999,max=-1; for (int i = 0; i &lt; 3; i++) &#123; if (a[i] &lt; min) &#123; min = a[i]; &#125; if (a[i]&gt;max) &#123; max = a[i]; &#125; &#125; return max - min;&#125;int main()&#123; double a[3]=&#123;234.0,324.0,5.4&#125;; printf(&quot;%f&quot;, max_min(a));&#125; 35.数组相加 编写一个函数，把两个数组中相对应的元素相加，然后把结果储存到第 3 个数 组中。也就是说，如果数组 1 中包含的值是 2、4、5、8,数组 2 中包含的值是 1、 0、4、6，那么该函数把 3、4、9、14 赋给第 3 个数组。函数接受 3 个数组名和一 个数组大小。在一个简单的程序中调用测试该函数。（函数、一维数组、数组作为函 数参数 1234567891011121314151617181920#include&lt;stdio.h&gt;void add(int a[], int b[], int c[])//两个数组相加&#123; for (int i = 0; i &lt; 5; i++) &#123; c[i] = a[i] + b[i]; &#125;&#125;int main()&#123; int a[5] = &#123; 1,2,3,4,5 &#125;; int b[5] = &#123; 1,2,3,4,5 &#125;; int c[5]; add(a, b, c); for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, c[i]); &#125;&#125; 36.数组扩大 编写一个程序，声明一个 int 类型的 3×5 二维数组，并用合适的值初始化它。 该程序打印数组中的值，然后各值翻倍(即是原值的 2 倍)，并显示出各元素的新值。 编写一个函数显示数组的内容，再编写一个函数把各元素的值翻倍。这两个函数都 以数组名和行数作为参数。（函数、二维数组、数组作为函数参数，实验三 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;void add(int a[][5], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; a[i][j] = a[i][j] * 2; &#125; &#125;&#125;void print(int a[][5], int n)&#123; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; printf(&quot;%d &quot;, a[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125;int main()&#123; int a[3][5] = &#123; &#123;21,321,31,23,34,&#125;, &#123;34,324,2343,24,423&#125;, &#123;23,432,432,4,43&#125; &#125;; printf(&quot;原来的\\n&quot;); print(a, 3); add(a, 3); printf(&quot;\\n&quot;); print(a, 3);&#125; 37.返回最大下标 编写一个函数，返回储存在 int 类型数组中的最大值；编写一个函数，返回储 存在 double 类型数组中最大值的下标；编写一个函数，把 double 类型数组中的 数据倒序排列。在一个简单的程序中调用并测试这三个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;void funtion_1(int funtion1[]);void funtion_1(int funtion1[])&#123; printf(&quot;第一个函数\\n&quot;); int max = -1; for (int i = 0; i &lt; 5; i++) &#123; if (funtion1[i]&gt;max) &#123; max = funtion1[i]; &#125; &#125; printf(&quot;%d\\n&quot;, max);&#125;void funtion_2(double funtion2[]);void funtion_2(double funtion2[])&#123; printf(&quot;第二个函数\\n&quot;); int k = 0; double aa = funtion2[0]; for (int i = 0; i &lt; 5; i++) &#123; if (funtion2[i] &gt; aa) &#123; aa = funtion2[i]; k = i; &#125; &#125; printf(&quot;%d\\n&quot;, k+1);&#125;void funtion_3(double funtion3[]);void funtion_3(double funtion3[])&#123; printf(&quot;第三个函数\\n&quot;); for (int i = 4; i &gt;= 0; i--) &#123; printf(&quot;%f \\n&quot;,funtion3[i]); &#125;&#125;int main()&#123; int funtion1[5] = &#123; 5,9,2,1,9 &#125;; double funtion2[5] = &#123; 1.0,6.0,3.0,7.0,9.9 &#125;; double funtion3[5] = &#123; 1.0,2.0,3.0,4.0,8.0&#125;; funtion_1(funtion1); printf(&quot;\\n&quot;); funtion_2(funtion2); printf(&quot;\\n&quot;); funtion_3(funtion3);&#125; 38.多功能数组 编写一个程序，提示用户输入 3 组数，每组数包含 5 个 double 类型的数（假 设用户都正确地响应，不会输入非数值数据）。该程序应完成下列任务。 a.把用户输入的数据储存在 3×5 的数组中 b.计算每组(5 个)数据的平均值 c.计算所有数据的平均值 d.找出这 15 个数据中的最大值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;void sc_anf(double a[][5],int n)//输入函数&#123; double val; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; scanf_s(&quot;%lf&quot;, &amp;val); a[i][j] = val; &#125; &#125;&#125;void average_zu(double a[][5], int n)//每组的平均数&#123; double av_zu=0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; av_zu = av_zu + a[i][j]; &#125; av_zu = av_zu / 5; printf(&quot;%f\\n&quot;, av_zu); av_zu = 0; &#125;&#125;double average_quanbu(double a[][5], int n)//所有的平均数&#123; double av_zu=0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; av_zu = av_zu + a[i][j]; &#125; &#125; printf(&quot;\\n&quot;); return av_zu / 15;&#125;void max(double a[][5], int n)//最大&#123; double max = -1; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; if (a[i][j] &gt; max) &#123; max = a[i][j]; &#125; &#125; &#125; printf(&quot;%f\\n&quot;, max);&#125;int main()&#123; double a[3][5]; sc_anf(a, 3); average_zu(a, 3); average_quanbu(a, 3); /*for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; printf(&quot;%f\\n&quot;, a[i][j]); &#125; &#125; */ max(a, 3);&#125; 39.平均数等计算 编写程序读入一个整数数组，用于保存 5 个学生的课程成绩，然后用函数调用 的形式实现课程的平均分、最高分和最低分的计算。（数组、循环 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;void hanshu(int a[])&#123; int max = -1, min = 999; double sum = 0; for (int i = 0; i &lt; 5; i++) &#123; sum = sum + a[i]; if (a[i]&lt;min) &#123; min=a[i]; &#125; if (a[i]&gt;max) &#123; max=a[i]; &#125; &#125; printf(&quot;课程平均分是：%.2f 最高分是：%d 最低分是 %d&quot;, sum / 5, max, min);&#125;int main()&#123; int chengji[5]; for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;请输入%d位同学的成绩;&quot;, i + 1); scanf_s(&quot;%d&quot;, &amp;chengji[i]); &#125; hanshu(chengji);&#125; 40.指针数组 编写一个程序，输入月份号，输出该月的英文月名。例如，输入 3，输出“March”， 要求按照指针数组处理。（第 8 章课后习题 1234567891011#include &lt;stdio.h&gt;int main()&#123; int n; char *p[12] = &#123;&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;&#125;; printf(&quot;请输入月份：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;英文是：%s\\n&quot;,*(p + n - 1));//因为*(p)z&#125; 41.相反顺序 编写一个程序，将数组 a 中 n 个整数按相反顺序存放，需使用指针变量作为实 参。（第 8 章课程例题 123456789101112131415161718192021#include &lt;stdio.h&gt;void xiangfan(int a[])&#123; int* p, * q, tmp; for (p = a, q = a + 9; p &lt; q; ++p, --q) &#123; tmp = *p; *p = *q; *q = tmp; &#125; for (p = a; p &lt; a + 10; ++p) printf(&quot;%d &quot;, *p); printf(&quot;\\n&quot;);&#125;int main()&#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,0&#125;; xiangfan(a); return 0;&#125; 42.复制字符串 [编写一个程序，将字符串 a 复制为字符串 b，然后输出字符串 b。要求使用指 针变量处理。（第 8 章课程例题 12345678910111213#include&lt;stdio.h&gt;void strcpy(char* a, char* b)&#123; while ((*b++ = *a++) != &#x27;\\0&#x27;);&#125;int main()&#123; char a[10] = &quot;love you&quot;; char b[10]; strcpy(a, b); printf(&quot;%s&quot;, b);&#125; 43.输出结构体 12把一个学生的信息(包括学号、姓名、性别、住址)放在一个结构体变量中，然后输出这个学生的信息。（第 9 章课程例题 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; struct MyStruct &#123; int xuehao; char name[100]; char sex[100]; char zhizhu[100]; &#125;MyStruct = &#123; 20210000,&quot;syr&quot;,&quot;nan&quot;,&quot;beijing&quot;&#125;; printf(&quot;%d &quot;, MyStruct.xuehao); printf(&quot;%s &quot;, MyStruct.name); printf(&quot;%s &quot;, MyStruct.sex); printf(&quot;%s &quot;, MyStruct.zhizhu);&#125; 44.民主选票 结构体数组：有 3 个候选人，每个选民只能投票选一人，要求编一个统计选票 的程序，先后输入被选人的名字，最后输出各人得票结果（第 9 章课程例题） 12345678910111213141516171819202122#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define PEOPLE 10struct person &#123; char name[20]; int count; &#125;people[3] = &#123; &quot;SYR&quot;,0,&quot;LCJ&quot;,0,&quot;WJL&quot;,0 &#125;; int main()&#123; int i, j; char people_name[20]; for (i = 1; i &lt;= PEOPLE; i++) &#123; scanf_s(&quot;%s&quot;, &amp;people_name,20); for (j = 0; j &lt; 3; j++) if (strcmp(people_name, people[j].name) == 0) //strcmp(a,b)如果a和b字符相同返回0 people[j].count++; &#125; for (i = 0; i &lt; 3; i++) printf(&quot;%s:%d\\n&quot;, people[i].name, people[i].count);&#125; 46.结构体指针 有 3 个学生的信息，放在结构体数组中，要求输出全部学生的信息。要求使用 结构体指针有关知识。（第 9 章课程例题 123456789101112131415161718#include&lt;stdio.h&gt;struct stduents&#123; char name[20]; char sex[20]; int age;&#125;;struct stduents st[3] = &#123;&#123;&quot;syr&quot;,&quot;nan&quot;,19,&#125;,&#123;&quot;lcj&quot;,&quot;nv&quot;,19&#125;,&#123;&quot;wjl&quot;,&quot;nv&quot;,19&#125;&#125;;int main()&#123; struct stduents* p; //*p = st[0]; for (p=st;p&lt;st+3; p++) &#123; printf(&quot;%s %s %d\\n&quot;, p-&gt;name,p-&gt;sex, p-&gt;age); &#125; &#125; D难 到这里后就开始对指针和结构体进一步深入学习 1到这里应该会灵活运用指针来修改结构体数 47.用指针排序 编写一个程序，用指针方法对 10 个整数按由大到小顺序排序，要求使用选择 排序法。（指针、数组、排序算法） 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;void paixu(int* p, int n);int main()&#123; int a[10], * p, i; for (i = 0; i &lt; 10; i++) &#123; scanf_s(&quot;%d&quot;, &amp;a[i]); &#125; paixu(a, 10); for (i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; return 0;&#125;void paixu(int* a, int n)&#123; int i, j, temp; for (i = 0; i &lt; n - 1; i++) &#123; for (j = 0; j &lt; n - 1 - i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125;&#125; 48.平方排序 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组， 要求也按非递减顺序排序。要求用函数实现。（函数、一维数组、数组作为函数参数， 排序算法 123示例：输入：-4,-1,0,3,10输出：0,1,9,16,100 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int a[5] = &#123;-5,4,3,-9,1&#125;; int b[5]; for (int i = 0; i&lt;5; i++) &#123; b[i] = a[i] * a[i]; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4-i; j++) &#123; if (b[j] &gt; b[j + 1]) &#123; int swap; swap = b[j]; b[j] = b[j + 1]; b[j + 1] = swap; &#125; &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, b[i]); &#125;&#125; 49.结构体的IO 编写一个函数 print，打印一个学生的成绩数组，该数组有 5 个学生的数据记 录，每个记录包括 num，nam，score[3]，用 input 函数输入这些记录，用 print 函数输出这些记录。（第 9 章例题） 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;struct student&#123; int num; char name[20]; int score[3];&#125;stu[5];void print(struct student* stu1);void input(struct student* stu1);int main()&#123; input(stu); print(stu); return 0;&#125;void input(struct student *stu1)&#123; int i, n = 5; printf(&quot;请依次输入学生信息：\\n&quot;); for (i = 0; i &lt; n; i++) &#123; printf(&quot;No.&quot;); scanf_s(&quot;%d&quot;, &amp;stu[i].num); scanf_s(&quot;%s&quot;, stu[i].name, 20); scanf_s(&quot; %d %d %d&quot;,&amp;stu[i].score[0], &amp; stu[i].score[1], &amp;stu[i].score[2]); &#125;&#125;void print(struct student *stu1)&#123; int i; printf(&quot;\\n\\n&quot;); for (i = 0; i &lt; 5; i++) printf(&quot;No.%d %s %d %d %d\\n&quot;, stu1[i].num, stu1[i].name, stu1[i].score[0], stu1[i].score[1], stu1[i].score[2]);&#125; 50.难 用指针实现以下程序，输入一个字符串，包括数字和非数字字符，例如： abddf90333?&lt;&gt;2308nfdiufoien8dsuf。其中连续的数字作为一个整数，依次放入一 个数组 a 中，例如 90333 放在 a[0]中，2308 放在 a[1]中……统计一共出现了多少个整 数，并输出这些整数。（第 8 章课后习题） 12345678910111213141516171819202122232425262728//这题我写错了，有时间我再改改#include&lt;stdio.h&gt;void st(char* str)&#123; int num=0; while (*str != &#x27;\\0&#x27;) &#123; if (*str&gt;=&#x27;0&#x27;&amp;&amp; *str &lt;= &#x27;9&#x27;) &#123; num++; printf(&quot;%c&quot;, *str); &#125; /*if (*str != &#x27;0&#x27; &amp;&amp; *str != &#x27;9&#x27;) &#123; printf(&quot;\\n&quot;); &#125; */ str++; &#125; printf(&quot;%d&quot;, num);&#125;int main()&#123; char str[100]; scanf_s(&quot;%s&quot;, str, 100); st(str);&#125; 51.计算日期是第几天 定义一个结构体变量（包括年、月、日），编写一个函数能够计算一个日期在本 年中是第几天（注意闰年的问题），在主函数中将年、月、日传递给功能函数，计算 结果返回主函数输出显示。（第 9 章课后习题） 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;void DATA(struct days today);struct days&#123; int nian; int yue; int ri;&#125;;int main()&#123; struct days today; scanf_s(&quot;%d %d %d&quot;, &amp;today.nian, &amp;today.yue, &amp;today.ri); DATA(today);&#125;void DATA(struct days today)&#123; int data = 0; int yue[12] = &#123; 31,28,31,30,31,30,31,31,30,31,30,31 &#125;; for (int i = 0; i &lt; today.yue-1; i++) &#123; data = data + yue[i]; &#125; data = data + today.ri; if (today.yue!=2) &#123; if ((today.nian % 400 == 0) || (today.nian % 4 == 0 &amp;&amp; today.nian != 00)) &#123; data = data + 1; &#125; &#125; printf(&quot;%d&quot;, data);&#125; 52.日期结构体 定义一个表示日期的结构体变量（包括年、月、日），并实现以下要求： 12345671) 编写一个函数，用于让用户输入年、月、日，函数参数为结构体指针；2) 编写一个函数，实现用“日/月/年”格式输出日期（例如 21/12/2020），函数参数为结构体变量；3) 编写一个函数，计算一个日期在本年中是第几天（注意闰年的问题），函数参数为要计算的日期（年、月、日），计算结果为函数返回值；4) 编写一个 main 函数，可以测试以上函数的功能，并给出 2020 年 5 月 15 日是这一年中的第几天。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;void DATA(struct day *p);void input(struct day* p);struct day &#123; int nian; int yue; int ri;&#125;;int main()&#123; struct day today; input(&amp;today); DATA(&amp;today); return 0;&#125;void input(struct day* p)&#123; printf(&quot;请输入年月日\\n&quot;); scanf_s(&quot;%d %d %d&quot;,&amp;p-&gt;nian,&amp;p-&gt;yue,&amp;p-&gt;ri);&#125;void DATA(struct day *today)&#123; int data = 0; int yue[12] = &#123; 31,28,31,30,31,30,31,31,30,31,30,31 &#125;; for (int i = 0; i &lt; (today-&gt;yue) - 1; i++) &#123; data = data + yue[i]; &#125; data = data + today-&gt;ri; if (today-&gt;yue != 2) &#123; if ((today-&gt;nian % 400 == 0) || (today-&gt;nian % 4 == 0 &amp;&amp; today-&gt;nian != 00)) &#123; data = data + 1; &#125; &#125; printf(&quot;%d&quot;, data);&#125; 53.结构体和函数和指针 123456编写一个程序，录入每位同学的信息，包括学号，姓名，c 语言成绩，数学成绩以及英语成绩。要求：1) 从键盘上输入 N 名同学的成绩；2) 求出每名同学的总成绩和平均分；3) 输出每名同学的信息，包括学号，姓名，总分，平均分；4) 按照 c 语言成绩排序输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;void input(struct student* p,int n);//输入函数void print(struct student* p, int n);//输出函数void pingjunfen(struct student* p, int n);//平均分和总成绩void paixu(struct students* p, int n);//根据c语言成绩struct student&#123; int id; char name[55]; int score[3];//c 英语 高数&#125;stu[50];int main()&#123; int sum; scanf_s(&quot;%d&quot;, &amp;sum); //struct student students,*p=&amp;students; input(stu, sum); print(stu, sum); pingjunfen(stu, sum); paixu(stu, sum);&#125;void input(struct student* p,int n)&#123; for (int i = 0; i &lt; n; i++) &#123; printf(&quot;No.&quot;); scanf_s(&quot;%d&quot;, &amp;stu[i].id); scanf_s(&quot;%s&quot;, stu[i].name, 20); scanf_s(&quot; %d %d %d&quot;, &amp;stu[i].score[0], &amp;stu[i].score[1], &amp;stu[i].score[2]); &#125;&#125;void print(struct student* p, int n)&#123; printf(&quot;\\n&quot;); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;No.%d %s %d %d %d\\n&quot;, stu[i].id, stu[i].name, stu[i].score[0], stu[i].score[1], stu[i].score[2]); &#125; &#125;void pingjunfen(struct student* p, int n)&#123; printf(&quot;\\n&quot;); int sum=0; double pingjun; for (int i = 0; i &lt; n; i++) &#123; sum = sum + stu[i].score[0] + stu[i].score[1] + stu[i].score[2]; pingjun = sum / 3; printf(&quot;%s 总成绩;%d 平均分;%.2f\\n&quot;,stu[i].name, sum, pingjun); pingjun = 0; sum = 0; &#125;&#125;void paixu(struct students* p, int n)&#123; struct student swap; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0; j &lt; n - 1 - i; j++) &#123; if (stu[j].score[0] &lt; stu[j + 1].score[0]) &#123; swap = stu[j]; stu[j] = stu[j + 1]; stu[j + 1] = swap; &#125; &#125; &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;No.%d %s %d %d %d\\n&quot;, stu[i].id, stu[i].name, stu[i].score[0], stu[i].score[1], stu[i].score[2]); &#125;&#125; E期末大挑战 1未写完 待续 1234567891011121314/*（2）学生具备下面功能：a）当用户尚未登录，可以注册账号。通过输入学号，姓名，班级，密码后注册。注意已注册的学号不能重复注册。b）当用户尚未登录，可以通过输入学号和密码登录，学号和密码与注册一致则成功登录，否则登录失败。（3）老师具备下面功能：a）当用户尚未登录，可以注册账号。通过输入工号，姓名，密码后注册。注意已注册的工号不能重复注册。b）当用户尚未登录，可以通过输入工号和密码登录，工号和密码与注册一致则成功登录，否则登录失败。c）登录成功后可以查看所有自己开授课程的信息（包含课程编号，课程名称）。d）登录成功后可以设定自己要开设的课程信息。e）登录成功后可以通过输入课程编号查看选修改课程的同学姓名、学号、和成绩。f）登录成功后可以通过输入课程编号开始录入该课程的成绩信息，系统逐条输出学生姓名和学号，老师随后录入成绩。g）登录成功后可以通过输入课程编号，选择查看成绩分阶段统计结果（90以上，80-89,70-79,60-69,60以下等）。h）登录成功后可以通过输入课程编号，选择正序和逆序查看成绩和学生名单。*/ ��生名单。 */","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"考试","slug":"考试","permalink":"https://kaguranotamashii.github.io/tags/%E8%80%83%E8%AF%95/"},{"name":"C语言","slug":"C语言","permalink":"https://kaguranotamashii.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Python基础","slug":"[main]CS/[main]computer-language/Python基础","date":"2021-12-04T07:22:31.000Z","updated":"2022-07-16T15:37:41.548Z","comments":true,"path":"posts/14703/","link":"","permalink":"https://kaguranotamashii.github.io/posts/14703/","excerpt":"学习笔记","text":"学习笔记 1.Python的基本语法 1Python的交互和脚本式 交互式是不创建脚本文件，通过解释器的交互模式来编写代码 脚本式，为创建.py格式进行执行 2标识符 在 Python 里，标识符由字母、数字、下划线组成。 在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。 Python 中的标识符是区分大小写的。 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。 Python 可以同一行显示多条语句，方法是用分号 ; 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ | 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` = ^=` `&gt;&gt;=` `&lt;&lt;=` 3.保留字 and exec not assert finally or break for pass class from print continue global raise def if return del import try elif in while else is with except lambda yield 2数据类型 1整数 python可以写任意大的整数 如果出现很大的数比如说10000000可以写成10000_000 2浮点数 浮点数可以用科学计数法来表示 比如说1.23*10七次幂可以写1.23e9, 0.0015等于1.5e-3 数值运算函数 round 12round(11.111,2)这个函数是四舍五入round(x[,d])d为保留位数默认为0// 11.11 abs 1abs（x）绝对值 pow 1234pow(x,y[,z])幂余pow(2,3,3)//2 divmod 123商余divmod(10，3）//（3，1） 3.字符串 字符串是以单引号或者双引号写出来的 字符串内部中有&quot;或者‘可以通过\\来表示 12345678910111213141516171819202122232425262728293031323334353637&#x27;I\\&#x27;m \\&quot;OK\\&quot;!&#x27;I&#x27;m &quot;OK&quot;!str1 = &#x27;hello, world!&#x27;# 通过内置函数len计算字符串的长度print(len(str1)) # 13# 获得字符串首字母大写的拷贝print(str1.capitalize()) # Hello, world!# 获得字符串每个单词首字母大写的拷贝print(str1.title()) # Hello, World!# 获得字符串变大写后的拷贝print(str1.upper()) # HELLO, WORLD!# 从字符串中查找子串所在位置print(str1.find(&#x27;or&#x27;)) # 8print(str1.find(&#x27;shit&#x27;)) # -1# 与find类似但找不到子串时会引发异常# print(str1.index(&#x27;or&#x27;))# print(str1.index(&#x27;shit&#x27;))# 检查字符串是否以指定的字符串开头print(str1.startswith(&#x27;He&#x27;)) # Falseprint(str1.startswith(&#x27;hel&#x27;)) # True# 检查字符串是否以指定的字符串结尾print(str1.endswith(&#x27;!&#x27;)) # True# 将字符串以指定的宽度居中并在两侧填充指定的字符print(str1.center(50, &#x27;*&#x27;))# 将字符串以指定的宽度靠右放置左侧填充指定的字符print(str1.rjust(50, &#x27; &#x27;))str2 = &#x27;abc123456&#x27;# 检查字符串是否由数字构成print(str2.isdigit()) # False# 检查字符串是否以字母构成print(str2.isalpha()) # False# 检查字符串是否以数字和字母构成print(str2.isalnum()) # Truestr3 = &#x27; jackfrued@126.com &#x27;print(str3)# 获得字符串修剪左右两侧空格之后的拷贝print(str3.strip()) 字符串函数 find 返回从左边第一个指定的字符索引，找不到返回-1 index 返回从左边第一个字符索引，找不到报错 123456str = &quot;abcde&quot;print(str.find(&#x27;c&#x27;))//2str = &quot;hello world&quot;a = str.index(&#x27;w&#x27;)print(a)//6 sqlit 字符串的拆分 12str = &quot;hello world&quot;print(str.split(&#x27; &#x27;))//[&#x27;hello&#x27;, &#x27;world&#x27;] chr(x) ord(x) 字符串的方法 方法必须用.方式 八种重要字符串的方法 str.lower str.upper() 返回字符串的副本，全部为大小写 str.split(sep=None)返回一个列表，由str根据sep被分割的部分组成 12&quot;a,b,c&quot;.split(&quot;,&quot;)# [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] str.count(sub)返回子串sub在str中中出现个数 12&quot;aabbaa&quot;,count(&quot;a&quot;)# 4 str.replace(old,new)返回str的副本，所以old子串被替换为new 12“python&quot;.replace(&quot;n&quot;,&quot;n123.io&quot;)# python123.io 字符串的格式化 python用于槽方式以及format方式 1&quot;&#123;&#125;是世界上最好用的语言之一，而&#123;&#125;是效率最高的语言&quot;.format(&quot;python&quot;,&quot;c++&quot;) 4布尔值 只有两个True和False 布尔值可以tong过and or not表达 123456789101112&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not FalseTrue 5.空值 用None表示，不能单纯理解为0 6变量 重点 python中 1a=&#x27;abc&#x27; python解释器干了两个事情 在内存中创建了‘abc’的字符串 在内存中创建a的变量指向‘abc’ 7.常量 8.list list是一种有序的集合，可以进行修改或者删除 1classmates=[&#x27;song&#x27;,&#x27;wang&#x27;,&#x27;zhang&#x27;] 使用len可获取list元素的个数 12&gt;&gt;&gt; len(classmates)3 索引 切片[start: end:step] 用索引可以访问list的元素 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; classmates[0]&#x27;song&#x27;&gt;&gt;&gt; classmates[1]&#x27;wang&#x27;&gt;&gt;&gt; classmates[2]&#x27;zhang&#x27;&gt;&gt;&gt; classmates[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range list1 = [1, 3, 5, 7, 100]print(list1) # [1, 3, 5, 7, 100]# 乘号表示列表元素的重复list2 = [&#x27;hello&#x27;] * 3print(list2) # [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]# 计算列表长度(元素个数)print(len(list1)) # 5# 下标(索引)运算print(list1[0]) # 1print(list1[4]) # 100# print(list1[5]) # IndexError: list index out of rangeprint(list1[-1]) # 100print(list1[-3]) # 5list1[2] = 300print(list1) # [1, 3, 300, 7, 100]# 通过循环用下标遍历列表元素for index in range(len(list1)): print(list1[index])# 通过for循环遍历列表元素for elem in list1: print(elem)# 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值for index, elem in enumerate(list1): print(index, elem) 当然我们也可以通过负数来索引 12&gt;&gt;&gt; classmates[-1]&#x27;zhang&#x27; 增删 因为list为可变的有序表 append 123&gt;&gt;&gt; classmates.append(&#x27;zhao&#x27;)&gt;&gt;&gt; classmatesclassmates=[&#x27;song&#x27;,&#x27;wang&#x27;,&#x27;zhang&#x27;,&#x27;zhao&#x27;] 元素想插入到指定的位置中.insert 12345&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)&gt;&gt;&gt; classmates&gt;&gt;&gt; classmates.append(&#x27;zhao&#x27;)classmates=[&#x27;song&#x27;,&#x27;jack&#x27;,&#x27;wang&#x27;,&#x27;zhang&#x27;,&#x27;zhao&#x27;] 删除末尾用 pop() 1234&gt;&gt;&gt; classmates.pop()&#x27;zhao&#x27;&gt;&gt;&gt; classmates[&#x27;song&#x27;,&#x27;jack&#x27;,&#x27;wang&#x27;,&#x27;zhang&#x27;] 想删除指定的位置用pop(i) 1234&gt;&gt;&gt; classmates.pop(1)&#x27;Jack&#x27;&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;] 12345678910111213141516171819202122list1 = [1, 3, 5, 7, 100]# 添加元素list1.append(200)list1.insert(1, 400)# 合并两个列表# list1.extend([1000, 2000])list1 += [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]print(len(list1)) # 9# 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1: list1.remove(3)if 1234 in list1: list1.remove(1234)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]# 从指定的位置删除元素list1.pop(0)list1.pop(len(list1) - 1)print(list1) # [400, 5, 7, 100, 200, 1000]# 清空列表元素list1.clear()print(list1) # [] 生成式和生成器 1234f = [x for x in range(1, 10)]print(f)f = [x + y for x in &#x27;ABCDE&#x27; for y in &#x27;1234567&#x27;]print(f) list中可以有不同类型的甚至list 123&gt;&gt;&gt; s = [22141, True, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;]&gt;&gt;&gt; len(s)4 9.tuple 有序的列表叫tuple，tuple不能被修改 不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 123&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2) 如果tuple中出现list也是可以修改的 12345&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;&gt;&gt;&gt; t(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;]) 10dict（dictionary） 其他的语言叫map 使用key-value dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下： 123&gt;&gt;&gt; d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;&gt;&gt;&gt; d[&#x27;Michael&#x27;]95 必须要有key才能读取value 一个key只能有一个value key不存在报错 如果想删除只要删除key就可以了 11.set set和dict类型 是存放key的但是不存放value key不能重复 set具有数学上的set性质 比如无序，没有重复元素 1234567891011121314&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125; 3.基本函数 1.判断 和c语言基本相似 注意不要少写了冒号 1234567age = 3if age &gt;= 18: print(&#x27;your age is&#x27;, age) print(&#x27;adult&#x27;)else: print(&#x27;your age is&#x27;, age) print(&#x27;teenager&#x27;) 12345678910111213141516age = 3if age &gt;= 18: print(&#x27;adult&#x27;)elif age &gt;= 6: #elif等于else if print(&#x27;teenager&#x27;)else: print(&#x27;kid&#x27;) if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 2.循环 python中的循环分为for in依次将list或者tuple中元素迭代 12345678names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]for name in names: print(name) //MichaelBobTracy 3.输出 1234567891011121314print(&quot;hello world&quot;)# 可以输出字符串# 含有运算符的表达式print(88 * 88 - 55)# 将数据输出文件中 主要盘符要存在 使用file=p a+以读写状态，没有就新建fp = open(&#x27;E:/编程/python/text.txt&#x27;, &#x27;a+&#x27;)print(&#x27;hello world&#x27;, file=fp)# 输出到这个文件夹fp.close()# 关闭a, b = 5, 10print(f&#x27;&#123;a&#125; * &#123;b&#125; = &#123;a * b&#125;&#x27;) 4.针对数据类型的特征 1.Slice 在list或者tuple取元素 range函数 12345678&gt;&gt;&gt;list(range(0, 30, 5))[0, 5, 10, 15, 20, 25]&gt;&gt;&gt; list(range(0, 10, 2))[0, 2, 4, 6, 8]&gt;&gt;&gt; list(range(0, -10, -1))[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 12345678list中可以通过for来切片&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;] python有更简单的方法实现切片操作 12345678910111213141516171819&gt;&gt;&gt; L[0:3][&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]&gt;&gt;&gt; L[:3][&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]&gt;&gt;&gt; L[1:3][&#x27;Sarah&#x27;, &#x27;Tracy&#x27;]如果0-99提取前十&gt;&gt;&gt; L=list(rang(100))&gt;&gt;&gt; l[0,1,2....99]&gt;&gt;&gt; l[:10]l [0,1,...9]前十个，每两个取一个l[:10:2]l[::5] 2.lteration 在python中通过for循环遍历list或者tuple叫迭送 3.列表生成式 5基本库 1time库 time 11648043734.0478468 ctime 1Wed Mar 23 21:57:29 2022 gmtine 1time.struct_time(tm_year=2022, tm_mon=3, tm_mday=23, tm_hour=13, tm_min=58, tm_sec=1, tm_wday=2, tm_yday=82, tm_isdst=0) 2022 天天向上的力量 一年365进步与退步千分之一 365中工作五天进步百分之一，周末退步百分之一 你和365天都在进步百分之一的卷仙一起工作，你工作日学习，但是休息日两天下降百分之一，那么你至少要在工作日学习百分之多少呢？ 123456789101112131415# daydayup.pydef dayUp(df): dayup = 1 for i in range(365): if i % 7 in[6,0]: dayup=dayup*(0.99) else: dayup =dayup*(1+df) return dayupdayfactor = 0.01while dayUp(dayfactor) &lt; 37.78: dayfactor+=0.001print(&quot;他工作日努力参数为&#123;:.3f&#125;&quot;.format(dayfactor))//0.019 文本进度条 1234567891011# TextProBar1.pyimport timescale = 10print(&quot;........执行开始........&quot;)for i in range(scale+1): a=&#x27;*&#x27;*i b = &#x27;.&#x27;*(scale-i) c = (i/scale)*100 print(&quot;\\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c,a,b)) time.sleep(0.1)print(&quot;........结束........&quot;) …结束…&quot;)","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Python","slug":"编程/Python","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://kaguranotamashii.github.io/tags/Python/"}]},{"title":"CSS基础","slug":"[main]CS/[main]web/基础三件套/CSS基础","date":"2021-12-03T06:46:59.000Z","updated":"2022-11-22T17:36:22.412Z","comments":true,"path":"posts/10605/","link":"","permalink":"https://kaguranotamashii.github.io/posts/10605/","excerpt":"CSS前端三剑客的老二","text":"CSS前端三剑客的老二 1.CSS简介 1html自身的局限性 2CSS选择器 css的规则主要由两个部分组成的 选择器和一条或者多条声明 12&lt;选择器 属性 值 coor red这句话是声明&gt;h1 &#123;color:red; font-size:25px;&#125; 简单来说，选择标签用的 选择器分为 基础选择器和复合选择器 基础又分为 标签选择器 类选择器 id选择器 通配符选择器 1.标签选择器 html标签名词作为选择器 语法 123标签名&#123;属性1：属性值1；&#125; 123456789&lt;style&gt; p &#123;color: burlywood;&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;/body&gt; 优点为快速为同类型的标签同意设置样态 但是如果是出现多个相同的属性，会一同全部修改 2.类选择器 （常用） 1.使用 123.类名&#123;属性1:属性值；&#125; 123456789101112&lt;style&gt; p &#123;color: burlywood;&#125; .red&#123; color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;p&gt;1234455&lt;/p&gt; &lt;div class=&quot;red&quot;&gt;我想变成红色&lt;/div&gt;&lt;/body&gt; 盒子 1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .red&#123; width: 100px; height: 100px; /*背景颜色*/ background-color: red; &#125; .green&#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;red&quot;&gt;hong&lt;/div&gt; &lt;div class=&quot;green&quot;&gt;绿色&lt;/div&gt; &lt;div class=&quot;red&quot;&gt;hong&lt;/div&gt;&lt;/body&gt; 2.多类名 在标签中class文件属性中写多个类名 但是类名中间必须要用空格 123456789101112 &lt;style&gt; .red&#123; color:red; &#125; .font35&#123; font-size: 30px; &#125; &lt;/style&gt;&lt;body&gt; &lt;div class=&quot;red font35&quot;&gt;神乐同学&lt;/div&gt;&lt;/body&gt; 3.ID选择器 id可以选择特定的属性 123456789 &lt;style&gt; #pink&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;pink&quot;&gt;dsadasda&lt;/div&gt;&lt;/body&gt; id选择用#定义 只能调用一次 二者区别在于使用次数 id选择器一般用于页面唯一的元素，所以一般和JavaScript使用 4通配符选择器 用*号定义，它可以表示所有的元素 2属性 1.文字 1font-family 字体可用网络字体等 1234567891011 &lt;style&gt; h2&#123; font-family: &#x27;宋体&#x27;,&#x27;微软雅黑&#x27;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;我是来自北京信息科技大学的神乐&lt;/h2&gt; &lt;p&gt;我是来自北京信息科技大学的神乐&lt;/p&gt; &lt;p&gt;我是来自北京信息科技大学的神乐&lt;/p&gt;&lt;/body&gt; 2.font-size 123&lt;style&gt;font-size:20px;&lt;/style&gt; px像素大小是网页中最常用的单位 谷歌浏览器默认字体问=为16px 不同浏览器字号大小不相同 body指定整个页面字体大小 3.font-weight css中使用font-weight修改粗细程度 1234&lt;style&gt; .bold&#123;font-weight: bold;&#125;&lt;/style&gt;&lt;p class=&quot;bold&quot;&gt;神乐&lt;/p&gt; bold就是相当于加粗效果 相当于number700 属性值 为400等于默认 700等于加粗 4font-style 1234&lt;style&gt; .bold&#123;font-style: normal;&#125;&lt;/style&gt;&lt;p class=&quot;bold&quot;&gt;神乐&lt;/p&gt; 属性值中 normal为默认 italic为显示斜体 如果em标签和属性为italic的会变正 5.font的复合用法 比如说div字体斜体 加粗 字号16 微软雅黑 1234567891011&lt;style&gt; div&#123; font-size:16px; font-family:&#x27;Microsoft yahei&#x27;; font-weight:700; font-style:italic; &#125;&lt;/style&gt;&lt;div&gt; 古道西风瘦马&lt;/div&gt; 或者 位置严格要求不能换 除了size和family不能省略 1234567/*font: font-style font-weight font-size/font-height font-family;*/ 类 粗 大 家div&#123;font: itailc 700 16px &quot;微软雅黑&quot;;&#125; 2.文本 文本属性分为 颜色 对齐 装饰文本 缩进 行间距 1.color 颜色表示方法分为三种 预定义颜色值 十六进制 RGB代码 123456div&#123;color: deeppink;color: #ff0000;color: rgb(200,0,0);&#125; 2.text-align 样态文本 属性值分为：left默认,center居中,right右对齐 3.text-decoration 属性值为none默认,underline下划线,overlines上划线,line-through删除线 4text-indent 文本缩进 通常是首行的缩进 123text-indent:10px;text-indent:2em;/*em的意思为相对单位*/ 5line-height 控制行间距离的高度 文本高度默认为16px 所以line-height:16px；就是没有行间距 3.css引入方式 1内部样态表 单独放在style中 方便 没有完全分离 2.行内样态表 直接在标签内部使用 1&lt;p style=&quot;color:red;&quot;&gt;我是内容&lt;/p？ style就是属性 写法要符合css规范 3外部样态表 1234这是文件名字为：style.css div&#123;color:red;&#125; 123456&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;syy.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是内容&lt;/div&gt;&lt;/body&gt; 4chrome调试工具 点我查看 5.Emmet语法 6.CSS复合选择器 后代选择器,子选择器,并集选择器, 1.后代选择器 主要 元素1 元素2{} 1234567891011 &lt;style&gt; ol li a &#123;color:pink&#125; .name li&#123;color: seagreen;&#125; &lt;/style&gt;&lt;ol&gt; &lt;li&gt;我是后代&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是孙子&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;name&quot;&gt; &lt;li&gt;我是神乐&lt;/li&gt;&lt;/ol&gt; 2.子选择器 重要 3,并集选择器 用逗号分隔开了 123456789div,p&#123;&#125;&lt;div&gt; &lt;/div&gt;&lt;p&gt; &lt;/p&gt; 4.伪类选择器 用：表示 1.链接伪类 有很多种链接伪类 link visited hover active 1234a:hover&#123;color:gray;&#125;鼠标经过显示gray颜色 1234567a&#123;color:gray;&#125;a:hover&#123;color:red;&#125; 2.:focus伪类选择器 123input:focus&#123;background-color:yellow;&#125; 7.CSS元素显示模式（重点) html元素分为块元素和行内元素两类型 1.块元素 h p div ul ol li等是最常见的div是最典型的 特点独占一行 高度宽度外内边距等可以控制 宽度默认为容器（父级宽度）100% 是一个容器以及盒子 可以放行内以及块级元素 文字类的元素不能使用块级元素 p里面只能放文字 2.行内元素 a strong b em i del s ins u span span是最典型的行内元素 高宽无效 一行可以显示多个 默认宽度就是本身内容宽度 3.行内块元素 img input td 两个特点都有比较特殊 总结 4.元素显示模式转换 display:block;转换块元素 display:inline;转换行内元素 display:inline-block行内块元素 12345&lt;style&gt; a&#123; display:block; &#125;&lt;/style&gt; 5.实例简洁版本侧边档 123456789101112131415161718192021&lt;style&gt; a&#123; display: block; height: 20px; width: 100px; background-color: darkgray; font-size: 14px ; color: #fff; text-indent: 2em; text-decoration: none; &#125; a:hover&#123; background-color: coral; &#125;&lt;/style&gt;&lt;body&gt; &lt;a href=&quot;#&quot;&gt;手机&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;电视&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;盒子&lt;/a&gt;&lt;/bod》 6单行文字垂直居中 可以通过文字的行高等于盒子的高度，就可以垂直居中 8CSS的背景 小图片或者logo大图片 背景颜色图片 平铺 位置 固定等等 1.background-color background-color一般默认为transparent 2.background-image 使用方法为 background-image:url (); 123456789101112&lt;head&gt; &lt;style&gt; div&#123; width: 5000px; height: 1500px; background-image: url(![](https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/202112101445712.png)); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 3.background-repeat 123456background-repeat:;/*默认平铺*/no-repeatrepeatrepeat-xrepeat-y 4.background-position 可以修改图片位置 12345678910111213background-position:x y;/*参数分为两种length 百分数position 方位名词 top center bottom left center right如果都是方位名词，与前后无关如left top和top left在一些情况下 想要精准也可以通过精确坐标 d*/ 5.background-attachment 背景固定 背景附着 这个设置设置背景图片是否固定还是滚动 scroll为滚动 fixed为固定 6背景属性混合写法 前五个复合写法可以像font一样节约代码量 一般没有要求但是，一般习惯写为一下 background:背景颜色 背景图片 背景平铺 背景滚动 位置 1background: red url() no-repeat fixed top; 7.背景色半透明 1background:(0,0,0,alpht) 7.综合案例 五彩导航 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;综合案例-五彩导航&lt;/title&gt; &lt;style&gt; .nav a&#123; display:inline-block; width: 120px; height: 58px; background-color: pink; text-align: center; color: #fff; text-decoration: none; line-height: 48px; &#125; .nav .bg1&#123; background-image: url(images/bg1.png); &#125; .nav .bg2&#123; background-image: url(images/bg2.png); &#125; .nav .bg1:hover&#123; background-image: url(images/bg11.png); &#125; .nav .bg2:hover&#123; background-image: url(images/bg22.png); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;bg1&quot;&gt;五彩导航&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bg2&quot;&gt;五彩导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;五彩导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;五彩导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;五彩导航&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9.CSS三大特征 1.层叠性 123456789101112131415161718 &lt;style&gt; div&#123; color:red; &#125; div&#123; color: royalblue; font-size: 50px; &#125; div&#123; color:seagreen &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; 大江东去 &lt;/div&gt;&lt;/body&gt; 这里div有三个选择 但是只执行的只有fintsize和最后一个color 就近原则，哪个近就执行哪个 样态不冲突 不会重叠 2.继承性 现实的继承 我们继承了父亲的姓 123456789101112 &lt;style&gt; div &#123; color: pink; font-size: 14px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;龙生龙,凤生凤,老鼠生的孩子会打洞&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; p继承了父div的性质 继承性就是简化代码 降低复杂性text font line 行高的继承 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;行高的继承&lt;/title&gt; &lt;style&gt; body &#123; color: pink; /* font: 12px/24px &#x27;Microsoft YaHei&#x27;; */ font: 12px; &#125; div &#123; /* 子元素继承了父元素 body 的行高 1.5 */ /* 这个1.5 就是当前元素文字大小 font-size 的1.5倍 所以当前div 的行高就是21像素 */ font-size: 14px; &#125; p &#123; /* 1.5 * 16 = 24 当前的行高 */ font-size: 16px; &#125; /* li 么有手动指定文字大小 则会继承父亲的 文字大小 body 12px 所以 li 的文字大小为 12px 当前li 的行高就是 12 * 1.5 = 18 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;粉红色的回忆&lt;/div&gt; &lt;p&gt;粉红色的回忆&lt;/p&gt; &lt;ul&gt; &lt;li&gt;我没有指定文字大小&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 3.优先性 选择器相同 则执行层叠层 不同 根据选择器权重决定 12345678910111213141516 &lt;style&gt; .test &#123; color: red; &#125; div &#123; color: pink!important; &#125; #demo &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test&quot; id=&quot;demo&quot; style=&quot;color: purple&quot;&gt;你笑起来真好看&lt;/div&gt;&lt;/body&gt; 10.盒子模型（超重点）Box Model 学习页面布局有三大模型 盒子 浮动 定位 12345盒子中要有border边框content内容padding内边距margin外边距 1.border边框 border中有 宽度 边框样态 颜色 123456789101112131415&lt;style&gt; div&#123; width: 300px; height: 200px; border-style: solid;/*solib实线 dashed 虚线 dotted点线边框*/ border-width: 20px; border-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617边框的复合写法 没有顺序 &lt;style&gt; div &#123; width: 300px; height: 200px; /* border-width: 5px; border-style: solid; border-color: pink; */ /* 边框的复合写法 简写: */ /* border: 5px solid pink; */ /* 上边框 */ border-top: 5px solid pink; /* 下边框 */ border-bottom: 10px dashed purple; border:red 5px solid; &#125; &lt;/style&gt; 2.padding内边距 padding控制内边距 12345678div &#123; width: 300px; height: 160px; background-color: pink; padding-top: 20px; padding-left: 22px; padding-right: 22px; &#125; padding影响了盒子的大小 会撑大盒子 1234567891011121314151617.nav &#123; height: 41px; border-top: 3px solid red; border-bottom: 1px solid beige; background-color: #fcfcfc; line-height: 41px;&#125;.nav a &#123; display: inline-block; font-size: 12px; color: blue; text-decoration: none; padding: 0 20px; height: 41px;&#125; 3.margin外边距 两个盒子的距离 还是和内边距相似 top right bottom left 外边距作用为水平居中 指定宽度 盒子左右外边距为auto 123margin-left:auto;margin-right:auto;margin:auto;margin:0 auto; 行内和行内块用text-alignLcenter 11.浮动float 传统网页布局三种方式 普通流 浮动 定位 标准流（普通 文档）按照标签规定默认排序 块单独一行 从上香下排序又div hr h1-h6 ui ol form table 行内按照左右排序如 span a i em 3浮动元素具有行内吧块元素特征 123456789101112131415161718192021222324252627282930313233343536 &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; &#125; .box &#123; width: 1226px; height: 285px; background-color: pink; margin: 0 auto; &#125; .box li &#123; width: 296px; height: 285px; background-color: purple; float: left; margin-right: 14px; &#125; .box .last &#123; margin-right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;box&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li class=&quot;last&quot;&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 清除浮动 12定位 有些效果无法用标准流和浮动，这时候要用定位 浮动可以让多个块级元素在一行没有空袭 定位用于自由控制盒子 1static静态定位 没有边偏移 2relative相对定位 3absolute绝对定位 子绝父相 对定位 子绝父相","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"编程/前端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://kaguranotamashii.github.io/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"https://kaguranotamashii.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"JavaScript基础","slug":"[main]CS/[main]web/基础三件套/JavaScript入门","date":"2021-12-01T11:19:12.000Z","updated":"2022-09-11T07:11:09.049Z","comments":true,"path":"posts/53227/","link":"","permalink":"https://kaguranotamashii.github.io/posts/53227/","excerpt":"前端三剑客的大哥捏","text":"前端三剑客的大哥捏 1.关于JavaScript 1.JavaScript是什么？ HTML 定义了网页的内容 CSS 描述了网页的布局 JavaScript 控制了网页的行为 浏览器不会执行js，通过js解释器 js的引入有三种 行内式的内嵌式 输入输出语句 12345678JavaScript 显示数据JavaScript 可以通过不同的方式来输出数据：使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 字面量和变量 js是一种弱类型或者动态的语言，不用提前声明类型，类型被自动确定 数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e)。 1isNaN来判断是否为非数字，并返回一个值 如果是数字返回false，反之true 字符串（String）字面量 可以使用单引号或双引号:表达式字面量 用于计算： 数组（Array）字面量 定义一个数组： [40, 100, 1, 5, 25, 10] 对象（Object）字面量 定义一个对象： {firstName:“John”, lastName:“Doe”, age:50, eyeColor:“blue”} 函数（Function）字面量 定义一个函数： function myFunction(a, b) { return a * b;} 在编程语言中，变量用于存储数据值。 JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值： JavaScript 数据类型 JavaScript 有多种数据类型：数字，字符串，数组，对象等等： 12345var length = 16; // Number 通过数字字面量赋值var points = x * 10; // Number 通过表达式字面量赋值var lastName = &quot;Johnson&quot;; // String 通过字符串字面量赋值var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; // Array 通过数组字面量赋值var person = &#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;&#125;; // Object 通过对象字面量赋值 var cars = new Array(); cars[0] = “Saab”; cars[1] = “Volvo”; cars[2] = “BMW”; 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： var person={firstname:“John”, lastname:“Doe”, id:5566}; 上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。 var person={ firstname : “John”, lastname : “Doe”, id : 5566 }; 12345678var person=&#123; firstname : &quot;John&quot;, lastname : &quot;Doe&quot;, id : 5566&#125;;document.write(person.lastname + &quot;&lt;br&gt;&quot;);document.write(person[&quot;lastname&quot;] + &quot;&lt;br&gt;&quot;); 语句 描述 break 用于跳出循环。 catch 语句块，在 try 语句块执行出错时执行 catch 语句块。 continue 跳过循环中的一个迭代。 do … while 执行一个语句块，在条件语句为 true 时继续执行该语句块。 for 在条件语句为 true 时，可以将代码块执行指定的次数。 for … in 用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 function 定义一个函数 if … else 用于基于不同的条件来执行不同的动作。 return 退出函数 switch 用于基于不同的条件来执行不同的动作。 throw 抛出（生成）错误 。 try 实现错误处理，与 catch 一同使用。 var 声明一个变量。 while 当条件语句为 true 时，执行语句块。 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。 函数 匿名函数 123var fun =funtion()&#123;console.log(&quot;hello world&quot;);&#125; 声明函数 一次声明多次使用 形参和实参 返回值 匿名函数 12345setInterval(function()&#123; console.log(&quot;hello&quot;)&#125;,100)setInterval重复使用//将匿名函数作为参数传递给定一个函数，或者方法 函数表达式 12345const fun=funtion(n,m)&#123;return n+m;&#125;let result=fun(11,33);console.log(result); 方法 1234567891011const cat=&#123; name:&quot;xiaosong&quot;, sayName:funtion()&#123; console.log(this.name); &#125; //或者 sayName()&#123; console.log(this.name); &#125; &#125; 箭头函数 12345const fun = (x) =&gt; &#123; return x * x;&#125;const fun = (x) =&gt; x * x; 面向对象 prototype ES5 继承关系 ES6继承 12345678910111213141516&lt;script&gt; class Animal &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayName() &#123; console.log(`我是$&#123;this.name&#125;`) &#125; &#125; class Dog extends Animal &#123; &#125; let dog = new Dog(&quot;旺财&quot;); dog.sayName();&lt;/script&gt; 创建方法 1利用对象字面量创建对象 123456789var obj-&#123;uname: &quot;songyuran&quot;,age: 18,sayhi: funtion()&#123;console.log(&quot;log&quot;);&#125;&#125; 利用new object创建对象 1234var obj=new Object();obj,uname=&#x27;songyiran&#x27;; 构造函数 因为一上只能创建一个对象，有了构造函数可以让相同的属性和方法抽象出来封装出来到函数里面 123456funtion Star(uname,age,sex)&#123;this.name=uname;this.age=age;this,sex=sex;&#125;var ldh=new Star(&quot;songyuran&quot;,18,&#x27;nan&#x27;); 遍历对象 1234for(var k in obj)&#123;console.log(k);console.log(obj[k]);&#125; 数组 遍历 while for forin forof map map push方法 pop 12345678910111213var a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];a.pop();a.push(&quot;E&quot;);a.sort()console.log(a);var b = [1, 24, 5, 6, 78]var newList = list.filter(function (item) &#123; if (item &gt; 3) &#123; return item; &#125;&#125;);console.log(newList); 内置对象 Math 1random()*(max-min+1)+min//0《=x《1 date 正则表达式 123var str=&quot;123&quot;;var reg=/123/;var result=reg.test(str); ES6 变量 1234567let变量块级作用域不存在变量提升不允许重复声明 常量 1234567891.const定义常量2.定义后不能修改3.不变的模板字符串 let year = &#x27;2020&#x27;; let mouth = &#x27;10&#x27;; let date = &#x27;11&#x27;; let result = `$&#123;year&#125;年$&#123;mouth&#125;月$&#123;date&#125;日`; console.log(result); DOM 元素节点 属性节点 文本节点 DOM树 获取元素 获取ID 1234getElementByld()get element by idconsole.dir打印返回的元素对象，更好查看里面的属性和方法 根据标签名 12getElementByTagNameelement.getElementByTagName 根据类名 1getElementByClassName 返回指定选择器第一个元素对象 1querySelector 返回指定所有的选择器所以元素对象 1query.SelectorAll 获取特殊元素body 1document.body html 1document.documentElemnt 事件基础 事件源 事件类型 事件处理程序 三要素 12345var btn =document.getElemnent.byId(&#x27;btn&#x27;)btn.onclick =funtion()&#123;alert(&quot;hello world&quot;)&#125; 修改元素 DOM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .swiper &#123; width: 640px; height: 320px; overflow: hidden; position: relative; &#125; .images-container &#123; width: 1920px; height: 320px; display: flex; transition: transform 0.9s; &#125; .images-container img &#123; width: 640px; height: 320px; &#125; /* .images-container:hover &#123; transform: translate(-640px); &#125; */ .number-list &#123; position: absolute; bottom: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;swiper&quot;&gt; &lt;div class=&quot;images-container&quot;&gt; &lt;img src=&quot;20220710232803.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;20220710232826.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;20220710232832.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;number-list&quot;&gt; &lt;button&gt;1&lt;/button&gt; &lt;button&gt;2&lt;/button&gt; &lt;button&gt;3&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; let btnList = document.querySelectorAll(&quot;.number-list button&quot;); let container = document.querySelector(&quot;.image-container&quot;); for (let i in btnList) &#123; btnList[i].onclick = function () &#123; container.style.transform = `translate(-555px)`; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM操作 12345在ui里添加liul.innerHtml=`&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;` 节点操作 i&gt; ` 1234### 节点操作","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"编程/前端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"编程/前端/javascript","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://kaguranotamashii.github.io/tags/javascript/"}]},{"title":"Html基础","slug":"[main]CS/[main]web/基础三件套/html基础","date":"2021-11-23T15:49:10.000Z","updated":"2022-11-22T17:35:54.908Z","comments":true,"path":"posts/48593/","link":"","permalink":"https://kaguranotamashii.github.io/posts/48593/","excerpt":"前端三剑客的弟弟","text":"前端三剑客的弟弟 [TOC] 1.HTML入门 ​ html是创建网页的标准标记语言。网页有很多的格式,html,jsp,asp等 ，html并不是编程语言，因为编程语言具有逻辑能力，html超越了传统的txt文本，具有超文本性，是一种标记语言。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;//这是文档的声明，声明文档为html&lt;html lang=&quot;zh-CN&quot;&gt;//en zh-CN&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;这是网页标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;a href=&quot;http://c.biancheng.net/&quot;&gt;这个一个超链接&lt;/a&gt; &lt;ul&gt; &lt;li&gt;HTML教程&lt;/li&gt; &lt;li&gt;CSS教程&lt;/li&gt; &lt;li&gt;JavaScript教程&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入内容&quot; /&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt;//h1-h6 &lt;p&gt;这是一个段落&lt;/p&gt; &lt;p&gt;这是另一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 以上这个就是最基本的网页格式，每个html标签(Tag)都有不同的含义 &lt;.html&gt;当作所有的html代码，可以把它当作外壳 &lt;.head&gt; 标签表示网页的头部，用来设置一些网页的参数 &lt;.meta charset=“UTF-8”&gt; 指明当前网页编码格式 UTF-8； &lt;.title&gt; 网页的标题，它会显示在浏览器的标题栏。 &lt;./head&gt; &lt;.body&gt;表示正文 &lt;.p&gt;表示段落，能容纳一段文字 &lt;.a&gt;用来表示一个超链接 &lt;.ul&gt;表示一个列表，里面的是子标签 HTML语言中最推荐vscode写 html小白入门 这是文本标题，下面是一张图片 按钮 d ​ 1234567891011121314&lt;!DOCTYPE&gt;&lt;!--html标记--&gt;&lt;html&gt; &lt;!--html总标记--&gt; &lt;head&gt;&lt;!--头信息标签--&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--utf-8编码--&gt; &lt;title&gt;html小白入门&lt;/title&gt;&lt;!--页面标题--&gt; &lt;head&gt; &lt;body&gt;&lt;!--网页显示标签，body标签内的信息都会在页面中显示--&gt; &lt;h1&gt;这是文本标题，下面是一张图片&lt;/h1&gt;&lt;!--文本标题标签--&gt; &lt;h2 href=&quot;baidu.com&quot;&gt;点我百度搜索&lt;/a&gt;&lt;!--超链接--&gt; &lt;imgsrc=&quot;tupian.jpg&quot;&gt;&lt;br&gt;&lt;!--图片标签，br是换行标签--&gt; &lt;input type=&quot;text&quot; value=&quot;这是输入框，请输入内容！&quot;&gt;&lt;br&gt;&lt;!--输入框标签--&gt; &lt;button type=&quot;submit&quot; &gt;按钮&lt;/button&gt;&lt;!--按钮标签--&gt; &lt;/body&gt;&lt;/html&gt; 这个就是最基本的使用方法 2.HMTL的语法 1.html标签的语法格式(请忽略.) &lt;.div class=“foo”&gt;我是内容&lt;/div.&gt; foo为属性 前后div为开始结束标签 开始标签可以写除了class的比如id title等 html标签是成对出现的，称之为双标签 有些特殊的比如说&lt;br/.&gt; div为内容划分元素 是出现最高的 2.标签关系HTML标签 包含关系 1234567891011 &lt;h1&gt;神楽の魂&lt;font size=&quot;4&quot; color=&quot;#666&quot;&gt;自我介绍&lt;/font&gt;&lt;/h1&gt; &lt;p&gt; 这是北京普通的双非&lt;b&gt;大学生&lt;/b&gt;的个人博客，目前 &lt;font color=&quot;red&quot;&gt;18岁&lt;sup&gt;①&lt;/sup&gt;&lt;/font&gt;，&lt;a href=&quot;https://kaguranotamashii.github.io/&quot; target=&quot;_blank&quot;&gt;猛击这里&lt;/a&gt;查看我的博客&lt;i&gt;C语言&lt;/i&gt;、&lt;i&gt;python&lt;/i&gt;、&lt;i&gt;html&lt;/i&gt; &lt;i&gt;css&lt;/i&gt; &lt;hr /&gt; &lt;small&gt;03年出生&lt;/small&gt; &lt;/p&gt;&lt;!包含关系&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;/html&gt; 对代码的说明 &lt;.font&gt; size改变大小 clor改变颜色 &lt;.b&gt;加粗 &lt;.sup&gt;上方的小标 &lt;.i&gt;斜 &lt;.hr&gt;分割线，它是自闭和标签 &lt;.a&gt;为打开超链接 其中&lt;.target&gt;为打开方式 ——blank表示在新标签打开 并列关系(兄弟关系) &lt;.head&gt;&lt;/.head&gt; 基本标签 &lt;html.&gt; html标签 根标签 &lt;head.&gt; 头部 在head中我们必须要设计的标签是title &lt;title.&gt; 标题 属于自己的网页标题 &lt;body.&gt; 主体 元素包含的所有内容，页面内容基本都是放在body中的 3.HTML属性 1.属性 1attr=&quot;value&quot; attr为属性名字 value表示属性值 1.专用属性 有些属性适合大部分 叫通用属性 有些只适合小部分 叫专用属性 比如说img中src和alt就是专用属性 a中href和target也是专用属性 1&lt;img src=&quot;xxxx.png&quot; alt=&quot;xxxxx&quot; width=&quot;100&quot; height=&quot;50&quot;&gt; 2.通用属性 如id,title,class,style 1.id id属性是用来赋值给某个标签名字，当使用css或者js时候，可以通过id来找到这个标签。 id可以快速找到定位，id可以方便区分，id具有唯一性 123&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;&lt;div id=&quot;content&quot;&gt;我的博客&lt;/div&gt;&lt;p id=&quot;url&quot;&gt;kaguranotamashii.github.io/&lt;/p&gt; 2.class class与id不同在于，class可以定义多个相同值 class=&quot; &quot; 123&lt;div class=&quot;className1 className2 className3&quot;&gt;&lt;/div&gt;&lt;p class=&quot;content&quot;&gt;神楽の魂的博客&lt;/p&gt;&lt;div class=&quot;content&quot;&gt;kaguranotamashii.github.io&lt;/div&gt; 3.title title属性是用来标签内容的描述说明 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;演示文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;http://c.biancheng.net/html/&quot; title=&quot;HTML教程&quot;&gt;HTML教程&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4.style style属性我们可以在html标签内部定义css样态，比如颜色，字体等等 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;演示文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p style=&quot;color:red;&quot;&gt;kaguranotamashii,github.io&lt;/p&gt; &lt;img src=&quot;./logo.png&quot; style=&quot;height:50px;&quot; alt=&quot;C语言中文网LOGO&quot;&gt; &lt;div style=&quot;padding:10px;border:2px solid #999;text-align:center;&quot;&gt;C语言中文网&lt;/div&gt;&lt;!这里做个批注padding表示内边距，内容区与边框之间的区域 border表示设置元素的边框--&gt; &lt;/body&gt;&lt;/html&gt; 4.HTML标题 1.&lt;.h1&gt;到&lt;.h6&gt;（head) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML标题标签演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;h1 标题&lt;/h1&gt; &lt;h2&gt;h2 标题&lt;/h2&gt; &lt;h3&gt;h3 标题&lt;/h3&gt; &lt;h4&gt;h4 标题&lt;/h4&gt; &lt;h5&gt;h5 标题&lt;/h5&gt; &lt;h6&gt;h6 标题&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 标题标签的使用只能用于定义标签，不能加粗 5.HTML段落标签&lt;.p&gt; paragraph 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是神楽の魂的博客网站为&lt;a href=&quot;kaguranotamashii.github.io&quot;&gt;点我&lt;/a&gt;&lt;/p&gt; &lt;p&gt;我的博客会写一些技术向的内容&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 1.&lt;.p&gt;的用法 段落标签由开始标签&lt;p&gt;和结束标签&lt;/p&gt;组成，开始和结束标签之间的内容会被视为一个段落。段落标签是一个非常基本的标签，我们在网页上发布文章时就会用到 2.段落中的空白符 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML段落中的空白符&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;神 楽の魂 的 博 客&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 如果想要在段落中换行，需要使用专门的换行标签&lt;br /&gt;，&lt;br /&gt;标签属于自闭和标签，因此不需要对应的结束标签`&lt; /br&gt; 文本在一个段落中会根据浏览器窗口大小自动换行 段落与段落有空隙 &lt;br/.&gt; 6.HTML文本格式化 突出重要性 比普通文字更重要 标签 描述 &lt; b&gt;… 加粗标签中的字体 &lt; em&gt;… 强调标签中的内容，并使标签中的字体倾斜 &lt; i&gt;… 定义标签中的字体为斜体 &lt; small&gt;… 定义标签中的字体为小号字体 &lt; strong&gt;… 强调标签中的内容，并将字体加粗（推荐） &lt; sub&gt;… 定义下标文本 &lt; sup&gt;… 定义上标文本 &lt; ins&gt;… 下划线 &lt; del&gt;… 在文本内容上添加删除线 &lt; code&gt;… 定义一段代码 &lt; kbd&gt;… 用来表示文本是通过键盘输入的(不建议使用) &lt; samp&gt;… 定义程序的样本 &lt; var&gt;… 定义变量 &lt; pre&gt;… 定义预格式化的文本，被该标签包裹的文本会保留所有的空格和换行符，字体也会呈现为等宽字体 &lt; abbr&gt;… 用来表示标签中的内容为缩写形式 &lt; address&gt;… 用来定义文档作者的联系信息，被该标签包裹的文本通常会以斜体呈现，并在文本前面换行 &lt; bdo&gt;… 定义标签中的文字方向 &lt; blockquote&gt;… 定义一段引用的文本，例如名人名言，文本会换行输出，并在左右两边进行缩进 &lt; q&gt;… 定义一段短的引用，浏览器会将引用的内容使用双引号包裹起来 &lt; cite&gt;… 表示对某个文献的引用，例如书籍或杂志的名称，文本会以斜体显示 &lt; dfn&gt;… 用来定义一个术语，标签中的文本会以斜体呈现 几个相似的格式化文本 1.strong和b 前者表示加重语气,后者只是单纯的加粗,在无障碍模式中strong会比b的声音更特殊. 2.em和i em也是加重处理,i仅仅是单纯的斜体 7div和span标签 两者没有语义，他们就是一个盒子，用来放内容 div division表示分割 分区 span表示跨度 跨距 div用来布局 但是一行只能有一个div 大盒子 span相反 一行可以放多个span 小盒子 8.特殊的字符 123&amp;nbsp;空格&amp;lt;小于&amp;gt;大于 7.HTML超链接&lt;.a&gt; 1.用法 1&lt;a href=&quot;url&quot; target=&quot;opentype&quot;&gt;链接文本&lt;/a&gt; 2href的属性 anchor 瞄 href 属性指定链接的目标，也就是要跳转到什么位置。href 可以有多种形式，例如： href 可以指向一个网页（.html、.php、.jsp、.asp 等格式），这也是最常见的形式，例如 href=“http://c.biancheng.net/view/1719.html”； href 可以指向图片（.jpg、.gif、.png 等格式）、音频（.mp3、.wav等格式）、视频（.mp4、.mkv格式）等媒体文件，例如 href=“/uploads/allimg/181221/134I32557-0.jpg”； href 可以指向压缩文件（.zip、.rar 等格式）、可执行程序（.exe）等，一些下载网站的链接就可以写成这种形式，例如 href=“./…/uploads/data_package/ComputerFoundation.zip”； href 甚至还可以指向本机的文件，只是很少这样使用，例如 href=“D:/Program Files/360/360safe/360Safe.exe”。 你看，href 本质上就是指向一个文件，这个文件几乎可以是任意格式的。如果浏览器支持这种格式，那么它就可以在浏览器上显示，比如常见的图片、音频、视频等，如果浏览器不支持这种格式，那么就提示用户下载。 3.target的属性 属性值 说明 _self 默认，在现有窗口中打开新页面，原窗口将被覆盖。 _blank 在新窗口中打开新页面，原窗口将被保留。 _parent 在当前框架的上一层打开新页面。 _top 在顶层框架中打开新页面。 如果不设置默认为_self 4.href的本地网页跳转 1234567&lt;a href=&quot;#sakura&quot;&gt;点我跳转&lt;/a&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p&gt;忽略我&lt;/p&gt;&lt;p id=&quot;sakura&quot;&gt;我是sakura&lt;/p&gt; 点我跳转 忽略我 忽略我 忽略我 忽略我 忽略我 我是sakura 8HTML插入图片&lt;.img&gt; 1.用法 1&lt;img src=&quot;url alt=&quot;text&quot;&gt; src(source)为必选属性,用来指明图片的地址和目录,支持多种图片类型 alt为可选属性,如果遇到图片加载不了,会显示alt的信息 123456&lt;body&gt; &lt;!-- 使用绝对路径插入网络图片 --&gt; &lt;img src=&quot;http://c.biancheng.net/cpp/templets/new/images/logo.jpg?v=3.994&quot; alt=&quot;C语言中文网Logo&quot;&gt; &lt;br&gt; &lt;!-- 在当前 HTML 文档的上层目录中有一个 images 文件夹，该文件夹下有一张图片 html5.png --&gt; &lt;img src=&quot;../images/html5.png&quot; alt=&quot;HTML5 Logo&quot;&gt;&lt;/body&gt; 2.设置图片的宽高度 ​ 比如这张图片渚薰被吃 1234&lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot; alt=&quot;渚薰被吃了&quot;title=&quot;渚薰被吃&quot; style=&quot;width: 200px; height: 100px;&quot;&gt;&lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot; alt=&quot;渚薰被吃了&quot; style=&quot;width: 200px; height: 150px;&quot;&gt;&lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot; alt=&quot;渚薰被吃了&quot; style=&quot;width: 100px; height: 200px;&quot;&gt;&lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot; alt=&quot;渚薰被吃了&quot; style=&quot;width: 150px; height: 200px;&quot;&gt; 3图片映射 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;HTML图片映射&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;logo.png&quot; usemap=&quot;#objects&quot; alt=&quot;C语言中文网Logo&quot;&gt; &lt;map name=&quot;objects&quot;&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0,0,82,126&quot; href=&quot;http://c.biancheng.net/html/&quot; alt=&quot;HTML教程&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;90,58,3&quot; href=&quot;http://www.biancheng.net/css3/&quot; alt=&quot;CSS教程&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;124,58,8&quot; href=&quot;http://www.biancheng.net/js/&quot; alt=&quot;JavaScript教程&quot;&gt; &lt;/map&gt;&lt;/body&gt;&lt;/html&gt; &lt;.map&gt;标签的name属性对应的是&lt;.img&gt;标签的usemap属性,&lt;.area&gt;用于定义点击图片的坐标shape 和 coords 属性 在 &lt;.area&gt; 标签中可以通过 shape 属性来定义可点击区域的形状，并通过 coords 属性来定义形状所对应的坐标。其中 shape 属性的可选值有三个，分别是 rect（矩形）、circle（圆形）和 poly（多边形），coords 属性中坐标的值则取决于可点击区域的形状。 假如定义一个矩形的可点击区域，示例代码如下： 1&lt;area shape=&quot;rect&quot; coords=&quot;x1, y1, x2, y2&quot; href=&quot;http://c.biancheng.net/&quot; alt=&quot;&quot;&gt; 其中 x1、y1 代表矩形的左上角坐标，x2、y2 代表矩形的右下角坐标。 假如定义一个圆形的可点击区域，示例代码如下： 1&lt;area shape=&quot;circle&quot; coords=&quot;x, y, radius&quot; href=&quot;&quot; alt=&quot;&quot;&gt; 其中 x、y 代表圆心的坐标，而 radius 则是圆的半径。 假如定义一个多边形的可点击区域，示例代码如下： 1&lt;area shape=&quot;poly&quot; coords=&quot;x1, y1, x2, y2, x3, y3, ..., xn, yn&quot; href=&quot;http://c.biancheng.net/&quot; alt=&quot;&quot;&gt; 其中每对 x 和 y 的值都代表一个多边形的顶点坐标。 注意：所有坐标都是相对于图片的左上角来计算的。 属性 属性值 说明 src 图片路径 必须属性 alt 文字 图片显示不出 title 文字 鼠标放在图片上后显示的文字 width 像素 宽度 height 像素 高度 border 像素 边框粗细 1234&lt;a href=&quot;http://baidu.com&quot;&gt; &lt;img src=&quot;http://r34tujk76.hb-bkt.clouddn.com/blog/20211126/195024889.jpg&quot;&gt;&lt;/a&gt; 9HTML&lt;.table&gt;表格 1.表格使用代码 12345678910111213141516171819202122&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;官网&lt;/th&gt; &lt;th&gt;性质&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;b站&lt;/td&gt; &lt;td&gt;bilibili.com&lt;/td&gt; &lt;td&gt;综合&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;百度&lt;/td&gt; &lt;td&gt;http://www.baidu.com/&lt;/td&gt; &lt;td&gt;搜索&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;当当&lt;/td&gt; &lt;td&gt;http://www.dangdang.com/&lt;/td&gt; &lt;td&gt;图书&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 在里面中出现了新的单词table tr td th tr表示table row 表示行数 td表示table datacell 表示表格的单元格 th表示table heading表示表头 2.表格的边框合并 如果不进行修改会显示双层边框这时候利用css的border-collapse的属性为collapse 1&lt;table border=&quot;1&quot; style&quot;border-collapse:collapse&quot; 3.表格的标题&lt;.caption&gt; 12&lt;table border=&quot;1&quot; style=&quot;border-collapse:collapse;&quot;&gt;&lt;caption&gt;这是标题&lt;/caption&gt; 第一行并且居中显示 4.合并 rowspan跨行合并单元格 colspan跨列合并单元格 1234567891011121314151617181920&lt;table border=&quot;1&quot; style=&quot;border-collapse: collapse;&quot;&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;官网&lt;/th&gt; &lt;th&gt;性质&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C语言中文网&lt;/td&gt; &lt;td&gt;http://c.biancheng.net/&lt;/td&gt; &lt;td&gt;教育&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;百度&lt;/td&gt; &lt;td&gt;www.baidu.com&lt;/td&gt; &lt;td&gt;搜索&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;http://www.dangdang.com/&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 5.表格的属性 10.HTML列表标签 &lt;.ul&gt;&lt;.ol&gt;&lt;.dl&gt; html为我们提功了三个列表表达方式 1.有序列表 123456789&lt;body&gt; &lt;p&gt;煮米饭的步骤：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;将水煮沸&lt;/li&gt; &lt;li&gt;加入一勺米&lt;/li&gt; &lt;li&gt;搅拌均匀&lt;/li&gt; &lt;li&gt;继续煮10分钟&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt; ol为order list的意思为有序列表 li为 list item的意思为每一项 2.无序列表 123456789&lt;body&gt; &lt;p&gt;早餐的种类：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;鸡蛋&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;面包&lt;/li&gt; &lt;li&gt;生菜&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;.ul&gt; 是 unordered list 的简称，表示无序列表。 &lt;…ul&gt; 和 &lt;.ol&gt; 中的 &lt;.li&gt; 一样，都表示列表中的每一项。默认情况下，无序列表的每一项都使用●符号表示。 3.自定义列表 定义如下 12345678&lt;dl&gt; &lt;dt&gt;标题1&lt;dt&gt; &lt;dd&gt;描述文本2&lt;dd&gt; &lt;dt&gt;标题2&lt;dt&gt; &lt;dd&gt;描述文本2&lt;dd&gt; &lt;dt&gt;标题3&lt;dt&gt; &lt;dd&gt;描述文本3&lt;dd&gt;&lt;/dl&gt; dl为定义列表 dt为定义术语 dd为定义描述 12345678910&lt;body&gt; &lt;dl&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;HTML 是一种专门用来开发网页的标记语言，您可以转到《&lt;a href=&quot;http://c.biancheng.net/html/&quot; target=&quot;_blank&quot;&gt;HTML教程&lt;/a&gt;》了解更多。&lt;/dd&gt; &lt;dt&gt;CSS&lt;/dt&gt; &lt;dd&gt;CSS 层叠样式表可以控制 HTML 文档的显示样式，用来美化网页，您可以转到《&lt;a href=&quot;http://c.biancheng.net/css3/&quot; target=&quot;_blank&quot;&gt;CSS教程&lt;/a&gt;》了解更多。&lt;/dd&gt; &lt;dt&gt;JavaScript&lt;/dt&gt; &lt;dd&gt;JavaScript 简称 JS，是一种用来开发网站（包括前端和后台）的脚本编程语言，您可以转到《&lt;a href=&quot;http://c.biancheng.net/js/&quot; target=&quot;_blank&quot;&gt;JS教程&lt;/a&gt;》了解更多。&lt;/dd&gt; &lt;/dl&gt;&lt;/body&gt; 4.列表的默认样态 1234567891011121314 &lt;ol style=&quot;margin:0px auto; padding-left:20px; list-style:upper-latin;&quot;&gt; &lt;li&gt;将水煮沸&lt;/li&gt; &lt;li&gt;加入一勺米&lt;/li&gt; &lt;li&gt;搅拌均匀&lt;/li&gt; &lt;li&gt;继续煮10分钟&lt;/li&gt; &lt;/ol&gt;对 CSS 样式的说明：margin:0px auto;将上下外边距设置为 0 像素，将左右外边距设置为自动。margin-bottom:0px;将下方外边距设置为 0 像素。margin:auto auto 10px 0px;将上方和右侧外边距设置为自动，将下方外边距设置为 10 像素，将左侧外边距设置为 0 像素。padding-left:20px;将左侧内边距设置为 20 像素。list-style:upper-latin;将列表项标记设置为大写拉丁字母。list-style:square;将列表项标记设置为实心方块。 11.⛤⛤⛤&lt;.form&gt;标签 如果想通过网页交互可以通过form实现 123&lt;form action=&quot;URL&quot; method=&quot;GET|POST&quot;&gt; 表单中的其它标签&lt;/form&gt; action属性表示表单交到哪里 method属性表示使用什么方式提交数据 表单属于 HTML 文档的一部分，其中包含了如输入框、复选框、单选按钮、提交按钮等不同的表单控件，用户通过修改表单中的元素（例如输入文本，选择某个选项等）来完成表单，通过表单中的提交按钮将表单数据提交给后端程序。 除了type以外input还有其它的属性 注意这个name，如果说没有name属性，在这里如果没有name属性比如上例，点击male和female都可以 单选和复选name应该是相同的值 checked这个是默认勾选的，比如说用户同意这种的 1文字域 账号 密码 1234&lt;form&gt;账号&lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br&gt;密码&lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;/form&gt; 2密码字段 如果想输入密码的话 input type=&quot;password&quot;修改password 这样就输入字符串，会变成星号 123&lt;form&gt;Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/form&gt; Password: 3.按钮 1234&lt;form&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; checked=&quot;checked&quot;&gt;Female&lt;/form&gt; Male Female 4.复选框checkboxes 1234&lt;form&gt;&lt;input type=&quot;checkbox&quot; value&quot;男&quot;&gt;男&lt;br&gt; &lt;input type=&quot;checkbox&quot; value&quot;女&quot;&gt;女&lt;/form&gt; 男 女 5提交按钮 1234&lt;form name=&quot;input&quot; action=&quot;html_form_action.php&quot; method=&quot;get&quot;&gt;Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; Username: Username: 假如您在上面的文本框内键入几个字母，然后点击确认按钮，那么输入数据会传送到 “html_form_action.php” 的页面。该页面将显示出输入的结果。 6.简单的下拉列表 1234567&lt;p&gt;你喜欢吃什么&lt;/p&gt;&lt;form&gt;&lt;select name=&quot;cars&quot;&gt;&lt;option value=&quot;volvo&quot;&gt;洋芋&lt;/option&gt;&lt;option value=&quot;saab&quot; selected=&quot;selected&quot;&gt;土豆&lt;/option&gt;&lt;/select&gt;&lt;/form&gt; 你喜欢吃什么 洋芋 土豆 ![mark](https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/202112051307064.png) 7重置reset 123&lt;form&gt; &lt;input type=&quot;reset&quot; value=&quot;点我重新填写&quot;&gt;&lt;/form&gt; 8定义点击按钮 1&lt;input type=&quot;button&quot; value=&quot;点我&quot;&gt; 9上传文件 1&lt;input type=&quot;file&quot; value=&quot;点我&quot;&gt; 10.label标签 12&lt;input type=&quot;radio&quot;name=&quot;sex&quot; id=&quot;nan&quot;&gt;&lt;label for=&quot;nan&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot;name=&quot;sex&quot; id=&quot;nv&quot;&gt;&lt;label for=&quot;nv&quot;&gt;女&lt;/label&gt; 11.表单元素 textarea表单元素 当用户输入过多的元素的时候不用单纯的text了 1234&lt;form&gt;今日反馈 &lt;textarea cols=&quot;5&quot; rows=&quot;1&quot;&gt; &lt;/textarea&gt;&lt;/form&gt; 今日反馈 13.html综合学习 1注册界面 .html综合学习 1注册界面","categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"编程/前端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://kaguranotamashii.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习","slug":"学习","permalink":"https://kaguranotamashii.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"我对程序员的再认知","slug":"我对程序员的再认识","date":"2021-11-22T16:08:12.000Z","updated":"2022-07-17T15:51:26.287Z","comments":true,"path":"posts/24454/","link":"","permalink":"https://kaguranotamashii.github.io/posts/24454/","excerpt":"1.接触 在高三的时候，和同学讨论志愿报名的时候，一些学物理的男生就表示计算机挣钱多。“我的亲戚学历不高，就自学前端什么什么的，在北京挣了多多少钱”。","text":"1.接触 在高三的时候，和同学讨论志愿报名的时候，一些学物理的男生就表示计算机挣钱多。“我的亲戚学历不高，就自学前端什么什么的，在北京挣了多多少钱”。 后来高考考上了信息科大的通信学院的电子信息工程（EE），没有考中我想去的CS（Computer Science），虽然很失望，但是可以尝试转专业。转专业的想法在我心中愈来愈强烈。因此从开始那天到Iflab社团招新那一段时候，我犯了很严重的错误。 2.反思 程序员的灵魂是什么？算法？代码？直到加入了iflab社团，导师为新生推荐的书籍中，部分都是哲学类的书籍，一时让我有了进入了文艺社的感觉。后来才明白，我用VS2019写出来的代码虽然有1G大，但是它没有思想，没有灵魂，没有‘生命力’的躯壳。 翁PJ学长的‘做一个天马行空的人’这封给新生的一封信。让我反思起从这几周我的盲目性，单纯为学习而学习的思维是非常不正确的，Hr不会听你的大学当过什么什么，这个感觉太像我在高考后，渴望着明明考不上的大学听到我的故事，而破例录取，但现实是残酷的。 编程是为了什么？钱？自由？其实都有一定的存在。用代码创造出自己的世界。最近在学习前端语言的时候我注意到了一系列课叫应用无障碍。与此同时B站也推出了对聋人帮助的实时字幕。这就是编程给特殊群体带来的便利。再比如苹果以及安卓手机的无障碍模式，都是用代码来为特殊人群的帮助。 3.继续行走 自己也是其中之一，我也感受到了代码的&quot;温暖&quot;，计算机中的代码不再是冷冰冰的英文字母和符号了，它变成了照亮迷路的旅途者的灯塔。 大一上半年的我，继续探索吧，寻找属于自己的灯塔吧，自己的方向吧。 202112051308290.png)","categories":[{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/categories/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/tags/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"}]},{"title":"博客的搭建记录.","slug":"博客常用的记录","date":"2021-11-22T06:35:49.000Z","updated":"2022-11-22T01:29:00.217Z","comments":true,"path":"posts/5977d6f4/","link":"","permalink":"https://kaguranotamashii.github.io/posts/5977d6f4/","excerpt":"对hexo的记录","text":"对hexo的记录 1.hexo的一些指令 本地预览 hexo s 配置文件和主题 hexo g **清空 hexo g ** 生成的内容 hexo clean 标题名称 hexo new post 标题名称 123categories: -cover: 图标 2.Typora和Hd的使用方法 typora的快捷键 1.段落 标题：Ctrl+1/2/3/4/5 段落：Ctrl+0 增大标题级别：Ctrl+= 减少标题级别：Ctrl± 表格：Ctrl+T 代码块：Ctrl+Shift+K 公式块：Ctrl+Shift+M 引用：Ctrl+Shift+Q 有序列表：Ctrl+Shift+[ 无序列表：Ctrl+Shift+] 增加缩进：Ctrl+] 减少缩进：Ctrl+[ 2.格式 加粗：Ctrl+B 斜体：Ctrl+I 下划线：Ctrl+U 代码：Ctrl+Shift+` 删除线：Alt+Shift+5 超链接：Ctrl+K 图像：Ctrl+Shift+I 清除样式：Ctrl+ 3.部分常用的 标题：Ctrl+1、2、3…对应一、二、三…级标题（光标定位到需要设置为标题的行，按快捷键） 加粗：Ctrl+B（选中要加粗的文本，按快捷键） 斜体：Ctrl+I（选中要设置斜体的文本，按快捷键） 下划线：Ctrl+U（选中要加下划线的文本，按快捷键） 删除线：Alt+Shift+5（选中要加删除线的文本，按快捷键） 代码片段：Ctrl+Shift+`（选中要设置为代码片段的文本，按快捷键） 代码块：Ctrl+Shift+K（任意位置按快捷键，选择编程语言然后在代码块中输入代码） 切换到下一行：Ctrl+Enter（任意位置按快捷键，在代码块中可以跳出代码块另起一行） 链接：Ctrl+K（先复制链接，然后选中要加链接的文本，按快捷键。Ctrl+左键点击文本可跳转到对应链接） 取消格式：再次按相同的快捷键即可 有序列表：数字+点+空格 任务列表：加号或减号+空格 切换到列表下一行：Space+Enter 嵌套列表：按Tab键 退出列表：按 Shift+Tab 插入表格：Ctrl+T 引用：输入&gt;后面加空格，或者Ctrl+Shift+Q 3.yilia的美化和修改（已经换蝴蝶主题） 标签 123456tags: - 小工具 - hexo - yilia---或者tags: [xx,xxxx] 截断点 12# 在博客md文件中，设置截断位置&lt;!--more--&gt; 图标 1`theme/yilia/source`目录下添加`favicon.ico`图片 文章点击量 1234567891011121314themes/yilia/layout/_partial/article.ejs中&lt;%- partial(&#x27;post/title&#x27;, &#123;class_name: &#x27;article-title&#x27;&#125;) %&gt;后面加入&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;br/&gt; &lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 阅读数: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt;&lt;% &#125; %&gt;&lt;!--显示阅读次数完毕--&gt; 插入图片 1npm install hexo-asset-image –save 打开blog的_cofig.yml修改 1post_asset_folder: true 新建文章的时候自动生成文章名字.filenname，将图片放入 总文章数 123456789将*themes\\yilia\\layout_partial*left-col.ejs文件的&lt;nav class=&quot;header-menu&quot;&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt; 不蒜子 12在 themes\\yilia\\layout_partial\\after-footer.ejs最后添加&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 1234567891011修改 themes\\yilia\\layout\\_partial\\footer.ejs，包括访客数和站点访问总量# PV方式，单个用户连续点击 n 篇，记录 n 次记录值&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;# UV方式，单个用户连续点击 n 篇，记录 1 次记录值&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;单篇# 使用 pv 记录方式，每访问一次，记录一次&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 4蝴蝶主题 12345678npm install hexo-generator-index-pin-top --save安装置顶md文件内部的配置top: 1000//数字越大置顶在前面//这个也是zsticky:comments: true 添加上这个，如果这篇文章不需要评论改为false，默认开启 Butterfly主题美化日记 | Akilarの糖果屋 Hexo+Butterfly主题美化 | 唐先森の博客 (tzy1997.com) Hexo 博客之 butterfly 主题优雅魔改系列 | 小康博客 (antmoe.com) Butterfly主题外挂标签（个人常用） | Hassan’s Blog (hassanwong.top) Search | Font Awesome 图标网站11 2022/6/17 隐藏文章 12345npm install hexo-generator-indexed---title: examplehide: true---","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://kaguranotamashii.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"个人博客/hexo","permalink":"https://kaguranotamashii.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo/"}],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://kaguranotamashii.github.io/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"https://kaguranotamashii.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"记录","slug":"记录","permalink":"https://kaguranotamashii.github.io/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"博客的搭建记录.","slug":"[main]hexo/博客常用的记录","date":"2021-11-22T06:35:49.000Z","updated":"2022-11-22T17:38:49.797Z","comments":true,"path":"posts/1501026038/","link":"","permalink":"https://kaguranotamashii.github.io/posts/1501026038/","excerpt":"","text":"1.hexo的一些指令 本地预览 hexo s 配置文件和主题 hexo g **清空 hexo g ** 生成的内容 hexo clean 标题名称 hexo new post 标题名称 123categories: -cover: 图标 2.Typora和Hd的使用方法 typora的快捷键 1.段落 标题：Ctrl+1/2/3/4/5 段落：Ctrl+0 增大标题级别：Ctrl+= 减少标题级别：Ctrl± 表格：Ctrl+T 代码块：Ctrl+Shift+K 公式块：Ctrl+Shift+M 引用：Ctrl+Shift+Q 有序列表：Ctrl+Shift+[ 无序列表：Ctrl+Shift+] 增加缩进：Ctrl+] 减少缩进：Ctrl+[ 2.格式 加粗：Ctrl+B 斜体：Ctrl+I 下划线：Ctrl+U 代码：Ctrl+Shift+` 删除线：Alt+Shift+5 超链接：Ctrl+K 图像：Ctrl+Shift+I 清除样式：Ctrl+ 3.部分常用的 标题：Ctrl+1、2、3…对应一、二、三…级标题（光标定位到需要设置为标题的行，按快捷键） 加粗：Ctrl+B（选中要加粗的文本，按快捷键） 斜体：Ctrl+I（选中要设置斜体的文本，按快捷键） 下划线：Ctrl+U（选中要加下划线的文本，按快捷键） 删除线：Alt+Shift+5（选中要加删除线的文本，按快捷键） 代码片段：Ctrl+Shift+`（选中要设置为代码片段的文本，按快捷键） 代码块：Ctrl+Shift+K（任意位置按快捷键，选择编程语言然后在代码块中输入代码） 切换到下一行：Ctrl+Enter（任意位置按快捷键，在代码块中可以跳出代码块另起一行） 链接：Ctrl+K（先复制链接，然后选中要加链接的文本，按快捷键。Ctrl+左键点击文本可跳转到对应链接） 取消格式：再次按相同的快捷键即可 有序列表：数字+点+空格 任务列表：加号或减号+空格 切换到列表下一行：Space+Enter 嵌套列表：按Tab键 退出列表：按 Shift+Tab 插入表格：Ctrl+T 引用：输入&gt;后面加空格，或者Ctrl+Shift+Q 3.yilia的美化和修改（已经换蝴蝶主题） 标签 123456tags: - 小工具 - hexo - yilia---或者tags: [xx,xxxx] 截断点 12# 在博客md文件中，设置截断位置&lt;!--more--&gt; 图标 1`theme/yilia/source`目录下添加`favicon.ico`图片 文章点击量 1234567891011121314themes/yilia/layout/_partial/article.ejs中&lt;%- partial(&#x27;post/title&#x27;, &#123;class_name: &#x27;article-title&#x27;&#125;) %&gt;后面加入&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;br/&gt; &lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 阅读数: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt;&lt;% &#125; %&gt;&lt;!--显示阅读次数完毕--&gt; 插入图片 1npm install hexo-asset-image –save 打开blog的_cofig.yml修改 1post_asset_folder: true 新建文章的时候自动生成文章名字.filenname，将图片放入 总文章数 123456789将*themes\\yilia\\layout_partial*left-col.ejs文件的&lt;nav class=&quot;header-menu&quot;&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt; 不蒜子 12在 themes\\yilia\\layout_partial\\after-footer.ejs最后添加&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 1234567891011修改 themes\\yilia\\layout\\_partial\\footer.ejs，包括访客数和站点访问总量# PV方式，单个用户连续点击 n 篇，记录 n 次记录值&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;# UV方式，单个用户连续点击 n 篇，记录 1 次记录值&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;单篇# 使用 pv 记录方式，每访问一次，记录一次&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 4蝴蝶主题 12345678npm install hexo-generator-index-pin-top --save安装置顶md文件内部的配置top: 1000//数字越大置顶在前面//这个也是zsticky:comments: true 添加上这个，如果这篇文章不需要评论改为false，默认开启 Butterfly主题美化日记 | Akilarの糖果屋 Hexo+Butterfly主题美化 | 唐先森の博客 (tzy1997.com) Hexo 博客之 butterfly 主题优雅魔改系列 | 小康博客 (antmoe.com) Butterfly主题外挂标签（个人常用） | Hassan’s Blog (hassanwong.top) Search | Font Awesome 图标网站11 5蝴蝶主题的美化 2022/6/17 隐藏文章 12345npm install hexo-generator-indexed---title: examplehide: true--- 7月7日更新 更新背景的流星雨 Hexo博客 | 如何让你的博客拥有星空背景和流星特效 | Justlovesmile’s BLOG 修改非夜间模式启用将js写成两份 一份文件关键词dark， 一份都是light 目前来看我的个人博客美化的已经差不多了吧 7月11日更新 夜间模式切换动画 实现白天夜晚切换动画 7/17 修改了右键小部件，写了点好玩的小彩蛋hhhh 在原有作者的前提下修改了 菜单切换夜间模式效果 夜间模式颜色 首页文章卡片修改 8.6 D:\\kagura blog\\kagura_blog\\themes\\butterfly\\source\\css_layout\\sidebar.styl 12right: -($sidebar-width)-5px//这边我不知道弄什么操作了 -5px 我的Blog美化日记——Hexo+Butterfly | Guo Le’s Blog","categories":[{"name":"hexo","slug":"hexo","permalink":"https://kaguranotamashii.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://kaguranotamashii.github.io/tags/hexo/"}]},{"title":"最初のBlog「神楽の魂という意味は？」","slug":"神楽の魂という意味は？","date":"2021-11-22T04:57:13.000Z","updated":"2022-08-07T02:50:48.812Z","comments":true,"path":"posts/999999/","link":"","permalink":"https://kaguranotamashii.github.io/posts/999999/","excerpt":"关于我的网名","text":"关于我的网名 1.ゲームから 初中的时候玩阴阳师，自动推荐的名字就是神乐之魂**「かぐらのたましい」**，也不知道怎么的就喜欢上了这个网名。 2.激しい 后来，高二的时候买了日语网课(因为我是小语种考生),一开始我在群名批注就改为神乐之魂。 那时候我还以为乐这个字读为le，后来小王子老师叫我网名的时候就是读yue，当时我也经常读错。不过随着日语水平的提高我叫它为かぐら。 后来和群友混熟了，他们都叫我神乐老弟（现在退群了），我也习惯了神乐之魂这个网名。 我的GitHub就是以神乐之魂的假名为基础命名的，但是太过于长了（kaguranotamashii），待考虑改为kagura。 3.新しいミライから 我的博客主要打算写我的对计算机的学习，以及我的一些思考。 ボクノミライハマダ始まったバカリ！(我的未来才刚开始！)","categories":[{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/categories/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"}],"tags":[]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"后端","slug":"编程/后端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/"},{"name":"云服务器","slug":"编程/后端/云服务器","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"建筑史","slug":"建筑史","permalink":"https://kaguranotamashii.github.io/categories/%E5%BB%BA%E7%AD%91%E5%8F%B2/"},{"name":"JavaWeb","slug":"编程/后端/JavaWeb","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%90%8E%E7%AB%AF/JavaWeb/"},{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/categories/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://kaguranotamashii.github.io/categories/Leetcode/"},{"name":"基础知识","slug":"Leetcode/基础知识","permalink":"https://kaguranotamashii.github.io/categories/Leetcode/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"前端","slug":"编程/前端","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/"},{"name":"vue框架","slug":"编程/前端/vue框架","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/vue%E6%A1%86%E6%9E%B6/"},{"name":"git","slug":"git","permalink":"https://kaguranotamashii.github.io/categories/git/"},{"name":"java","slug":"编程/java","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/java/"},{"name":"jquery","slug":"编程/前端/jquery","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/jquery/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kaguranotamashii.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"cpp","slug":"编程/cpp","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/cpp/"},{"name":"Python","slug":"编程/Python","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/Python/"},{"name":"javascript","slug":"编程/前端/javascript","permalink":"https://kaguranotamashii.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%89%8D%E7%AB%AF/javascript/"},{"name":"个人博客","slug":"个人博客","permalink":"https://kaguranotamashii.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"个人博客/hexo","permalink":"https://kaguranotamashii.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo/"},{"name":"hexo","slug":"hexo","permalink":"https://kaguranotamashii.github.io/categories/hexo/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://kaguranotamashii.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"云服务器","slug":"云服务器","permalink":"https://kaguranotamashii.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"西方建筑","slug":"西方建筑","permalink":"https://kaguranotamashii.github.io/tags/%E8%A5%BF%E6%96%B9%E5%BB%BA%E7%AD%91/"},{"name":"东方建筑","slug":"东方建筑","permalink":"https://kaguranotamashii.github.io/tags/%E4%B8%9C%E6%96%B9%E5%BB%BA%E7%AD%91/"},{"name":"Java","slug":"Java","permalink":"https://kaguranotamashii.github.io/tags/Java/"},{"name":"年度总结","slug":"年度总结","permalink":"https://kaguranotamashii.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"闲聊杂谈","slug":"闲聊杂谈","permalink":"https://kaguranotamashii.github.io/tags/%E9%97%B2%E8%81%8A%E6%9D%82%E8%B0%88/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kaguranotamashii.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"vue框架","slug":"vue框架","permalink":"https://kaguranotamashii.github.io/tags/vue%E6%A1%86%E6%9E%B6/"},{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://kaguranotamashii.github.io/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"name":"git","slug":"git","permalink":"https://kaguranotamashii.github.io/tags/git/"},{"name":"java","slug":"java","permalink":"https://kaguranotamashii.github.io/tags/java/"},{"name":"黑苹果","slug":"黑苹果","permalink":"https://kaguranotamashii.github.io/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"jquery","slug":"jquery","permalink":"https://kaguranotamashii.github.io/tags/jquery/"},{"name":"swift","slug":"swift","permalink":"https://kaguranotamashii.github.io/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://kaguranotamashii.github.io/tags/ios/"},{"name":"数据结构","slug":"数据结构","permalink":"https://kaguranotamashii.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"cpp","slug":"cpp","permalink":"https://kaguranotamashii.github.io/tags/cpp/"},{"name":"考试","slug":"考试","permalink":"https://kaguranotamashii.github.io/tags/%E8%80%83%E8%AF%95/"},{"name":"C语言","slug":"C语言","permalink":"https://kaguranotamashii.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"https://kaguranotamashii.github.io/tags/Python/"},{"name":"CSS","slug":"CSS","permalink":"https://kaguranotamashii.github.io/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"https://kaguranotamashii.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://kaguranotamashii.github.io/tags/javascript/"},{"name":"学习","slug":"学习","permalink":"https://kaguranotamashii.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"搭建博客","slug":"搭建博客","permalink":"https://kaguranotamashii.github.io/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"指令","slug":"指令","permalink":"https://kaguranotamashii.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"记录","slug":"记录","permalink":"https://kaguranotamashii.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"hexo","slug":"hexo","permalink":"https://kaguranotamashii.github.io/tags/hexo/"}]}