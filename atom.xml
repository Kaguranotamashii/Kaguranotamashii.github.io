<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神楽の魂的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2019-12-21T09:17:24.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>神楽の魂</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-understanding-equals-and-hashcode/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-understanding-equals-and-hashcode/</id>
    <published>2022-06-23T15:31:23.696Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-理解-equals-和-hashCode-方法"><a href="#附录-理解-equals-和-hashCode-方法" class="headerlink" title="附录:理解 equals 和 hashCode 方法"></a>附录:理解 equals 和 hashCode 方法</h1><p>假设有一个容器使用 hash 函数，当你创建一个放到这个容器时，你必须定义 <strong>hashCode()</strong> 函数和 <strong>equals()</strong> 函数。这两个函数一起被用于 hash 容器中的查询操作。</p><h2 id="equals-规范"><a href="#equals-规范" class="headerlink" title="equals 规范"></a>equals 规范</h2><p>当你创建一个类的时候，它自动继承自 <strong>Objcet</strong> 类。如果你不覆写 <strong>equals()</strong> ，你将会获得 <strong>Objcet</strong> 对象的 <strong>equals()</strong> 函数。默认情况下，这个函数会比较对象的地址。所以只有你在比较同一个对象的时候，你才会获得<strong>true</strong>。默认的情况是”区分度最高的”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/DefaultComparison.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultComparison</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i, j, k;</span><br><span class="line">    DefaultComparison(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultComparison</span><br><span class="line">        a = <span class="keyword">new</span> DefaultComparison(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        b = <span class="keyword">new</span> DefaultComparison(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(a == a);</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常你会希望放宽这个限制。一般来说如果两个对象有相同的类型和相同的字段，你会认为这两个对象相等，但也会有一些你不想加入 <strong>equals()</strong> 函数中来比较的字段。这是类型设计的一部分。</p><p>一个合适的 <strong>equals()</strong>函数必须满足以下五点条件：</p><ol><li>反身性：对于任何 <strong>x</strong>， <strong>x.equals(x)</strong> 应该返回 <strong>true</strong>。</li><li>对称性：对于任何 <strong>x</strong> 和 <strong>y</strong>， <strong>x.equals(y)</strong> 应该返回 <strong>true</strong>当且仅当 <strong>y.equals(x)</strong> 返回 <strong>true</strong> 。</li><li>传递性：对于任何<strong>x</strong>,<strong>y</strong>,还有<strong>z</strong>，如果 <strong>x.equals(y)</strong> 返回 <strong>true</strong> 并且 <strong>y.equals(z)</strong> 返回 <strong>true</strong>，那么 <strong>x.equals(z)</strong> 应该返回 <strong>true</strong>。</li><li>一致性：对于任何 <strong>x</strong>和<strong>y</strong>，在对象没有被改变的情况下，多次调用 <strong>x.equals(y)</strong> 应该总是返回 <strong>true</strong> 或者<strong>false</strong>。</li><li>对于任何非<strong>null</strong>的<strong>x</strong>，<strong>x.equals(null)</strong>应该返回<strong>false</strong>。</li></ol><p>下面是满足这些条件的测试，并且判断对象是否和自己相等（我们这里称呼其为<strong>右值</strong>）：</p><ol><li>如果<strong>右值</strong>是<strong>null</strong>，那么不相等。</li><li>如果<strong>右值</strong>是<strong>this</strong>，那么两个对象相等。</li><li>如果<strong>右值</strong>不是同一个类型或者子类，那么两个对象不相等。</li><li>如果所有上面的检查通过了，那么你必须决定 <strong>右值</strong> 中的哪些字段是重要的，然后比较这些字段。<br>Java 7 引入了 <strong>Objects</strong> 类型来帮助这个流程，这样我们能够写出更好的 <strong>equals()</strong> 函数。</li></ol><p>下面的例子比较了不同类型的 <strong>Equality</strong>类。为了避免重复的代码，我们使用<em>工厂函数设计模</em>式来实现样例。 <strong>EqualityFactory</strong>接口提供<strong>make()</strong>函数来生成一个<strong>Equaity</strong>对象，这样不同的<strong>EqualityFactory</strong>能够生成<strong>Equality</strong>不同的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/EqualityFactory.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">EqualityFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Equality <span class="title">make</span><span class="params">(<span class="keyword">int</span> i, String s, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来定义 <strong>Equality</strong>，它包含三个字段（所有的字段我们认为在比较中都很重要）和一个 <strong>equals()</strong> 函数用来满足上述的四种检查。构造函数展示了它的类名来保证我们在执行我们想要的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/Equality.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equality</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">protected</span> String s;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> d;<span class="function"><span class="keyword">public</span> <span class="title">Equality</span><span class="params">(<span class="keyword">int</span> i, String s, <span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">this</span>.d = d;</span><br><span class="line">        System.out.println(<span class="string">&quot;made &#x27;Equality&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object rval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rval == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rval == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(rval <span class="keyword">instanceof</span> Equality))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Equality other = (Equality)rval;</span><br><span class="line">        <span class="keyword">if</span>(!Objects.equals(i, other.i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Objects.equals(s, other.s))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Objects.equals(d, other.d))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String descr, String expected, Object rval)</span> </span>&#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;-- Testing %s --%n&quot;</span> + <span class="string">&quot;%s instanceof Equality: %s%n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;Expected %s, got %s%n&quot;</span>,</span><br><span class="line">        descr, descr, rval <span class="keyword">instanceof</span> Equality,</span><br><span class="line">        expected, equals(rval));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAll</span><span class="params">(EqualityFactory eqf)</span> </span>&#123;</span><br><span class="line">        Equality</span><br><span class="line">        e = eqf.make(<span class="number">1</span>, <span class="string">&quot;Monty&quot;</span>, <span class="number">3.14</span>),</span><br><span class="line">        eq = eqf.make(<span class="number">1</span>, <span class="string">&quot;Monty&quot;</span>, <span class="number">3.14</span>),</span><br><span class="line">        neq = eqf.make(<span class="number">99</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">1.618</span>);</span><br><span class="line">        e.test(<span class="string">&quot;null&quot;</span>, <span class="string">&quot;false&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        e.test(<span class="string">&quot;same object&quot;</span>, <span class="string">&quot;true&quot;</span>, e);</span><br><span class="line">        e.test(<span class="string">&quot;different type&quot;</span>,</span><br><span class="line">        <span class="string">&quot;false&quot;</span>, Integer.valueOf(<span class="number">99</span>));e.test(<span class="string">&quot;same values&quot;</span>, <span class="string">&quot;true&quot;</span>, eq);</span><br><span class="line">        e.test(<span class="string">&quot;different values&quot;</span>, <span class="string">&quot;false&quot;</span>, neq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAll( (i, s, d) -&gt; <span class="keyword">new</span> Equality(i, s, d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">-- Testing null --</span></span><br><span class="line"><span class="comment">null instanceof Equality: false</span></span><br><span class="line"><span class="comment">Expected false, got false</span></span><br><span class="line"><span class="comment">-- Testing same object --</span></span><br><span class="line"><span class="comment">same object instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected true, got true</span></span><br><span class="line"><span class="comment">-- Testing different type --</span></span><br><span class="line"><span class="comment">different type instanceof Equality: false</span></span><br><span class="line"><span class="comment">Expected false, got false-- Testing same values --</span></span><br><span class="line"><span class="comment">same values instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected true, got true</span></span><br><span class="line"><span class="comment">-- Testing different values --</span></span><br><span class="line"><span class="comment">different values instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected false, got false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>testAll()</strong> 执行了我们期望的所有不同类型对象的比较。它使用工厂创建了<strong>Equality</strong>对象。</p><p>在 <strong>main()</strong> 里，请注意对 <strong>testAll()</strong> 的调用很简单。因为<strong>EqualityFactory</strong>有着单一的函数，它能够和 lambda 表达式一起使用来表示<strong>make()</strong>函数。</p><p>上述的 <strong>equals()</strong> 函数非常繁琐，并且我们能够将其简化成规范的形式，请注意：</p><ol><li><strong>instanceof</strong>检查减少了<strong>null</strong>检查的需要。</li><li>和<strong>this</strong>的比较是多余的。一个正确书写的 <strong>equals()</strong> 函数能正确地和自己比较。</li></ol><p>因为 <strong>&amp;&amp;</strong> 是一个短路比较，它会在第一次遇到失败的时候退出并返回<strong>false</strong>。所以，通过使用 <strong>&amp;&amp;</strong> 将检查链接起来，我们可以写出更精简的 <strong>equals()</strong> 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/SuccinctEquality.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccinctEquality</span> <span class="keyword">extends</span> <span class="title">Equality</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuccinctEquality</span><span class="params">(<span class="keyword">int</span> i, String s, <span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(i, s, d);</span><br><span class="line">        System.out.println(<span class="string">&quot;made &#x27;SuccinctEquality&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object rval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rval <span class="keyword">instanceof</span> SuccinctEquality &amp;&amp;</span><br><span class="line">        Objects.equals(i, ((SuccinctEquality)rval).i) &amp;&amp;</span><br><span class="line">        Objects.equals(s, ((SuccinctEquality)rval).s) &amp;&amp;</span><br><span class="line">        Objects.equals(d, ((SuccinctEquality)rval).d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Equality.testAll( (i, s, d) -&gt;</span><br><span class="line">        <span class="keyword">new</span> SuccinctEquality(i, s, d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;SuccinctEquality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;SuccinctEquality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;SuccinctEquality&#x27;</span></span><br><span class="line"><span class="comment">-- Testing null --</span></span><br><span class="line"><span class="comment">null instanceof Equality: false</span></span><br><span class="line"><span class="comment">Expected false, got false</span></span><br><span class="line"><span class="comment">-- Testing same object --</span></span><br><span class="line"><span class="comment">same object instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected true, got true</span></span><br><span class="line"><span class="comment">-- Testing different type --</span></span><br><span class="line"><span class="comment">different type instanceof Equality: false</span></span><br><span class="line"><span class="comment">Expected false, got false</span></span><br><span class="line"><span class="comment">-- Testing same values --</span></span><br><span class="line"><span class="comment">same values instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected true, got true</span></span><br><span class="line"><span class="comment">-- Testing different values --different values instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected false, got false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于每个 <strong>SuccinctEquality</strong>，基类构造函数在派生类构造函数前被调用，输出显示我们依然获得了正确的结果，你可以发现短路返回已经发生了，不然的话，<strong>null</strong>测试和“不同类型”的测试会在 <strong>equals()</strong> 函数下面的比较中强制转化的时候抛出异常。<br><strong>Objects.equals()</strong> 会在你组合其他类型的时候发挥很大的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/ComposedEquality.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Part</span> </span>&#123;</span><br><span class="line">    String ss;</span><br><span class="line">    <span class="keyword">double</span> dd;</span><br><span class="line"></span><br><span class="line">    Part(String ss, <span class="keyword">double</span> dd) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ss = ss;</span><br><span class="line">        <span class="keyword">this</span>.dd = dd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object rval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rval <span class="keyword">instanceof</span> Part &amp;&amp;</span><br><span class="line">        Objects.equals(ss, ((Part)rval).ss) &amp;&amp;</span><br><span class="line">        Objects.equals(dd, ((Part)rval).dd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComposedEquality</span> <span class="keyword">extends</span> <span class="title">SuccinctEquality</span> </span>&#123;</span><br><span class="line">    Part part;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComposedEquality</span><span class="params">(<span class="keyword">int</span> i, String s, <span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(i, s, d);</span><br><span class="line">        part = <span class="keyword">new</span> Part(s, d);</span><br><span class="line">        System.out.println(<span class="string">&quot;made &#x27;ComposedEquality&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object rval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rval <span class="keyword">instanceof</span> ComposedEquality &amp;&amp;</span><br><span class="line">        <span class="keyword">super</span>.equals(rval) &amp;&amp;</span><br><span class="line">        Objects.equals(part,</span><br><span class="line">        ((ComposedEquality)rval).part);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Equality.testAll( (i, s, d) -&gt;</span><br><span class="line">        <span class="keyword">new</span> ComposedEquality(i, s, d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;SuccinctEquality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;ComposedEquality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;SuccinctEquality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;ComposedEquality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;Equality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;SuccinctEquality&#x27;</span></span><br><span class="line"><span class="comment">made &#x27;ComposedEquality&#x27;</span></span><br><span class="line"><span class="comment">-- Testing null --null instanceof Equality: false</span></span><br><span class="line"><span class="comment">Expected false, got false</span></span><br><span class="line"><span class="comment">-- Testing same object --</span></span><br><span class="line"><span class="comment">same object instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected true, got true</span></span><br><span class="line"><span class="comment">-- Testing different type --</span></span><br><span class="line"><span class="comment">different type instanceof Equality: false</span></span><br><span class="line"><span class="comment">Expected false, got false</span></span><br><span class="line"><span class="comment">-- Testing same values --</span></span><br><span class="line"><span class="comment">same values instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected true, got true</span></span><br><span class="line"><span class="comment">-- Testing different values --</span></span><br><span class="line"><span class="comment">different values instanceof Equality: true</span></span><br><span class="line"><span class="comment">Expected false, got false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意 super.equals()这个调用，没有必要重新发明它（因为你不总是有权限访问基类所有的必要字段）</p><h3 id="不同子类的相等性"><a href="#不同子类的相等性" class="headerlink" title="不同子类的相等性"></a>不同子类的相等性</h3><p>继承意味着两个不同子类的对象当其向上转型的时候可以是相等的。假设你有一个 Animal 对象的集合。这个集合天然接受<strong>Animal</strong>的子类。在这个例子中是<strong>Dog</strong>和<strong>Pig</strong>。每个<strong>Animal</strong>有一个<strong>name</strong>和<strong>size</strong>，还有唯一的内部<strong>id</strong>数字。</p><p>我们通过<strong>Objects</strong>类，以规范的形式定义 <strong>equals()</strong>函数和<strong>hashCode()</strong>。但是我们只能在基类<strong>Animal</strong>中定义他们。并且我们在这两个函数中没有包含<strong>id</strong>字段。从<strong>equals()</strong>函数的角度看待，这意味着我们只关心它是否是<strong>Animal</strong>，而不关心是否是<strong>Animal</strong>的某个子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/SubtypeEquality.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line">    Animal(String name, Size size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object rval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rval <span class="keyword">instanceof</span> Animal &amp;&amp;</span><br><span class="line">        <span class="comment">// Objects.equals(id, ((Animal)rval).id) &amp;&amp; // [1]</span></span><br><span class="line">        Objects.equals(name, ((Animal)rval).name) &amp;&amp;</span><br><span class="line">        Objects.equals(size, ((Animal)rval).size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, size);</span><br><span class="line">        <span class="comment">// return Objects.hash(name, size, id); // [2]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%s[%d]: %s %s %x&quot;</span>,</span><br><span class="line">        getClass().getSimpleName(), id,</span><br><span class="line">        name, size, hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    Dog(String name, Size size) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    Pig(String name, Size size) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubtypeEquality</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Animal&gt; pets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog(<span class="string">&quot;Ralph&quot;</span>, Size.MEDIUM));</span><br><span class="line">        pets.add(<span class="keyword">new</span> Pig(<span class="string">&quot;Ralph&quot;</span>, Size.MEDIUM));</span><br><span class="line">        pets.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Dog[0]: Ralph MEDIUM a752aeee</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果我们只考虑类型的话，某些情况下它的确说得通——只从基类的角度看待问题，这是李氏替换原则的基石。这个代码完美符合替换理论因为派生类没有添加任何额外不再基类中的额外函数。派生类只是在表现上不同，而不是在接口上。（当然这不是常态）</p><p>但是当我们提供了两个有着相同数据的不同的对象类型，然后将他们放置在 <strong>HashSet<Animal></Animal></strong> 中。只有他们中的一个能存活。这强调了 <strong>equals()</strong> 不是完美的数学理论，而只是机械般的理论。<br><strong>hashCode()</strong> 和 <strong>equals()</strong> 必须能够允许类型在 hash 数据结构中正常工作。例子中 <strong>Dog</strong> 和 <strong>Pig</strong> 会被映射到同 <strong>HashSet</strong> 的同一个桶中。这个时候，<strong>HashSet</strong> 回退到 <strong>equals()</strong> 来区分对象，但是 <strong>equals()</strong> 也认为两个对象是相同的。<strong>HashSet</strong>因为已经有一个相同的对象了，所以没有添加 <strong>Pig</strong>。<br>我们依然能够通过使得其他字段对象不同来让例子能够正常工作。在这里每个 <strong>Animal</strong> 已经有了一个独一无二的 <strong>id</strong> ，所以你能够取消 <strong>equals()</strong> 函数中的 <strong>[1]</strong> 行注释，或者取消 <strong>hashCode()</strong> 函数中的 <strong>[2]</strong> 行注释。按照规范，你应该同时完成这两个操作，如此能够将所有“不变的”字段包含在两个操作中（“不变”所以 <strong>equals()</strong> 和 <strong>hashCode()</strong> 在哈希数据结构中的排序和取值时，不会生成不同的值。我将“不变的”放在引号中因为你必须计算出是否已经发生变化）。</p><blockquote><p><strong>旁注</strong>： 在<strong>hashCode()</strong>中，如果你只能够使用一个字段，使用<strong>Objcets.hashCode()</strong>。如果你使用多个字段，那么使用 <strong>Objects.hash()</strong>。</p></blockquote><p>我们也可以通过标准方式，将 <strong>equals()</strong> 定义在子类中（不包含 <strong>id</strong> ）解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/SubtypeEquality2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog2</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    Dog2(String name, Size size) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object rval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rval <span class="keyword">instanceof</span> Dog2 &amp;&amp;<span class="keyword">super</span>.equals(rval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig2</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    Pig2(String name, Size size) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object rval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rval <span class="keyword">instanceof</span> Pig2 &amp;&amp;</span><br><span class="line">        <span class="keyword">super</span>.equals(rval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubtypeEquality2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Animal&gt; pets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog2(<span class="string">&quot;Ralph&quot;</span>, Size.MEDIUM));</span><br><span class="line">        pets.add(<span class="keyword">new</span> Pig2(<span class="string">&quot;Ralph&quot;</span>, Size.MEDIUM));</span><br><span class="line">        pets.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Dog2[0]: Ralph MEDIUM a752aeee</span></span><br><span class="line"><span class="comment">Pig2[1]: Ralph MEDIUM a752aeee</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意 <strong>hashCode()</strong> 是独一无二的，但是因为对象不再 <strong>equals()</strong> ，所以两个函数都出现在<strong>HashSet</strong>中。另外，<strong>super.equals()</strong> 意味着我们不需要访问基类的<strong>private</strong>字段。</p><p>一种说法是 Java 从<strong>equals()</strong> 和<strong>hashCode()</strong> 的定义中分离了可替代性。我们仍然能够将<strong>Dog</strong>和<strong>Pig</strong>放置在 <strong>Set\<Animal\></Animal\></strong> 中，无论 <strong>equals()</strong> 和 <strong>hashCode()</strong> 是如何定义的，但是对象不会在哈希数据结构中正常工作，除非这些函数能够被合理定义。不幸的是，<strong>equals()</strong> 不总是和 <strong>hashCode()</strong> 一起使用，这在你尝试为了某个特殊类型避免定义它的时候会让问题复杂化。并且这也是为什么遵循规范是有价值的。然而这会变得更加复杂，因为你不总是需要定义其中一个函数。</p><h2 id="哈希和哈希码"><a href="#哈希和哈希码" class="headerlink" title="哈希和哈希码"></a>哈希和哈希码</h2><p>在 <a href>集合</a> 章节中，我们使用预先定义的类作为 HashMap 的键。这些示例之所以有用，是因为预定义的类具有所有必需的连线，以使它们正确地充当键。</p><p>当创建自己的类作为 HashMap 的键时，会发生一个常见的陷阱，从而忘记进行必要的接线。例如，考虑一个将 Earthhog 对象与 Prediction 对象匹配的天气预报系统。这似乎很简单：使用 Groundhog 作为键，使用 Prediction 作为值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/Groundhog.java</span></span><br><span class="line"><span class="comment">// Looks plausible, but doesn&#x27;t work as a HashMap key</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; number = n; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Groundhog #&quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/Prediction.java</span></span><br><span class="line"><span class="comment">// Predicting the weather</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prediction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextBoolean() ?</span><br><span class="line">                <span class="string">&quot;Six more weeks of Winter!&quot;</span> : <span class="string">&quot;Early Spring!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/SpringDetector.java</span></span><br><span class="line"><span class="comment">// What will the weather be?</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;T&gt; ghog =</span><br><span class="line">                    type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">            Map&lt;Groundhog, Prediction&gt; map =</span><br><span class="line">                    IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">                            .mapToObj(i -&gt; &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="keyword">return</span> ghog.newInstance(i);</span><br><span class="line">                                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .collect(Collectors.toMap(</span><br><span class="line">                                    Function.identity(),</span><br><span class="line">                                    gh -&gt; <span class="keyword">new</span> Prediction()));</span><br><span class="line">            map.forEach((k, v) -&gt;</span><br><span class="line">                    System.out.println(k + <span class="string">&quot;: &quot;</span> + v));</span><br><span class="line">            Groundhog gh = ghog.newInstance(<span class="number">3</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;Looking up prediction for &quot;</span> + gh);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(gh))</span><br><span class="line">                System.out.println(map.get(gh));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Key not found: &quot;</span> + gh);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(NoSuchMethodException |</span><br><span class="line">                IllegalAccessException |</span><br><span class="line">                InvocationTargetException |</span><br><span class="line">                InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        detectSpring(Groundhog.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Groundhog #3: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Groundhog #0: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #8: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Groundhog #6: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #4: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #2: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Groundhog #1: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #9: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #5: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Groundhog #7: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Looking up prediction for Groundhog #3</span></span><br><span class="line"><span class="comment">Key not found: Groundhog #3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>每个 Groundhog 都被赋予了一个常数，因此你可以通过如下的方式在 HashMap 中寻找对应的 Prediction。“给我一个和 Groundhog#3 相关联的 Prediction”。而 Prediction 通过一个随机生成的 boolean 来选择天气。<code>detectSpring()</code> 方法通过反射来实例化 Groundhog 类，或者它的子类。稍后，当我们继承一种新型的“Groundhog ”以解决此处演示的问题时，这将派上用场。</p><p>这里的 HashMap 被 Groundhog 和其相关联的 Prediction 充满。并且上面展示了 HashMap 里面填充的内容。接下来我们使用填充了常数 3 的 Groundhog 作为 key 用于寻找对应的 Prediction 。（这个键值对肯定在 Map 中）。</p><p>这看起来十分简单，但是这样做并没有奏效 —— 它无法找到数字 3 这个键。问题出在 Groundhog 自动地继承自基类 Object，所以这里使用 Object 的 hashCode0 方法生成散列码，而它默认是使用对象的地址计算散列码。因此，由 Groundhog(3)生成的第一个实例的散列码与由 Groundhog(3)生成的第二个实例的散列码是不同的，而我们正是使用后者进行查找的。</p><p>我们需要恰当的重写 hashCode()方法。但是它仍然无法正常运行，除非你同时重写 equals()方法，它也是 Object 的一部分。HashMap 使用 equals()判断当前的键是否与表中存在的键相同。</p><p>这是因为默认的 Object.equals()只是比较对象的地址，所以一个 Groundhog(3)并不等于另一个 Groundhog(3)，因此，如果要使用自己的类作为 HashMap 的键，必须同时重载 hashCode()和 equals()，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/Groundhog2.java</span></span><br><span class="line"><span class="comment">// A class that&#x27;s used as a key in a HashMap</span></span><br><span class="line"><span class="comment">// must override hashCode() and equals()</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog2</span> <span class="keyword">extends</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">super</span>(n); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> number; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Groundhog2 &amp;&amp;</span><br><span class="line">                Objects.equals(</span><br><span class="line">                        number, ((Groundhog2)o).number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/SpringDetector2.java</span></span><br><span class="line"><span class="comment">// A working key</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringDetector.detectSpring(Groundhog2.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Groundhog #0: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Groundhog #1: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #2: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Groundhog #3: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #4: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #5: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Groundhog #6: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #7: Early Spring!</span></span><br><span class="line"><span class="comment">Groundhog #8: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Groundhog #9: Six more weeks of Winter!</span></span><br><span class="line"><span class="comment">Looking up prediction for Groundhog #3</span></span><br><span class="line"><span class="comment">Early Spring!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Groundhog2.hashCode0 返回 Groundhog 的标识数字（编号）作为散列码。在此例中，程序员负责确保不同的 Groundhog 具有不同的编号。hashCode()并不需要总是能够返回唯一的标识码（稍后你会理解其原因），但是 equals() 方法必须严格地判断两个对象是否相同。此处的 equals()是判断 Groundhog 的号码，所以作为 HashMap 中的键，如果两个 Groundhog2 对象具有相同的 Groundhog 编号，程序就出错了。</p><p>如何定义 equals() 方法在上一节 <a href>equals 规范</a>中提到了。输出表明我们现在的输出是正确的。</p><h3 id="理解-hashCode"><a href="#理解-hashCode" class="headerlink" title="理解 hashCode"></a>理解 hashCode</h3><p>前面的例子只是正确解决问题的第一步。它只说明，如果不为你的键覆盖 hashCode() 和 equals() ，那么使用散列的数据结构（HashSet，HashMap，LinkedHashst 或 LinkedHashMap）就无法正确处理你的键。然而，要很好地解决此问题，你必须了解这些数据结构的内部构造。</p><p>首先，使用散列的目的在于：想要使用一个对象来查找另一个对象。不过使用 TreeMap 或者你自己实现的 Map 也可以达到此目的。与散列实现相反，下面的示例用一对 ArrayLists 实现了一个 Map，与 AssociativeArray.java 不同，这其中包含了 Map 接口的完整实现，因此提供了 entrySet()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/SlowMap.java</span></span><br><span class="line"><span class="comment">// A Map implemented with ArrayLists</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlowMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;K&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = get(key); <span class="comment">// The old value or null</span></span><br><span class="line">        <span class="keyword">if</span>(!keys.contains(key)) &#123;</span><br><span class="line">            keys.add(key);</span><br><span class="line">            values.add(value);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            values.set(keys.indexOf(key), value);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123; <span class="comment">// key: type Object, not K</span></span><br><span class="line">        <span class="keyword">if</span>(!keys.contains(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> values.get(keys.indexOf(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K, V&gt;&gt; set= <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Iterator&lt;K&gt; ki = keys.iterator();</span><br><span class="line">        Iterator&lt;V&gt; vi = values.iterator();</span><br><span class="line">        <span class="keyword">while</span>(ki.hasNext())</span><br><span class="line">            set.add(<span class="keyword">new</span> MapEntry&lt;&gt;(ki.next(), vi.next()));</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SlowMap&lt;String,String&gt; m= <span class="keyword">new</span> SlowMap&lt;&gt;();</span><br><span class="line">        m.putAll(Countries.capitals(<span class="number">8</span>));</span><br><span class="line">        m.forEach((k, v) -&gt;</span><br><span class="line">                System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">        System.out.println(m.get(<span class="string">&quot;BENIN&quot;</span>));</span><br><span class="line">        m.entrySet().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CAMEROON=Yaounde</span></span><br><span class="line"><span class="comment">ANGOLA=Luanda</span></span><br><span class="line"><span class="comment">BURKINA FASO=Ouagadougou</span></span><br><span class="line"><span class="comment">BURUNDI=Bujumbura</span></span><br><span class="line"><span class="comment">ALGERIA=Algiers</span></span><br><span class="line"><span class="comment">BENIN=Porto-Novo</span></span><br><span class="line"><span class="comment">CAPE VERDE=Praia</span></span><br><span class="line"><span class="comment">BOTSWANA=Gaberone</span></span><br><span class="line"><span class="comment">Porto-Novo</span></span><br><span class="line"><span class="comment">CAMEROON=Yaounde</span></span><br><span class="line"><span class="comment">ANGOLA=Luanda</span></span><br><span class="line"><span class="comment">BURKINA FASO=Ouagadougou</span></span><br><span class="line"><span class="comment">BURUNDI=Bujumbura</span></span><br><span class="line"><span class="comment">ALGERIA=Algiers</span></span><br><span class="line"><span class="comment">BENIN=Porto-Novo</span></span><br><span class="line"><span class="comment">CAPE VERDE=Praia</span></span><br><span class="line"><span class="comment">BOTSWANA=Gaberone</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>put()方法只是将键与值放入相应的 ArrayList。为了与 Map 接口保持一致，它必须返回旧的键，或者在没有任何旧键的情况下返回 null。</p><p>同样遵循了 Map 规范，get()会在键不在 SlowMap 中的时候产生 null。如果键存在，它将被用来查找表示它在 keys 列表中的位置的数值型索引，并且这个数字被用作索引来产生与 values 列表相关联的值。注意，在 get()中 key 的类型是 Object，而不是你所期望的参数化类型 K（并且是在 AssociativeArrayjava 中真正使用的类型），这是将泛型注入到 Java 语言中的时刻如此之晚所导致的结果-如果泛型是 Java 语言最初就具备的属性，那么 get()就可以执行其参数的类型。</p><p>Map.entrySet() 方法必须产生一个 Map.Entry 对象集。但是，Map.Entry 是一个接口，用来描述依赖于实现的结构，因此如果你想要创建自己的 Map 类型，就必须同时定义 Map.Entry 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/MapEntry.java</span></span><br><span class="line"><span class="comment">// A simple Map.Entry for sample Map implementations</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapEntry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        V result = value;</span><br><span class="line">        value = v;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object rval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rval <span class="keyword">instanceof</span> MapEntry &amp;&amp;</span><br><span class="line">                Objects.equals(key,</span><br><span class="line">                        ((MapEntry&lt;K, V&gt;)rval).getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value,</span><br><span class="line">                        ((MapEntry&lt;K, V&gt;)rval).getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 equals 方法的实现遵循了<a href>equals 规范</a>。在 Objects 类中有一个非常熟悉的方法可以帮助创建 hashCode() 方法： Objects.hash()。当你定义含有超过一个属性的对象的 <code>hashCode()</code> 时，你可以使用这个方法。如果你的对象只有一个属性，可以直接使用 <code>Objects.hashCode()</code>。</p><p>尽管这个解决方案非常简单，并且看起来在 SlowMap.main() 的琐碎测试中可以正常工作，但是这并不是一个恰当的实现，因为它创建了键和值的副本。entrySet() 的恰当实现应该在 Map 中提供视图，而不是副本，并且这个视图允许对原始映射表进行修改（副本就不行）。</p><h3 id="为了速度而散列"><a href="#为了速度而散列" class="headerlink" title="为了速度而散列"></a>为了速度而散列</h3><p>SlowMap.java 说明了创建一种新的 Map 并不困难。但是正如它的名称 SlowMap 所示，它不会很快，所以如果有更好的选择，就应该放弃它。它的问题在于对键的查询，键没有按照任何特定顺序保存，所以只能使用简单的线性查询，而线性查询是最慢的查询方式。</p><p>散列的价值在于速度：散列使得查询得以快速进行。由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的排序状态，然后使用 Collections.binarySearch()进行查询。</p><p>散列则更进一步，它将键保存在某处，以便能够很快找到。存储一组元素最快的数据结构是数组，所以使用它来表示键的信息（请小心留意，我是说键的信息，而不是键本身）。但是因为数组不能调整容量，因此就有一个问题：我们希望在 Map 中保存数量不确定的值，但是如果键的数量被数组的容量限制了，该怎么办呢？</p><p>答案就是：数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在 Object 中的、且可能由你的类覆盖的 hashCode()方法（在计算机科学的术语中称为散列函数）生成。</p><p>于是查询一个值的过程首先就是计算散列码，然后使用散列码查询数组。如果能够保证没有冲突（如果值的数量是固定的，那么就有可能），那可就有了一个完美的散列函数，但是这种情况只是特例。。通常，冲突由外部链接处理：数组并不直接保存值，而是保存值的 list。然后对 list 中的值使用 equals()方法进行线性的查询。这部分的查询自然会比较慢，但是，如果散列函数好的话，数组的每个位置就只有较少的值。因此，不是查询整个 list，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这便是 HashMap 会如此快的原因。</p><p>理解了散列的原理，我们就能够实现一个简单的散列 Map 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/SimpleHashMap.java</span></span><br><span class="line"><span class="comment">// A demonstration hashed Map</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Choose a prime number for the hash table</span></span><br><span class="line"><span class="comment">// size, to achieve a uniform distribution:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">997</span>;</span><br><span class="line">    <span class="comment">// You can&#x27;t have a physical array of generics,</span></span><br><span class="line"><span class="comment">// but you can upcast to one:</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    LinkedList&lt;MapEntry&lt;K, V&gt;&gt;[] buckets =</span><br><span class="line">            <span class="keyword">new</span> LinkedList[SIZE];</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> index = Math.abs(key.hashCode()) % SIZE;</span><br><span class="line">        <span class="keyword">if</span>(buckets[index] == <span class="keyword">null</span>)</span><br><span class="line">            buckets[index] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;MapEntry&lt;K, V&gt;&gt; bucket = buckets[index];</span><br><span class="line">        MapEntry&lt;K, V&gt; pair = <span class="keyword">new</span> MapEntry&lt;&gt;(key, value);</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        ListIterator&lt;MapEntry&lt;K, V&gt;&gt; it =</span><br><span class="line">                bucket.listIterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            MapEntry&lt;K, V&gt; iPair = it.next();</span><br><span class="line">            <span class="keyword">if</span>(iPair.getKey().equals(key)) &#123;</span><br><span class="line">                oldValue = iPair.getValue();</span><br><span class="line">                it.set(pair); <span class="comment">// Replace old with new</span></span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!found)</span><br><span class="line">            buckets[index].add(pair);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Math.abs(key.hashCode()) % SIZE;</span><br><span class="line">        <span class="keyword">if</span>(buckets[index] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(MapEntry&lt;K, V&gt; iPair : buckets[index])</span><br><span class="line">            <span class="keyword">if</span>(iPair.getKey().equals(key))</span><br><span class="line">                <span class="keyword">return</span> iPair.getValue();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K, V&gt;&gt; set= <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(LinkedList&lt;MapEntry&lt;K, V&gt;&gt; bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(MapEntry&lt;K, V&gt; mpair : bucket)</span><br><span class="line">                set.add(mpair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHashMap&lt;String,String&gt; m =</span><br><span class="line">                <span class="keyword">new</span> SimpleHashMap&lt;&gt;();</span><br><span class="line">        m.putAll(Countries.capitals(<span class="number">8</span>));</span><br><span class="line">        m.forEach((k, v) -&gt;</span><br><span class="line">                System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">        System.out.println(m.get(<span class="string">&quot;BENIN&quot;</span>));</span><br><span class="line">        m.entrySet().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CAMEROON=Yaounde</span></span><br><span class="line"><span class="comment">ANGOLA=Luanda</span></span><br><span class="line"><span class="comment">BURKINA FASO=Ouagadougou</span></span><br><span class="line"><span class="comment">BURUNDI=Bujumbura</span></span><br><span class="line"><span class="comment">ALGERIA=Algiers</span></span><br><span class="line"><span class="comment">BENIN=Porto-Novo</span></span><br><span class="line"><span class="comment">CAPE VERDE=Praia</span></span><br><span class="line"><span class="comment">BOTSWANA=Gaberone</span></span><br><span class="line"><span class="comment">Porto-Novo</span></span><br><span class="line"><span class="comment">CAMEROON=Yaounde</span></span><br><span class="line"><span class="comment">ANGOLA=Luanda</span></span><br><span class="line"><span class="comment">BURKINA FASO=Ouagadougou</span></span><br><span class="line"><span class="comment">BURUNDI=Bujumbura</span></span><br><span class="line"><span class="comment">ALGERIA=Algiers</span></span><br><span class="line"><span class="comment">BENIN=Porto-Novo</span></span><br><span class="line"><span class="comment">CAPE VERDE=Praia</span></span><br><span class="line"><span class="comment">BOTSWANA=Gaberone</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由于散列表中的“槽位”（slot）通常称为桶位（bucket），因此我们将表示实际散列表的数组命名为 bucket，为使散列分布均匀，桶的数量通常使用质数<sup><a href="#fn_2" id="reffn_2">2</a></sup>。注意，为了能够自动处理冲突，使用了一个 LinkedList 的数组；每一个新的元素只是直接添加到 list 尾的某个特定桶位中。即使 Java 不允许你创建泛型数组，那你也可以创建指向这种数组的引用。这里，向上转型为这种数组是很方便的，这样可以防止在后面的代码中进行额外的转型。</p><p>对于 put() 方法，hashCode() 将针对键而被调用，并且其结果被强制转换为正数。为了使产生的数字适合 bucket 数组的大小，取模操作符将按照该数组的尺寸取模。如果数组的某个位置是 null，这表示还没有元素被散列至此，所以，为了保存刚散列到该定位的对象，需要创建一个新的 LinkedList。一般的过程是，查看当前位置的 ist 中是否有相同的元素，如果有，则将旧的值赋给 oldValue，然后用新的值取代旧的值。标记 found 用来跟踪是否找到（相同的）旧的键值对，如果没有，则将新的对添加到 list 的末尾。</p><p>get()方法按照与 put()方法相同的方式计算在 buckets 数组中的索引（这很重要，因为这样可以保证两个方法可以计算出相同的位置）如果此位置有 LinkedList 存在，就对其进行查询。</p><p>注意，这个实现并不意味着对性能进行了调优，它只是想要展示散列映射表执行的各种操作。如果你浏览一下 java.util.HashMap 的源代码，你就会看到一个调过优的实现。同样，为了简单，SimpleHashMap 使用了与 SlowMap 相同的方式来实现 entrySet()，这个方法有些过于简单，不能用于通用的 Map。</p><h3 id="重写-hashCode"><a href="#重写-hashCode" class="headerlink" title="重写 hashCode()"></a>重写 hashCode()</h3><p>在明白了如何散列之后，编写自己的 hashCode()就更有意义了。</p><p>首先，你无法控制 bucket 数组的下标值的产生。这个值依赖于具体的 HashMap 对象的容量，而容量的改变与容器的充满程度和负载因子（本章稍后会介绍这个术语）有关。hashCode()生成的结果，经过处理后成为桶位的下标（在 SimpleHashMap 中，只是对其取模，模数为 bucket 数组的大小）。</p><p>设计 hashCode()时最重要的因素就是：无论何时，对同一个对象调用 hashCode()都应该生成同样的值。如果在将一个对象用 put()添加进 HashMap 时产生一个 hashCode()值，而用 get()取出时却产生了另一个 hashCode()值，那么就无法重新取得该对象了。所以，如果你的 hashCode()方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()就会生成一个不同的散列码，相当于产生了一个不同的键。</p><p>此外，也不应该使 hashCode()依赖于具有唯一性的对象信息，尤其是使用 this 值，这只能产生很糟糕的 hashCode()，因为这样做无法生成一个新的键，使之与 put()中原始的键值对中的键相同。这正是 SpringDetector.java 的问题所在，因为它默认的 hashCode0 使用的是对象的地址。所以，应该使用对象内有意义的识别信息。</p><p>下面以 String 类为例。String 有个特点：如果程序中有多个 String 对象，都包含相同的字符串序列，那么这些 String 对象都映射到同一块内存区域。所以 new String(“hello”)生成的两个实例，虽然是相互独立的，但是对它们使用 hashCode()应该生成同样的结果。通过下面的程序可以看到这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/StringHashCode.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] hellos = <span class="string">&quot;Hello Hello&quot;</span>.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(hellos[<span class="number">0</span>].hashCode());</span><br><span class="line">        System.out.println(hellos[<span class="number">1</span>].hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于 String 而言，hashCode() 明显是基于 String 的内容的。</p><p>因此，要想使 hashCode() 实用，它必须速度快，并且必须有意义。也就是说，它必须基于对象的内容生成散列码。记得吗，散列码不必是独一无二的（应该更关注生成速度，而不是唯一性），但是通过 hashCode() 和 equals() ，必须能够完全确定对象的身份。</p><p>因为在生成桶的下标前，hashCode()还需要做进一步的处理，所以散列码的生成范围并不重要，只要是 int 即可。</p><p>还有另一个影响因素：好的 hashCode() 应该产生分布均匀的散列码。如果散列码都集中在一块，那么 HashMap 或者 HashSet 在某些区域的负载会很重，这样就不如分布均匀的散列函数快。</p><p>在 Effective Java Programming Language Guide（Addison-Wesley 2001）这本书中，Joshua Bloch 为怎样写出一份像样的 hashCode()给出了基本的指导：</p><ol><li>给 int 变量 result 赋予某个非零值常量，例如 17。</li><li>为对象内每个有意义的字段（即每个可以做 equals）操作的字段计算出一个 int 散列码 c：</li></ol><div class="table-container"><table><thead><tr><th>字段类型</th><th>计算公式</th></tr></thead><tbody><tr><td>boolean</td><td>c = (f ? 0 : 1)</td></tr><tr><td>byte , char , short , or int</td><td>c = (int)f</td></tr><tr><td>long</td><td>c = (int)(f ^ (f&gt;&gt;&gt;32))</td></tr><tr><td>float</td><td>c = Float.floatToIntBits(f);</td></tr><tr><td>double</td><td>long l =Double.doubleToLongBits(f); <br>c = (int)(l ^ (l &gt;&gt;&gt; 32))</td></tr><tr><td>Object , where equals() calls equals() for this field</td><td>c = f.hashCode()</td></tr><tr><td>Array</td><td>应用以上规则到每一个元素中</td></tr></tbody></table></div><ol><li>合并计算得到的散列码： <strong>result = 37 * result + c;​</strong></li><li>返回 result。</li><li>检查 hashCode()最后生成的结果，确保相同的对象有相同的散列码。</li></ol><p>下面便是遵循这些指导的一个例子。提示，你没有必要书写像如下的代码 —— 相反，使用 <code>Objects.hash()</code> 去用于散列多字段的对象（如同在本例中的那样），然后使用 <code>Objects.hashCode()</code> 如散列单字段的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/CountedString.java</span></span><br><span class="line"><span class="comment">// Creating a good hashCode()</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; created =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountedString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        s = str;</span><br><span class="line">        created.add(s);</span><br><span class="line"><span class="comment">// id is the total number of instances</span></span><br><span class="line"><span class="comment">// of this String used by CountedString:</span></span><br><span class="line">        <span class="keyword">for</span>(String s2 : created)</span><br><span class="line">            <span class="keyword">if</span>(s2.equals(s))</span><br><span class="line">                id++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;String: &quot;</span> + s + <span class="string">&quot; id: &quot;</span> + id +</span><br><span class="line">                <span class="string">&quot; hashCode(): &quot;</span> + hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// The very simple approach:</span></span><br><span class="line"><span class="comment">// return s.hashCode() * id;</span></span><br><span class="line"><span class="comment">// Using Joshua Bloch&#x27;s recipe:</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">        result = <span class="number">37</span> * result + s.hashCode();</span><br><span class="line">        result = <span class="number">37</span> * result + id;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> CountedString &amp;&amp;</span><br><span class="line">                Objects.equals(s, ((CountedString)o).s) &amp;&amp;</span><br><span class="line">                Objects.equals(id, ((CountedString)o).id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;CountedString,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        CountedString[] cs = <span class="keyword">new</span> CountedString[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">            cs[i] = <span class="keyword">new</span> CountedString(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">            map.put(cs[i], i); <span class="comment">// Autobox int to Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="keyword">for</span>(CountedString cstring : cs) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Looking up &quot;</span> + cstring);</span><br><span class="line">            System.out.println(map.get(cstring));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">&#123;String: hi id: 4 hashCode(): 146450=3, String: hi id:</span></span><br><span class="line"><span class="comment">5 hashCode(): 146451=4, String: hi id: 2 hashCode():</span></span><br><span class="line"><span class="comment">146448=1, String: hi id: 3 hashCode(): 146449=2,</span></span><br><span class="line"><span class="comment">String: hi id: 1 hashCode(): 146447=0&#125;</span></span><br><span class="line"><span class="comment">Looking up String: hi id: 1 hashCode(): 146447</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">Looking up String: hi id: 2 hashCode(): 146448</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">Looking up String: hi id: 3 hashCode(): 146449</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">Looking up String: hi id: 4 hashCode(): 146450</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">Looking up String: hi id: 5 hashCode(): 146451</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>CountedString 由一个 String 和一个 id 组成，此 id 代表包含相同 String 的 CountedString 对象的编号。所有的 String 都被存储在 static ArrayList 中，在构造器中通过选代遍历此 ArrayList 完成对 id 的计算。</p><p>hashCode()和 equals() 都基于 CountedString 的这两个字段来生成结果；如果它们只基于 String 或者只基于 id，不同的对象就可能产生相同的值。</p><p>在 main）中，使用相同的 String 创建了多个 CountedString 对象。这说明，虽然 String 相同，但是由于 id 不同，所以使得它们的散列码并不相同。在程序中，HashMap 被打印了出来，因此可以看到它内部是如何存储元素的（以无法辨别的次序），然后单独查询每一个键，以此证明查询机制工作正常。</p><p>作为第二个示例，请考虑 Individual 类，它被用作<a href>类型信息</a>中所定义的 typeinfo.pet 类库的基类。Individual 类在那一章中就用到了，而它的定义则放到了本章，因此你可以正确地理解其实现。</p><p>在这里替换了手工去计算 <code>hashCode()</code>，我们使用了更合适的方式 <code>Objects.hash()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeinfo/pets/Individual.java</span></span><br><span class="line"><span class="keyword">package</span> typeinfo.pets;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">Individual</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Individual</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Individual</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    <span class="comment">// &#x27;name&#x27; is optional:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Individual</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() +</span><br><span class="line">                (name == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Individual &amp;&amp;</span><br><span class="line">                Objects.equals(id, ((Individual)o).id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Individual arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Compare by class name first:</span></span><br><span class="line">        String first = getClass().getSimpleName();</span><br><span class="line">        String argFirst = arg.getClass().getSimpleName();</span><br><span class="line">        <span class="keyword">int</span> firstCompare = first.compareTo(argFirst);</span><br><span class="line">        <span class="keyword">if</span>(firstCompare != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> firstCompare;</span><br><span class="line">        <span class="keyword">if</span>(name != <span class="keyword">null</span> &amp;&amp; arg.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> secondCompare = name.compareTo(arg.name);</span><br><span class="line">            <span class="keyword">if</span>(secondCompare != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> secondCompare;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (arg.id &lt; id ? -<span class="number">1</span> : (arg.id == id ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compareTo() 方法有一个比较结构，因此它会产生一个排序序列，排序的规则首先按照实际类型排序，然后如果有名字的话，按照 name 排序，最后按照创建的顺序排序。下面的示例说明了它是如何工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalshashcode/IndividualTest.java</span></span><br><span class="line"><span class="keyword">import</span> collections.MapOfList;</span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndividualTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Individual&gt; pets = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;? extends Pet&gt; lp :</span><br><span class="line">                MapOfList.petPeople.values())</span><br><span class="line">            <span class="keyword">for</span>(Pet p : lp)</span><br><span class="line">                pets.add(p);</span><br><span class="line">        pets.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Cat Elsie May</span></span><br><span class="line"><span class="comment">Cat Pinkola</span></span><br><span class="line"><span class="comment">Cat Shackleton</span></span><br><span class="line"><span class="comment">Cat Stanford</span></span><br><span class="line"><span class="comment">Cymric Molly</span></span><br><span class="line"><span class="comment">Dog Margrett</span></span><br><span class="line"><span class="comment">Mutt Spot</span></span><br><span class="line"><span class="comment">Pug Louie aka Louis Snorkelstein Dupree</span></span><br><span class="line"><span class="comment">Rat Fizzy</span></span><br><span class="line"><span class="comment">Rat Freckly</span></span><br><span class="line"><span class="comment">Rat Fuzzy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由于所有的宠物都有名字，因此它们首先按照类型排序，然后在同类型中按照名字排序。</p><h2 id="调优-HashMap"><a href="#调优-HashMap" class="headerlink" title="调优 HashMap"></a>调优 HashMap</h2><p>我们有可能手动调优 HashMap 以提高其在特定应用程序中的性能。为了理解调整 HashMap 时的性能问题，一些术语是必要的：</p><ul><li>容量（Capacity）：表中存储的桶数量。</li><li>初始容量（Initial Capacity）：当表被创建时，桶的初始个数。 HashMap 和 HashSet 有可以让你指定初始容量的构造器。</li><li>个数（Size）：目前存储在表中的键值对的个数。</li><li>负载因子（Load factor）：通常表现为 $\frac{size}{capacity}$。当负载因子大小为 0 的时候表示为一个空表。当负载因子大小为 0.5 表示为一个半满表（half-full table），以此类推。轻负载的表几乎没有冲突，因此是插入和查找的最佳选择（但会减慢使用迭代器进行遍历的过程）。 HashMap 和 HashSet 有可以让你指定负载因子的构造器。当表内容量达到了负载因子，集合就会自动扩充为原始容量（桶的数量）的两倍，并且会将原始的对象存储在新的桶集合中（也被称为 rehashing）</li></ul><p>HashMap 中负载因子的大小为 0.75（当表内容量大小不足四分之三的时候，不会发生 rehashing 现象）。这看起来是一个非常好的同时考虑到时间和空间消耗的平衡策略。更高的负载因子会减少空间的消耗，但是会增加查询的耗时。重要的是，查询操作是你使用的最频繁的一个操作（包括 <code>get()</code> 和 <code>put()</code> 方法）。</p><p>如果你知道存储在 HashMap 中确切的条目个数，直接创建一个足够容量大小的 HashMap，以避免自动发生的 rehashing 操作。</p><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:<br><sup><a href="#fn_2" id="reffn_2">2</a></sup>: 事实证明，质数实际上并不是散列桶的理想容量。近来，（经过广泛的测试）Java 的散列函数都使用 2 的整数次方。对现代的处理器来说，除法与求余数是最慢的操作。使用 2 的整数次方长度的散列表，可用掩码代替除法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-理解-equals-和-hashCode-方法&quot;&gt;&lt;a href=&quot;#附录-理解-equals-和-hashCode-方法&quot; class=&quot;headerlink&quot; title=&quot;附录:理解 equals 和 hashCode 方法&quot;&gt;&lt;/a&gt;附录:理解 eq</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-the-positive-legacy-of-c-plus-plus-and-java/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-the-positive-legacy-of-c-plus-plus-and-java/</id>
    <published>2022-06-23T15:31:23.694Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-C-和-Java-的优良传统"><a href="#附录-C-和-Java-的优良传统" class="headerlink" title="附录:C++和 Java 的优良传统"></a>附录:C++和 Java 的优良传统</h1><blockquote><p>在各种讨论声中，有一些人认为 C++是一种设计糟糕的语言。 我认为理解 C++和 Java 语言的选择有助于了解更大的视角。</p></blockquote><p>也就是说，我几乎不再使用 C++了。当我使用它的时候，要么是用来检查遗留代码，要么是编写性能关键（performance-critical）部分，程序通常尽可能小，以便用其他语言编写的其他程序来调用。</p><p>因为我在最初的 8 年里一直在 C++标准委员会工作，所以我见证了那些被做出的决定。它们都经过了极其谨慎的考虑，远远超过了许多在 Java 中做出的决定。</p><p>然而，正如人们正确地指出的那样，由此产生的语言使用起来既复杂又痛苦，而且只要我一段时间不使用它，我就会忘记那些古怪的规则。在我写书的时候，我是从第一原理（first principles）处了解这些规则的，而不是记住了它们。</p><p>为了理解 C++语言为何既令人不愉快且复杂，同时又是精心设计的，必须要牢记 C++中所有内容的主要设计决策：与 C. Bjarne Stroustrup（该语言的创造者，即“C++之父”）的兼容性决定。这样的设计似乎是为了可以让大量的 C 程序员透明地转移到对象（代指 C++）上：允许他们在 C++下编译他们的 C 代码。这是一个巨大的限制，一直是 C++最大的优势……而且也是它的祸根。这就是使得 C++成功的原因，也是使它复杂的原因。</p><p>它也欺骗了那些不太了解 C++的 Java 设计师。例如，他们认为运算符重载对于程序员来说很难正确使用。这在 C++中基本上是正确的，因为 C++既有栈分配又有堆分配，你必须重载运算符来处理所有情况而且不要造成内存泄漏。这确实很困难。然而，Java 有单一的内存分配机制和一个垃圾收集器，这使得运算符重载变得微不足道，正如 C＃中那样（但在早于 Java 的 Python 中已经可以看到）。但多年来，来自 Java 团队的一贯态度是“运算符重载太复杂了”。这里还有许多决策，所做的事明显不应该是他们做的。正是由于这些原因，让我有了蔑视 Gosling（即“Java 之父”）和 Java 团队决策的名声。（Java 7 和 8 由于某种原因包含了更好的决策。但是向后兼容性这个约束总是会阻碍真正的改进。语言永远不会是它本来的样子。）</p><p>还有很多其他的例子。“为了提高效率，必须包含基本类型”；坚持“万物皆对象”是正确的；当对性能有要求的时候，提供一个陷阱门（trap door）来做低级别的活动（lower-level activities）（这里也可以使用 hotspot 技术透明地提高性能，正如他们最终做的那样）；不能直接使用浮点处理器去计算超越函数，它用软件来完成。我已经尽可能多地提出了这样的问题，但我得到的却一直是类似“这是 Java 方式”这样的回复。</p><p>当我提出关于泛型的设计有多糟糕的时候，我得到了相同的回复，以及“我们必须向后兼容那样以前用 Java 做出的决策”（即使它们是糟糕的决策）。最近越来越多的人已经获得了足够的泛型经验，可以发现泛型真的很难用。事实上，C++模板更强大、更一致（现在更容易使用，因为编译器的错误消息是可以容忍的）。人们一直在认真对待物化（reification），这可能是有用的东西，但是在那种被严格约束所削弱的设计中并没有多大影响。</p><p>这样的例子还有很多很多。这是否意味着 Java 失败了？绝对不。Java 将程序员的主流带入了垃圾收集、虚拟机和一致的错误处理模型的世界。由于它的所有缺陷，它将我们提升到了一个水平，现在我们已经准备好使用更高级别的语言了。</p><p>有一点，C++是领先的语言，人们认为它总是如此。许多人对 Java 有同样的看法，但由于 JVM，Java 使得取代自己变得更加容易。现在有可能会有人创建一种新语言，并使其在短时间内像 Java 一样高效运行。以前，为新语言开发一个正确有效的编译器需要花费大部分开发时间。</p><p>这种情况已经发生了，包括像 Scala 这样的高级静态语言，以及动态语言，新的且可移植的，如 Groovy，Clojure，JRuby 和 Jython。这是未来，并且过渡很顺畅，因为可以很轻易地将这些新语言与现有 Java 代码结合使用，并且必要时可以重写那些在 Java 中的瓶颈。</p><p>在撰写本文时，Java 是世界上的头号编程语言。然而，Java 最终将会减弱，就像 C++一样，沦只在特殊情况下使用（或者只是用来支持传统的代码，因为它不能像 C++那样和硬件连接）。但是无意中的好处，也是 Java 真正意外的光彩之处在于它为自己的替代品创造了一条非常畅通的道路，即使 Java 本身已经达到了无法再发展的程度。未来所有的语言都应该从中学习：要么创建一个可以重构的文化（像 Python 和 Ruby 做的那样），要么就让竞争者茁壮成长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-C-和-Java-的优良传统&quot;&gt;&lt;a href=&quot;#附录-C-和-Java-的优良传统&quot; class=&quot;headerlink&quot; title=&quot;附录:C++和 Java 的优良传统&quot;&gt;&lt;/a&gt;附录:C++和 Java 的优良传统&lt;/h1&gt;&lt;blockquote</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-supplements/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-supplements/</id>
    <published>2022-06-23T15:31:23.692Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-补充"><a href="#附录-补充" class="headerlink" title="附录:补充"></a>附录:补充</h1><blockquote><p>本书有许多补充内容，包括 MindView 网站提供的项目和服务。</p></blockquote><p>本附录介绍了这些补充内容，你可以自行决定它们是否对你有所帮助。</p><h2 id="可下载的补充"><a href="#可下载的补充" class="headerlink" title="可下载的补充"></a>可下载的补充</h2><p>可以从 <a href="https://github.com/BruceEckel/OnJava8-examples">https://github.com/BruceEckel/OnJava8-examples</a> 免费下载本书的代码。这里包括 Gradle 构建文件和其它一些必要的支持文件，以便成功构建和执行本书中所有的示例代码。</p><h2 id="通过-Thinking-in-C-来巩固-Java-基础"><a href="#通过-Thinking-in-C-来巩固-Java-基础" class="headerlink" title="通过 Thinking-in-C 来巩固 Java 基础"></a>通过 Thinking-in-C 来巩固 Java 基础</h2><p>在 <a href="www.OnJava8.com">www.OnJava8.com</a> 上，可以免费下载<em>Thinking in C</em>的演示文稿。 此演示文稿由 Chuck Allison 创建，由 MindView 有限责任公司开发。这是一个电子演示文稿，介绍了 Java 语法所基于的 C 语法，运算符和函数。</p><h2 id="Hand-On-Java-电子演示文稿"><a href="#Hand-On-Java-电子演示文稿" class="headerlink" title="Hand-On Java 电子演示文稿"></a>Hand-On Java 电子演示文稿</h2><p><em>Hand-On Java 电子演示文稿</em>（Hands-On Java eSeminar）是基于<em>Thinking in Java</em>第 2 版。对应于该书中的每一章，它附带有一个音频讲解和相应的幻灯片。我创建了这个电子演示文稿，并讲述了这些材料。这个资料是 HTML5 格式的，所以它应该可以在大多数现代浏览器上运行。该演示文稿将在<a href="www.OnJava8.com">www.OnJava8.com</a>上发售，你可以在该网站上找到该产品的试用版演示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-补充&quot;&gt;&lt;a href=&quot;#附录-补充&quot; class=&quot;headerlink&quot; title=&quot;附录:补充&quot;&gt;&lt;/a&gt;附录:补充&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本书有许多补充内容，包括 MindView 网站提供的项目和服务。&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-standard-io/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-standard-io/</id>
    <published>2022-06-23T15:31:23.691Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-标准IO"><a href="#附录-标准IO" class="headerlink" title="附录:标准IO"></a>附录:标准IO</h1><blockquote><p><em>标准 I/O</em>这个术语参考Unix中的概念，指程序所使用的单一信息流（这种思想在大多数操作系统中，也有相似形式的实现）。</p></blockquote><p>程序的所有输入都可以来自于<em>标准输入</em>，其所有输出都可以流向<em>标准输出</em>，并且其所有错误信息均可以发送到<em>标准错误</em>。<em>标准 I/O</em> 的意义在于程序之间可以很容易地连接起来，一个程序的标准输出可以作为另一个程序的标准输入。这是一个非常强大的工具。</p><h2 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h2><p>遵循标准 I/O 模型，Java 提供了标准输入流 <code>System.in</code>、标准输出流 <code>System.out</code> 和标准错误流 <code>System.err</code>。在本书中，你已经了解到如何使用 <code>System.out</code>将数据写到标准输出。 <code>System.out</code> 已经预先包装<sup><a href="#fn_1" id="reffn_1">1</a></sup>成了 <code>PrintStream</code> 对象。标准错误流 <code>System.err</code> 也预先包装为 <code>PrintStream</code> 对象，但是标准输入流 <code>System.in</code> 是原生的没有经过包装的 <code>InputStream</code>。这意味着尽管可以直接使用标准输出流 <code>System.in</code> 和标准错误流 <code>System.err</code>，但是在读取 <code>System.in</code> 之前必须先对其进行包装。</p><p>我们通常一次一行地读取输入。为了实现这个功能，将 <code>System.in</code> 包装成 <code>BufferedReader</code> 来使用，这要求我们用 <code>InputStreamReader</code> 把 <code>System.in</code> 转换<sup><a href="#fn_2" id="reffn_2">2</a></sup>成 <code>Reader</code> 。下面这个例子将键入的每一行显示出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// standardio/Echo.java</span></span><br><span class="line"><span class="comment">// How to read from standard input</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> onjava.TimedAbort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimedAbort abort = <span class="keyword">new</span> TimedAbort(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in))</span><br><span class="line">                .lines()</span><br><span class="line">                .peek(ln -&gt; abort.restart())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="comment">// Ctrl-Z or two seconds inactivity</span></span><br><span class="line">        <span class="comment">// terminates the program</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BufferedReader</code> 提供了 <code>lines()</code> 方法，返回类型是 <code>Stream&lt;String&gt;</code> 。这显示出流模型的的灵活性：仅使用标准输入就能很好地工作。 <code>peek()</code> 方法重启 <code>TimeAbort</code>，只要保证至少每隔两秒有输入就能够使程序保持开启状态。</p><h2 id="将System-out-转换成-PrintWriter"><a href="#将System-out-转换成-PrintWriter" class="headerlink" title="将System.out 转换成 PrintWriter"></a>将<code>System.out</code> 转换成 <code>PrintWriter</code></h2><p><code>System.out</code> 是一个 <code>PrintStream</code>，而 <code>PrintStream</code> 是一个<code>OutputStream</code>。 <code>PrintWriter</code> 有一个把 <code>OutputStream</code> 作为参数的构造器。因此，如果你需要的话，可以使用这个构造器把 <code>System.out</code> 转换成 <code>PrintWriter</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// standardio/ChangeSystemOut.java</span></span><br><span class="line"><span class="comment">// Turn System.out into a PrintWriter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintWriter out =</span><br><span class="line">                <span class="keyword">new</span> PrintWriter(System.out, <span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world</span><br></pre></td></tr></table></figure><p>要使用 <code>PrintWriter</code> 带有两个参数的构造器，并设置第二个参数为 <code>true</code>，从而使能自动刷新到输出缓冲区的功能；否则，可能无法看到打印输出。</p><h2 id="重定向标准-I-O"><a href="#重定向标准-I-O" class="headerlink" title="重定向标准 I/O"></a>重定向标准 I/O</h2><p>Java的 <code>System</code> 类提供了简单的 <code>static</code> 方法调用，从而能够重定向标准输入流、标准输出流和标准错误流：</p><ul><li>setIn（InputStream）</li><li>setOut（PrintStream）</li><li>setErr(PrintStream)</li></ul><p>如果我们突然需要在显示器上创建大量的输出，而这些输出滚动的速度太快以至于无法阅读时，重定向输出就显得格外有用，可把输出内容重定向到文件中供后续查看。对于我们想重复测试特定的用户输入序列的命令行程序来说，重定向输入就很有价值。下例简单演示了这些方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// standardio/Redirecting.java</span></span><br><span class="line"><span class="comment">// Demonstrates standard I/O redirection</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Redirecting.java&quot;</span>));</span><br><span class="line">                PrintStream out = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                        <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Redirecting.txt&quot;</span>)))</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.setIn(in);</span><br><span class="line">            System.setOut(out);</span><br><span class="line">            System.setErr(out);</span><br><span class="line">            <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(System.in))</span><br><span class="line">                    .lines()</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.setOut(console);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序将文件中内容载入到标准输入，并把标准输出和标准错误重定向到另一个文件。它在程序的开始保存了最初对 <code>System.out</code> 对象的引用，并且在程序结束时将系统输出恢复到了该对象上。</p><p>I/O重定向操作的是字节流而不是字符流，因此使用 <code>InputStream</code> 和 <code>OutputStream</code>，而不是 <code>Reader</code> 和 <code>Writer</code>。</p><h2 id="执行控制"><a href="#执行控制" class="headerlink" title="执行控制"></a>执行控制</h2><p>你经常需要在Java内部直接执行操作系统的程序，并控制这些程序的输入输出，Java类库提供了执行这些操作的类。</p><p>一项常见的任务是运行程序并将输出结果发送到控制台。本节包含了一个可以简化此任务的实用工具。</p><p>在使用这个工具时可能会产生两种类型的错误：导致异常的普通错误——对于这些错误我们只需要重新抛出一个 <code>RuntimeException</code> 即可，以及进程自身的执行过程中导致的错误——我们需要用单独的异常来报告这些错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/OSExecuteException.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSExecuteException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OSExecuteException</span><span class="params">(String why)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(why);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了运行程序，我们需要传递给 <code>OSExecute.command()</code> 一个 <code>String command</code>，我们可以在控制台键入同样的指令运行程序。该命令传递给 <code>java.lang.ProcessBuilder</code> 的构造器（需要将其作为 <code>String</code> 对象的序列），然后启动生成的 <code>ProcessBuilder</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/OSExecute.java</span></span><br><span class="line"><span class="comment">// Run an operating system command</span></span><br><span class="line"><span class="comment">// and send the output to the console</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSExecute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">command</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> err = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process process = <span class="keyword">new</span> ProcessBuilder(</span><br><span class="line">                    command.split(<span class="string">&quot; &quot;</span>)).start();</span><br><span class="line">            <span class="keyword">try</span> (</span><br><span class="line">                    BufferedReader results = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                            <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                                    process.getInputStream()));</span><br><span class="line">                    BufferedReader errors = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                            <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                                    process.getErrorStream()))</span><br><span class="line">            ) &#123;</span><br><span class="line">                results.lines()</span><br><span class="line">                        .forEach(System.out::println);</span><br><span class="line">                err = errors.lines()</span><br><span class="line">                        .peek(System.err::println)</span><br><span class="line">                        .count() &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OSExecuteException(</span><br><span class="line">                    <span class="string">&quot;Errors executing &quot;</span> + command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了捕获在程序执行时产生的标准输出流，我们可以调用 <code>getInputStream()</code>。这是因为 <code>InputStream</code> 是我们可以从中读取信息的流。</p><p>这里这些行只是被打印了出来，但是你也可以从 <code>command()</code> 捕获和返回它们。</p><p>该程序的错误被发送到了标准错误流，可以调用 <code>getErrorStream()</code> 捕获。如果存在任何错误，它们都会被打印并且抛出 <code>OSExcuteException</code> ，以便调用程序处理这个问题。</p><p>下面是展示如何使用 <code>OSExecute</code> 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// standardio/OSExecuteDemo.java</span></span><br><span class="line"><span class="comment">// Demonstrates standard I/O redirection</span></span><br><span class="line"><span class="comment">// &#123;javap -cp build/classes/main OSExecuteDemo&#125;</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSExecuteDemo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>javap</code> 反编译器（随JDK发布）来反编译程序，编译结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;OSExecuteDemo.java&quot;</span><br><span class="line">public class OSExecuteDemo &#123;</span><br><span class="line">  public OSExecuteDemo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote id="fn_1"><sup>1</sup>. 译者注：这里用到了<strong>装饰器模式</strong>。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 译者注：这里用到了<strong>适配器模式</strong>。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-标准IO&quot;&gt;&lt;a href=&quot;#附录-标准IO&quot; class=&quot;headerlink&quot; title=&quot;附录:标准IO&quot;&gt;&lt;/a&gt;附录:标准IO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;标准 I/O&lt;/em&gt;这个术语参考Unix中的概念，指程序所使用的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-programming-guidelines/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-programming-guidelines/</id>
    <published>2022-06-23T15:31:23.689Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-编程指南"><a href="#附录-编程指南" class="headerlink" title="附录:编程指南"></a>附录:编程指南</h1><blockquote><p>本附录包含了有助于指导你进行低级程序设计和编写代码的建议。</p></blockquote><p>当然，这些只是指导方针，而不是规则。我们的想法是将它们用作灵感，并记住偶尔会违反这些指导方针的特殊情况。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ol><li><p><strong>优雅总是会有回报</strong>。从短期来看，似乎需要更长的时间才能找到一个真正优雅的问题解决方案，但是当该解决方案第一次应用并能轻松适应新情况，而不需要数小时，数天或数月的挣扎时，你会看到奖励（即使没有人可以测量它们）。它不仅为你提供了一个更容易构建和调试的程序，而且它也更容易理解和维护，这也正是经济价值所在。这一点可以通过一些经验来理解，因为当你想要使一段代码变得优雅时，你可能看起来效率不是很高。抵制急于求成的冲动，它只会减慢你的速度。</p></li><li><p><strong>先让它工作，然后再让它变快</strong>。即使你确定一段代码非常重要并且它是你系统中的主要瓶颈**，也是如此。不要这样做。使用尽可能简单的设计使系统首先运行。然后如果速度不够快，请对其进行分析。你几乎总会发现“你的”瓶颈不是问题。节省时间，才是真正重要的东西。</p></li><li><p><strong>记住“分而治之”的原则</strong>。如果所面临的问题太过混乱**，就去想象一下程序的基本操作，因为存在一个处理困难部分的神奇“片段”（piece）。该“片段”是一个对象，编写使用该对象的代码，然后查看该对象并将其困难部分封装到其他对象中，等等。</p></li><li><p><strong>将类创建者与类用户（客户端程序员）分开</strong>。类用户是“客户”，不需要也不想知道类幕后发生了什么。类创建者必须是设计类的专家，他们编写类，以便新手程序员都可以使用它，并仍然可以在应用程序中稳健地工作。将该类视为其他类的<em>服务提供者</em>（service provider）。只有对其它类透明，才能很容易地使用这个类。</p></li><li><p><strong>创建类时，给类起个清晰的名字，就算不需要注释也能理解这个类</strong>。你的目标应该是使客户端程序员的接口在概念上变得简单。为此，在适当时使用方法重载来创建直观，易用的接口。</p></li><li><p><strong>你的分析和设计必须至少能够产生系统中的类、它们的公共接口以及它们与其他类的关系，尤其是基类</strong>。 如果你的设计方法产生的不止于此，就该问问自己，该方法生成的所有部分是否在程序的生命周期内都具有价值。如果不是，那么维护它们会很耗费精力。对于那些不会影响他们生产力的东西，开发团队的成员往往不会去维护，这是许多设计方法都没有考虑的生活现实。</p></li><li><p><strong>让一切自动化</strong>。首先在编写类之前，编写测试代码，并将其与类保持一致。通过构建工具自动运行测试。你可能会使用事实上的标准 Java 构建工具 Gradle。这样，通过运行测试代码可以自动验证任何更改，将能够立即发现错误。因为你知道自己拥有测试框架的安全网，所以当发现需要时，可以更大胆地进行彻底的更改。请记住，语言的巨大改进来自内置的测试，包括类型检查，异常处理等，但这些内置功能很有限，你必须完成剩下的工作，针对具体的类或程序，去完善这些测试内容，从而创建一个强大的系统。</p></li><li><p><strong>在编写类之前，先编写测试代码，以验证类的设计是完善的</strong>。如果不编写测试代码，那么就不知道类是什么样的。此外，通过编写测试代码，往往能够激发出类中所需的其他功能或约束。而这些功能或约束并不总是出现在分析和设计过程中。测试还会提供示例代码，显示了如何使用这个类。</p></li><li><p><strong>所有的软件设计问题，都可以通过引入一个额外的间接概念层次（extra level of conceptual indirection）来解决</strong>。这个软件工程的基本规则<sup><a href="#fn_1" id="reffn_1">1</a></sup>是抽象的基础，是面向对象编程的主要特征。在面向对象编程中，我们也可以这样说：“如果你的代码太复杂，就要生成更多的对象。”</p></li><li><p><strong>间接（indirection）应具有意义（与准则 9 一致）</strong>。这个含义可以简单到“将常用代码放在单个方法中。”如果添加没有意义的间接（抽象，封装等）级别，那么它就像没有足够的间接性那样糟糕。</p></li><li><p><strong>使类尽可能原子化</strong>。 为每个类提供一个明确的目的，它为其他类提供一致的服务。如果你的类或系统设计变得过于复杂，请将复杂类分解为更简单的类。最直观的指标是尺寸大小，如果一个类很大，那么它可能是做的事太多了，应该被拆分。建议重新设计类的线索是：</p><ul><li>一个复杂的<em>switch</em>语句：考虑使用多态。</li><li>大量方法涵盖了很多不同类型的操作：考虑使用多个类。</li><li>大量成员变量涉及很多不同的特征：考虑使用多个类。</li><li>其他建议可以参见 Martin Fowler 的<em>Refactoring: Improving the Design of Existing Code</em>（重构：改善既有代码的设计）（Addison-Wesley 1999）。</li></ul></li><li><p><strong>注意长参数列表</strong>。那样方法调用会变得难以编写，读取和维护。相反，尝试将方法移动到更合适的类，并且（或者）将对象作为参数传递。</p></li><li><p><strong>不要重复自己</strong>。如果一段代码出现在派生类的许多方法中，则将该代码放入基类中的单个方法中，并从派生类方法中调用它。这样不仅可以节省代码空间，而且可以轻松地传播更改。有时，发现这个通用代码会为接口添加有价值的功能。此指南的更简单版本也可以在没有继承的情况下发生：如果类具有重复代码的方法，则将该重复代码放入一个公共方，法并在其他方法中调用它。</p></li><li><p><strong>注意<em>switch</em>语句或链式<em>if-else</em>子句</strong>。一个<em>类型检查编码</em>（type-check coding）的指示器意味着需要根据某种类型信息选择要执行的代码（确切的类型最初可能不明显）。很多时候可以用继承和多态替换这种代码，多态方法调用将会执行类型检查，并提供了更可靠和更容易的可扩展性。</p></li><li><p><strong>从设计的角度，寻找和分离那些因不变的事物而改变的事物</strong>。也就是说，在不强制重新设计的情况下搜索可能想要更改的系统中的元素，然后将这些元素封装在类中。</p></li><li><p><strong>不要通过子类扩展基本功能</strong>。如果一个接口元素对于类来说是必不可少的，则它应该在基类中，而不是在派生期间添加。如果要在继承期间添加方法，请考虑重新设计。</p></li><li><p><strong>少即是多</strong>。从一个类的最小接口开始，尽可能小而简单，以解决手头的问题，但不要试图预测类的所有使用方式。在使用该类时，就将会了解如何扩展接口。但是，一旦这个类已经在使用了，就无法在不破坏客户端代码的情况下缩小接口。如果必须添加更多方法，那很好，它不会破坏代码。但即使新方法取代旧方法的功能，也只能是保留现有接口（如果需要，可以结合底层实现中的功能）。如果必须通过添加更多参数来扩展现有方法的接口，请使用新参数创建重载方法，这样，就不会影响到对现有方法的任何调用。</p></li><li><p><strong>大声读出你的类以确保它们合乎逻辑</strong>。将基类和派生类之间的关系称为“is-a”，将成员对象称为“has-a”。</p></li><li><p><strong>在需要在继承和组合之间作决定时，问一下自己是否必须向上转换为基类型</strong>。如果不是，则使用组合（成员对象）更好。这可以消除对多种基类型的感知需求（perceived need）。如果使用继承，则用户会认为他们应该向上转型。</p></li><li><p><strong>注意重载</strong>。方法不应该基于参数的值而有条件地执行代码。在这里，应该创建两个或多个重载方法。</p></li><li><p><strong>使用异常层次结构</strong>，最好是从标准 Ja​​va 异常层次结构中的特定适当类派生。然后，捕获异常的人可以为特定类型的异常编写处理程序，然后为基类型编写处理程序。如果添加新的派生异常，现有客户端代码仍将通过基类型捕获异常。</p></li><li><p><strong>有时简单的聚合可以完成工作</strong>。航空公司的“乘客舒适系统”由独立的元素组成：座位，空调，影视等，但必须在飞机上创建许多这样的元素。你创建私有成员并建立一个全新的接口了吗？如果不是，在这种情况下，组件也应该是公共接口的一部分，因此应该创建公共成员对象。这些对象有自己的私有实现，这些实现仍然是安全的。请注意，简单聚合不是经常使用的解决方案，但确实会有时候会用到。</p></li><li><p><strong>考虑客户程序员和维护代码的人的观点</strong>。设计类以便尽可能直观地被使用。预测要进行的更改，并精心设计类，以便轻松地进行更改。</p></li><li><p><strong>注意“巨型对象综合症”</strong>（giant object syndrome）。这通常是程序员的痛苦，他们是面向对象编程的新手，总是编写面向过程程序并将其粘贴在一个或两个巨型对象中。除应用程序框架外，对象代表应用程序中的概念，而不是应用程序本身。</p></li><li><p><strong>如果你必须做一些丑陋的事情，至少要把类内的丑陋本地化</strong>。</p></li><li><p><strong>如果必须做一些不可移植的事情，那就对这个事情做一个抽象，并在一个类中进行本地化</strong>。这种额外的间接级别可防止在整个程序中扩散这种不可移植性。 （这个原则也体现在<em>桥接</em>模式中，等等）。</p></li><li><p><strong>对象不应该仅仅只是持有一些数据</strong>。它们也应该有明确的行为。有时候，“数据传输对象”（data transfer objects）是合适的，但只有在泛型集合不合适时，才被明确用于打包和传输一组元素。</p></li><li><p><strong>在从现有类创建新类时首先选择组合</strong>。仅在设计需要时才使用继承。如果在可以使用组合的地方使用继承，那么设计将会变得很复杂，这是没必要的。</p></li><li><p><strong>使用继承和覆盖方法来表达行为的差异，而不是使用字段来表示状态的变化</strong>。如果发现一个类使用了状态变量，并且有一些方法是基于这些变量切换行为的，那么请重新设计它，以表示子类和覆盖方法中的行为差异。一个极端的反例是继承不同的类来表示颜色，而不是使用“颜色”字段。</p></li><li><p><strong>注意<em>协变</em>（variance）</strong>。两个语义不同的对象可能具有相同的操作或职责。为了从继承中受益，会试图让其中一个成为另一个的子类，这是一种很自然的诱惑。这称为协变，但没有真正的理由去强制声明一个并不存在的父子类关系。更好的解决方案是创建一个通用基类，并为两者生成一个接口，使其成为这个通用基类的派生类。这仍然可以从继承中受益，并且这可能是关于设计的一个重要发现。</p></li><li><p><strong>在继承期间注意<em>限定</em>（limitation）</strong>。最明确的设计为继承的类增加了新的功能。含糊的设计在继承期间删除旧功能而不添加新功能。但是规则是用来打破的，如果是通过调用一个旧的类库来工作，那么将一个现有类限制在其子类型中，可能比重构层次结构更有效，因此新类适合在旧类的上层。</p></li><li><p><strong>使用设计模式来消除“裸功能”（naked functionality）</strong>。也就是说，如果类只需要创建一个对象，请不要推进应用程序并写下注释“只生成一个。”应该将其包装成一个单例（singleton）。如果主程序中有很多乱七八糟的代码去创建对象，那么找一个像工厂方法一样的创建模式，可以在其中封装创建过程。消除“裸功能”不仅会使代码更易于理解和维护，而且还会使其能够更加防范应对后面的善意维护者（well-intentioned maintainers）。</p></li><li><p><strong>注意“分析瘫痪”（analysis paralysis）</strong>。记住，不得不经常在不了解整个项目的情况下推进项目，并且通常了解那些未知因素的最好、最快的方式是进入下一步而不是尝试在脑海中弄清楚。在获得解决方案之前，往往无法知道解决方案。Java 有内置的防火墙，让它们为你工作。你在一个类或一组类中的错误不会破坏整个系统的完整性。</p></li><li><p><strong>如果认为自己有很好的分析，设计或实施，请做一个演练</strong>。从团队外部带来一些人，不一定是顾问，但可以是公司内其他团体的人。用一双新眼睛评审你的工作，可以在一个更容易修复它们的阶段发现问题，而不仅仅是把大量时间和金钱全扔到演练过程中。</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li><p><strong>遵循编码惯例</strong>。有很多不同的约定，例如，<a href="https://google.github.io/styleguide/javaguide.html">谷歌使用的约定</a>（本书中的代码尽可能地遵循这些约定）。如果坚持使用其他语言的编码风格，那么读者就会很难去阅读。无论决定采用何种编码约定，都要确保它们在整个项目中保持一致。集成开发环境通常包含内置的重新格式化（reformatter）和检查器（checker）。</p></li><li><p><strong>无论使用何种编码风格，如果你的团队（甚至更好是公司）对其进行标准化，它就确实会产生重大影响</strong>。这意味着，如果不符合这个标准，那么每个人都认为修复别人的编码风格是公平的游戏。标准化的价值在于解析代码可以花费较少的脑力，因此可以更专注于代码的含义。</p></li><li><p><strong>遵循标准的大写规则</strong>。类名的第一个字母大写。字段，方法和对象（引用）的第一个字母应为小写。所有标识符应该将各个单词组合在一起，并将所有中间单词的首字母大写。例如：</p><ul><li><strong>ThisIsAClassName</strong></li><li><strong>thisIsAMethodOrFieldName</strong></li></ul><p>将 <strong>static final</strong> 类型的标识符的所有字母全部大写，并用下划线分隔各个单词，这些标识符在其定义中具有常量初始值。这表明它们是编译时常量。</p><ul><li><strong>包是一个特例</strong>，它们都是小写的字母，即使是中间词。域扩展（com，org，net，edu 等）也应该是小写的。这是 Java 1.1 和 Java 2 之间的变化。</li></ul></li><li><p><strong>不要创建自己的“装饰”私有字段名称</strong>。这通常以前置下划线和字符的形式出现。匈牙利命名法（译者注：一种命名规范，基本原则是：变量名=属性+类型+对象描述。Win32 程序风格采用这种命名法，如<code>WORD wParam1;LONG lParam2;HANDLE hInstance</code>）是最糟糕的例子，你可以在其中附加额外字符用于指示数据类型，用途，位置等，就好像你正在编写汇编语言一样，编译器根本没有提供额外的帮助。这些符号令人困惑，难以阅读，并且难以执行和维护。让类和包来指定名称范围。如果认为必须装饰名称以防止混淆，那么代码就可能过于混乱，这应该被简化。</p></li><li><p>在创建一般用途的类时，<strong>遵循“规范形式”</strong>。包括<strong>equals()</strong>，<strong>hashCode()</strong>，<strong>toString()</strong>，<strong>clone()</strong>的定义（实现<strong>Cloneable</strong>，或选择其他一些对象复制方法，如序列化），并实现<strong>Comparable</strong>和<strong>Serializable</strong>。</p></li><li><p><strong>对读取和更改私有字段的方法使用“get”，“set”和“is”命名约定</strong>。这种做法不仅使类易于使用，而且也是命名这些方法的标准方法，因此读者更容易理解。</p></li><li><p><strong>对于所创建的每个类，请包含该类的 JUnit 测试</strong>（请参阅<em>junit.org</em>以及<a href>第十六章：代码校验</a>中的示例）。无需删除测试代码即可在项目中使用该类，如果进行更改，则可以轻松地重新运行测试。测试代码也能成为如何使用这个类的示例。</p></li><li><p><strong>有时需要继承才能访问基类的 protected 成员</strong>。这可能导致对多种基类型的感知需求（perceived need）。如果不需要向上转型，则可以首先派生一个新类来执行受保护的访问。然后把该新类作为使用它的任何类中的成员对象，以此来代替直接继承。</p></li><li><p><strong>为了提高效率，避免使用<em>final</em>方法</strong>。只有在分析后发现方法调用是瓶颈时，才将<strong>final</strong>用于此目的。</p></li><li><p><strong>如果两个类以某种功能方式相互关联（例如集合和迭代器），则尝试使一个类成为另一个类的内部类</strong>。这不仅强调了类之间的关联，而且通过将类嵌套在另一个类中，可以允许在单个包中重用类名。Java 集合库通过在每个集合类中定义内部<strong>Iterator</strong>类来实现此目的，从而为集合提供通用接口。使用内部类的另一个原因是作为<strong>私有</strong>实现的一部分。这里，内部类将有利于实现隐藏，而不是上面提到的类关联和防止命名空间污染。</p></li><li><p><strong>只要你注意到类似乎彼此之间具有高耦合，请考虑如果使用内部类可能获得的编码和维护改进</strong>。内部类的使用不会解耦类，而是明确耦合关系，并且更方便。</p></li><li><p><strong>不要成为过早优化的牺牲品</strong>。过早优化是很疯狂的行为。特别是，不要担心编写（或避免）本机方法（native methods），将某些方法设置为<strong>final</strong>，或者在首次构建系统时调整代码以使其高效。你的主要目标应该是验证设计。即使设计需要一定的效率，也<em>先让它工作，然后再让它变快</em>。</p></li><li><p><strong>保持作用域尽可能小，以便能见度和对象的寿命尽可能小</strong>。这减少了在错误的上下文中使用对象并隐藏了难以发现的 bug 的机会。例如，假设有一个集合和一段迭代它的代码。如果复制该代码以用于一个新集合，那么可能会意外地将旧集合的大小用作新集合的迭代上限。但是，如果旧集合比较大，则会在编译时捕获错误。</p></li><li><p><strong>使用标准 Java 库中的集合</strong>。熟练使用它们，将会大大提高工作效率。首选<strong>ArrayList</strong>用于序列，<strong>HashSet</strong>用于集合，<strong>HashMap</strong>用于关联数组，<strong>LinkedList</strong>用于堆栈（而不是<strong>Stack</strong>，尽管也可以创建一个适配器来提供堆栈接口）和队列（也可以使用适配器，如本书所示）。当使用前三个时，将其分别向上转型为<strong>List</strong>，<strong>Set</strong>和<strong>Map</strong>，那么就可以根据需要轻松更改为其他实现。</p></li><li><p><strong>为使整个程序健壮，每个组件必须健壮</strong>。在所创建的每个类中，使用 Java 所提供的所有工具，如访问控制，异常，类型检查，同步等。这样，就可以在构建系统时安全地进入下一级抽象。</p></li><li><p><strong>编译时错误优于运行时错误</strong>。尝试尽可能在错误发生点处理错误。在最近的处理程序中尽其所能地捕获它能处理的所有异常。在当前层面处理所能处理的所有异常，如果解决不了，就重新抛出异常。</p></li><li><p><strong>注意长方法定义</strong>。方法应该是简短的功能单元，用于描述和实现类接口的离散部分。维护一个冗长而复杂的方法是很困难的，而且代价很大，并且这个方法可能是试图做了太多事情。如果看到这样的方法，这表明，至少应该将它分解为多种方法。也可能建议去创建一个新类。小的方法也可以促进类重用。（有时方法必须很大，但它们应该只做一件事。）</p></li><li><p><strong>保持“尽可能私有”</strong>。一旦公开了你的类库中的一个方面（一个方法，一个类，一个字段），你就永远无法把它拿回来。如果这样做，就将破坏某些人的现有代码，迫使他们重写和重新设计。如果你只公开了必须公开的内容，就可以轻易地改变其他一切，而不会对其他人造成影响，而且由于设计趋于发展，这是一个重要的自由。通过这种方式，更改具体实现将对派生类造成的影响最小。在处理多线程时，私有尤其重要，只有<strong>私有</strong>字段可以防止不同步使用。具有包访问权限的类应该仍然具有<strong>私有</strong>字段，但通常有必要提供包访问权限的方法而不是将它们<strong>公开</strong>。</p></li><li><p><strong>大量使用注释，并使用<em>Javadoc commentdocumentation</em>语法生成程序文档</strong>。但是，注释应该为代码增加真正的意义，如果注释只是重申了代码已经清楚表达的内容，这是令人讨厌的。请注意，Java 类和方法名称的典型详细信息减少了对某些注释的需求。</p></li><li><p><strong>避免使用“魔法数字”</strong>。这些是指硬编码到代码中的数字。如果后续必须要更改它们，那将是一场噩梦，因为你永远不知道“100”是指“数组大小”还是“完全不同的东西”。相反，创建一个带有描述性名称的常量并在整个程序中使用常量标识符。这使程序更易于理解，更易于维护。</p></li><li><p><strong>在创建构造方法时，请考虑异常</strong>。最好的情况是，构造方法不会做任何抛出异常的事情。次一级的最佳方案是，该类仅由健壮的类组成或继承自健壮的类，因此如果抛出异常则不需要处理。否则，必须清除<strong>finally</strong>子句中的组合类。如果构造方法必然失败，则适当的操作是抛出异常，因此调用者不会认为该对象是正确创建的而盲目地继续下去。</p></li><li><p><strong>在构造方法内部，只需要将对象设置为正确的状态</strong>。主动避免调用其他方法（<strong>final</strong>方法除外），因为这些方法可以被其他人覆盖，从而在构造期间产生意外结果。（有关详细信息，请参阅<a href>第六章：初始化和清理</a>章节。）较小，较简单的构造方法不太可能抛出异常或导致问题。</p></li><li><p><strong>如果类在客户端程序员用完对象时需要进行任何清理，请将清理代码放在一个明确定义的方法中</strong>，并使用像 <strong>dispose()</strong> 这样的名称来清楚地表明其目的。另外，在类中放置一个 <strong>boolean</strong> 标志来指示是否调用了 <strong>dispose()</strong> ，因此 <strong>finalize()</strong> 可以检查“终止条件”（参见<a href>第六章：初始化和清理</a>章节）。</p></li><li><p><strong><em>finalize()</em> 的职责只能是验证对象的“终止条件”以进行调试</strong>。（参见<a href>第六章：初始化和清理</a>一章）在特殊情况下，可能需要释放垃圾收集器无法释放的内存。因为可能无法为对象调用垃圾收集器，所以无法使用 <strong>finalize()</strong> 执行必要的清理。为此，必须创建自己的 <strong>dispose()</strong> 方法。在类的 <strong>finalize()</strong> 方法中，检查以确保对象已被清理，如果没有被清理，则抛出一个派生自<strong>RuntimeException</strong>的异常，以指示编程错误。在依赖这样的计划之前，请确保 <strong>finalize()</strong> 适用于你的系统。（可能需要调用 <strong>System.gc()</strong> 来确保此行为。）</p></li><li><p><strong>如果必须在特定范围内清理对象（除了通过垃圾收集器），请使用以下准则：</strong> 初始化对象，如果成功，立即进入一个带有 <strong>finally</strong> 子句的 <strong>try</strong> 块，并在 <strong>finally</strong>中执行清理操作。</p></li><li><p><strong>在继承期间覆盖 <em>finalize()</em> 时，记得调用 <em>super.finalize()</em></strong>。（如果是直接继承自 <strong>Object</strong> 则不需要这样做。）调用 <strong>super.finalize()</strong> 作为重写的 <strong>finalize()</strong> 的最终行为而不是在第一行调用它，这样可以确保基类组件在需要时仍然有效。</p></li><li><p><strong>创建固定大小的对象集合时，将它们转换为数组，</strong> 尤其是在从方法中返回此集合时。这样就可以获得数组编译时类型检查的好处，并且数组的接收者可能不需要在数组中强制转换对象来使用它们。请注意，集合库的基类 <strong>java.util.Collection</strong> 有两个 <strong>toArray()</strong> 方法来完成此任务。</p></li><li><p><strong>优先选择 <em>接口</em> 而不是 <em>抽象类</em></strong>。如果知道某些东西应该是基类，那么第一选择应该是使其成为一个接口，并且只有在需要方法定义或成员变量时才将其更改为抽象类。一个接口关心客户端想要做什么，而一个类倾向于关注（或允许）实现细节。</p></li><li><p><strong>为了避免非常令人沮丧的经历，请确保类路径中的每个名称只对应一个不在包中的类</strong>。否则，编译器可以首先找到具有相同名称的其他类，并报告没有意义的错误消息。如果你怀疑自己有类路径问题，请尝试在类路径的每个起始点查找具有相同名称的 <strong>.class</strong> 文件。理想情况下，应该将所有类放在包中。</p></li><li><p><strong>注意意外重载</strong>。如果尝试覆盖基类方法但是拼写错误，则最终会添加新方法而不是覆盖现有方法。但是，这是完全合法的，因此在编译时或运行时不会获得任何错误消息，但代码将无法正常工作。始终使用 <strong>@Override</strong> 注释来防止这种情况。</p></li><li><p><strong>注意过早优化</strong>。先让它工作，然后再让它变快。除非发现代码的特定部分存在性能瓶颈。除非是使用分析器发现瓶颈，否则过早优化会浪费时间。性能调整所隐藏的额外成本是代码将变得难以理解和维护。</p></li><li><p><strong>请注意，相比于编写代码，代码被阅读的机会更多</strong>。清晰的设计可能产生易于理解的程序，但注释，详细解释，测试和示例是非常宝贵的，它们可以帮助你和你的所有后继者。如果不出意外，试图从 JDK 文档中找出有用信息的挫败感应该可以说服你。</p></li></ol><blockquote id="fn_1"><sup>1</sup>. Andrew Koenig 向我解释了它。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-编程指南&quot;&gt;&lt;a href=&quot;#附录-编程指南&quot; class=&quot;headerlink&quot; title=&quot;附录:编程指南&quot;&gt;&lt;/a&gt;附录:编程指南&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本附录包含了有助于指导你进行低级程序设计和编写代码的建议。&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-passing-and-returning-objects/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-passing-and-returning-objects/</id>
    <published>2022-06-23T15:31:23.688Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-对象传递和返回"><a href="#附录-对象传递和返回" class="headerlink" title="附录:对象传递和返回"></a>附录:对象传递和返回</h1><blockquote><p>到现在为止，你已经对“传递”对象实际上是传递引用这一想法想法感到满意。</p></blockquote><p>在许多编程语言中，你可以使用该语言的“常规”方式来传递对象，并且大多数情况下一切正常。 但是通常会出现这种情况，你必须做一些不平常的事情，突然事情变得更加复杂。 Java 也不例外，当您传递对象并对其进行操作时，准确了解正在发生的事情很重要。 本附录提供了这种见解。</p><p>提出本附录问题的另一种方法是，如果你之前使用类似 C++的编程语言，则是“ Java 是否有指针？” Java 中的每个对象标识符（除原语外）都是这些指针之一，但它们的用法是不仅受编译器的约束，而且受运行时系统的约束。 换一种说法，Java 有指针，但没有指针算法。 这些就是我一直所说的“引用”，您可以将它们视为“安全指针”，与小学的安全剪刀不同-它们不敏锐，因此您不费吹灰之力就无法伤害自己，但是它们有时可能很乏味。</p><h2 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h2><p>当你将引用传递给方法时，它仍指向同一对象。 一个简单的实验演示了这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// references/PassReferences.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassReferences</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(PassReferences h)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;h inside f(): &quot;</span> + h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PassReferences p = <span class="keyword">new</span> PassReferences();</span><br><span class="line">        System.out.println(<span class="string">&quot;p inside main(): &quot;</span> + p);</span><br><span class="line">        f(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">p inside main(): PassReferences@15db9742</span></span><br><span class="line"><span class="comment">h inside f(): PassReferences@15db9742</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>方法 <code>toString()</code> 在打印语句中自动调用，并且 <code>PassReferences</code> 直接从 <code>Object</code> 继承而无需重新定义 <code>toString（）</code> 。 因此，使用的是 <code>Object</code> 的 <code>toString（）</code> 版本，它打印出对象的类，然后打印出该对象所在的地址（不是引用，而是实际的对象存储）。</p><h2 id="本地拷贝"><a href="#本地拷贝" class="headerlink" title="本地拷贝"></a>本地拷贝</h2><h2 id="控制克隆"><a href="#控制克隆" class="headerlink" title="控制克隆"></a>控制克隆</h2><h2 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h2><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-对象传递和返回&quot;&gt;&lt;a href=&quot;#附录-对象传递和返回&quot; class=&quot;headerlink&quot; title=&quot;附录:对象传递和返回&quot;&gt;&lt;/a&gt;附录:对象传递和返回&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;到现在为止，你已经对“传递”对象实际上是传递引用这</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-object-serialization/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-object-serialization/</id>
    <published>2022-06-23T15:31:23.687Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-对象序列化"><a href="#附录-对象序列化" class="headerlink" title="附录:对象序列化"></a>附录:对象序列化</h1><p>当你创建对象时，只要你需要，它就会一直存在，但是在程序终止时，无论如何它都不会继续存在。尽管这么做肯定是有意义的，但是仍旧存在某些情况，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行时它所拥有的信息相同。当然，你可以通过将信息写入文件或数据库来达到相同的效果，但是在使万物都成为对象的精神中，如果能够将一个对象声明为是“持久性”的，并为我们处理掉所有细节，那将会显得十分方便。</p><p>Java 的对象序列化将那些实现了 Serializable 接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。也就是说，可以在运行 Windows 系统的计算机上创建一个对象，将其序列化，通过网络将它发送给一台运行 Unix 系统的计算机，然后在那里准确地重新组装，而却不必担心数据在不同机器上的表示会不同，也不必关心宇节的顺序或者其他任何细节。</p><p>就其本身来说，对象序列化可以实现轻量级持久性（lightweight persistence），“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行它可以生存于程序的调用之间。通过将一个序列化对象写人磁盘，然后在重新调用程序时恢复该对象，就能够实现持久性的效果。之所以称其为“轻量级”，是因为不能用某种”persistent”（持久）关键字来简单地定义一个对象，并让系统自动维护其他细节问题（尽管将来有可能实现）。相反，对象必须在程序中显式地序列化（serialize）和反序列化还原（deserialize），如果需要个更严格的持久性机制，可以考虑像 Hibemate 之类的工具。</p><p>对象序列化的概念加入到语言中是为了支持两种主要特性。一是 Java 的远程方法调用（Remote Method Invocation，RMI），它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。</p><p>再者，对 Java Beans 来说，对象的序列化也是必需的（在撰写本文时被视为失败的技术），使用一个 Bean 时，一般情况下是在设计阶段对它的状态信息进行配置。这种状态信息必须保存下来，并在程序启动时进行后期恢复，这种具体工作就是由对象序列化完成的。</p><p>只要对象实现了 Serializable 接口（该接口仅是一个标记接口，不包括任何方法），对象的序列化处理就会非常简单。当序列化的概念被加入到语言中时，许多标准库类都发生了改变，以便具备序列化特性-其中包括所有基本数据类型的封装器、所有容器类以及许多其他的东西。甚至 Class 对象也可以被序列化。</p><p>要序列化一个对象，首先要创建某些 OutputStream 对象，然后将其封装在一个 ObjectOutputStream 对象内。这时，只需调用 writeObject() 即可将对象序列化，并将其发送给 OutputStream（对象化序列是基于字节的，因要使用 InputStream 和 OutputStream 继承层次结构）。要反向进行该过程（即将一个序列还原为一个对象），需要将一个 InputStream 封装在 ObjectInputStream 内，然后调用 readObject()。和往常一样，我们最后获得的是一个引用，它指向一个向上转型的 Object，所以必须向下转型才能直接设置它们。</p><p>对象序列化特别“聪明”的一个地方是它不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象；接着又能对对象内包含的每个这样的引用进行追踪，依此类推。这种情况有时被称为“对象网”，单个对象可与之建立连接，而且它还包含了对象的引用数组以及成员对象。如果必须保持一套自己的对象序列化机制，那么维护那些可追踪到所有链接的代码可能会显得非常麻烦。然而，由于 Java 的对象序列化似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。下面这个例子通过对链接的对象生成一个 worm（蠕虫）对序列化机制进行了测试。每个对象都与 worm 中的下一段链接，同时又与属于不同类（Data）的对象引用数组链接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/Worm.java</span></span><br><span class="line"><span class="comment">// Demonstrates object serialization</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    Data(<span class="keyword">int</span> n) &#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worm</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> Data[] d = &#123;</span><br><span class="line">            <span class="keyword">new</span> Data(rand.nextInt(<span class="number">10</span>)),</span><br><span class="line">            <span class="keyword">new</span> Data(rand.nextInt(<span class="number">10</span>)),</span><br><span class="line">            <span class="keyword">new</span> Data(rand.nextInt(<span class="number">10</span>))</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> Worm next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="comment">// Value of i == number of segments</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worm</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Worm constructor: &quot;</span> + i);</span><br><span class="line">        c = x;</span><br><span class="line">        <span class="keyword">if</span>(--i &gt; <span class="number">0</span>)</span><br><span class="line">            next = <span class="keyword">new</span> Worm(i, (<span class="keyword">char</span>)(x + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No-arg constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        result.append(c);</span><br><span class="line">        result.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Data dat : d)</span><br><span class="line">            result.append(dat);</span><br><span class="line">        result.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="keyword">null</span>)</span><br><span class="line">            result.append(next);</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">    <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,</span></span><br><span class="line"><span class="function">            IOException </span>&#123;</span><br><span class="line">        Worm w = <span class="keyword">new</span> Worm(<span class="number">6</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;w = &quot;</span> + w);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;worm.dat&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            out.writeObject(<span class="string">&quot;Worm storage\n&quot;</span>);</span><br><span class="line">            out.writeObject(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;worm.dat&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            String s = (String)in.readObject();</span><br><span class="line">            Worm w2 = (Worm)in.readObject();</span><br><span class="line">            System.out.println(s + <span class="string">&quot;w2 = &quot;</span> + w2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ByteArrayOutputStream bout =</span><br><span class="line">                        <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream out2 =</span><br><span class="line">                        <span class="keyword">new</span> ObjectOutputStream(bout)</span><br><span class="line">        ) &#123;</span><br><span class="line">            out2.writeObject(<span class="string">&quot;Worm storage\n&quot;</span>);</span><br><span class="line">            out2.writeObject(w);</span><br><span class="line">            out2.flush();</span><br><span class="line">            <span class="keyword">try</span>(</span><br><span class="line">                    ObjectInputStream in2 = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                            <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                                    bout.toByteArray()))</span><br><span class="line">            ) &#123;</span><br><span class="line">                String s = (String)in2.readObject();</span><br><span class="line">                Worm w3 = (Worm)in2.readObject();</span><br><span class="line">                System.out.println(s + <span class="string">&quot;w3 = &quot;</span> + w3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Worm constructor: 6</span><br><span class="line">Worm constructor: 5</span><br><span class="line">Worm constructor: 4</span><br><span class="line">Worm constructor: 3</span><br><span class="line">Worm constructor: 2</span><br><span class="line">Worm constructor: 1</span><br><span class="line">w = :a(853):b(119):c(802):d(788):e(199):f(881)</span><br><span class="line">Worm storage</span><br><span class="line">w2 = :a(853):b(119):c(802):d(788):e(199):f(881)</span><br><span class="line">Worm storage</span><br><span class="line">w3 = :a(853):b(119):c(802):d(788):e(199):f(881)</span><br></pre></td></tr></table></figure><p>更有趣的是，Worm 内的 Data 对象数组是用随机数初始化的（这样就不用怀疑编译器保留了某种原始信息），每个 Worm 段都用一个 char 加以标记。该 char 是在递归生成链接的 Worm 列表时自动产生的。要创建一个 Worm，必须告诉构造器你所希望的它的长度。在产生下一个引用时，要调用 Worm 构造器，并将长度减 1，以此类推。最后一个 next 引用则为 null（空），表示已到达 Worm 的尾部</p><p>以上这些操作都使得事情变得更加复杂，从而加大了对象序列化的难度。然而，真正的序列化过程却是非常简单的。一旦从另外某个流创建了 ObjectOutputstream，writeObject() 就会将对象序列化。注意也可以为一个 String 调用 writeObject() 也可以用与 DataOutputStream 相同的方法写人所有基本数据类型（它们具有同样的接口）。</p><p>有两段看起来相似的独立的代码。一个读写的是文件，而另一个读写的是字节数组（ByteArray），可利用序列化将对象读写到任何 DatalnputStream 或者 DataOutputStream。</p><p>从输出中可以看出，被还原后的对象确实包含了原对象中的所有链接。</p><p>注意在对一个 Serializable 对象进行还原的过程中，没有调用任何构造器，包括默认的构造器。整个对象都是通过从 InputStream 中取得数据恢复而来的。</p><h2 id="查找类"><a href="#查找类" class="headerlink" title="查找类"></a>查找类</h2><p>你或许会奇怪，将一个对象从它的序列化状态中恢复出来，有哪些工作是必须的呢？举个例子来说，假如我们将一个对象序列化，并通过网络将其作为文件传送给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个对象吗？</p><p>回答这个问题的最好方法就是做一个实验。下面这个文件位于本章的子目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/Alien.java</span></span><br><span class="line"><span class="comment">// A serializable class</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alien</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>而用于创建和序列化一个 Alien 对象的文件也位于相同的目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/FreezeAlien.java</span></span><br><span class="line"><span class="comment">// Create a serialized output file</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreezeAlien</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;X.file&quot;</span>));</span><br><span class="line">        ) &#123;</span><br><span class="line">            Alien quellek = <span class="keyword">new</span> Alien();</span><br><span class="line">            out.writeObject(quellek);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦该程序被编译和运行，它就会在 c12 目录下产生一个名为 X.file 的文件。以下代码位于一个名为 xiles 的子目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/xfiles/ThawAlien.java</span></span><br><span class="line"><span class="comment">// Recover a serialized file</span></span><br><span class="line"><span class="comment">// &#123;java serialization.xfiles.ThawAlien&#125;</span></span><br><span class="line"><span class="comment">// &#123;RunFirst: FreezeAlien&#125;</span></span><br><span class="line"><span class="keyword">package</span> serialization.xfiles;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThawAlien</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;X.file&quot;</span>)));</span><br><span class="line">        Object mystery = in.readObject();</span><br><span class="line">        System.out.println(mystery.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span></span></span><br></pre></td></tr></table></figure><p>为了正常运行，必须保证 Java 虚拟机能找到相关的.class 文件。</p><h2 id="控制序列化"><a href="#控制序列化" class="headerlink" title="控制序列化"></a>控制序列化</h2><p>正如大家所看到的，默认的序列化机制并不难操纵。然而，如果有特殊的需要那又该怎么办呢？例如，也许要考虑特殊的安全问题，而且你不希望对象的某一部分被序列化；或者一个对象被还原以后，某子对象需要重新创建，从而不必将该子对象序列化。</p><p>在这些特殊情况下，可通过实现 Externalizable 接口——代替实现 Serializable 接口-来对序列化过程进行控制。这个 Externalizable 接口继承了 Serializable 接口，同时增添了两个方法：writeExternal0 和 readExternal0。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。</p><p>下面这个例子展示了 Externalizable 接口方法的简单实现。注意 Blip1 和 Blip2 除了细微的差别之外，几乎完全一致（研究一下代码，看看你能否发现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/Blips.java</span></span><br><span class="line"><span class="comment">// Simple use of Externalizable &amp; a pitfall</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blip1</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip1 Constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip1.writeExternal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip1.readExternal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blip2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    Blip2() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip2 Constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip2.writeExternal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip2.readExternal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blips</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructing objects:&quot;</span>);</span><br><span class="line">        Blip1 b1 = <span class="keyword">new</span> Blip1();</span><br><span class="line">        Blip2 b2 = <span class="keyword">new</span> Blip2();</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Blips.serialized&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Saving objects:&quot;</span>);</span><br><span class="line">            o.writeObject(b1);</span><br><span class="line">            o.writeObject(b2);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now get them back:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Recovering b1:&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Blips.serialized&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            b1 = (Blip1)in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// OOPS! Throws an exception:</span></span><br><span class="line">        <span class="comment">//- System.out.println(&quot;Recovering b2:&quot;);</span></span><br><span class="line">        <span class="comment">//- b2 = (Blip2)in.readObject();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Constructing objects:</span><br><span class="line">Blip1 Constructor</span><br><span class="line">Blip2 Constructor</span><br><span class="line">Saving objects:</span><br><span class="line">Blip1.writeExternal</span><br><span class="line">Blip2.writeExternal</span><br><span class="line">Recovering b1:</span><br><span class="line">Blip1 Constructor</span><br><span class="line">Blip1.readExternal</span><br></pre></td></tr></table></figure><p>没有恢复 Blip2 对象的原因是那样做会导致一个异常。你找出 Blip1 和 Blip2 之间的区别了吗？Blipl 的构造器是“公共的”（pablic），Blip2 的构造器却不是，这样就会在恢复时造成异常。试试将 Blip2 的构造器变成 public 的，然后删除//注释标记，看看是否能得到正确的结果。</p><p>恢复 b1 后，会调用 Blip1 默认构造器。这与恢复一个 Serializable 对象不同。对于 Serializable 对象，对象完全以它存储的二进制位为基础来构造，而不调用构造器。而对于一个 Externalizable 对象，所有普通的默认构造器都会被调用（包括在字段定义时的初始化），然后调用 readExternal() 必须注意这一点—所有默认的构造器都会被调用，才能使 Externalizable 对象产生正确的行为。</p><p>下面这个例子示范了如何完整保存和恢复一个 Externalizable 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/Blip3.java</span></span><br><span class="line"><span class="comment">// Reconstructing an externalizable object</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip3</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> String s; <span class="comment">// No initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip3 Constructor&quot;</span>);</span><br><span class="line"><span class="comment">// s, i not initialized</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">(String x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip3(String x, int a)&quot;</span>);</span><br><span class="line">        s = x;</span><br><span class="line">        i = a;</span><br><span class="line"><span class="comment">// s &amp; i initialized only in non-no-arg constructor.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s + i; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip3.writeExternal&quot;</span>);</span><br><span class="line"><span class="comment">// You must do this:</span></span><br><span class="line">        out.writeObject(s);</span><br><span class="line">        out.writeInt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Blip3.readExternal&quot;</span>);</span><br><span class="line"><span class="comment">// You must do this:</span></span><br><span class="line">        s = (String)in.readObject();</span><br><span class="line">        i = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructing objects:&quot;</span>);</span><br><span class="line">        Blip3 b3 = <span class="keyword">new</span> Blip3(<span class="string">&quot;A String &quot;</span>, <span class="number">47</span>);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Blip3.serialized&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Saving object:&quot;</span>);</span><br><span class="line">            o.writeObject(b3);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// Now get it back:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Recovering b3:&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Blip3.serialized&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            b3 = (Blip3)in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Constructing objects:</span><br><span class="line">Blip3(String x, int a)</span><br><span class="line">A String 47</span><br><span class="line">Saving object:</span><br><span class="line">Blip3.writeExternal</span><br><span class="line">Recovering b3:</span><br><span class="line">Blip3 Constructor</span><br><span class="line">Blip3.readExternal</span><br><span class="line">A String 47</span><br></pre></td></tr></table></figure><p>其中，字段 s 和只在第二个构造器中初始化，而不是在默认的构造器中初始化。这意味着假如不在 readExternal0 中初始化 s 和 i，s 就会为 null，而就会为零（因为在创建对象的第一步中将对象的存储空间清理为 0）。如果注释掉跟随于”You must do this”后面的两行代码，然后运行程序，就会发现当对象被还原后，s 是 null，而 i 是零。</p><p>我们如果从一个 Externalizable 对象继承，通常需要调用基类版本的 writeExternal() 和 readExternal() 来为基类组件提供恰当的存储和恢复功能。</p><p>因此，为了正常运行，我们不仅需要在 writeExternal() 方法（没有任何默认行为来为 Externalizable 对象写入任何成员对象）中将来自对象的重要信息写入，还必须在 readExternal() 方法中恢复数据。起先，可能会有一点迷惑，因为 Externalizable 对象的默认构造行为使其看起来似乎像某种自动发生的存储与恢复操作。但实际上并非如此。</p><h3 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h3><p>当我们对序列化进行控制时，可能某个特定子对象不想让 Java 的序列化机制自动保存与恢复。如果子对象表示的是我们不希望将其序列化的敏感信息（如密码），通常就会面临这种情况。即使对象中的这些信息是 private（私有）属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问到它。</p><p>有一种办法可防止对象的敏感部分被序列化，就是将类实现为 Externalizable，如前面所示。这样一来，没有任何东西可以自动序列化，并且可以在 writeExternal() 内部只对所需部分进行显式的序列化。</p><p>然而，如果我们正在操作的是一个 Seralizable 对象，那么所有序列化操作都会自动进行。为了能够予以控制，可以用 transient（瞬时）关键字逐个字段地关闭序列化，它的意思是“不用麻烦你保存或恢复数据——我自己会处理的”。</p><p>例如，假设某个 Logon 对象保存某个特定的登录会话信息，登录的合法性通过校验之后，我们想把数据保存下来，但不包括密码。为做到这一点，最简单的办法是实现 Serializable，并将 password 字段标志为 transient，下面是具体的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/Logon.java</span></span><br><span class="line"><span class="comment">// Demonstrates the &quot;transient&quot; keyword</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logon</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logon</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">        username = name;</span><br><span class="line">        password = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;logon info: \n username: &quot;</span> +</span><br><span class="line">                username + <span class="string">&quot;\n date: &quot;</span> + date +</span><br><span class="line">                <span class="string">&quot;\n password: &quot;</span> + password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logon a = <span class="keyword">new</span> Logon(<span class="string">&quot;Hulk&quot;</span>, <span class="string">&quot;myLittlePony&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;logon a = &quot;</span> + a);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectOutputStream o =</span><br><span class="line">                        <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Logon.dat&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            o.writeObject(a);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Now get them back:</span></span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Logon.dat&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;Recovering object at &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            a = (Logon)in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;logon a = &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">logon a = logon info:</span><br><span class="line">username: Hulk</span><br><span class="line">date: Tue May 09 06:07:47 MDT 2017</span><br><span class="line">password: myLittlePony</span><br><span class="line">Recovering object at Tue May 09 06:07:49 MDT 2017</span><br><span class="line">logon a = logon info:</span><br><span class="line">username: Hulk</span><br><span class="line">date: Tue May 09 06:07:47 MDT 2017</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure><p>可以看到，其中的 date 和 username 是一般的（不是 transient 的），所以它们会被自动序列化。而 password 是 transient 的，所以不会被自动保存到磁盘；另外，自动序列化机制也不会尝试去恢复它。当对象被恢复时，password 就会变成 null。注意，虽然 toString() 是用重载后的+运算符来连接 String 对象，但是 null 引用会被自动转换成字符串 null。</p><p>我们还可以发现：date 字段被存储了到磁盘并从磁盘上被恢复了出来，而且没有再重新生成。由于 Externalizable 对象在默认情况下不保存它们的任何字段，所以 transient 关键字只能和 Serializable 对象一起使用。</p><h3 id="Externalizable-的替代方法"><a href="#Externalizable-的替代方法" class="headerlink" title="Externalizable 的替代方法"></a>Externalizable 的替代方法</h3><p>如果不是特别坚持实现 Externalizable 接口，那么还有另一种方法。我们可以实现 Serializable 接口，并添加（注意我说的是“添加”，而非“覆盖”或者“实现”）名为 writeObject() 和 readObject() 的方法。这样一旦对象被序列化或者被反序列化还原，就会自动地分别调用这两个方法。也就是说，只要我们提供了这两个方法，就会使用它们而不是默认的序列化机制。</p><p>这些方法必须具有准确的方法特征签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br></pre></td></tr></table></figure><p>从设计的观点来看，现在事情变得真是不可思议。首先，我们可能会认为由于这些方法不是基类或者 Serializable 接口的一部分，所以应该在它们自己的接口中进行定义。但是注意它们被定义成了 private，这意味着它们仅能被这个类的其他成员调用。然而，实际上我们并没有从这个类的其他方法中调用它们，而是 ObjectOutputStream 和 ObjectInputStream 对象的 writeObject() 和 readobject() 方法调用你的对象的 writeObject() 和 readObject() 方法（注意关于这里用到的相同方法名，我尽量抑制住不去谩骂。一句话：混乱）。读者可能想知道 ObjectOutputStream 和 ObjectInputStream 对象是怎样访问你的类中的 private 方法的。我们只能假设这正是序列化神奇的一部分。</p><p>在接口中定义的所有东西都自动是 public 的，因此如果 writeObject() 和 readObject() 必须是 private 的，那么它们不会是接口的一部分。因为我们必须要完全遵循其方法特征签名，所以其效果就和实现了接口一样。</p><p>在调用 ObjectOutputStream.writeObject() 时，会检查所传递的 Serializable 对象，看看是否实现了它自己的 writeObject()。如果是这样，就跳过正常的序列化过程并调用它的 writeObiect()。readObject() 的情形与此相同。</p><p>还有另外一个技巧。在你的 writeObject() 内部，可以调用 defaultWriteObject() 来选择执行默认的 writeObject()。类似地，在 readObject() 内部，我们可以调用 defaultReadObject()，下面这个简单的例子演示了如何对一个 Serializable 对象的存储与恢复进行控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/SerialCtl.java</span></span><br><span class="line"><span class="comment">// Controlling serialization by adding your own</span></span><br><span class="line"><span class="comment">// writeObject() and readObject() methods</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialCtl</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerialCtl</span><span class="params">(String aa, String bb)</span> </span>&#123;</span><br><span class="line">        a = <span class="string">&quot;Not Transient: &quot;</span> + aa;</span><br><span class="line">        b = <span class="string">&quot;Transient: &quot;</span> + bb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a + <span class="string">&quot;\n&quot;</span> + b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        stream.defaultWriteObject();</span><br><span class="line">        stream.writeObject(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        stream.defaultReadObject();</span><br><span class="line">        b = (String)stream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SerialCtl sc = <span class="keyword">new</span> SerialCtl(<span class="string">&quot;Test1&quot;</span>, <span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Before:\n&quot;</span> + sc);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                ByteArrayOutputStream buf =</span><br><span class="line">                        <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream o =</span><br><span class="line">                        <span class="keyword">new</span> ObjectOutputStream(buf);</span><br><span class="line">        ) &#123;</span><br><span class="line">            o.writeObject(sc);</span><br><span class="line"><span class="comment">// Now get it back:</span></span><br><span class="line">            <span class="keyword">try</span> (</span><br><span class="line">                    ObjectInputStream in =</span><br><span class="line">                            <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                                            buf.toByteArray()));</span><br><span class="line">            ) &#123;</span><br><span class="line">                SerialCtl sc2 = (SerialCtl)in.readObject();</span><br><span class="line">                System.out.println(<span class="string">&quot;After:\n&quot;</span> + sc2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Before:</span><br><span class="line">Not Transient: Test1</span><br><span class="line">Transient: Test2</span><br><span class="line">After:</span><br><span class="line">Not Transient: Test1</span><br><span class="line">Transient: Test2</span><br></pre></td></tr></table></figure><p>在这个例子中，有一个 String 字段是普通字段，而另一个是 transient 字段，用来证明非 transient 字段由 defaultWriteObject() 方法保存，而 transient 字段必须在程序中明确保存和恢复。字段是在构造器内部而不是在定义处进行初始化的，以此可以证实它们在反序列化还原期间没有被一些自动化机制初始化。</p><p>如果我们打算使用默认机制写入对象的非 transient 部分，那么必须调用 defaultwriteObject() 作为 writeObject() 中的第一个操作，并让 defaultReadObject() 作为 readObject() 中的第一个操作。这些都是奇怪的方法调用。例如，如果我们正在为 ObjectOutputStream 调用 defaultWriteObject() 且没有传递任何参数，然而不知何故它却可以运行，并且知道对象的引用以及如何写入非 transient 部分。真是奇怪之极。</p><p>对 transient 对象的存储和恢复使用了我们比较熟悉的代码。请再考虑一下在这里所发生的事情。在 main0）中，创建 SerialCtl 对象，然后将其序列化到 ObjectOutputStream（注意在这种情况下，使用的是缓冲区而不是文件-这对于 ObjectOutputStream 来说是完全一样的）。序列化发生在下面这行代码当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.writeObject(sc);</span><br></pre></td></tr></table></figure><p>writeObject() 方法必须检查 sc，判断它是否拥有自己的 writeObject() 方法（不是检查接口——这里根本就没有接口，也不是检查类的类型，而是利用反射来真正地搜索方法）。如果有，那么就会使用它。对 readObject() 也采用了类似的方法。或许这是解决这个问题的唯一切实可行的方法，但它确实有点古怪。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>有时可能想要改变可序列化类的版本（比如源类的对象可能保存在数据库中）。虽然 Java 支持这种做法，但是你可能只在特殊的情况下才这样做，此外，还需要对它有相当深程度的了解（在这里我们就不再试图达到这一点）。从 <a href="http://java.oracle.com">http://java.oracle.com</a> 下的 JDK 文档中对这一主题进行了非常彻底的论述。</p><h2 id="使用持久化"><a href="#使用持久化" class="headerlink" title="使用持久化"></a>使用持久化</h2><p>个比较诱人的使用序列化技术的想法是：存储程序的一些状态，以便我们随后可以很容易地将程序恢复到当前状态。但是在我们能够这样做之前，必须回答几个问题。如果我们将两个对象-它们都具有指向第三个对象的引用-进行序列化，会发生什么情况？当我们从它们的序列化状态恢复这两个对象时，第三个对象会只出现一次吗？如果将这两个对象序列化成独立的文件，然后在代码的不同部分对它们进行反序列化还原，又会怎样呢？</p><p>下面这个例子说明了上述问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/MyWorld.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> House preferredHouse;</span><br><span class="line">    Animal(String nm, House h) &#123;</span><br><span class="line">        name = nm;</span><br><span class="line">        preferredHouse = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;[&quot;</span> + <span class="keyword">super</span>.toString() +</span><br><span class="line">                <span class="string">&quot;], &quot;</span> + preferredHouse + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House house = <span class="keyword">new</span> House();</span><br><span class="line">        List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        animals.add(</span><br><span class="line">                <span class="keyword">new</span> Animal(<span class="string">&quot;Bosco the dog&quot;</span>, house));</span><br><span class="line">        animals.add(</span><br><span class="line">                <span class="keyword">new</span> Animal(<span class="string">&quot;Ralph the hamster&quot;</span>, house));</span><br><span class="line">        animals.add(</span><br><span class="line">                <span class="keyword">new</span> Animal(<span class="string">&quot;Molly the cat&quot;</span>, house));</span><br><span class="line">        System.out.println(<span class="string">&quot;animals: &quot;</span> + animals);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ByteArrayOutputStream buf1 =</span><br><span class="line">                        <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream o1 =</span><br><span class="line">                        <span class="keyword">new</span> ObjectOutputStream(buf1)</span><br><span class="line">        ) &#123;</span><br><span class="line">            o1.writeObject(animals);</span><br><span class="line">            o1.writeObject(animals); <span class="comment">// Write a 2nd set</span></span><br><span class="line"><span class="comment">// Write to a different stream:</span></span><br><span class="line">            <span class="keyword">try</span>(</span><br><span class="line">                    ByteArrayOutputStream buf2 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    ObjectOutputStream o2 = <span class="keyword">new</span> ObjectOutputStream(buf2)</span><br><span class="line">            ) &#123;</span><br><span class="line">                o2.writeObject(animals);</span><br><span class="line"><span class="comment">// Now get them back:</span></span><br><span class="line">                <span class="keyword">try</span>(</span><br><span class="line">                        ObjectInputStream in1 =</span><br><span class="line">                                <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                                        <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                                                buf1.toByteArray()));</span><br><span class="line">                        ObjectInputStream in2 =</span><br><span class="line">                                <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                                        <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                                                buf2.toByteArray()))</span><br><span class="line">                ) &#123;</span><br><span class="line">                    List</span><br><span class="line">                            animals1 = (List)in1.readObject(),</span><br><span class="line">                            animals2 = (List)in1.readObject(),</span><br><span class="line">                            animals3 = (List)in2.readObject();</span><br><span class="line">                    System.out.println(</span><br><span class="line">                            <span class="string">&quot;animals1: &quot;</span> + animals1);</span><br><span class="line">                    System.out.println(</span><br><span class="line">                            <span class="string">&quot;animals2: &quot;</span> + animals2);</span><br><span class="line">                    System.out.println(</span><br><span class="line">                            <span class="string">&quot;animals3: &quot;</span> + animals3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">animals: [Bosco the dog[Animal@15db9742],</span><br><span class="line">House@6d06d69c</span><br><span class="line">, Ralph the hamster[Animal@7852e922], House@6d06d69c</span><br><span class="line">, Molly the cat[Animal@4e25154f], House@6d06d69c</span><br><span class="line">]</span><br><span class="line">animals1: [Bosco the dog[Animal@7ba4f24f],</span><br><span class="line">House@3b9a45b3</span><br><span class="line">, Ralph the hamster[Animal@7699a589], House@3b9a45b3</span><br><span class="line">, Molly the cat[Animal@58372a00], House@3b9a45b3</span><br><span class="line">]</span><br><span class="line">animals2: [Bosco the dog[Animal@7ba4f24f],</span><br><span class="line">House@3b9a45b3</span><br><span class="line">, Ralph the hamster[Animal@7699a589], House@3b9a45b3</span><br><span class="line">, Molly the cat[Animal@58372a00], House@3b9a45b3</span><br><span class="line">]</span><br><span class="line">animals3: [Bosco the dog[Animal@4dd8dc3],</span><br><span class="line">House@6d03e736</span><br><span class="line">, Ralph the hamster[Animal@568db2f2], House@6d03e736</span><br><span class="line">, Molly the cat[Animal@378bf509], House@6d03e736</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里有一件有趣的事：我们可以通过一个字节数组来使用对象序列化，从而实现对任何可 Serializable 对象的“深度复制”（deep copy）—— 深度复制意味着我们复制的是整个对象网，而不仅仅是基本对象及其引用。复制对象将在本书的 <a href>附录：传递和返回对象 </a> 一章中进行深入地探讨。</p><p>在这个例子中，Animal 对象包含有 House 类型的字段。在 main() 方法中，创建了一个 Animal 列表并将其两次序列化，分别送至不同的流。当其被反序列化还原并被打印时，我们可以看到所示的执行某次运行后的结果（每次运行时，对象将会处在不同的内存地址）。</p><p>当然，我们期望这些反序列化还原后的对象地址与原来的地址不同。但请注意，在 animals1 和 animals2 中却出现了相同的地址，包括二者共享的那个指向 House 对象的引用。另一方面，当恢复 animals3 时，系统无法知道另一个流内的对象是第一个流内的对象的别名，因此它会产生出完全不同的对象网。</p><p>只要将任何对象序列化到单一流中，就可以恢复出与我们写出时一样的对象网，并且没有任何意外重复复制出的对象。当然，我们可以在写出第一个对象和写出最后一个对象期间改变这些对象的状态，但是这是我们自己的事，无论对象在被序列化时处于什么状态（无论它们和其他对象有什么样的连接关系），它们都可以被写出。</p><p>最安全的做法是将其作为“原子”操作进行序列化。如果我们序列化了某些东西，再去做其他一些工作，再来序列化更多的东西，如此等等，那么将无法安全地保存系统状态。取而代之的是，将构成系统状态的所有对象都置入单一容器内，并在一个操作中将该容器直接写出。然后同样只需一次方法调用，即可以将其恢复。</p><p>下面这个例子是一个想象的计算机辅助设计（CAD）系统，该例演示了这一方法。此外，它还引入了 static 字段的问题：如果我们查看 JDK 文档，就会发现 Class 是 Serializable 的，因此只需直接对 Class 对象序列化，就可以很容易地保存 static 字段。在任何情况下，这都是一种明智的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/AStoreCADState.java</span></span><br><span class="line"><span class="comment">// Saving the state of a fictitious CAD system</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; RED, BLUE, GREEN &#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> xPos, yPos, dimension;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color newColor)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">    Shape(<span class="keyword">int</span> xVal, <span class="keyword">int</span> yVal, <span class="keyword">int</span> dim) &#123;</span><br><span class="line">        xPos = xVal;</span><br><span class="line">        yPos = yVal;</span><br><span class="line">        dimension = dim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass() + <span class="string">&quot;color[&quot;</span> + getColor() +</span><br><span class="line">                <span class="string">&quot;] xPos[&quot;</span> + xPos + <span class="string">&quot;] yPos[&quot;</span> + yPos +</span><br><span class="line">                <span class="string">&quot;] dim[&quot;</span> + dimension + <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">randomFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xVal = rand.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> yVal = rand.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> dim = rand.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">switch</span>(counter++ % <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">new</span> Circle(xVal, yVal, dim);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> Square(xVal, yVal, dim);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> Line(xVal, yVal, dim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Color color = Color.RED;</span><br><span class="line">    Circle(<span class="keyword">int</span> xVal, <span class="keyword">int</span> yVal, <span class="keyword">int</span> dim) &#123;</span><br><span class="line">        <span class="keyword">super</span>(xVal, yVal, dim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color newColor)</span> </span>&#123;</span><br><span class="line">        color = newColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Color color = Color.RED;</span><br><span class="line">    Square(<span class="keyword">int</span> xVal, <span class="keyword">int</span> yVal, <span class="keyword">int</span> dim) &#123;</span><br><span class="line">        <span class="keyword">super</span>(xVal, yVal, dim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color newColor)</span> </span>&#123;</span><br><span class="line">        color = newColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Color color = Color.RED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">    <span class="title">serializeStaticState</span><span class="params">(ObjectOutputStream os)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123; os.writeObject(color); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">    <span class="title">deserializeStaticState</span><span class="params">(ObjectInputStream os)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        color = (Color)os.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    Line(<span class="keyword">int</span> xVal, <span class="keyword">int</span> yVal, <span class="keyword">int</span> dim) &#123;</span><br><span class="line">        <span class="keyword">super</span>(xVal, yVal, dim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color newColor)</span> </span>&#123;</span><br><span class="line">        color = newColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AStoreCADState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Class&lt;? extends Shape&gt;&gt; shapeTypes =</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        Circle.class, Square.class, Line.class);</span><br><span class="line">        List&lt;Shape&gt; shapes = IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">                .mapToObj(i -&gt; Shape.randomFactory())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// Set all the static colors to GREEN:</span></span><br><span class="line">        shapes.forEach(s -&gt; s.setColor(Color.GREEN));</span><br><span class="line">        <span class="comment">// Save the state vector:</span></span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectOutputStream out =</span><br><span class="line">                        <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;CADState.dat&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            out.writeObject(shapeTypes);</span><br><span class="line">            Line.serializeStaticState(out);</span><br><span class="line">            out.writeObject(shapes);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Display the shapes:</span></span><br><span class="line">        System.out.println(shapes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="class"><span class="keyword">class</span> <span class="title">Circlecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[58] <span class="title">yPos</span>[55] <span class="title">dim</span>[93]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Squarecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[61] <span class="title">yPos</span>[61] <span class="title">dim</span>[29]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Linecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[68] <span class="title">yPos</span>[0] <span class="title">dim</span>[22]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Circlecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[7] <span class="title">yPos</span>[88] <span class="title">dim</span>[28]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Squarecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[51] <span class="title">yPos</span>[89] <span class="title">dim</span>[9]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Linecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[78] <span class="title">yPos</span>[98] <span class="title">dim</span>[61]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Circlecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[20] <span class="title">yPos</span>[58] <span class="title">dim</span>[16]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Squarecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[40] <span class="title">yPos</span>[11] <span class="title">dim</span>[22]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Linecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[4] <span class="title">yPos</span>[83] <span class="title">dim</span>[6]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Circlecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[75] <span class="title">yPos</span>[10] <span class="title">dim</span>[42]</span></span><br><span class="line"><span class="class">]</span></span><br></pre></td></tr></table></figure><p>Shape 类实现了 Serializable，所以任何自 Shape 继承的类也都会自动是 Serializable 的。每个 Shape 都含有数据，而且每个派生自 Shape 的类都包含一个 static 字段，用来确定各种 Shape 类型的颜色（如果将 static 字段置入基类，只会产生一个 static 字段，因为 static 字段不能在派生类中复制）。可对基类中的方法进行重载，以便为不同的类型设置颜色（static 方法不会动态绑定，所以这些都是普通的方法）。每次调用 randomFactory() 方法时，它都会使用不同的随机数作为 Shape 的数据，从而创建不同的 Shape。</p><p>在 main() 中，一个 ArrayList 用于保存 Class 对象，而另一个用于保存几何形状。</p><p>恢复对象相当直观：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/RecoverCADState.java</span></span><br><span class="line"><span class="comment">// Restoring the state of the fictitious CAD system</span></span><br><span class="line"><span class="comment">// &#123;RunFirst: AStoreCADState&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecoverCADState</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                ObjectInputStream in =</span><br><span class="line">                        <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(<span class="string">&quot;CADState.dat&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line"><span class="comment">// Read in the same order they were written:</span></span><br><span class="line">            List&lt;Class&lt;? extends Shape&gt;&gt; shapeTypes =</span><br><span class="line">                    (List&lt;Class&lt;? extends Shape&gt;&gt;)in.readObject();</span><br><span class="line">            Line.deserializeStaticState(in);</span><br><span class="line">            List&lt;Shape&gt; shapes =</span><br><span class="line">                    (List&lt;Shape&gt;)in.readObject();</span><br><span class="line">            System.out.println(shapes);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="class"><span class="keyword">class</span> <span class="title">Circlecolor</span>[<span class="title">RED</span>] <span class="title">xPos</span>[58] <span class="title">yPos</span>[55] <span class="title">dim</span>[93]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Squarecolor</span>[<span class="title">RED</span>] <span class="title">xPos</span>[61] <span class="title">yPos</span>[61] <span class="title">dim</span>[29]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Linecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[68] <span class="title">yPos</span>[0] <span class="title">dim</span>[22]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Circlecolor</span>[<span class="title">RED</span>] <span class="title">xPos</span>[7] <span class="title">yPos</span>[88] <span class="title">dim</span>[28]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Squarecolor</span>[<span class="title">RED</span>] <span class="title">xPos</span>[51] <span class="title">yPos</span>[89] <span class="title">dim</span>[9]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Linecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[78] <span class="title">yPos</span>[98] <span class="title">dim</span>[61]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Circlecolor</span>[<span class="title">RED</span>] <span class="title">xPos</span>[20] <span class="title">yPos</span>[58] <span class="title">dim</span>[16]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Squarecolor</span>[<span class="title">RED</span>] <span class="title">xPos</span>[40] <span class="title">yPos</span>[11] <span class="title">dim</span>[22]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Linecolor</span>[<span class="title">GREEN</span>] <span class="title">xPos</span>[4] <span class="title">yPos</span>[83] <span class="title">dim</span>[6]</span></span><br><span class="line"><span class="class">, <span class="title">class</span> <span class="title">Circlecolor</span>[<span class="title">RED</span>] <span class="title">xPos</span>[75] <span class="title">yPos</span>[10] <span class="title">dim</span>[42]</span></span><br><span class="line"><span class="class">]</span></span><br></pre></td></tr></table></figure><p>可以看到，xPos，yPos 以及 dim 的值都被成功地保存和恢复了，但是对 static 信息的读取却出现了问题。所有读回的颜色应该都是“3”，但是真实情况却并非如此。Circle 的值为 1（定义为 RED），而 Square 的值为 0（记住，它们是在构造器中被初始化的）。看上去似乎 static 数据根本没有被序列化！确实如此——尽管 Class 类是 Serializable 的，但它却不能按我们所期望的方式运行。所以假如想序列化 static 值，必须自己动手去实现。</p><p>这正是 Line 中的 serializeStaticState() 和 deserializeStaticState() 两个 static 方法的用途。可以看到，它们是作为存储和读取过程的一部分被显式地调用的。（注意必须维护写入序列化文件和从该文件中读回的顺序。）因此，为了使 CADStatejava 正确运转起来，你必须：</p><ol><li>为几何形状添加 serializeStaticState() 和 deserializeStaticState()</li><li>移除 ArrayList shapeTypes 以及与之有关的所有代码。</li><li>在几何形状内添加对新的序列化和反序列化还原静态方法的调用。</li></ol><p>另一个要注意的问题是安全，因为序列化也会将 private 数据保存下来。如果你关心安全问题，那么应将其标记成 transient，但是这之后，还必须设计一种安全的保存信息的方法，以便在执行恢复时可以复位那些 private 变量。</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>对象序列化的一个重要限制是它只是 Java 的解决方案：只有 Java 程序才能反序列化这种对象。一种更具互操作性的解决方案是将数据转换为 XML 格式，这可以使其被各种各样的平台和语言使用。</p><p>因为 XML 十分流行，所以用它来编程时的各种选择不胜枚举，包括随 JDK 发布的 javax.xml.*类库。我选择使用 Elliotte Rusty Harold 的开源 XOM 类库（可从 www.xom.nu 下载并获得文档），因为它看起来最简单，同时也是最直观的用 Java 产生和修改 XML 的方式。另外，XOM 还强调了 XML 的正确性。</p><p>作为一个示例，假设有一个 APerson 对象，它包含姓和名，你想将它们序列化到 XML 中。下面的 APerson 类有一个 getXML() 方法，它使用 XOM 来产生被转换为 XML 的 Element 对象的 APerson 数据；还有一个构造器，接受 Element 并从中抽取恰当的 APerson 数据（注意，XML 示例都在它们自己的子目录中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/APerson.java</span></span><br><span class="line"><span class="comment">// Use the XOM library to write and read XML</span></span><br><span class="line"><span class="comment">// nu.xom.Node comes from http://www.xom.nu</span></span><br><span class="line"><span class="keyword">import</span> nu.xom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first, last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APerson</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Produce an XML Element from this APerson object:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Element <span class="title">getXML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Element person = <span class="keyword">new</span> Element(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        Element firstName = <span class="keyword">new</span> Element(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        firstName.appendChild(first);</span><br><span class="line">        Element lastName = <span class="keyword">new</span> Element(<span class="string">&quot;last&quot;</span>);</span><br><span class="line">        lastName.appendChild(last);</span><br><span class="line">        person.appendChild(firstName);</span><br><span class="line">        person.appendChild(lastName);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Constructor restores a APerson from XML:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APerson</span><span class="params">(Element person)</span> </span>&#123;</span><br><span class="line">        first = person</span><br><span class="line">                .getFirstChildElement(<span class="string">&quot;first&quot;</span>).getValue();</span><br><span class="line">        last = person</span><br><span class="line">                .getFirstChildElement(<span class="string">&quot;last&quot;</span>).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first + <span class="string">&quot; &quot;</span> + last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make it human-readable:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">    <span class="title">format</span><span class="params">(OutputStream os, Document doc)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Serializer serializer =</span><br><span class="line">                <span class="keyword">new</span> Serializer(os,<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">        serializer.setIndent(<span class="number">4</span>);</span><br><span class="line">        serializer.setMaxLength(<span class="number">60</span>);</span><br><span class="line">        serializer.write(doc);</span><br><span class="line">        serializer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;APerson&gt; people = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> APerson(<span class="string">&quot;Dr. Bunsen&quot;</span>, <span class="string">&quot;Honeydew&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> APerson(<span class="string">&quot;Gonzo&quot;</span>, <span class="string">&quot;The Great&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> APerson(<span class="string">&quot;Phillip J.&quot;</span>, <span class="string">&quot;Fry&quot;</span>));</span><br><span class="line">        System.out.println(people);</span><br><span class="line">        Element root = <span class="keyword">new</span> Element(<span class="string">&quot;people&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(APerson p : people)</span><br><span class="line">            root.appendChild(p.getXML());</span><br><span class="line">        Document doc = <span class="keyword">new</span> Document(root);</span><br><span class="line">        format(System.out, doc);</span><br><span class="line">        format(<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;People.xml&quot;</span>)), doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Dr. Bunsen Honeydew, Gonzo The Great, Phillip J. Fry]</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">first</span>&gt;</span>Dr. Bunsen<span class="tag">&lt;/<span class="name">first</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">last</span>&gt;</span>Honeydew<span class="tag">&lt;/<span class="name">last</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">first</span>&gt;</span>Gonzo<span class="tag">&lt;/<span class="name">first</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">last</span>&gt;</span>The Great<span class="tag">&lt;/<span class="name">last</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">first</span>&gt;</span>Phillip J.<span class="tag">&lt;/<span class="name">first</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">last</span>&gt;</span>Fry<span class="tag">&lt;/<span class="name">last</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XOM 的方法都具有相当的自解释性，可以在 XOM 文档中找到它们。XOM 还包含一个 Serializer 类，你可以在 format() 方法中看到它被用来将 XML 转换为更具可读性的格式。如果只调用 toXML()，那么所有东西都会混在一起，因此 Serializer 是一种便利工具。</p><p>从 XML 文件中反序列化 Person 对象也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialization/People.java</span></span><br><span class="line"><span class="comment">// nu.xom.Node comes from http://www.xom.nu</span></span><br><span class="line"><span class="comment">// &#123;RunFirst: APerson&#125;</span></span><br><span class="line"><span class="keyword">import</span> nu.xom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">APerson</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Document doc =</span><br><span class="line">                <span class="keyword">new</span> Builder().build(<span class="keyword">new</span> File(fileName));</span><br><span class="line">        Elements elements =</span><br><span class="line">                doc.getRootElement().getChildElements();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.size(); i++)</span><br><span class="line">            add(<span class="keyword">new</span> APerson(elements.get(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        People p = <span class="keyword">new</span> People(<span class="string">&quot;People.xml&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Dr. Bunsen Honeydew, Gonzo The Great, Phillip J. Fry]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>People 构造器使用 XOM 的 Builder.build() 方法打开并读取一个文件，而 getChildElements() 方法产生了一个 Elements 列表（不是标准的 Java List，只是一个拥有 size() 和 get() 方法的对象，因为 Harold 不想强制人们使用特定版本的 Java，但是仍旧希望使用类型安全的容器）。在这个列表中的每个 Element 都表示一个 Person 对象，因此它可以传递给第二个 Person 构造器。注意，这要求你提前知道 XML 文件的确切结构，但是这经常会有些问题。如果文件结构与你预期的结构不匹配，那么 XOM 将抛出异常。对你来说，如果你缺乏有关将来的 XML 结构的信息，那么就有可能会编写更复杂的代码去探测 XML 文档，而不是只对其做出假设。</p><p>为了获取这些示例去编译它们，你必须将 XOM 发布包中的 JAR 文件放置到你的类路径中。</p><p>这里只给出了用 Java 和 XOM 类库进行 XML 编程的简介，更详细的信息可以浏览 www.xom.nu 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-对象序列化&quot;&gt;&lt;a href=&quot;#附录-对象序列化&quot; class=&quot;headerlink&quot; title=&quot;附录:对象序列化&quot;&gt;&lt;/a&gt;附录:对象序列化&lt;/h1&gt;&lt;p&gt;当你创建对象时，只要你需要，它就会一直存在，但是在程序终止时，无论如何它都不会继续存在。尽管</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-new-io/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-new-io/</id>
    <published>2022-06-23T15:31:23.685Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-新-IO"><a href="#附录-新-IO" class="headerlink" title="附录:新 IO"></a>附录:新 IO</h1><blockquote><p>Java 新 I/O 库是在 1.4 版本引入到 <code>Java .nio.* package</code> 中的，旨在更快速。</p></blockquote><p>实际上，新 I/O 使用 <strong>NIO</strong>（同步非阻塞）的方式重写了老的 I/O 了，因此它获得了 <strong>NIO</strong> 的种种优点。即使我们不显式地使用 <strong>NIO</strong> 方式来编写代码，也能带来性能和速度的提高。这种提升不仅仅体现在文件读写（File I/O），同时也体现在网络读写（Network I/O）中。例如，网络编程。</p><p>速度的提升来自于使用了更接近操作系统 I/O 执行方式的结构：<strong>Channel</strong>（通道） 和 <strong>Buffer</strong>（缓冲区）。我们可以想象一个煤矿：通道就是连接矿层（数据）的矿井，缓冲区是运送煤矿的小车。通过小车装煤，再从车里取矿。换句话说，我们不能直接和 <strong>Channel</strong> 交互; 我们需要与 <strong>Buffer</strong> 交互并将 <strong>Buffer</strong> 中的数据发送到 <strong>Channel</strong> 中；<strong>Channel</strong> 需要从 <strong>Buffer</strong> 中提取或放入数据。</p><p>本篇我们将深入探讨 <code>nio</code> 包。虽然 像 I/O 流这样的高级库使用了 <strong>NIO</strong>，但多数时候，我们考虑这个层次的问题。使用 Java 7 和 8 版本，理想情况下我们甚至不必费心去处理 I/O 流。当然，一些特殊情况除外。在<a href="./17-Files.md">文件</a>（<strong>File</strong>）一章中基本涵盖了我们日常使用的相关内容。只有在遇到性能瓶颈（例如内存映射文件）或创建自己的 I/O 库时，我们才需要去理解 <strong>NIO</strong>。</p><h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><p>有且仅有 <strong>ByteBuffer</strong>（字节缓冲区，保存原始字节的缓冲区）这一类型可直接与通道交互。查看 <code>java.nio.</code><strong>ByteBuffer</strong> 的 JDK 文档，你会发现它是相当基础的：通过初始化某个大小的存储空间，再使用一些方法以原始字节形式或原始数据类型来放置和获取数据。但是我们无法直接存放对象，即使是最基本的 <strong>String</strong> 类型数据。这是一个相当底层的操作，也正因如此，使得它与大多数操作系统的映射更加高效。</p><p>旧式 I/O 中的三个类分别被更新成 <strong>FileChannel</strong>（文件通道），分别是：<strong>FileInputStream</strong>、<strong>FileOutputStream</strong>，以及用于读写的 <strong>RandomAccessFile</strong> 类。</p><p>注意，这些都是符合底层 <strong>NIO</strong> 特性的字节操作流。 另外，还有 <strong>Reader</strong> 和 <strong>Writer</strong> 字符模式的类是不产生通道的。但 <code>java.nio.channels.</code><strong>Channels</strong> 类具有从通道中生成 <strong>Reader</strong> 和 <strong>Writer</strong> 的实用方法。</p><p>下面来练习上述三种类型的流生成可读、可写、可读/写的通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们不保证这段代码用于其他用途时是否有效</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多信息</span></span><br><span class="line"><span class="comment">// 从流中获取通道</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;data.txt&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写入一个文件:</span></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> FileOutputStream(name)</span><br><span class="line">        .getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      fc.write(ByteBuffer</span><br><span class="line">        .wrap(<span class="string">&quot;Some text &quot;</span>.getBytes()));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在文件尾添加：</span></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> RandomAccessFile(</span><br><span class="line">        name, <span class="string">&quot;rw&quot;</span>).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      fc.position(fc.size()); <span class="comment">// 移动到结尾</span></span><br><span class="line">      fc.write(ByteBuffer</span><br><span class="line">        .wrap(<span class="string">&quot;Some more&quot;</span>.getBytes()));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件e:</span></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> FileInputStream(name)</span><br><span class="line">        .getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line">      fc.read(buff);</span><br><span class="line">      buff.flip();</span><br><span class="line">      <span class="keyword">while</span>(buff.hasRemaining())</span><br><span class="line">        System.out.write(buff.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some text Some more</span><br></pre></td></tr></table></figure><p>我们这里所讲的任何流类，都可以通过调用 <code>getChannel( )</code> 方法生成一个 <strong>FileChannel</strong>（文件通道）。<strong>FileChannel</strong> 的操作相当基础：操作 <strong>ByteBuffer</strong> 来用于读写，并独占式访问和锁定文件区域(稍后将对此进行描述)。</p><p>将字节放入 <strong>ByteBuffer</strong> 的一种方法是直接调用 <code>put()</code> 方法将一个或多个字节放入 <strong>ByteBuffer</strong>；当然也可以是其它基本类型的数据。此外，参考上例，我们还可以调用 <code>wrap()</code> 方法包装现有字节数组到 <strong>ByteBuffer</strong>。执行此操作时，不会复制底层数组，而是将其用作生成的 <strong>ByteBuffer</strong> 存储。这样产生的 <strong>ByteBuffer</strong> 是数组“支持”的。</p><p>data.txt 文件被 <strong>RandomAccessFile</strong> 重新打开。<strong>注意</strong>，你可以在文件中移动 <strong>FileChanne</strong>。 在这里，它被移动到末尾，以便添加额外的写操作。</p><p>对于只读访问，必须使用静态 <code>allocate()</code> 方法显式地分配 <strong>ByteBuffer</strong>。<strong>NIO</strong> 的目标是快速移动大量数据，因此 <strong>ByteBuffer</strong> 的大小应该很重要 —— 实际上，这里设置的 1K 都可能偏小了(我们在工作中应该反复测试以找到最佳大小)。</p><p>通过使用 <code>allocateDirect()</code> 而不是 <code>allocate()</code> 来生成与操作系统具备更高耦合度的“直接”缓冲区，也有可能获得更高的速度。然而，这种分配的开销更大，而且实际效果因操作系统的不同而有所不同，因此，在工作中你必须再次测试程序，以检验直接缓冲区是否能为你带来速度上的优势。</p><p>一旦调用 <strong>FileChannel</strong> 类的 <code>read()</code> 方法将字节数据存储到 <strong>ByteBuffer</strong> 中，你还必须调用缓冲区上的 <code>flip()</code> 方法来准备好提取字节（这听起来有点粗糙，实际上这已是非常低层的操作，且为了达到最高速度）。如果要进一步调用 <code>read()</code> 来使用 <strong>ByteBuffer</strong> ，还需要每次 <code>clear()</code> 来准备缓冲区。下面是个简单的代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/ChannelCopy.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 channels and buffers 移动文件</span></span><br><span class="line"><span class="comment">// &#123;java ChannelCopy ChannelCopy.java test.txt&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(args.length != <span class="number">2</span>) &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">        <span class="string">&quot;arguments: sourcefile destfile&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel in = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">        args[<span class="number">0</span>]).getChannel();</span><br><span class="line">      FileChannel out = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">        args[<span class="number">1</span>]).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">      <span class="keyword">while</span>(in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip(); <span class="comment">// 准备写入</span></span><br><span class="line">        out.write(buffer);</span><br><span class="line">        buffer.clear();  <span class="comment">// 准备读取</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>FileChannel</strong> 用于读取；<strong>FileChannel</strong> 用于写入。当 <strong>ByteBuffer</strong> 分配好存储，调用 <strong>FileChannel</strong> 的 <code>read()</code> 方法返回 <strong>-1</strong>（毫无疑问，这是来源于 Unix 和 C 语言）时，说明输入流读取完了。在每次 <code>read()</code> 将数据放入缓冲区之后，<code>flip()</code> 都会准备好缓冲区，以便 <code>write()</code> 提取它的信息。在 <code>write()</code> 之后，数据仍然在缓冲区中，我们需要 <code>clear()</code> 来重置所有内部指针，以便在下一次 <code>read()</code> 中接受数据。</p><p>但是，上例并不是处理这种操作的理想方法。方法 <code>transferTo()</code> 和 <code>transferFrom()</code> 允许你直接连接此通道到彼通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/TransferTo.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 transferTo() 在通道间传输</span></span><br><span class="line"><span class="comment">// &#123;java TransferTo TransferTo.java TransferTo.txt&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(args.length != <span class="number">2</span>) &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">        <span class="string">&quot;arguments: sourcefile destfile&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel in = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">        args[<span class="number">0</span>]).getChannel();</span><br><span class="line">      FileChannel out = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">        args[<span class="number">1</span>]).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      in.transferTo(<span class="number">0</span>, in.size(), out);</span><br><span class="line">      <span class="comment">// Or:</span></span><br><span class="line">      <span class="comment">// out.transferFrom(in, 0, in.size());</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能不会经常用到，但知道这一点很好。</p><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>为了将 <strong>GetChannel.java</strong> 文件中的信息打印出来。在 Java 中，我们每次提取一个字节的数据并将其转换为字符。看起来很简单 —— 如果你有看过 <code>ava.nio.</code><strong>CharBuffer</strong> 类，你会发现一个 <code>toString()</code> 方法。该方法的作用是“返回一个包含此缓冲区字符的字符串”。</p><p>既然 <strong>ByteBuffer</strong> 可以通过 <strong>CharBuffer</strong> 类的 <code>asCharBuffer()</code> 方法查看，那我们就来尝试一样。从下面输出语句的第一行可以看出，这并不正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/BufferToText.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="comment">// text 和 ByteBuffers 互转</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferToText</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">        <span class="string">&quot;data2.txt&quot;</span>).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      fc.write(ByteBuffer.wrap(<span class="string">&quot;Some text&quot;</span>.getBytes()));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">        <span class="string">&quot;data2.txt&quot;</span>).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      fc.read(buff);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buff.flip();</span><br><span class="line">    <span class="comment">// 无法运行</span></span><br><span class="line">    System.out.println(buff.asCharBuffer());</span><br><span class="line">    <span class="comment">// 使用默认系统默认编码解码</span></span><br><span class="line">    buff.rewind();</span><br><span class="line">    String encoding =</span><br><span class="line">      System.getProperty(<span class="string">&quot;file.encoding&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Decoded using &quot;</span> +</span><br><span class="line">      encoding + <span class="string">&quot;: &quot;</span></span><br><span class="line">      + Charset.forName(encoding).decode(buff));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码和打印</span></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">        <span class="string">&quot;data2.txt&quot;</span>).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      fc.write(ByteBuffer.wrap(</span><br><span class="line">        <span class="string">&quot;Some text&quot;</span>.getBytes(<span class="string">&quot;UTF-16BE&quot;</span>)));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试再次读取：</span></span><br><span class="line">    buff.clear();</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">        <span class="string">&quot;data2.txt&quot;</span>).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      fc.read(buff);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buff.flip();</span><br><span class="line">    System.out.println(buff.asCharBuffer());</span><br><span class="line">    <span class="comment">// 通过 CharBuffer 写入：</span></span><br><span class="line">    buff = ByteBuffer.allocate(<span class="number">24</span>);</span><br><span class="line">    buff.asCharBuffer().put(<span class="string">&quot;Some text&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">        <span class="string">&quot;data2.txt&quot;</span>).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      fc.write(buff);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取和显示：</span></span><br><span class="line">    buff.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileChannel fc = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">        <span class="string">&quot;data2.txt&quot;</span>).getChannel()</span><br><span class="line">    ) &#123;</span><br><span class="line">      fc.read(buff);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buff.flip();</span><br><span class="line">    System.out.println(buff.asCharBuffer());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">????</span><br><span class="line">Decoded using windows-1252: Some text</span><br><span class="line">Some text</span><br><span class="line">Some textNULNULNUL</span><br></pre></td></tr></table></figure><p>缓冲区包含普通字节，为了将这些字节转换为字符，我们必须在输入时对它们进行编码(这样它们输出时就有意义了)，或者在输出时对它们进行解码。我们可以使用 <code>java.nio.charset.</code><strong>Charset</strong> 字符集工具类来完成。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/AvailableCharSets.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="comment">// 展示 Charsets 和 aliases</span></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableCharSets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SortedMap&lt;String,Charset&gt; charSets =</span><br><span class="line">      Charset.availableCharsets();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String csName : charSets.keySet()) &#123;</span><br><span class="line">      System.out.print(csName);</span><br><span class="line">      Iterator aliases = charSets.get(csName)</span><br><span class="line">        .aliases().iterator();</span><br><span class="line">      <span class="keyword">if</span>(aliases.hasNext())</span><br><span class="line">        System.out.print(<span class="string">&quot;: &quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(aliases.hasNext()) &#123;</span><br><span class="line">        System.out.print(aliases.next());</span><br><span class="line">        <span class="keyword">if</span>(aliases.hasNext())</span><br><span class="line">          System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Big5: csBig5</span><br><span class="line">Big5-HKSCS: big5-hkscs, big5hk, Big5_HKSCS, big5hkscs</span><br><span class="line">CESU-8: CESU8, csCESU-8</span><br><span class="line">EUC-JP: csEUCPkdFmtjapanese, x-euc-jp, eucjis,</span><br><span class="line">Extended_UNIX_Code_Packed_Format_for_Japanese, euc_jp,</span><br><span class="line">eucjp, x-eucjp</span><br><span class="line">EUC-KR: ksc5601-1987, csEUCKR, ksc5601_1987, ksc5601,</span><br><span class="line">5601,</span><br><span class="line">euc_kr, ksc_5601, ks_c_5601-1987, euckr</span><br><span class="line">GB18030: gb18030-2000</span><br><span class="line">GB2312: gb2312, euc-cn, x-EUC-CN, euccn, EUC_CN,</span><br><span class="line">gb2312-80,</span><br><span class="line">gb2312-1980</span><br><span class="line">                  ...</span><br></pre></td></tr></table></figure><p>回到 <strong>BufferToText.java</strong> 中，如果你 <code>rewind()</code> 缓冲区（回到数据的开头），使用该平台的默认字符集 <code>decode()</code> 数据，那么生成的 <strong>CharBuffer</strong> 数据将在控制台上正常显示。可以通过 <code>System.getProperty(“file.encoding”)</code> 方法来查看平台默认字符集名称。传递该名称参数到 <code>Charset.forName()</code> 方法可以生成对应的 <code>Charset</code> 对象用于解码字符串。</p><p>另一种方法是使用字符集 <code>encode()</code> 方法，该字符集在读取文件时生成可打印的内容，如你在 <strong>BufferToText.java</strong> 的第三部分中所看到的。上例中，<strong>UTF-16BE</strong> 被用于将文本写入文件，当文本被读取时，你所要做的就是将其转换为 <strong>CharBuffer</strong>，并生成预期的文本。</p><p>最后，如果将 <strong>CharBuffer</strong> 写入 <strong>ByteBuffer</strong>，你会看到发生了什么(更多详情，稍后了解)。<strong>注意</strong>，为 <strong>ByteBuffer</strong> 分配了 24 个字节，按照每个字符占用 2 个自字节， 12 个字符的空间已经足够了。由于“some text”只有 9 个字符，受其 <code>toString()</code> 方法影响，剩下的 0 字节部分也出现在了 <strong>CharBuffer</strong> 的展示中，如输出所示。</p><h2 id="基本类型获取"><a href="#基本类型获取" class="headerlink" title="基本类型获取"></a>基本类型获取</h2><p>虽然 <strong>ByteBuffer</strong> 只包含字节，但它包含了一些方法，用于从其所包含的字节中生成各种不同的基本类型数据。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/GetData.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="comment">// 从 ByteBuffer 中获取不同的数据展示</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">    <span class="comment">// 自动分配 0 到 ByteBuffer:</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; bb.limit())</span><br><span class="line">      <span class="keyword">if</span>(bb.get() != <span class="number">0</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;nonzero&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    bb.rewind();</span><br><span class="line">    <span class="comment">// 保存和读取 char 数组:</span></span><br><span class="line">    bb.asCharBuffer().put(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = bb.getChar()) != <span class="number">0</span>)</span><br><span class="line">      System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    bb.rewind();</span><br><span class="line">    <span class="comment">// 保存和读取 short:</span></span><br><span class="line">    bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">471142</span>);</span><br><span class="line">    System.out.println(bb.getShort());</span><br><span class="line">    bb.rewind();</span><br><span class="line">    <span class="comment">// 保存和读取 int:</span></span><br><span class="line">    bb.asIntBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">    System.out.println(bb.getInt());</span><br><span class="line">    bb.rewind();</span><br><span class="line">    <span class="comment">// 保存和读取 long:</span></span><br><span class="line">    bb.asLongBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">    System.out.println(bb.getLong());</span><br><span class="line">    bb.rewind();</span><br><span class="line">    <span class="comment">// 保存和读取 float:</span></span><br><span class="line">    bb.asFloatBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">    System.out.println(bb.getFloat());</span><br><span class="line">    bb.rewind();</span><br><span class="line">    <span class="comment">// 保存和读取 double:</span></span><br><span class="line">    bb.asDoubleBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">    System.out.println(bb.getDouble());</span><br><span class="line">    bb.rewind();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 1025</span><br><span class="line">H o w d y !</span><br><span class="line">12390</span><br><span class="line">99471142</span><br><span class="line">99471142</span><br><span class="line">9.9471144E7</span><br><span class="line">9.9471142E7</span><br></pre></td></tr></table></figure><p>在分配 <strong>ByteBuffer</strong> 之后，我们检查并确认它的 1,024 元素被初始化为 0。（截至到达 <code>limit()</code> 结果的位置）。</p><p>将基本类型数据插入 <strong>ByteBuffer</strong> 的最简单方法就是使用 <code>asCharBuffer()</code>、<code>asShortBuffer()</code> 等方法获取该缓冲区适当的“视图”（View），然后调用该“视图”的 <code>put()</code> 方法。</p><p>这是针对每种基本数据类型执行的。其中唯一有点奇怪的是 <strong>ShortBuffer</strong> 的 <code>put()</code>，它需要类型强制转换。其他视图缓冲区不需要在其 <code>put()</code> 方法中进行转换。</p><h2 id="视图缓冲区"><a href="#视图缓冲区" class="headerlink" title="视图缓冲区"></a>视图缓冲区</h2><p>“视图缓冲区”（view buffer）是通过特定的基本类型的窗口来查看底层 <strong>ByteBuffer</strong>。<strong>ByteBuffer</strong> 仍然是“支持”视图的实际存储，因此对视图所做的任何更改都反映在对 <strong>ByteBuffer</strong> 中的数据的修改中。</p><p>如前面的示例所示，这方便地将基本类型插入 <strong>ByteBuffer</strong>。视图缓冲区还可以从 <strong>ByteBuffer</strong> 读取基本类型数据，每次单个（<strong>ByteBuffer</strong> 规定），或者批量读取到数组。下面是一个通过 <strong>IntBuffer</strong> 在 <strong>ByteBuffer</strong> 中操作 <strong>int</strong> 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/IntBufferDemo.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="comment">// 利用 IntBuffer 保存 int 数据到 ByteBuffer</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">    IntBuffer ib = bb.asIntBuffer();</span><br><span class="line">    <span class="comment">// 保存 int 数组：</span></span><br><span class="line">    ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">11</span>, <span class="number">42</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">143</span>, <span class="number">811</span>, <span class="number">1016</span> &#125;);</span><br><span class="line">    <span class="comment">//绝对位置读写：</span></span><br><span class="line">    System.out.println(ib.get(<span class="number">3</span>));</span><br><span class="line">    ib.put(<span class="number">3</span>, <span class="number">1811</span>);</span><br><span class="line">    <span class="comment">// 在重置缓冲区前设置新的限制</span></span><br><span class="line"></span><br><span class="line">    ib.flip();</span><br><span class="line">    <span class="keyword">while</span>(ib.hasRemaining()) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = ib.get();</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">99</span><br><span class="line">11</span><br><span class="line">42</span><br><span class="line">47</span><br><span class="line">1811</span><br><span class="line">143</span><br><span class="line">811</span><br><span class="line">1016</span><br></pre></td></tr></table></figure><p><code>put()</code> 方法重载，首先用于存储 <strong>int</strong> 数组。下面的 <code>get()</code> 和 <code>put()</code> 方法调用直接访问底层 <strong>ByteBuffer</strong> 中的 <strong>int</strong> 位置。<strong>注意</strong>，通过直接操作 <strong>ByteBuffer</strong> ，这些绝对位置访问也可以用于基本类型。</p><p>一旦底层 <strong>ByteBuffer</strong> 通过视图缓冲区填充了 <strong>int</strong> 或其他基本类型，那么就可以直接将该 <strong>ByteBuffer</strong> 写入通道。你可以轻松地从通道读取数据，并使用视图缓冲区将所有内容转换为特定的基本类型。下面是一个例子，通过在同一个 <strong>ByteBuffer</strong> 上生成不同的视图缓冲区，将相同的字节序列解释为 <strong>short</strong>、<strong>int</strong>、<strong>float</strong>、<strong>long</strong> 和 <strong>double</strong>。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/ViewBuffers.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBuffers</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.wrap(</span><br><span class="line">      <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> &#125;);</span><br><span class="line">    bb.rewind();</span><br><span class="line">    System.out.print(<span class="string">&quot;Byte Buffer &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(bb.hasRemaining())</span><br><span class="line">      System.out.print(</span><br><span class="line">        bb.position()+ <span class="string">&quot; -&gt; &quot;</span> + bb.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    CharBuffer cb =</span><br><span class="line">      ((ByteBuffer)bb.rewind()).asCharBuffer();</span><br><span class="line">    System.out.print(<span class="string">&quot;Char Buffer &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(cb.hasRemaining())</span><br><span class="line">      System.out.print(</span><br><span class="line">        cb.position() + <span class="string">&quot; -&gt; &quot;</span> + cb.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    FloatBuffer fb =</span><br><span class="line">      ((ByteBuffer)bb.rewind()).asFloatBuffer();</span><br><span class="line">    System.out.print(<span class="string">&quot;Float Buffer &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(fb.hasRemaining())</span><br><span class="line">      System.out.print(</span><br><span class="line">        fb.position()+ <span class="string">&quot; -&gt; &quot;</span> + fb.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    IntBuffer ib =</span><br><span class="line">      ((ByteBuffer)bb.rewind()).asIntBuffer();</span><br><span class="line">    System.out.print(<span class="string">&quot;Int Buffer &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(ib.hasRemaining())</span><br><span class="line">      System.out.print(</span><br><span class="line">        ib.position()+ <span class="string">&quot; -&gt; &quot;</span> + ib.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    LongBuffer lb =</span><br><span class="line">      ((ByteBuffer)bb.rewind()).asLongBuffer();</span><br><span class="line">    System.out.print(<span class="string">&quot;Long Buffer &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(lb.hasRemaining())</span><br><span class="line">      System.out.print(</span><br><span class="line">        lb.position()+ <span class="string">&quot; -&gt; &quot;</span> + lb.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    ShortBuffer sb =</span><br><span class="line">      ((ByteBuffer)bb.rewind()).asShortBuffer();</span><br><span class="line">    System.out.print(<span class="string">&quot;Short Buffer &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(sb.hasRemaining())</span><br><span class="line">      System.out.print(</span><br><span class="line">        sb.position()+ <span class="string">&quot; -&gt; &quot;</span> + sb.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    DoubleBuffer db =</span><br><span class="line">      ((ByteBuffer)bb.rewind()).asDoubleBuffer();</span><br><span class="line">    System.out.print(<span class="string">&quot;Double Buffer &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(db.hasRemaining())</span><br><span class="line">      System.out.print(</span><br><span class="line">        db.position()+ <span class="string">&quot; -&gt; &quot;</span> + db.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Byte Buffer 0 -&gt; 0, 1 -&gt; 0, 2 -&gt; 0, 3 -&gt; 0, 4 -&gt; 0, 5</span><br><span class="line">-&gt; 0, 6 -&gt; 0, 7 -&gt; 97,</span><br><span class="line">Char Buffer 0 -&gt; NUL, 1 -&gt; NUL, 2 -&gt; NUL, 3 -&gt; a,</span><br><span class="line">Float Buffer 0 -&gt; 0.0, 1 -&gt; 1.36E-43,</span><br><span class="line">Int Buffer 0 -&gt; 0, 1 -&gt; 97,</span><br><span class="line">Long Buffer 0 -&gt; 97,</span><br><span class="line">Short Buffer 0 -&gt; 0, 1 -&gt; 0, 2 -&gt; 0, 3 -&gt; 97,</span><br><span class="line">Double Buffer 0 -&gt; 4.8E-322,</span><br></pre></td></tr></table></figure><p><strong>ByteBuffer</strong> 通过“包装”一个 8 字节数组生成，然后通过所有不同基本类型的视图缓冲区显示该数组。下图显示了从不同类型的缓冲区读取数据时，数据显示的差异：</p><p><img src="../images/1554546258113.png" alt="1554546258113"></p><h3 id="字节存储次序"><a href="#字节存储次序" class="headerlink" title="字节存储次序"></a>字节存储次序</h3><p>不同的机器可以使用不同的字节存储顺序（Endians）来存储数据。“高位优先”（Big Endian）：将最重要的字节放在最低内存地址中，而“低位优先”（Little Endian）：将最重要的字节放在最高内存地址中。</p><p>当存储大于单字节的数据时，如 <strong>int</strong>、<strong>float</strong> 等，我们可能需要考虑字节排序问题。<strong>ByteBuffer</strong> 以“高位优先”形式存储数据；通过网络发送的数据总是使用“高位优先”形式。我们可以 使用 <strong>ByteOrder</strong> 的 <code>order()</code> 方法和参数 <strong>ByteOrder.BIG_ENDIAN</strong> 或 <strong>ByteOrder.LITTLE_ENDIAN</strong> 来改变它的字节存储次序。</p><p>下例是一个包含两个字节的 <strong>ByteBuffer</strong> ：</p><p><img src="../images/1554546378822.png" alt="1554546378822"></p><p>将数据作为 <strong>short</strong> 型来读取（<code>ByteBuffer.asshortbuffer()</code>)），生成数字 97 （00000000 01100001）。更改为“低位优先”后 将生成数字 24832 （01100001 00000000）。</p><p>这显示了字节顺序的变化取决于字节存储次序设置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/Endians.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="comment">// 不同字节存储次序的存储</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endians</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">12</span>]);</span><br><span class="line">    bb.asCharBuffer().put(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(bb.array()));</span><br><span class="line">    bb.rewind();</span><br><span class="line">    bb.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">    bb.asCharBuffer().put(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(bb.array()));</span><br><span class="line">    bb.rewind();</span><br><span class="line">    bb.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">    bb.asCharBuffer().put(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(bb.array()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102]</span><br><span class="line">[0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102]</span><br><span class="line">[97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102, 0]</span><br></pre></td></tr></table></figure><p><strong>ByteBuffer</strong> 分配空间将 <strong>charArray</strong> 中的所有字节作为外部缓冲区保存，因此可以调用 <code>array()</code> 方法来显示底层字节。<code>array()</code> 方法是“可选的”，你只能在数组支持的缓冲区上调用它，否则将抛出 <strong>UnsupportedOperationException</strong> 异常。</p><p><strong>charArray</strong> 通过 <strong>CharBuffer</strong> 视图插入到 <strong>ByteBuffer</strong> 中。当显示底层字节时，默认排序与后续“高位”相同，而“地位”交换字节</p><h2 id="缓冲区数据操作"><a href="#缓冲区数据操作" class="headerlink" title="缓冲区数据操作"></a>缓冲区数据操作</h2><p>下图说明了 <strong>nio</strong> 类之间的关系，展示了如何移动和转换数据。例如，要将字节数组写入文件，使用 <strong>ByteBuffer.</strong><code>wrap()</code> 方法包装字节数组，使用 <code>getChannel()</code> 在 <strong>FileOutputStream</strong> 上打开通道，然后从 <strong>ByteBuffer</strong> 将数据写入 <strong>FileChannel</strong>。</p><p><img src="../images/1554546452861.png" alt="1554546452861"></p><p><strong>ByteBuffer</strong> 是将数据移入和移出通道的唯一方法，我们只能创建一个独立的基本类型缓冲区，或者使用 <code>as</code> 方法从 <strong>ByteBuffer</strong> 获得一个新缓冲区。也就是说，不能将基本类型缓冲区转换为 <strong>ByteBuffer</strong>。但我们能够通过视图缓冲区将基本类型数据移动到 <strong>ByteBuffer</strong> 中或移出 <strong>ByteBuffer</strong>。</p><h3 id="缓冲区细节"><a href="#缓冲区细节" class="headerlink" title="缓冲区细节"></a>缓冲区细节</h3><p>缓冲区由数据和四个索引组成，以有效地访问和操作该数据：mark、position、limit 和 capacity（标记、位置、限制和容量）。伴随着的还有一组方法可以设置和重置这些索引，并可查询它们的值。</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><strong>capacity()</strong></td><td style="text-align:left">返回缓冲区的 capacity</td></tr><tr><td style="text-align:left"><strong>clear()</strong></td><td style="text-align:left">清除缓冲区，将 position 设置为零并 设 limit 为 capacity;可调用此方法来覆盖现有缓冲区</td></tr><tr><td style="text-align:left"><strong>flip()</strong></td><td style="text-align:left">将 limit 设置为 position，并将 position 设置为 0;此方法用于准备缓冲区，以便在数据写入缓冲区后进行读取</td></tr><tr><td style="text-align:left"><strong>limit()</strong></td><td style="text-align:left">返回 limit 的值</td></tr><tr><td style="text-align:left"><strong>limit(int limit)</strong></td><td style="text-align:left">重设 limit</td></tr><tr><td style="text-align:left"><strong>mark()</strong></td><td style="text-align:left">设置 mark 为当前的 position</td></tr><tr><td style="text-align:left"><strong>position()</strong></td><td style="text-align:left">返回 position</td></tr><tr><td style="text-align:left"><strong>position(int pos)</strong></td><td style="text-align:left">设置 position</td></tr><tr><td style="text-align:left"><strong>remaining()</strong></td><td style="text-align:left">返回 limit 到 position</td></tr><tr><td style="text-align:left"><strong>hasRemaining()</strong></td><td style="text-align:left">如果在 position 与 limit 中间有元素，返回 <code>true</code></td></tr></tbody></table></div><p>从缓冲区插入和提取数据的方法通过更新索引来反映所做的更改。下例使用一种非常简单的算法（交换相邻字符）来对 <strong>CharBuffer</strong> 中的字符进行加扰和解扰。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/UsingBuffers.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingBuffers</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span></span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">symmetricScramble</span><span class="params">(CharBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">      buffer.mark();</span><br><span class="line">      <span class="keyword">char</span> c1 = buffer.get();</span><br><span class="line">      <span class="keyword">char</span> c2 = buffer.get();</span><br><span class="line">      buffer.reset();</span><br><span class="line">      buffer.put(c2).put(c1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] data = <span class="string">&quot;UsingBuffers&quot;</span>.toCharArray();</span><br><span class="line">    ByteBuffer bb =</span><br><span class="line">      ByteBuffer.allocate(data.length * <span class="number">2</span>);</span><br><span class="line">    CharBuffer cb = bb.asCharBuffer();</span><br><span class="line">    cb.put(data);</span><br><span class="line">    System.out.println(cb.rewind());</span><br><span class="line">    symmetricScramble(cb);</span><br><span class="line">    System.out.println(cb.rewind());</span><br><span class="line">    symmetricScramble(cb);</span><br><span class="line">    System.out.println(cb.rewind());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UsingBuffers</span><br><span class="line">sUniBgfuefsr</span><br><span class="line">UsingBuffers</span><br></pre></td></tr></table></figure><p>虽然可以通过使用 <strong>char</strong> 数组调用 <code>wrap()</code> 直接生成 <strong>CharBuffer</strong>，但是底层的 <strong>ByteBuffer</strong> 将被分配，而 <strong>CharBuffer</strong> 将作为 <strong>ByteBuffer</strong> 上的视图生成。这强调了目标始终是操作 <strong>ByteBuffer</strong>，因为它与通道交互。</p><p>下面是程序在 <code>symmetricgrab()</code> 方法入口时缓冲区的样子:</p><p><img src="../images/1554546627710.png" alt="1554546627710"></p><p>position 指向缓冲区中的第一个元素，capacity 和 limit 紧接在最后一个元素之后。在<code>symmetricgrab()</code> 中，<strong>while</strong> 循环迭代到 position 等于 limit。当在缓冲区上调用相对位置的 <code>get()</code> 或 <code>put()</code> 函数时，缓冲区的位置会发生变化。你可以调用绝对位置的 <code>get()</code> 和 <code>put()</code> 方法，它们包含索引参数：<code>get()</code> 或 <code>put()</code> 发生的位置。这些方法不修改缓冲区 position 的值。</p><p>当控件进入 <strong>while</strong> 循环时，使用 <code>mark()</code> 设置 mark 的值。缓冲区的状态为：</p><p><img src="../images/1554546666685.png" alt="1554546666685"></p><p>两个相对 <code>get()</code> 调用将前两个字符的值保存在变量 <code>c1</code> 和 <code>c2</code> 中。在这两个调用之后，缓冲区看起来是这样的：</p><p><img src="../images/1554546693664.png" alt="1554546693664"></p><p>为了执行交换，我们在位置 0 处编写 <code>c2</code>，在位置 1 处编写 <code>c1</code>。我们可以使用绝对 <code>put()</code> 方法来实现这一点，或者用 <code>reset()</code> 方法，将 position 的值设置为 mark：</p><p><img src="../images/1554546847181.png" alt="1554546847181"></p><p>两个 <code>put()</code> 方法分别编写 <code>c2</code> 和 <code>c1</code> ：</p><p><img src="../images/1554546861836.png" alt="1554546861836"></p><p>在下一次循环中，将 mark 设置为 position 的当前值：</p><p><img src="../images/1554546881189.png" alt="1554546881189"></p><p>该过程将继续，直到遍历整个缓冲区为止。在 <strong>while</strong> 循环的末尾，position 位于缓冲区的末尾。如果显示缓冲区，则只显示位置和限制之间的字符。因此，要显示缓冲区的全部内容，必须使用 <code>rewind()</code> 将 position 设置为缓冲区的开始位置。这是 <code>rewind()</code> 调用后缓冲区的状态（mark 的值变成未定义）：</p><p><img src="../images/1554546890132.png" alt="1554546890132"></p><p>再次调用 <code>symmetricgrab()</code> 方法时，<strong>CharBuffer</strong> 将经历相同的过程并恢复到原始状态。</p><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件能让你创建和修改那些因为太大而无法放入内存的文件。有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问。这种解决办法能大大简化修改文件的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/LargeMappedFiles.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="comment">// 使用内存映射来创建一个大文件</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeMappedFiles</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> length = <span class="number">0x8000000</span>; <span class="comment">// 128 MB</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      RandomAccessFile tdat =</span><br><span class="line">        <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.dat&quot;</span>, <span class="string">&quot;rw&quot;</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      MappedByteBuffer out = tdat.getChannel().map(</span><br><span class="line">        FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, length);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        out.put((<span class="keyword">byte</span>)<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Finished writing&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = length/<span class="number">2</span>; i &lt; length/<span class="number">2</span> + <span class="number">6</span>; i++)</span><br><span class="line">        System.out.print((<span class="keyword">char</span>)out.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Finished writing</span><br><span class="line">xxxxxx</span><br></pre></td></tr></table></figure><p>为了读写，我们从 <strong>RandomAccessFile</strong> 开始，获取该文件的通道，然后调用 <code>map()</code> 来生成 <strong>MappedByteBuffer</strong> ，这是一种特殊的直接缓冲区。你必须指定要在文件中映射的区域的起始点和长度—这意味着你可以选择映射大文件的较小区域。</p><p><strong>MappedByteBuffer</strong> 继承了 <strong>ByteBuffer</strong>，所以拥有<strong>ByteBuffer</strong> 全部的方法。这里只展示了 <code>put()</code> 和 <code>get()</code> 的最简单用法，但是你也可以使用 <code>asCharBuffer()</code> 等方法。</p><p>使用前面的程序创建的文件长度为 128MB，可能比你的操作系统单次所允许的操作的内存要大。该文件似乎可以同时访问，因为它只有一部分被带进内存，而其他部分被交换出去。这样，一个非常大的文件（最多 2GB）可以很容易地修改。<strong>注意</strong>，操作系统底层的文件映射工具用于性能的最大化。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>虽然旧的 I/O 流的性能通过使用 <strong>NIO</strong> 实现得到了改进，但是映射文件访问往往要快得多。下例带来一个简单的性能比较。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/MappedIO.java</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedIO</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numOfInts =      <span class="number">4_000_000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numOfUbuffInts = <span class="number">100_000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Tester(String name) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.print(name + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">      <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">      test();</span><br><span class="line">      <span class="keyword">double</span> duration = System.nanoTime() - start;</span><br><span class="line">      System.out.format(<span class="string">&quot;%.3f%n&quot;</span>, duration/<span class="number">1.0e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Tester[] tests = &#123;</span><br><span class="line">    <span class="keyword">new</span> Tester(<span class="string">&quot;Stream Write&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">          DataOutputStream dos =</span><br><span class="line">            <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">              <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                  <span class="keyword">new</span> File(<span class="string">&quot;temp.tmp&quot;</span>))))</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfInts; i++)</span><br><span class="line">            dos.writeInt(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> Tester(<span class="string">&quot;Mapped Write&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">          FileChannel fc =</span><br><span class="line">            <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;temp.tmp&quot;</span>, <span class="string">&quot;rw&quot;</span>)</span><br><span class="line">              .getChannel()</span><br><span class="line">        ) &#123;</span><br><span class="line">          IntBuffer ib =</span><br><span class="line">            fc.map(FileChannel.MapMode.READ_WRITE,</span><br><span class="line">              <span class="number">0</span>, fc.size()).asIntBuffer();</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfInts; i++)</span><br><span class="line">            ib.put(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> Tester(<span class="string">&quot;Stream Read&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">          DataInputStream dis =</span><br><span class="line">            <span class="keyword">new</span> DataInputStream(</span><br><span class="line">              <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">&quot;temp.tmp&quot;</span>)))</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfInts; i++)</span><br><span class="line">            dis.readInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> Tester(<span class="string">&quot;Mapped Read&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">          FileChannel fc = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">            <span class="keyword">new</span> File(<span class="string">&quot;temp.tmp&quot;</span>)).getChannel()</span><br><span class="line">        ) &#123;</span><br><span class="line">          IntBuffer ib =</span><br><span class="line">            fc.map(FileChannel.MapMode.READ_ONLY,</span><br><span class="line">              <span class="number">0</span>, fc.size()).asIntBuffer();</span><br><span class="line">          <span class="keyword">while</span>(ib.hasRemaining())</span><br><span class="line">            ib.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> Tester(<span class="string">&quot;Stream Read/Write&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">          RandomAccessFile raf =</span><br><span class="line">            <span class="keyword">new</span> RandomAccessFile(</span><br><span class="line">              <span class="keyword">new</span> File(<span class="string">&quot;temp.tmp&quot;</span>), <span class="string">&quot;rw&quot;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">          raf.writeInt(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfUbuffInts; i++) &#123;</span><br><span class="line">            raf.seek(raf.length() - <span class="number">4</span>);</span><br><span class="line">            raf.writeInt(raf.readInt());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> Tester(<span class="string">&quot;Mapped Read/Write&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">          FileChannel fc = <span class="keyword">new</span> RandomAccessFile(</span><br><span class="line">            <span class="keyword">new</span> File(<span class="string">&quot;temp.tmp&quot;</span>), <span class="string">&quot;rw&quot;</span>).getChannel()</span><br><span class="line">        ) &#123;</span><br><span class="line">          IntBuffer ib =</span><br><span class="line">            fc.map(FileChannel.MapMode.READ_WRITE,</span><br><span class="line">              <span class="number">0</span>, fc.size()).asIntBuffer();</span><br><span class="line">          ib.put(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numOfUbuffInts; i++)</span><br><span class="line">            ib.put(ib.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Arrays.stream(tests).forEach(Tester::runTest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream Write: 0.615</span><br><span class="line">Mapped Write: 0.050</span><br><span class="line">Stream Read: 0.577</span><br><span class="line">Mapped Read: 0.015</span><br><span class="line">Stream Read/Write: 4.069</span><br><span class="line">Mapped Read/Write: 0.013</span><br></pre></td></tr></table></figure><p><strong>Tester</strong> 使用了模板方法（Template Method）模式，它为匿名内部子类中定义的 <code>test()</code> 的各种实现创建一个测试框架。每个子类都执行一种测试，因此 <code>test()</code> 方法还提供了执行各种 I/O 活动的原型。</p><p>虽然映射的写似乎使用 <strong>FileOutputStream</strong>，但是文件映射中的所有输出必须使用 <strong>RandomAccessFile</strong>，就像前面代码中的读/写一样。</p><p>请注意，<code>test()</code> 方法包括初始化各种 I/O 对象的时间，因此，尽管映射文件的设置可能很昂贵，但是与流 I/O 相比，总体收益非常可观。</p><h2 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h2><p>文件锁定可同步访问，因此文件可以共享资源。但是，争用同一文件的两个线程可能位于不同的 JVM 中，或者一个可能是 Java 线程，另一个可能是操作系统中的本机线程。文件锁对其他操作系统进程可见，因为 Java 文件锁定直接映射到本机操作系统锁定工具。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/FileLocking.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLocking</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      FileOutputStream fos =</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">      FileLock fl = fos.getChannel().tryLock()</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Locked File&quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        fl.release();</span><br><span class="line">        System.out.println(<span class="string">&quot;Released Lock&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException | InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Locked File</span><br><span class="line">Released Lock</span><br></pre></td></tr></table></figure><p>通过调用 <strong>FileChannel</strong> 上的 <code>tryLock()</code> 或 <code>lock()</code>，可以获得整个文件的 <strong>FileLock</strong>。（<strong>SocketChannel</strong>、<strong>DatagramChannel</strong> 和 <strong>ServerSocketChannel</strong> 不需要锁定，因为它们本质上是单进程实体；通常不会在两个进程之间共享一个网络套接字）。</p><p><code>tryLock()</code> 是非阻塞的。它试图获取锁，若不能获取（当其他进程已经持有相同的锁，并且它不是共享的），它只是从方法调用返回。</p><p><code>lock()</code> 会阻塞，直到获得锁，或者调用 <code>lock()</code> 的线程中断，或者调用 <code>lock()</code> 方法的通道关闭。使用 <strong>FileLock.</strong><code>release()</code> 释放锁。</p><p>还可以使用</p><blockquote><p><code>tryLock(long position, long size, boolean shared)</code></p></blockquote><p>或</p><blockquote><p><code>lock(long position, long size, boolean shared)</code></p></blockquote><p>锁定文件的一部分，锁住 <strong>size-position</strong> 区域。第三个参数指定是否共享此锁。</p><p>虽然零参数锁定方法适应文件大小的变化，但是如果文件大小发生变化，具有固定大小的锁不会发生变化。如果从一个位置到另一个位置获得一个锁，并且文件的增长超过了 position + size ，那么超出 position + size 的部分没有被锁定。零参数锁定方法锁定整个文件，即使它在增长。</p><p>底层操作系统必须提供对独占锁或共享锁的支持。如果操作系统不支持共享锁并且对一个操作系统发出请求，则使用独占锁。可以使用 <strong>FileLock.</strong><code>isShared()</code> 查询锁的类型（共享或独占）。</p><h3 id="映射文件的部分锁定"><a href="#映射文件的部分锁定" class="headerlink" title="映射文件的部分锁定"></a>映射文件的部分锁定</h3><p>文件映射通常用于非常大的文件。你可能需要锁定此类文件的某些部分，以便其他进程可以修改未锁定的部分。例如，数据库必须同时对许多用户可用。这里你可以看到两个线程，每个线程都锁定文件的不同部分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newio/LockingMappedFiles.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// 我们无法保证该代码是否适用于其他用途。</span></span><br><span class="line"><span class="comment">// 访问 http://OnJava8.com 了解更多本书信息。</span></span><br><span class="line"><span class="comment">// Locking portions of a mapped file</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockingMappedFiles</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH = <span class="number">0x8FFFFFF</span>; <span class="comment">// 128 MB</span></span><br><span class="line">  <span class="keyword">static</span> FileChannel fc;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    fc = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.dat&quot;</span>, <span class="string">&quot;rw&quot;</span>)</span><br><span class="line">      .getChannel();</span><br><span class="line">    MappedByteBuffer out = fc.map(</span><br><span class="line">      FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, LENGTH);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)</span><br><span class="line">      out.put((<span class="keyword">byte</span>)<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="keyword">new</span> LockAndModify(out, <span class="number">0</span>, <span class="number">0</span> + LENGTH/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> LockAndModify(</span><br><span class="line">      out, LENGTH/<span class="number">2</span>, LENGTH/<span class="number">2</span> + LENGTH/<span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAndModify</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buff;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start, end;</span><br><span class="line">    LockAndModify(ByteBuffer mbb, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">      <span class="keyword">this</span>.start = start;</span><br><span class="line">      <span class="keyword">this</span>.end = end;</span><br><span class="line">      mbb.limit(end);</span><br><span class="line">      mbb.position(start);</span><br><span class="line">      buff = mbb.slice();</span><br><span class="line">      start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Exclusive lock with no overlap:</span></span><br><span class="line">        FileLock fl = fc.lock(start, end, <span class="keyword">false</span>);</span><br><span class="line">        System.out.println(</span><br><span class="line">          <span class="string">&quot;Locked: &quot;</span>+ start +<span class="string">&quot; to &quot;</span>+ end);</span><br><span class="line">        <span class="comment">// Perform modification:</span></span><br><span class="line">        <span class="keyword">while</span>(buff.position() &lt; buff.limit() - <span class="number">1</span>)</span><br><span class="line">          buff.put((<span class="keyword">byte</span>)(buff.get() + <span class="number">1</span>));</span><br><span class="line">        fl.release();</span><br><span class="line">        System.out.println(</span><br><span class="line">          <span class="string">&quot;Released: &quot;</span> + start + <span class="string">&quot; to &quot;</span> + end);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Locked: 75497471 to 113246206</span><br><span class="line">Locked: 0 to 50331647</span><br><span class="line">Released: 75497471 to 113246206</span><br><span class="line">Released: 0 to 50331647</span><br></pre></td></tr></table></figure><p><strong>LockAndModify</strong> 线程类设置缓冲区并创建要修改的 <code>slice()</code>，在 <code>run()</code> 中，锁在文件通道上获取（不能在缓冲区上获取锁—只能在通道上获取锁）。<code>lock()</code> 的调用非常类似于获取对象上的线程锁 —— 现在有了一个“临界区”，可以对文件的这部分进行独占访问。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><p>当 JVM 退出或关闭获取锁的通道时，锁会自动释放，但是你也可以显式地调用 <strong>FileLock</strong> 对象上的 <code>release()</code>，如上所示。</p><blockquote id="fn_1"><sup>1</sup>. 更多详情可参考<a href="./book/Appendix-Low-Level-Concurrency.md">附录:并发底层原理</a>。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-新-IO&quot;&gt;&lt;a href=&quot;#附录-新-IO&quot; class=&quot;headerlink&quot; title=&quot;附录:新 IO&quot;&gt;&lt;/a&gt;附录:新 IO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java 新 I/O 库是在 1.4 版本引入到 &lt;code&gt;Java .</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-low-level-concurrency/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-low-level-concurrency/</id>
    <published>2022-06-23T15:31:23.684Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-并发底层原理"><a href="#附录-并发底层原理" class="headerlink" title="附录:并发底层原理"></a>附录:并发底层原理</h1><blockquote><p>尽管不建议你自己编写底层 Java 并发代码，但是这样通常有助于了解它是如何工作的。</p></blockquote><p><a href="./24-Concurrent-Programming.md">并发编程</a> 章节中介绍了一些用于高级并发的概念，包括为 Java 并发编程而最新提出的，更安全的概念（ parallel Streams 和 CompletableFutures ）。本附录则介绍在 Java 中底层并发概念，因此在阅读本篇时，你能有所了解掌握这些代码。你还会将进一步了解并发的普遍问题。</p><p>在 Java 的早期版本中, 底层并发概念是并发编程的重要组成部分。我们会着眼于围绕这些技巧的复杂性以及为何你应该避免它们而谈。 “并发编程” 章节展示最新的 Java 版本(尤其是 Java 8)所提供的改进技巧，这些技巧使得并发的使用，如果本来不容易使用，也会变得更容易些。</p><h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><p>并发将程序划分成独立分离运行的任务。每个任务都由一个 <em>执行线程</em> 来驱动，我们通常将其简称为 <em>线程</em> 。而一个 <em>线程</em> 就是操作系统进程中单一顺序的控制流。因此，单个进程可以有多个并发执行的任务，但是你的程序使得每个任务都好像有自己的处理器一样。此线程模型为编程带来了便利，它简化了在单一程序中处理变戏法般的多任务过程。操作系统则从处理器上分配时间片到你程序的所有线程中。</p><p>Java 并发的核心机制是 <strong>Thread</strong> 类，在该语言最初版本中， <strong>Thread （线程）</strong> 是由程序员直接创建和管理的。随着语言的发展以及人们发现了更好的一些方法，中间层机制 - 特别是 <strong>Executor</strong> 框架 - 被添加进来，以消除自己管理线程时候的心理负担（及错误）。 最终，甚至发展出比 <strong>Executor</strong> 更好的机制，如 <a href="./24-Concurrent-Programming.md">并发编程</a> 一章所示。</p><p><strong>Thread（线程）</strong> 是将任务关联到处理器的软件概念。虽然创建和使用 <strong>Thread</strong> 类看起来与任何其他类都很相似，但实际上它们是非常不同的。当你创建一个 <strong>Thread</strong> 时，JVM 将分配一大块内存到专为线程保留的特殊区域上，用于提供运行任务时所需的一切，包括：</p><ul><li>程序计数器，指明要执行的下一个 JVM 字节码指令。</li><li>用于支持 Java 代码执行的栈，包含有关此线程已到达当时执行位置所调用方法的信息。它也包含每个正在执行的方法的所有局部变量(包括原语和堆对象的引用)。每个线程的栈通常在 64K 到 1M 之间 <sup><a href="#fn_1" id="reffn_1">1</a></sup> 。</li><li>第二个则用于 native code（本机方法代码）执行的栈</li><li><em>thread-local variables</em> （线程本地变量）的存储区域</li><li>用于控制线程的状态管理变量</li></ul><p>包括 <code>main()</code> 在内的所有代码都会在某个线程内运行。 每当调用一个方法时，当前程序计数器被推到该线程的栈上，然后栈指针向下移动以足够来创建一个栈帧，其栈帧里存储该方法的所有局部变量，参数和返回值。所有基本类型变量都直接在栈上，虽然方法中创建（或方法中使用）对象的任何引用都位于栈帧中，但对象本身存于堆中。这仅且只有一个堆，被程序中所有线程所共享。</p><p>除此以外，线程必须绑定到操作系统，这样它就可以在某个时候连接到处理器。这是作为线程构建过程的一部分为你管理的。Java 使用底层操作系统中的机制来管理线程的执行。</p><h3 id="最佳线程数"><a href="#最佳线程数" class="headerlink" title="最佳线程数"></a>最佳线程数</h3><p>如果你查看第 24 章 <a href="./24-Concurrent-Programming.md">并发编程</a> 中使用 <em>CachedThreadPool</em> 的用例，你会发现 <strong>ExecutorService</strong> 为每个我们提交的任务分配一个线程。然而，并行流（<strong>parallel Stream</strong>）在 <a href="https://github.com/BruceEckel/OnJava8-Examples/blob/master/concurrent/CountingStream.java"><strong>CountingStream.java</strong> </a> 中只分配了 8 个线程（id 中 1-7 为工作线程，8 为 <code>main()</code> 方法的主线程，它巧妙地将其用作额外的并行流）。如果你尝试提高 <code>range()</code> 方法中的上限值，你会看到没有创建额外的线程。这是为什么？</p><p>我们可以查出当前机器上处理器的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/NumberOfProcessors.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfProcessors</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">    Runtime.getRuntime().availableProcessors());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在我的机器上（使用英特尔酷睿 i7），我有四个内核，每个内核呈现两个<em>超线程</em>（指一种硬件技巧，能在单个处理器上产生非常快速的上下文切换，在某些情况下可以使内核看起来像运行两个硬件线程）。虽然这是 “最近” 计算机上的常见配置(在撰写本文时)，但你可能会看到不同的结果，包括 <strong>CountingStream.java </strong> 中同等数量的默认线程。</p><p>你的操作系统可能有办法来查出关于处理器的更多信息，例如，在 Windows 10 上，按下 “开始” 键，输入 “任务管理器” 和 Enter 键。点击 “详细信息” 。选择 “性能” 标签,你将会看到各种各样的关于你的硬件信息,包括“内核” 和 “逻辑处理器” 。</p><p>事实证明，“通用”线程的最佳数量就算是可用处理器的数量(对于特定的问题可能不是这样)。这原因来自在 Java 线程之间切换上下文的代价：存储被挂起线程的当前状态，并检索另一个线程的当前状态，以便从它进入挂起的位置继续执行。对于 8 个处理器和 8 个（计算密集型）Java 线程，JVM 在运行这 8 个任务时从不需要切换上下文。对于比处理器数量少的任务，分配更多线程没有帮助。</p><p>定义了 “逻辑处理器” 数量的 Intel 超线程，但并没有增加计算能力 - 该特性在硬件级别维护额外的线程上下文，从而加快了上下文切换，这有助于提高用户界面的响应能力。对于计算密集型任务，请考虑将线程数量与物理内核(而不是超线程)的数量匹配。尽管 Java 认为每个超线程都是一个处理器，但这似乎是由于 Intel 对超线程的过度营销造成的错误。尽管如此，为了简化编程，我只允许 JVM 决定默认的线程数。 你将需要试验你的产品应用。 这并不意味着将线程数与处理器数相匹配就适用于所有问题; 相反，它主要用于计算密集型解决方案。</p><h3 id="我可以创建多少个线程？"><a href="#我可以创建多少个线程？" class="headerlink" title="我可以创建多少个线程？"></a>我可以创建多少个线程？</h3><p>Thread（线程）对象的最大部分是用于执行方法的 Java 堆栈。查看 Thread （线程）对象的大小因操作系统而异。该程序通过创建 Thread 对象来测试它，直到 JVM 内存不足为止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/ThreadSize.java</span></span><br><span class="line"><span class="comment">// &#123;ExcludeFromGradle&#125; Takes a long time or hangs</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSize</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dummy</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">new</span> Nap(<span class="number">1</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService exec =</span><br><span class="line">      Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Dummy());</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Error e) &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">      e.getClass().getSimpleName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要你不断递交任务，<strong>CachedThreadPool</strong> 就会继续创建线程。将 <strong>Dummy</strong> 对象递交到 <code>execute()</code> 方法以开始任务，如果线程池无可用线程，则分配一个新线程。执行的暂停方法 <code>pause()</code> 运行时间必须足够长，使任务不会开始即完成(从而为新任务释放现有线程)。只要任务不断进入而没有完成，<strong>CachedThreadPool</strong> 最终就会耗尽内存。</p><p>我并不总是能够在我尝试的每台机器上造成内存不足的错误。在一台机器上，我看到这样的结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> java ThreadSize</span></span><br><span class="line">OutOfMemoryError: 2816</span><br></pre></td></tr></table></figure><p>我们可以使用 <strong>-Xss</strong> 标记减少每个线程栈分配的内存大小。允许的最小线程栈大小是 64k:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">java -Xss64K ThreadSize</span></span><br><span class="line">OutOfMemoryError: 4952</span><br></pre></td></tr></table></figure><p>如果我们将线程栈大小增加到 2M ，我们就可以分配更少的线程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">java -Xss2M ThreadSize</span></span><br><span class="line">OutOfMemoryError: 722</span><br></pre></td></tr></table></figure><p>Windows 操作系统默认栈大小是 320K，我们可以通过验证它给出的数字与我们完全不设置栈大小时的数字是大致相同:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">java -Xss320K ThreadSize</span></span><br><span class="line">OutOfMemoryError: 2816</span><br></pre></td></tr></table></figure><p>你还可以使用 <strong>-Xmx</strong> 标志增加 JVM 的最大内存分配:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">java -Xss64K -Xmx5M ThreadSize</span></span><br><span class="line">OutOfMemoryError: 5703</span><br></pre></td></tr></table></figure><p>请注意的是操作系统还可能对允许的线程数施加限制。</p><p>因此，“我可以拥有多少线程”这一问题的答案是“几千个”。但是，如果你发现自己分配了数千个线程，那么你可能需要重新考虑你的做法; 恰当的问题是“我需要多少线程？”</p><h3 id="The-WorkStealingPool-工作窃取线程池"><a href="#The-WorkStealingPool-工作窃取线程池" class="headerlink" title="The WorkStealingPool (工作窃取线程池)"></a>The WorkStealingPool (工作窃取线程池)</h3><p>这是一个 <strong>ExecutorService</strong> ，它使用所有可用的(由 JVM 报告) 处理器自动创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/WorkStealingPool.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">    Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkStealingPool</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">      Runtime.getRuntime().availableProcessors());</span><br><span class="line">    ExecutorService exec =</span><br><span class="line">      Executors.newWorkStealingPool();</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">      .mapToObj(n -&gt; <span class="keyword">new</span> ShowThread())</span><br><span class="line">      .forEach(exec::execute);</span><br><span class="line">    exec.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-2</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-1</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-2</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-3</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-2</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-1</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-3</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-1</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-4</span></span><br><span class="line"><span class="comment">ForkJoinPool-1-worker-2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>工作窃取算法允许已经耗尽输入队列中的工作项的线程从其他队列“窃取”工作项。目标是在处理器之间分配工作项，从而最大限度地利用所有可用的处理器来完成计算密集型任务。这项算法也用于 Java 的 fork/join 框架。</p><h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>这可能会让你感到惊讶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SwallowedException.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwallowedException</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exec =</span><br><span class="line">      Executors.newSingleThreadExecutor();</span><br><span class="line">    exec.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;);</span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序什么也不输出（然而，如果你用 <strong>execute</strong> 方法替换 <code>submit()</code> 方法，你就将会看到异常抛出。这说明在线程中抛出异常是很棘手的，需要特别注意的事情。</p><p>你无法捕获到从线程逃逸的异常。一旦异常越过了任务的 <code>run()</code> 方法，它就会传递至控制台，除非你采取特殊步骤来捕获此类错误异常。</p><p>下面是一个抛出异常的代码，该异常会传递到它的 <code>run()</code> 方法之外，而 <code>main()</code> 方法会显示运行它时会发生什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/ExceptionThread.java</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService es =</span><br><span class="line">      Executors.newCachedThreadPool();</span><br><span class="line">    es.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">    es.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;pool-1-thread-1&quot;</span></span><br><span class="line"><span class="comment">java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">        at ExceptionThread.run(ExceptionThread.java:8)</span></span><br><span class="line"><span class="comment">        at java.util.concurrent.ThreadPoolExecutor.runW</span></span><br><span class="line"><span class="comment">orker(ThreadPoolExecutor.java:1142)</span></span><br><span class="line"><span class="comment">        at java.util.concurrent.ThreadPoolExecutor$Work</span></span><br><span class="line"><span class="comment">er.run(ThreadPoolExecutor.java:617)</span></span><br><span class="line"><span class="comment">        at java.lang.Thread.run(Thread.java:745)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>输出是(经过调整一些限定符以适应阅读)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;pool-1-thread-1&quot; RuntimeException</span><br><span class="line">  at ExceptionThread.run(ExceptionThread.java:9)</span><br><span class="line">  at ThreadPoolExecutor.runWorker(...)</span><br><span class="line">  at ThreadPoolExecutor$Worker.run(...)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><p>即使在 <code>main()</code> 方法体内包裹 <strong>try-catch</strong> 代码块来捕获异常也不成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/NaiveExceptionHandling.java</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiveExceptionHandling</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService es =</span><br><span class="line">      Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      es.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RuntimeException ue) &#123;</span><br><span class="line">      <span class="comment">// This statement will NOT execute!</span></span><br><span class="line">      System.out.println(<span class="string">&quot;Exception was handled!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;pool-1-thread-1&quot;</span></span><br><span class="line"><span class="comment">java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">        at ExceptionThread.run(ExceptionThread.java:8)</span></span><br><span class="line"><span class="comment">        at java.util.concurrent.ThreadPoolExecutor.runW</span></span><br><span class="line"><span class="comment">orker(ThreadPoolExecutor.java:1142)</span></span><br><span class="line"><span class="comment">        at java.util.concurrent.ThreadPoolExecutor$Work</span></span><br><span class="line"><span class="comment">er.run(ThreadPoolExecutor.java:617)</span></span><br><span class="line"><span class="comment">        at java.lang.Thread.run(Thread.java:745)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这会产生与前一个示例相同的结果:未捕获异常。</p><p>为解决这个问题，需要改变 <strong>Executor</strong> （执行器）生成线程的方式。 <strong>Thread.UncaughtExceptionHandler</strong> 是一个添加给每个 <strong>Thread</strong> 对象，用于进行异常处理的接口。</p><p>当该线程即将死于未捕获的异常时，将自动调用 <code>Thread.UncaughtExceptionHandler.uncaughtException()</code><br>方法。为了调用该方法，我们创建一个新的 <strong>ThreadFactory</strong> 类型来让 <strong>Thread.UncaughtExceptionHandler</strong> 对象附加到每个它所新创建的 <strong>Thread</strong>（线程）对象上。我们赋值该工厂对象给 <strong>Executors</strong> 对象的 方法，让它的方法来生成新的 <strong>ExecutorService</strong> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/CaptureUncaughtException.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;run() by &quot;</span> + t.getName());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;caught &quot;</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span> + <span class="string">&quot; creating new Thread&quot;</span>);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    System.out.println(<span class="string">&quot;created &quot;</span> + t);</span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">      <span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureUncaughtException</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService exec =</span><br><span class="line">      Executors.newCachedThreadPool(</span><br><span class="line">        <span class="keyword">new</span> HandlerThreadFactory());</span><br><span class="line">    exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HandlerThreadFactory@4e25154f creating new Thread</span></span><br><span class="line"><span class="comment">created Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">eh = MyUncaughtExceptionHandler@70dea4e</span></span><br><span class="line"><span class="comment">run() by Thread-0</span></span><br><span class="line"><span class="comment">eh = MyUncaughtExceptionHandler@70dea4e</span></span><br><span class="line"><span class="comment">caught java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>额外会在代码中添加跟踪机制，用来验证工厂对象创建的线程是否获得新 <strong>UncaughtExceptionHandler</strong> 。现在未捕获的异常由 <strong>uncaughtException</strong> 方法捕获。</p><p>上面的示例根据具体情况来设置处理器。如果你知道你将要在代码中处处使用相同的异常处理器，那么更简单的方式是在 <strong>Thread</strong> 类中设置一个 <strong>static</strong>（静态） 字段，并将这个处理器设置为默认的未捕获异常处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SettingDefaultHandler.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingDefaultHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">      <span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">    ExecutorService es =</span><br><span class="line">      Executors.newCachedThreadPool();</span><br><span class="line">    es.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">    es.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">caught java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>只有在每个线程没有设置异常处理器时候，默认处理器才会被调用。系统会检查线程专有的版本，如果没有，则检查是否线程组中有专有的 <code>uncaughtException()</code> 方法；如果都没有，就会调用 <strong>defaultUncaughtExceptionHandler</strong> 方法。</p><p>可以将此方法与 <strong>CompletableFuture</strong> 的改进方法进行比较。</p><h2 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h2><p>你可以将单线程程序看作一个孤独的实体，在你的问题空间中移动并同一时间只做一件事。因为只有一个实体，你永远不会想到两个实体试图同时使用相同资源的问题：问题犹如两个人试图同时停放在同一个空间，同时走过一扇门，甚至同时说话。</p><p>通过并发，事情不再孤单，但现在两个或更多任务可能会相互干扰。如果你不阻止这种冲突，你将有两个任务同时尝试访问同一个银行帐户，打印到同一个打印机，调整同一个阀门，等等。</p><h3 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h3><p>当你启动一个任务来执行某些工作时，可以通过两种不同的方式捕获该工作的结果:通过副作用或通过返回值。</p><p>从编程方式上看，副作用似乎更容易:你只需使用结果来操作环境中的某些东西。例如，你的任务可能会执行一些计算，然后直接将其结果写入集合。</p><p>伴随这种方式的问题是集合通常是共享资源。当运行多个任务时，任何任务都可能同时读写 <em>共享资源</em> 。这揭示了 <em>资源竞争</em> 问题，这是处理任务时的主要陷阱之一。</p><p>在单线程系统中，你不需要考虑资源竞争，因为你永远不可能同时做多件事。当你有多个任务时，你就必须始终防止资源竞争。</p><p>解决此问题的的一种方法是使用能够应对资源竞争的集合，如果多个任务同时尝试对此类集合进行写入，那么此类集合可以应付该问题。在 Java 并发库中，你将发现许多尝试解决资源竞争问题的类；在本附录中，你将看到其中的一些，但覆盖范围并不全面。</p><p>请思考以下的示例，其中一个任务负责生成偶数，其他任务则负责消费这些数字。在这里，消费者任务的唯一工作就是检查偶数的有效性。</p><p>我们将定义消费者任务 <strong>EvenChecker</strong> 类，以便在后续示例中可复用。为了将 <strong>EvenChecker</strong> 与我们的各种实验生成器类解耦，我们首先创建名为 <strong>IntGenerator</strong> 的抽象类，它包含 <strong>EvenChecker</strong> 必须知道的最低必要方法：它包含 <code>next()</code> 方法，以及可以取消它执行生成的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/IntGenerator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicBoolean canceled =</span><br><span class="line">    <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; canceled.set(<span class="keyword">true</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canceled.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cancel()</code> 方法改变 <strong>AtomicBoolean</strong> 类型的 <strong>canceled</strong> 标志位的状态， 而 <code>isCanceled()</code> 方法则告诉标志位是否设置。因为 <strong>canceled</strong> 标志位是 <strong>AtomicBoolean</strong> 类型，由于它是原子性的，这意味着分配和值返回等简单操作发生时没有中断的可能性，因此你无法在这些简单操作中看到该字段处于中间状态。你将在本附录的后面部分了解有关原子性和 <strong>Atomic</strong> 类的更多信息</p><p>任何 <strong>IntGenerator</strong> 都可以使用下面的 <strong>EvenChecker</strong> 类进行测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/EvenChecker.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.TimedAbort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> IntGenerator generator;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EvenChecker</span><span class="params">(IntGenerator generator, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.generator = generator;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!generator.isCanceled()) &#123;</span><br><span class="line">      <span class="keyword">int</span> val = generator.next();</span><br><span class="line">      <span class="keyword">if</span>(val % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(val + <span class="string">&quot; not even!&quot;</span>);</span><br><span class="line">        generator.cancel(); <span class="comment">// Cancels all EvenCheckers</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Test any IntGenerator:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; checkers =</span><br><span class="line">      IntStream.range(<span class="number">0</span>, count)</span><br><span class="line">        .mapToObj(i -&gt; <span class="keyword">new</span> EvenChecker(gp, i))</span><br><span class="line">        .map(CompletableFuture::runAsync)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    checkers.forEach(CompletableFuture::join);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Default value for count:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TimedAbort(<span class="number">4</span>, <span class="string">&quot;No odd numbers discovered&quot;</span>);</span><br><span class="line">    test(gp, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test()</code> 方法开启了许多访问同一个 <strong>IntGenerator</strong> 的 <strong>EvenChecker</strong>。<strong>EvenChecker</strong> 任务们会不断读取和测试与其关联的 <strong>IntGenerator</strong> 对象中的生成值。如果 <strong>IntGenerator</strong> 导致失败，<code>test()</code> 方法会报告并返回。</p><p>依赖于 <strong>IntGenerator</strong> 对象的所有 <strong>EvenChecker</strong> 任务都会检查它是否已被取消。如果 <code>generator.isCanceled()</code> 返回值为 true ，则 <code>run()</code> 方法返回。 任何 <strong>EvenChecker</strong> 任务都可以在 <strong>IntGenerator</strong> 上调用 <code>cancel()</code> ，这会导致使用该 <strong>IntGenerator</strong> 的其他所有 <strong>EvenChecker</strong> 正常关闭。</p><p>在本设计中，共享公共资源（ <strong>IntGenerator</strong> ）的任务会监视该资源的终止信号。这消除所谓的竞争条件，其中两个或更多的任务竞争响应某个条件并因此冲突或不一致结果的情况。</p><p>你必须仔细考虑并防止并发系统失败的所有可能途径。例如，一个任务不能依赖于另一个任务，因为任务关闭的顺序无法得到保证。这里，通过使任务依赖于非任务对象，我们可以消除潜在的竞争条件。</p><p>一般来说，我们假设 <code>test()</code> 方法最终失败，因为各个 <strong>EvenChecker</strong> 的任务在 <strong>IntGenerator</strong> 处于 “不恰当的” 状态时，仍能够访问其中的信息。但是，直到 <strong>IntGenerator</strong> 完成许多循环之前，它可能无法检测到问题，具体取决于操作系统的详细信息和其他实现细节。为确保本书的自动构建不会卡住，我们使用 <strong>TimedAbort</strong> 类，在此处定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/TimedAbort.java</span></span><br><span class="line"><span class="comment">// Terminate a program after t seconds</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedAbort</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> restart = <span class="keyword">true</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TimedAbort</span><span class="params">(<span class="keyword">double</span> t, String msg)</span> </span>&#123;</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(restart) &#123;</span><br><span class="line">          restart = <span class="keyword">false</span>;</span><br><span class="line">          TimeUnit.MILLISECONDS</span><br><span class="line">            .sleep((<span class="keyword">int</span>)(<span class="number">1000</span> * t));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(msg);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TimedAbort</span><span class="params">(<span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(t, <span class="string">&quot;TimedAbort &quot;</span> + t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span> </span>&#123; restart = <span class="keyword">true</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 lambda 表达式创建一个 <strong>Runnable</strong> ，该表达式使用 <strong>CompletableFuture</strong> 的 <code>runAsync()</code> 静态方法执行。 <code>runAsync()</code> 方法的值会立即返回。 因此，<strong>TimedAbort</strong> 不会保持任何打开的任务，否则已完成任务，但如果它需要太长时间，它仍将终止该任务（ <strong>TimedAbort</strong> 有时被称为守护进程）。</p><p><strong>TimedAbort</strong> 还允许你 <code>restart()</code> 方法重启任务，在有某些有用的活动进行时保持程序打开。</p><p>我们可以看到正在运行的 <strong>TimedAbort</strong> 示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/TestAbort.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TimedAbort(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Napping for 4&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Nap(<span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Napping for 4</span></span><br><span class="line"><span class="comment">TimedAbort 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果你注释掉 <strong>Nap</strong> 创建实列那行，程序执行会立即退出，表明 <strong>TimedAbort</strong> 没有维持程序打开。</p><p>我们将看到第一个 <strong>IntGenerator</strong> 示例有一个生成一系列偶数值的 <code>next()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/EvenProducer.java</span></span><br><span class="line"><span class="comment">// When threads collide</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenProducer</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++currentEvenValue; <span class="comment">// [1]</span></span><br><span class="line">    ++currentEvenValue;</span><br><span class="line">    <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EvenChecker.test(<span class="keyword">new</span> EvenProducer());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">419 not even!</span></span><br><span class="line"><span class="comment">425 not even!</span></span><br><span class="line"><span class="comment">423 not even!</span></span><br><span class="line"><span class="comment">421 not even!</span></span><br><span class="line"><span class="comment">417 not even!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>[1] 一个任务有可能在另外一个任务执行第一个对 <strong>currentEvenValue</strong> 的自增操作之后，但是没有执行第二个操作之前，调用 <code>next()</code> 方法。这将使这个值处于 “不恰当” 的状态。</li></ul><p>为了证明这是可能发生的， <code>EvenChecker.test()</code> 创建了一组 <strong>EventChecker</strong> 对象，以连续读取 <strong>EvenProducer</strong> 的输出并测试检查每个数值是否都是偶数。如果不是，就会报告错误，而程序也将关闭。</p><p>多线程程序的部分问题是，即使存在 bug ，如果失败的可能性很低，程序仍然可以正确显示。</p><p>重要的是要注意到自增操作自身需要多个步骤，并且在自增过程中任务可能会被线程机制挂起 - 也就是说，在 Java 中，自增不是原子性的操作。因此，如果不保护任务，即使单纯的自增也不是线程安全的。</p><p>该示例程序并不总是在第一次非偶数产生时终止。所有任务都不会立即关闭，这是并发程序的典型特征。</p><h3 id="解决资源竞争"><a href="#解决资源竞争" class="headerlink" title="解决资源竞争"></a>解决资源竞争</h3><p>前面的示例揭示了当你使用线程时的基本问题：你永远不知道线程哪个时刻运行。想象一下坐在一张桌子上，用叉子，将最后一块食物放在盘子上，当叉子到达时，食物突然消失…仅因为你的线程被挂起而另一个用餐者进来吃了食物了。这就是在编写并发程序时要处理的问题。为了使并发工作有效，你需要某种方式来阻止两个任务访问同一个资源，至少在关键时期是这样。</p><p>防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它，而在其被解锁时候，另一个任务就可以锁定并使用它，以此类推。如果汽车前排座位是受限资源，那么大喊着 “冲呀” 的孩子就会（在这次旅途过程中）获得该资源的锁。</p><p>为了解决线程冲突的问题，基本的并发方案将序列化访问共享资源。这意味着一次只允许一个任务访问共享资源。这通常是通过在访问资源的代码片段周围加上一个子句来实现的，该子句一次只允许一个任务访问这段代码。因为这个子句产生 <em>互斥</em> 效果，所以这种机制的通常称为是 <em>mutex</em> （互斥量）。</p><p>考虑一下屋子里的浴室：多个人（即多个由线程驱动的任务）都希望能独立使用浴室（即共享资源）。为了使用浴室，一个人先敲门来看看是否可用。如果没人的话，他就能进入浴室并锁上门。任何其他想使用浴室的任务就会被 “阻挡”，因此这些任务就在门口等待，直到浴室是可用的。</p><p>当浴室使用完毕，就是时候给其他任务进入，这时比喻就有点不准确了。事实上没有人排队，我们也不知道下一个使用浴室是谁，因为线程调度机制并不是确定性的。相反，就好像在浴室前面有一组被阻止的任务一样，当锁定浴室的任务解锁并出现时，线程调度机制将会决定下一个要进入的任务。</p><p>Java 以提供关键字 <strong>synchronized</strong> 的形式，为防止资源冲突提供了内置支持。当任务希望执行被 <strong>synchronized</strong> 关键字保护的代码片段的时候，Java 编译器会生成代码以查看锁是否可用。如果可用，该任务获取锁，执行代码，然后释放锁。</p><p>共享资源一般是以对象形式存在的内存片段，但也可以是文件、I/O 端口，或者类似打印机的东西。要控制对共享资源的访问，得先把它包装进一个对象。然后把任何访问该资源的方法标记为 <strong>synchronized</strong> 。 如果一个任务在调用其中一个 <strong>synchronized</strong> 方法之内，那么在这个任务从该方法返回之前，其他所有要调用该对象的 <strong>synchronized</strong> 方法的任务都会被阻塞。</p><p>通常你会将字段设为 <strong>private</strong>，并仅通过方法访问这些字段。你可用通过使用 <strong>synchronized</strong> 关键字声明方法来防止资源冲突。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>所有对象都自动包含独立的锁（也称为 <em>monitor</em>，即监视器）。当你调用对象上任何 <strong>synchronized</strong> 方法，此对象将被加锁，并且该对象上的的其他 <strong>synchronized</strong> 方法调用只有等到前一个方法执行完成并释放了锁之后才能被调用。如果一个任务对对象调用了 <code>f()</code> ，对于同一个对象而言，就只能等到 <code>f()</code> 调用结束并释放了锁之后，其他任务才能调用 <code>f()</code> 和 <code>g()</code>。所以，某个特定对象的所有 <strong>synchronized</strong> 方法共享同一个锁，这个锁可以防止多个任务同时写入对象内存。</p><p>在使用并发时，将字段设为 <strong>private</strong> 特别重要；否则，<strong>synchronized</strong> 关键字不能阻止其他任务直接访问字段，从而产生资源冲突。</p><p>一个线程可以获取对象的锁多次。如果一个方法调用在同一个对象上的第二个方法，而后者又在同一个对象上调用另一个方法，就会发生这种情况。 JVM 会跟踪对象被锁定的次数。如果对象已解锁，则其计数为 0 。当一个线程首次获得锁时，计数变为 1 。每次同一线程在同一对象上获取另一个锁时，计数就会自增。显然，只有首先获得锁的线程才允许多次获取多个锁。每当线程离开 <strong>synchronized</strong> 方法时，计数递减，直到计数变为 0 ，完全释放锁以给其他线程使用。每个类也有一个锁（作为该类的 <strong>Class</strong> 对象的一部分），因此 <strong>synchronized</strong> 静态方法可以在类范围的基础上彼此锁定，不让同时访问静态数据。</p><p>你应该什么时候使用同步呢？可以永远 <em>Brian</em> 的同步法则<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><blockquote><p>如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。</p></blockquote><p>如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关方法。如果只同步其中一个方法，那么其他方法可以忽略对象锁，并且可以不受惩罚地调用。这是很重要的一点：每个访问临界共享资源的方法都必须被同步，否则将不会正确地工作。</p><h3 id="同步控制-EventProducer"><a href="#同步控制-EventProducer" class="headerlink" title="同步控制 EventProducer"></a>同步控制 EventProducer</h3><p>通过在 <strong>EvenProducer.java</strong> 文件中添加 <strong>synchronized</strong> 关键字，可以防止不希望的线程访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SynchronizedEvenProducer.java</span></span><br><span class="line"><span class="comment">// Simplifying mutexes with the synchronized keyword</span></span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">SynchronizedEvenProducer</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++currentEvenValue;</span><br><span class="line">    <span class="keyword">new</span> Nap(<span class="number">0.01</span>); <span class="comment">// Cause failure faster</span></span><br><span class="line">    ++currentEvenValue;</span><br><span class="line">    <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EvenChecker.test(<span class="keyword">new</span> SynchronizedEvenProducer());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">No odd numbers discovered</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在两个自增操作之间插入 <code>Nap()</code> 构造器方法，以提高在 <strong>currentEvenValue</strong> 是奇数的状态时上下文切换的可能性。因为互斥锁可以阻止多个任务同时进入临界区，所有这不会产生失败。第一个进入 <code>next()</code> 方法的任务将获得锁，任何试图获取锁的后续任务都将被阻塞，直到第一个任务释放锁。此时，调度机制选择另一个等待锁的任务。通过这种方式，任何时刻只能有一个任务通过互斥锁保护的代码。</p><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p><strong>volatile</strong> 可能是 Java 中最微妙和最难用的关键字。幸运的是，在现代 Java 中，你几乎总能避免使用它，如果你确实看到它在代码中使用，你应该保持怀疑态度和怀疑 - 这很有可能代码是过时的，或者编写代码的人不清楚使用它在大体上（或两者都有）易变性（<strong>volatile</strong>） 或并发性的后果。</p><p>使用 <strong>volatile</strong> 有三个理由。</p><h3 id="字分裂"><a href="#字分裂" class="headerlink" title="字分裂"></a>字分裂</h3><p>当你的 Java 数据类型足够大（在 Java 中 <strong>long</strong> 和 <strong>double</strong> 类型都是 64 位），写入变量的过程分两步进行，就会发生 <em>Word tearing</em> （字分裂）情况。 JVM 被允许将 64 位数量的读写作为两个单独的 32 位操作执行<sup><a href="#fn_3" id="reffn_3">3</a></sup>，这增加了在读写过程中发生上下文切换的可能性，因此其他任务会看到不正确的结果。这被称为 <em>Word tearing</em> （字分裂），因为你可能只看到其中一部分修改后的值。基本上，任务有时可以在第一步之后但在第二步之前读取变量，从而产生垃圾值（对于例如 <strong>boolean</strong> 或 <strong>int</strong> 类型的小变量是没有问题的；任何 <strong>long</strong> 或 <strong>double</strong> 类型则除外）。</p><p>在缺乏任何其他保护的情况下，用 <strong>volatile</strong> 修饰符定义一个 <strong>long</strong> 或 <strong>double</strong> 变量，可阻止字分裂情况。然而，如果使用 <strong>synchronized</strong> 或 <strong>java.util.concurrent.atomic</strong> 类之一保护这些变量，则 <strong>volatile</strong> 将被取代。此外，<strong>volatile</strong> 不会影响到增量操作并不是原子操作的事实。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>第二个问题属于 <a href="./24-Concurrent-Programming.md#四句格言">Java 并发的四句格言</a>里第二句格言 “一切都重要” 的部分。你必须假设每个任务拥有自己的处理器，并且每个处理器都有自己的本地内存缓存。该缓存准许处理器允许的更快，因为处理器并不总是需要从比起使用缓存显著花费更多时间的主内存中获取数据。</p><p>出现这个问题是因为 Java 尝试尽可能地提高执行效率。缓存的主要目的是避免从主内存中读取数据。当并发时，有时不清楚 Java 什么时候应该将值从主内存刷新到本地缓存 — 而这个问题称为 <em>缓存一致性</em> （ <em>cache coherence</em> ）。</p><p>每个线程都可以在处理器缓存中存储变量的本地副本。将字段定义为 <strong>volatile</strong> 可以防止这些编译器优化，这样读写就可以直接进入内存，而不会被缓存。一旦该字段发生写操作，所有任务的读操作都将看到更改。如果一个 <strong>volatile</strong> 字段刚好存储在本地缓存，则会立即将其写入主内存，并且该字段的任何读取都始终发生在主内存中。</p><p><strong>volatile</strong> 应该在何时适用于变量：</p><ol><li>该变量同时被多个任务访问。</li><li>这些访问中至少有一个是写操作。</li><li>你尝试避免同步 （在现代 Java 中，你可以使用高级工具来避免进行同步）。</li></ol><p>举个例字，如果你使用变量作为停止任务的标志值。那么该变量至少必须声明为 <strong>volatile</strong> （尽管这并不一定能保证这种标志的线程安全）。否则，当一个任务更改标志值时，这些更改可以存储在本地处理器缓存中，而不会刷新到主内存。当另一个任务查看标记值时，它不会看到更改。我更喜欢在 <a href="./24-Concurrent-Programming.md">并发编程</a> 中 <a href="./24-Concurrent-Programming.md#终止耗时任务">终止耗时任务</a> 章节中使用 <strong>AtomicBoolean</strong> 类型作为标志值的办法</p><p>任务对其自身变量所做的任何写操作都始终对该任务可见，因此，如果只在任务中使用变量，你不需要使其变量声明为 <strong>volatile</strong> 。</p><p>如果单个线程对变量写入而其他线程只读取它，你可以放弃该变量声明为 <strong>volatile</strong>。通常，如果你有多个线程对变量写入，<strong>volatile</strong> 无法解决你的问题，并且你必须使用 <strong>synchronized</strong> 来防止竞争条件。 这有一个特殊的例外：可以让多个线程对该变量写入，<em>只要它们不需要先读取它并使用该值创建新值来写入变量</em> 。如果这些多个线程在结果中使用旧值，则会出现竞争条件，因为其余一个线程之一可能会在你的线程进行计算时修改该变量。即使你开始做对了，想象一下在代码修改或维护过程中忘记和引入一个重大变化是多么容易，或者对于不理解问题的不同程序员来说是多么容易（这在 Java 中尤其成问题因为程序员倾向于严重依赖编译时检查来告诉他们，他们的代码是否正确）。</p><p>重要的是要理解原子性和可见性是两个不同的概念。在非 <strong>volatile</strong> 变量上的原子操作是不能保证是否将其刷新到主内存。</p><p>同步也会让主内存刷新，所以如果一个变量完全由 <strong>synchronized</strong> 的方法或代码段(或者 <strong>java.util.concurrent.atomic</strong> 库里类型之一)所保护，则不需要让变量用 <strong>volatile</strong>。</p><h3 id="重排与-Happen-Before-原则"><a href="#重排与-Happen-Before-原则" class="headerlink" title="重排与 Happen-Before 原则"></a>重排与 <em>Happen-Before</em> 原则</h3><p>只要结果不会改变程序表现，Java 可以通过重排指令来优化性能。然而，重排可能会影响本地处理器缓存与主内存交互的方式，从而产生细微的程序 bug 。直到 Java 5 才理解并解决了这个无法阻止重排的问题。现在，<strong>volatile</strong> 关键字可以阻止重排 <strong>volatile</strong> 变量周围的读写指令。这种重排规则称为 <em>happens before</em> 担保原则 。</p><p>这项原则保证在 <strong>volatile</strong> 变量读写之前发生的指令先于它们的读写之前发生。同样，任何跟随 <strong>volatile</strong> 变量之后读写的操作都保证发生在它们的读写之后。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/ReOrdering.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReOrdering</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> one, two, three, four, five, six;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> volaTile;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    one = <span class="number">1</span>;</span><br><span class="line">    two = <span class="number">2</span>;</span><br><span class="line">    three = <span class="number">3</span>;</span><br><span class="line">    volaTile = <span class="number">92</span>;</span><br><span class="line">    <span class="keyword">int</span> x = four;</span><br><span class="line">    <span class="keyword">int</span> y = five;</span><br><span class="line">    <span class="keyword">int</span> z = six;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中 <strong>one</strong>，<strong>two</strong>，<strong>three</strong> 变量赋值操作就可以被重排，只要它们都发生在 <strong>volatile</strong> 变量写操作之前。同样，只要 <strong>volatile</strong> 变量写操作发生在所有语句之前， <strong>x</strong>，<strong>y</strong>，<strong>z</strong> 语句可以被重排。这种 <strong>volatile</strong> （易变性）操作通常称为 <em>memory barrier</em> （内存屏障）。 <em>happens before</em> 担保原则确保 <strong>volatile</strong> 变量的读写指令不能跨过内存屏障进行重排。</p><p><em>happens before</em> 担保原则还有另一个作用：当线程向一个 <strong>volatile</strong> 变量写入时，在线程写入之前的其他所有变量（包括非 <strong>volatile</strong> 变量）也会刷新到主内存。当线程读取一个 <strong>volatile</strong> 变量时，它也会读取其他所有变量（包括非 <strong>volatile</strong> 变量）与 <strong>volatile</strong> 变量一起刷新到主内存。尽管这是一个重要的特性，它解决了 Java 5 版本之前出现的一些非常狡猾的 bug ，但是你不应该依赖这项特性来“自动”使周围的变量变得易变性 （ <strong>volatile</strong> ）的 。如果你希望变量是易变性 （ <strong>volatile</strong> ）的，那么维护代码的任何人都应该清楚这一点。</p><h3 id="什么时候使用-volatile"><a href="#什么时候使用-volatile" class="headerlink" title="什么时候使用 volatile"></a>什么时候使用 volatile</h3><p>对于 Java 早期版本，编写一个证明需要 <strong>volatile</strong> 的示例并不难。如果你进行搜索，你可以找到这样的例子，但是如果你在 Java 8 中尝试这些例子，它们就不起作用了(我没有找到任何一个)。我努力写这样一个例子，但没什么用。这可能原因是 JVM 或者硬件，或两者都得到了改进。这种效果对现有的应该 <strong>volatile</strong> （易变性） 但不 <strong>volatile</strong> 的存储的程序是有益的；对于此类程序，失误发生的频率要低得多，而且问题更难追踪。</p><p>如果你尝试使用 <strong>volatile</strong> ，你可能更应该尝试让一个变量线程安全而不是引起同步的成本。因为 <strong>volatile</strong> 使用起来非常微妙和棘手，所以我建议根本不要使用它;相反，请使用本附录后面介绍的 <strong>java.util.concurrent.atomic</strong> 里面类之一。它们以比同步低得多的成本提供了完全的线程安全性。</p><p>如果你正在尝试调试其他人的并发代码，请首先查找使用 <strong>volatile</strong> 的代码并将其替换为<strong>Atomic</strong> 变量。除非你确定程序员对并发性有很高的理解，否则它们很可能会误用 <strong>volatile</strong> 。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>在 Java 线程的讨论中，经常反复提交但不正确的知识是：“原子操作不需要同步”。 一个 <em>原子操作</em> 是不能被线程调度机制中断的操作；一旦操作开始，那么它一定可以在可能发生的“上下文切换”之前（切换到其他线程执行）执行完毕。依赖于原子性是很棘手且很危险的，如果你是一个并发编程专家，或者你得到了来自这样的专家的帮助，你才应该使用原子性来代替同步，如果你认为自己足够聪明可以应付这种玩火似的情况，那么请接受下面的测试：</p><blockquote><p>Goetz 测试：如果你可以编写用于现代微处理器的高性能 JVM ，那么就有资格考虑是否可以避免同步<sup><a href="#fn_4" id="reffn_4">4</a></sup> 。</p></blockquote><p>了解原子性是很有用的，并且知道它与其他高级技术一起用于实现一些更加巧妙的 <strong>java.util.concurrent</strong> 库组件。 但是要坚决抵制自己依赖它的冲动。</p><p>原子性可以应用于除 <strong>long</strong> 和 <strong>double</strong> 之外的所有基本类型之上的 “简单操作”。对于读写和写入除 <strong>long</strong> 和 <strong>double</strong> 之外的基本类型变量这样的操作，可以保证它们作为不可分 (原子) 的操作执行。</p><p>因为原子操作不能被线程机制中断。专家程序员可以利用这个来编写无锁代码（<em>lock-free code</em>），这些代码不需要被同步。但即使这样也过于简单化了。有时候，甚至看起来应该是安全的原子操作，实际上也可能不安全。本书的读者通常不会通过前面提到的 Goetz 测试，因此也就不具备用原子操作来替换同步的能力。尝试着移除同步通常是一种表示不成熟优化的信号，并且会给你带来大量的麻烦，可能不会获得太多或任何的好处。</p><p>在多核处理器系统，相对于单核处理器而言，可见性问题远比原子性问题多得多。一个任务所做的修改，即使它们是原子性的，也可能对其他任务不可见（例如，修改只是暂时性存储在本地处理器缓存中），因此不同的任务对应用的状态有不同的视图。另一方面，同步机制强制多核处理器系统上的一个任务做出的修改必须在应用程序中是可见的。如果没有同步机制，那么修改时可见性将无法确认。</p><p>什么才属于原子操作时？对于属性中的值做赋值和返回操作通常都是原子性的，但是在 C++ 中，甚至下面的操作都可能是原子性的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i++; <span class="comment">// Might be atomic in C++</span></span><br><span class="line">i += <span class="number">2</span>; <span class="comment">// Might be atomic in C++</span></span><br></pre></td></tr></table></figure><p>但是在 C++ 中，这取决于编译器和处理器。你无法编写出依赖于原子性的 C++ 跨平台代码，因为 C++ <sup><a href="#fn_5" id="reffn_5">5</a></sup>没有像 Java 那样的一致 <em>内存模型</em> （memory model）。</p><p>在 Java 中，上面的操作肯定不是原子性的，正如下面的方法产生的 JVM 指令中可以看到的那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/NotAtomic.java</span></span><br><span class="line"><span class="comment">// &#123;javap -c NotAtomic&#125;</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotAtomic</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; i++; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; i += <span class="number">3</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Compiled from &quot;NotAtomic.java&quot;</span></span><br><span class="line"><span class="comment">public class NotAtomic &#123;</span></span><br><span class="line"><span class="comment">  int i;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  public NotAtomic();</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">       0: aload_0</span></span><br><span class="line"><span class="comment">       1: invokespecial #1 // Method</span></span><br><span class="line"><span class="comment">java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="comment">       4: return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  void f1();</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">       0: aload_0</span></span><br><span class="line"><span class="comment">       1: dup</span></span><br><span class="line"><span class="comment">       2: getfield      #2 // Field</span></span><br><span class="line"><span class="comment">i:I</span></span><br><span class="line"><span class="comment">       5: iconst_1</span></span><br><span class="line"><span class="comment">       6: iadd</span></span><br><span class="line"><span class="comment">       7: putfield      #2 // Field</span></span><br><span class="line"><span class="comment">i:I</span></span><br><span class="line"><span class="comment">      10: return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  void f2();</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">       0: aload_0</span></span><br><span class="line"><span class="comment">       1: dup</span></span><br><span class="line"><span class="comment">       2: getfield      #2 // Field</span></span><br><span class="line"><span class="comment">i:I</span></span><br><span class="line"><span class="comment">       5: iconst_3</span></span><br><span class="line"><span class="comment">       6: iadd</span></span><br><span class="line"><span class="comment">       7: putfield      #2 // Field</span></span><br><span class="line"><span class="comment">i:I</span></span><br><span class="line"><span class="comment">      10: return</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>每条指令都会产生一个 “get” 和 “put”，它们之间还有一些其他指令。因此在获取指令和放置指令之间，另有一个任务可能会修改这个属性，所有，这些操作不是原子性的。</p><p>让我们通过定义一个抽象类来测试原子性的概念，这个抽象类的方法是将一个整数类型进行偶数自增，并且 <code>run()</code> 不断地调用这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/IntTestable.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">IntTestable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">IntSupplier</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">      evenIncrement();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IntSupplier</strong> 是一个带 <code>getAsInt()</code> 方法的函数式接口。</p><p>现在我们可以创建一个测试，它作为一个独立的任务启动 <code>run()</code> 方法 ，然后获取值来检查它们是否为偶数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/Atomicity.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.TimedAbort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Atomicity</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntTestable it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TimedAbort(<span class="number">4</span>, <span class="string">&quot;No failures found&quot;</span>);</span><br><span class="line">    CompletableFuture.runAsync(it);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> val = it.getAsInt();</span><br><span class="line">      <span class="keyword">if</span>(val % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;failed with: &quot;</span> + val);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易盲目地应用原子性的概念。在这里，<code>getAsInt()</code> 似乎是安全的原子性方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/UnsafeReturn.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeReturn</span> <span class="keyword">extends</span> <span class="title">IntTestable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++; i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Atomicity.test(<span class="keyword">new</span> UnsafeReturn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">failed with: 79</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是， <code>Atomicity.test()</code> 方法还是出现有非偶数的失败。尽管，返回 <strong>i</strong> 变量确实是原子操作，但是同步缺失允许了在对象处于不稳定的中间状态时读取值。最重要的是，由于 <strong>i</strong> 也不是 <strong>volatile</strong> 变量，所以存在可见性问题。包括 <code>getValue()</code> 和 <code>evenIncrement()</code> 都必须同步(这也顾及到没有使用 <strong>volatile</strong> 修饰的 <strong>i</strong> 变量):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SafeReturn.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeReturn</span> <span class="keyword">extends</span> <span class="title">IntTestable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++; i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Atomicity.test(<span class="keyword">new</span> SafeReturn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">No failures found</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>只有并发编程专家有能力去尝试做像前面例子情况的优化；再次强调，请遵循 Brain 的同步法则。</p><h3 id="Josh-的序列号"><a href="#Josh-的序列号" class="headerlink" title="Josh 的序列号"></a>Josh 的序列号</h3><p>作为第二个示例，考虑某些更简单的东西：创建一个产生序列号的类，灵感启发于 Joshua Bloch 的 <em>Effective Java Programming Language Guide</em> (Addison-Wesley 出版社, 2001) 第 190 页。每次调用 <code>nextSerialNumber()</code> 都必须返回唯一值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SerialNumbers.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumbers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serialNumber++; <span class="comment">// Not thread-safe</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SerialNumbers</strong> 是你可以想象到最简单的类，如果你具备 C++ 或者其他底层的知识背景，你可能会认为自增是一个原子操作，因为 C++ 的自增操作通常被单个微处理器指令所实现（尽管不是以任何一致，可靠，跨平台的方式）。但是，正如前面所提到的，Java 自增操作不是原子性的，并且操作同时涉及读取和写入，因此即使在这样一个简单的操作中，也存在有线程问题的空间。</p><p>我们在这里加入 volatile ，看看它是否有帮助。然而，真正的问题是 <code>nextSerialNumber()</code> 方法在不进行线程同步的情况下访问共享的可变变量值。</p><p>为了测试 <strong>SerialNumbers</strong>，我们将创建一个不会耗尽内存的集合，假如需要很长时间来检测问题。这里展示的 <strong>CircularSet</strong> 重用了存储 <strong>int</strong> 变量的内存，最终新值会覆盖旧值(复制的速度通常发生足够快，你也可以使用 <strong>java.util.Set</strong> 来代替):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/CircularSet.java</span></span><br><span class="line"><span class="comment">// Reuses storage so we don&#x27;t run out of memory</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularSet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="comment">// Initialize to a value not produced</span></span><br><span class="line">    <span class="comment">// by SerialNumbers:</span></span><br><span class="line">    Arrays.fill(array, -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    array[index] = i;</span><br><span class="line">    <span class="comment">// Wrap index and write over old elements:</span></span><br><span class="line">    index = ++index % size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span>(array[i] == val) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add()</code> 和 <code>contains()</code> 方法是线程同步的，以防止线程冲突。<br>The add() and contains() methods are synchronized to prevent thread collisions.</p><p><strong>SerialNumberChecker</strong> 类包含一个存储最近序列号的 <strong>CircularSet</strong> 变量，以及一个填充数值给 <strong>CircularSet</strong> 和确保它里面的序列号是唯一的 <code>run()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SerialNumberChecker.java</span></span><br><span class="line"><span class="comment">// Test SerialNumbers implementations for thread-safety</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CircularSet serials = <span class="keyword">new</span> CircularSet(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">private</span> SerialNumbers producer;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SerialNumberChecker</span><span class="params">(SerialNumbers producer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.producer = producer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> serial = producer.nextSerialNumber();</span><br><span class="line">      <span class="keyword">if</span>(serials.contains(serial)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duplicate: &quot;</span> + serial);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      serials.add(serial);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(SerialNumbers producer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      CompletableFuture.runAsync(</span><br><span class="line">        <span class="keyword">new</span> SerialNumberChecker(producer));</span><br><span class="line">    <span class="keyword">new</span> Nap(<span class="number">4</span>, <span class="string">&quot;No duplicates detected&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test()</code> 方法创建多个任务来竞争单独的 <strong>SerialNumbers</strong> 对象。这时参于竞争的的 SerialNumberChecker 任务们就会试图生成重复的序列号（这情况在具有更多内核处理器的机器上发生得更快）。</p><p>当我们测试基本的 <strong>SerialNumbers</strong> 类，它会失败（产生重复序列号）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SerialNumberTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SerialNumberChecker.test(<span class="keyword">new</span> SerialNumbers());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Duplicate: 148044</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>volatile</strong> 在这里没有帮助。要解决这个问题，将 <strong>synchronized</strong> 关键字添加到 <code>nextSerialNumber()</code> 方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SynchronizedSerialNumbers.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">SynchronizedSerialNumbers</span> <span class="keyword">extends</span> <span class="title">SerialNumbers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serialNumber++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SerialNumberChecker.test(</span><br><span class="line">      <span class="keyword">new</span> SynchronizedSerialNumbers());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">No duplicates detected</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>volatile</strong> 不再是必需的，因为 <strong>synchronized</strong> 关键字保证了 volatile （易变性） 的特性。</p><p>读取和赋值原语应该是安全的原子操作。然后，正如在 <strong>UnsafeReturn.java</strong> 中所看到，使用原子操作访问处于不稳定中间状态的对象仍然很容易。对这个问题做出假设既棘手又危险。最明智的做法就是遵循 Brian 的同步规则(如果可以，首先不要共享变量)。</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>Java 5 引入了专用的原子变量类，例如 <strong>AtomicInteger</strong>、<strong>AtomicLong</strong>、<strong>AtomicReference</strong> 等。这些提供了原子性升级。这些快速、无锁的操作，它们是利用了现代处理器上可用的机器级原子性。</p><p>下面，我们可以使用 <strong>atomicinteger</strong> 重写 <strong>unsafereturn.java</strong> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/AtomicIntegerTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> <span class="keyword">extends</span> <span class="title">IntTestable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i.get(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123; i.addAndGet(<span class="number">2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Atomicity.test(<span class="keyword">new</span> AtomicIntegerTest());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">No failures found</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>现在，我们通过使用 <strong>AtomicInteger</strong> 来消除了 <strong>synchronized</strong> 关键字。</p><p>下面使用 <strong>AtomicInteger</strong> 来重写 <strong>SynchronizedEvenProducer.java</strong> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/AtomicEvenProducer.java</span></span><br><span class="line"><span class="comment">// Atomic classes: occasionally useful in regular code</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicEvenProducer</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger currentEvenValue =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentEvenValue.addAndGet(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EvenChecker.test(<span class="keyword">new</span> AtomicEvenProducer());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">No odd numbers discovered</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>再次，使用 <strong>AtomicInteger</strong> 消除了对所有其他同步方式的需要。</p><p>下面是一个使用 <strong>AtomicInteger</strong> 实现 <strong>SerialNumbers</strong> 的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/AtomicSerialNumbers.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">AtomicSerialNumbers</span> <span class="keyword">extends</span> <span class="title">SerialNumbers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger serialNumber =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serialNumber.getAndIncrement();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SerialNumberChecker.test(</span><br><span class="line">      <span class="keyword">new</span> AtomicSerialNumbers());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">No duplicates detected</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这些都是对单一字段的简单示例； 当你创建更复杂的类时，你必须确定哪些字段需要保护，在某些情况下，你可能仍然最后在方法上使用 <strong>synchronized</strong> 关键字。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>有时，你只是想防止多线程访问方法中的部分代码，而不是整个方法。要隔离的代码部分称为临界区，它使用我们用于保护整个方法相同的 <strong>synchronized</strong> 关键字创建，但使用不同的语法。语法如下， <strong>synchronized</strong> 指定某个对象作为锁用于同步控制花括号内的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject) &#123;</span><br><span class="line">  <span class="comment">// This code can be accessed</span></span><br><span class="line">  <span class="comment">// by only one task at a time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也被称为 <em>同步控制块</em> （synchronized block）；在进入此段代码前，必须得到 <strong>syncObject</strong> 对象的锁。如果一些其他任务已经得到这个锁，那么就得等到锁被释放以后，才能进入临界区。当发生这种情况时，尝试获取该锁的任务就会挂起。线程调度会定期回来并检查锁是否已经释放；如果释放了锁则唤醒任务。</p><p>使用同步控制块而不是同步控制整个方法的主要动机是性能（有时，算法确实聪明，但还是要特别警惕来自并发性问题上的聪明）。下面的示例演示了同步控制代码块而不是整个方法可以使方法更容易被其他任务访问。该示例会统计成功访问 <code>method()</code> 的计数并且发起一些任务来尝试竞争调用 <code>method()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SynchronizedComparison.java</span></span><br><span class="line"><span class="comment">// speeds up access.</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Guarded</span> </span>&#123;</span><br><span class="line">  AtomicLong callCount = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName() +</span><br><span class="line">      <span class="string">&quot;: &quot;</span> + callCount.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethod</span> <span class="keyword">extends</span> <span class="title">Guarded</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Nap(<span class="number">0.01</span>);</span><br><span class="line">    callCount.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CriticalSection</span> <span class="keyword">extends</span> <span class="title">Guarded</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Nap(<span class="number">0.01</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      callCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Guarded g;</span><br><span class="line">  Caller(Guarded g) &#123; <span class="keyword">this</span>.g = g; &#125;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong successfulCalls =</span><br><span class="line">    <span class="keyword">new</span> AtomicLong();</span><br><span class="line">  <span class="keyword">private</span> AtomicBoolean stop =</span><br><span class="line">    <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; stop.set(<span class="keyword">true</span>); &#125;</span><br><span class="line">    &#125;, <span class="number">2500</span>);</span><br><span class="line">    <span class="keyword">while</span>(!stop.get()) &#123;</span><br><span class="line">      g.method();</span><br><span class="line">      successfulCalls.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;-&gt; &quot;</span> + successfulCalls.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedComparison</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Guarded g)</span> </span>&#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; callers =</span><br><span class="line">      Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Caller(g),</span><br><span class="line">        <span class="keyword">new</span> Caller(g),</span><br><span class="line">        <span class="keyword">new</span> Caller(g),</span><br><span class="line">        <span class="keyword">new</span> Caller(g))</span><br><span class="line">        .map(CompletableFuture::runAsync)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    callers.forEach(CompletableFuture::join);</span><br><span class="line">    System.out.println(g);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">new</span> CriticalSection());</span><br><span class="line">    test(<span class="keyword">new</span> SynchronizedMethod());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">-&gt; 243</span></span><br><span class="line"><span class="comment">-&gt; 243</span></span><br><span class="line"><span class="comment">-&gt; 243</span></span><br><span class="line"><span class="comment">-&gt; 243</span></span><br><span class="line"><span class="comment">CriticalSection: 972</span></span><br><span class="line"><span class="comment">-&gt; 69</span></span><br><span class="line"><span class="comment">-&gt; 61</span></span><br><span class="line"><span class="comment">-&gt; 83</span></span><br><span class="line"><span class="comment">-&gt; 36</span></span><br><span class="line"><span class="comment">SynchronizedMethod: 249</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Guarded</strong> 类负责跟踪 <strong>callCount</strong> 中成功调用 <code>method()</code> 的次数。<strong>SynchronizedMethod</strong> 的方式是同步控制整个 <code>method</code> 方法，而 <strong>CriticalSection</strong> 的方式是使用同步控制块来仅同步 <code>method</code> 方法的一部分代码。这样，耗时的 <strong>Nap</strong> 对象可以被排除到同步控制块外。输出会显示 <strong>CriticalSection</strong> 中可用的 <code>method()</code> 有多少。</p><p>请记住，使用同步控制块是有风险；它要求你确切知道同步控制块外的非同步代码是实际上要线程安全的。</p><p><strong>Caller</strong> 是尝试在给定的时间周期内尽可能多地调用 <code>method()</code> 方法（并报告调用次数）的任务。为了构建这个时间周期，我们会使用虽然有点过时但仍然可以很好地工作的 <strong>java.util.Timer</strong> 类。此类接收一个 <strong>TimerTask</strong> 参数, 但该参数并不是函数式接口，所以我们不能使用 <strong>lambda</strong> 表达式，必须显式创建该类对象（在这种情况下，使用匿名内部类）。当超时的时候，定时对象将设置 <strong>AtomicBoolean</strong> 类型的 <strong>stop</strong> 字段为 true ，这样循环就会退出。</p><p><code>test()</code> 方法接收一个 <strong>Guarded</strong> 类对象并创建四个 <strong>Caller</strong> 任务。所有这些任务都添加到同一个 <strong>Guarded</strong> 对象上，因此它们竞争来获取使用 <code>method()</code> 方法的锁。</p><p>你通常会看到从一次运行到下一次运行的输出变化。结果表明， <strong>CriticalSection</strong> 方式比起 <strong>SynchronizedMethod</strong> 方式允许更多地访问 <code>method()</code> 方法。这通常是使用 <strong>synchronized</strong> 块取代同步控制整个方法的原因：允许其他任务更多访问(只要这样做是线程安全的)。</p><h3 id="在其他对象上同步"><a href="#在其他对象上同步" class="headerlink" title="在其他对象上同步"></a>在其他对象上同步</h3><p><strong>synchronized</strong> 块必须给定一个在其上进行同步的对象。并且最合理的方式是，使用其方法正在被调用的当前对象： <strong>synchronized(this)</strong>，这正是前面示例中 <strong>CriticalSection</strong> 采取的方式。在这种方式中，当 <strong>synchronized</strong> 块获得锁的时候，那么该对象其他的 <strong>synchronized</strong> 方法和临界区就不能被调用了。因此，在进行同步时，临界区的作用是减小同步的范围。</p><p>有时必须在另一个对象上同步，但是如果你要这样做，就必须确保所有相关的任务都是在同一个任务上同步的。下面的示例演示了当对象中的方法在不同的锁上同步时，两个任务可以同时进入同一对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/SyncOnObject.java</span></span><br><span class="line"><span class="comment">// Synchronizing on another object</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualSynch</span> </span>&#123;</span><br><span class="line">  ConcurrentLinkedQueue&lt;String&gt; trace =</span><br><span class="line">    <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">boolean</span> nap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      trace.add(String.format(<span class="string">&quot;f() &quot;</span> + i));</span><br><span class="line">      <span class="keyword">if</span>(nap) <span class="keyword">new</span> Nap(<span class="number">0.01</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> Object syncObject = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">boolean</span> nap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(syncObject) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        trace.add(String.format(<span class="string">&quot;g() &quot;</span> + i));</span><br><span class="line">        <span class="keyword">if</span>(nap) <span class="keyword">new</span> Nap(<span class="number">0.01</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncOnObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">boolean</span> fNap, <span class="keyword">boolean</span> gNap)</span> </span>&#123;</span><br><span class="line">    DualSynch ds = <span class="keyword">new</span> DualSynch();</span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; cfs =</span><br><span class="line">      Arrays.stream(<span class="keyword">new</span> Runnable[] &#123;</span><br><span class="line">        () -&gt; ds.f(fNap), () -&gt; ds.g(gNap) &#125;)</span><br><span class="line">        .map(CompletableFuture::runAsync)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    cfs.forEach(CompletableFuture::join);</span><br><span class="line">    ds.trace.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;****&quot;</span>);</span><br><span class="line">    test(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">f() 0</span></span><br><span class="line"><span class="comment">g() 0</span></span><br><span class="line"><span class="comment">g() 1</span></span><br><span class="line"><span class="comment">g() 2</span></span><br><span class="line"><span class="comment">g() 3</span></span><br><span class="line"><span class="comment">g() 4</span></span><br><span class="line"><span class="comment">f() 1</span></span><br><span class="line"><span class="comment">f() 2</span></span><br><span class="line"><span class="comment">f() 3</span></span><br><span class="line"><span class="comment">f() 4</span></span><br><span class="line"><span class="comment">****</span></span><br><span class="line"><span class="comment">f() 0</span></span><br><span class="line"><span class="comment">g() 0</span></span><br><span class="line"><span class="comment">f() 1</span></span><br><span class="line"><span class="comment">f() 2</span></span><br><span class="line"><span class="comment">f() 3</span></span><br><span class="line"><span class="comment">f() 4</span></span><br><span class="line"><span class="comment">g() 1</span></span><br><span class="line"><span class="comment">g() 2</span></span><br><span class="line"><span class="comment">g() 3</span></span><br><span class="line"><span class="comment">g() 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>DualSync.f()</code> 方法（通过同步整个方法）在 <strong>this</strong> 上同步，而 <code>g()</code> 方法有一个在 <strong>syncObject</strong> 上同步的 <strong>synchronized</strong> 块。因此，这两个同步是互相独立的。在 <code>test()</code> 方法中运行的两个调用 <code>f()</code> 和 <code>g()</code> 方法的独立任务演示了这一点。<strong>fNap</strong> 和 <strong>gNap</strong> 标志变量分别指示 <code>f()</code> 和 <code>g()</code> 是否应该在其 <strong>for</strong> 循环中调用 <code>Nap()</code> 方法。例如，当 f() 线程休眠时 ，该线程继续持有它的锁，但是你可以看到这并不阻止调用 <code>g()</code> ，反之亦然。</p><h3 id="使用显式锁对象"><a href="#使用显式锁对象" class="headerlink" title="使用显式锁对象"></a>使用显式锁对象</h3><p><strong>java.util.concurrent</strong> 库包含在 <strong>java.util.concurrent.locks</strong> 中定义的显示互斥锁机制。 必须显式地创建，锁定和解锁 <strong>Lock</strong> 对象，因此它产出的代码没有内置 <strong>synchronized</strong> 关键字那么优雅。然而，它在解决某些类型的问题时更加灵活。下面是使用显式 <strong>Lock</strong> 对象重写 <strong>SynchronizedEvenProducer.java</strong> 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/MutexEvenProducer.java</span></span><br><span class="line"><span class="comment">// Preventing thread collisions with mutexes</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenProducer</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      <span class="keyword">new</span> Nap(<span class="number">0.01</span>); <span class="comment">// Cause failure faster</span></span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EvenChecker.test(<span class="keyword">new</span> MutexEvenProducer());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">No odd numbers discovered</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>MutexEvenProducer</strong> 添加一个名为 <strong>lock</strong> 的互斥锁并在 <code>next()</code> 中使用 <code>lock()</code> 和 <code>unlock()</code> 方法创建一个临界区。当你使用 <strong>Lock</strong> 对象时，使用下面显示的习惯用法很重要：在调用 <code>Lock()</code> 之后，你必须放置 <strong>try-finally</strong> 语句，该语句在 <strong>finally</strong> 子句中带有 <code>unlock()</code> 方法 - 这是确保锁总是被释放的惟一方法。注意，<strong>return</strong> 语句必须出现在 <strong>try</strong> 子句中，以确保 <strong>unlock()</strong> 不会过早发生并将数据暴露给第二个任务。</p><p>尽管 <strong>try-finally</strong> 比起使用 <strong>synchronized</strong> 关键字需要用得更多代码，但它也代表了显式锁对象的优势之一。如果使用 <strong>synchronized</strong> 关键字失败，就会抛出异常，但是你没有机会进行任何清理以保持系统处于良好状态。而使用显式锁对象，可以使用 <strong>finally</strong> 子句在系统中维护适当的状态。</p><p>一般来说，当你使用 <strong>synchronized</strong> 的时候，需要编写的代码更少，并且用户出错的机会也大大减少，因此通常只在解决特殊问题时使用显式锁对象。例如，使用 <strong>synchronized</strong> 关键字，你不能尝试获得锁并让其失败，或者你在一段时间内尝试获得锁，然后放弃 - 为此，你必须使用这个并发库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/AttemptLocking.java</span></span><br><span class="line"><span class="comment">// Locks in the concurrent library allow you</span></span><br><span class="line"><span class="comment">// to give up on trying to acquire a lock</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> captured = lock.tryLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;tryLock(): &quot;</span> + captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> captured = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      captured = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(</span><br><span class="line">        <span class="string">&quot;tryLock(2, TimeUnit.SECONDS): &quot;</span> + captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttemptLocking al = <span class="keyword">new</span> AttemptLocking();</span><br><span class="line">    al.untimed(); <span class="comment">// True -- lock is available</span></span><br><span class="line">    al.timed();   <span class="comment">// True -- lock is available</span></span><br><span class="line">    <span class="comment">// Now create a second task to grab the lock:</span></span><br><span class="line">    CompletableFuture.runAsync( () -&gt; &#123;</span><br><span class="line">        al.lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;acquired&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> Nap(<span class="number">0.1</span>);  <span class="comment">// Give the second task a chance</span></span><br><span class="line">    al.untimed(); <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">    al.timed();   <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">tryLock(): true</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class="line"><span class="comment">acquired</span></span><br><span class="line"><span class="comment">tryLock(): false</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>ReentrantLock</strong> 可以尝试或者放弃获取锁，因此如果某些任务已经拥有锁，你可以决定放弃并执行其他操作，而不是一直等到锁释放，就像 <code>untimed()</code> 方法那样。而在 <code>timed()</code> 方法中，则尝试获取可能在 2 秒后没成功而放弃的锁。在 <code>main()</code> 方法中，一个单独的线程被匿名类所创建，并且它会获得锁，因此让 <code>untimed()</code> 和 <code>timed()</code> 方法有东西可以去竞争。</p><p>显式锁比起内置同步锁提供更细粒度的加锁和解锁控制。这对于实现专门的同步并发结构，比如用于遍历链表节点的 <em>交替锁</em> ( <em>hand-over-hand locking</em> ) ，也称为 <em>锁耦合</em> （ <em>lock coupling</em> ）- 该遍历代码要求必须在当前节点的解锁之前捕获下一个节点的锁。</p><h2 id="库组件"><a href="#库组件" class="headerlink" title="库组件"></a>库组件</h2><p><strong>java.util.concurrent</strong> 库提供大量旨在解决并发问题的类，可以帮助你生成更简单，更鲁棒的并发程序。但请注意，这些工具是比起并行流和 <strong>CompletableFuture</strong> 更底层的机制。</p><p>在本节中，我们将看一些使用不同组件的示例，然后讨论一下 <em>lock-free</em>（无锁） 库组件是如何工作的。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>这是一个无界阻塞队列 （ <strong>BlockingQueue</strong> ），用于放置实现了 <strong>Delayed</strong> 接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，因此队首对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有队首元素，并且 <code>poll()</code> 将返回 <strong>null</strong>（正因为这样，你不能将 <strong>null</strong> 放置到这种队列中）。</p><p>下面是一个示例，其中的 <strong>Delayed</strong> 对象自身就是任务，而 <strong>DelayedTaskConsumer</strong> 将最“紧急”的任务（到期时间最长的任务）从队列中取出，然后运行它。注意的是这样 <strong>DelayQueue</strong> 就成为了优先级队列的一种变体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/DelayQueueDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.concurrent.TimeUnit.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> delta;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> trigger;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> List&lt;DelayedTask&gt; sequence =</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  DelayedTask(<span class="keyword">int</span> delayInMilliseconds) &#123;</span><br><span class="line">    delta = delayInMilliseconds;</span><br><span class="line">    trigger = System.nanoTime() +</span><br><span class="line">      NANOSECONDS.convert(delta, MILLISECONDS);</span><br><span class="line">    sequence.add(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(</span><br><span class="line">      trigger - System.nanoTime(), NANOSECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed arg)</span> </span>&#123;</span><br><span class="line">    DelayedTask that = (DelayedTask)arg;</span><br><span class="line">    <span class="keyword">if</span>(trigger &lt; that.trigger) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(trigger &gt; that.trigger) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="keyword">this</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      String.format(<span class="string">&quot;[%d] Task %d&quot;</span>, delta, id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">summary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;(%d:%d)&quot;</span>, id, delta);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndTask</span> <span class="keyword">extends</span> <span class="title">DelayedTask</span> </span>&#123;</span><br><span class="line">    EndTask(<span class="keyword">int</span> delay) &#123; <span class="keyword">super</span>(delay); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sequence.forEach(dt -&gt;</span><br><span class="line">        System.out.println(dt.summary()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DelayQueue&lt;DelayedTask&gt; tasks =</span><br><span class="line">      Stream.concat( <span class="comment">// Random delays:</span></span><br><span class="line">        <span class="keyword">new</span> Random(<span class="number">47</span>).ints(<span class="number">20</span>, <span class="number">0</span>, <span class="number">4000</span>)</span><br><span class="line">          .mapToObj(DelayedTask::<span class="keyword">new</span>),</span><br><span class="line">        <span class="comment">// Add the summarizing task:</span></span><br><span class="line">        Stream.of(<span class="keyword">new</span> DelayedTask.EndTask(<span class="number">4000</span>)))</span><br><span class="line">      .collect(Collectors</span><br><span class="line">        .toCollection(DelayQueue::<span class="keyword">new</span>));</span><br><span class="line">    <span class="keyword">while</span>(tasks.size() &gt; <span class="number">0</span>)</span><br><span class="line">      tasks.take().run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[128] Task 12 [429] Task 6 [551] Task 13 [555] Task 2</span></span><br><span class="line"><span class="comment">[693] Task 3 [809] Task 15 [961] Task 5 [1258] Task 1</span></span><br><span class="line"><span class="comment">[1258] Task 20 [1520] Task 19 [1861] Task 4 [1998] Task</span></span><br><span class="line"><span class="comment">17 [2200] Task 8 [2207] Task 10 [2288] Task 11 [2522]</span></span><br><span class="line"><span class="comment">Task 9 [2589] Task 14 [2861] Task 18 [2868] Task 7</span></span><br><span class="line"><span class="comment">[3278] Task 16 (0:4000)</span></span><br><span class="line"><span class="comment">(1:1258)</span></span><br><span class="line"><span class="comment">(2:555)</span></span><br><span class="line"><span class="comment">(3:693)</span></span><br><span class="line"><span class="comment">(4:1861)</span></span><br><span class="line"><span class="comment">(5:961)</span></span><br><span class="line"><span class="comment">(6:429)</span></span><br><span class="line"><span class="comment">(7:2868)</span></span><br><span class="line"><span class="comment">(8:2200)</span></span><br><span class="line"><span class="comment">(9:2522)</span></span><br><span class="line"><span class="comment">(10:2207)</span></span><br><span class="line"><span class="comment">(11:2288)</span></span><br><span class="line"><span class="comment">(12:128)</span></span><br><span class="line"><span class="comment">(13:551)</span></span><br><span class="line"><span class="comment">(14:2589)</span></span><br><span class="line"><span class="comment">(15:809)</span></span><br><span class="line"><span class="comment">(16:3278)</span></span><br><span class="line"><span class="comment">(17:1998)</span></span><br><span class="line"><span class="comment">(18:2861)</span></span><br><span class="line"><span class="comment">(19:1520)</span></span><br><span class="line"><span class="comment">(20:1258)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>DelayedTask</strong> 包含一个称为 <strong>sequence</strong> 的 <strong>List&lt;DelayedTask&gt;</strong> ，它保存了任务被创建的顺序，因此我们可以看到排序是按照实际发生的顺序执行的。</p><p><strong>Delay</strong> 接口有一个方法， <code>getDelay()</code> ， 该方法用来告知延迟到期有多长时间，或者延迟在多长时间之前已经到期了。这个方法强制我们去使用 <strong>TimeUnit</strong> 类，因为这就是参数类型。这会产生一个非常方便的类，因为你可以很容易地转换单位而无需作任何声明。例如，<strong>delta</strong> 的值是以毫秒为单位存储的，但是 <code>System.nanoTime()</code> 产生的时间则是以纳秒为单位的。你可以转换 <strong>delta</strong> 的值，方法是声明它的单位以及你希望以什么单位来表示，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NANOSECONDS.convert(delta, MILLISECONDS);</span><br></pre></td></tr></table></figure><p>在 <code>getDelay()</code> 中， 所希望的单位是作为 <strong>unit</strong> 参数传递进来的，你使用它将当前时间与触发时间之间的差转换为调用者要求的单位，而无需知道这些单位是什么（这是<em>策略</em>设计模式的一个简单示例，在这种模式中，算法的一部分是作为参数传递进来的）。</p><p>为了排序， <strong>Delayed</strong> 接口还继承了 <strong>Comparable</strong> 接口，因此必须实现 <code>compareTo()</code> , 使其可以产生合理的比较。</p><p>从输出中可以看到，任务创建的顺序对执行顺序没有任何影响 - 相反，任务是按照所期望的延迟顺序所执行的。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>这是一个很基础的优先级队列，它具有可阻塞的读取操作。在下面的示例中， <strong>Prioritized</strong> 对象会被赋予优先级编号。几个 <strong>Producer</strong> 任务的实例会插入 <strong>Prioritized</strong> 对象到 <strong>PriorityBlockingQueue</strong> 中，但插入之间会有随机延时。然后，单个 <strong>Consumer</strong> 任务在执行 <code>take()</code> 时会显示多个选项，<strong>PriorityBlockingQueue</strong> 会将当前具有最高优先级的 <strong>Prioritized</strong> 对象提供给它。</p><p>在 <strong>Prioritized</strong> 中的静态变量 <strong>counter</strong> 是 <strong>AtomicInteger</strong> 类型。这是必要的，因为有多个 <strong>Producer</strong> 并行运行；如果不是 <strong>AtomicInteger</strong> 类型，你将会看到重复的 <strong>id</strong> 号。 这个问题在 <a href="./24-Concurrent-Programming.md">并发编程</a> 的 <a href="./24-Concurrent-Programming.md">构造函数非线程安全</a> 一节中讨论过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevel/PriorityBlockingQueueDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prioritized</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Prioritized</span>&gt;  </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger counter =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter.getAndIncrement();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Prioritized&gt; sequence =</span><br><span class="line">    <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">  Prioritized(<span class="keyword">int</span> priority) &#123;</span><br><span class="line">    <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    sequence.add(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Prioritized arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> priority &lt; arg.priority ? <span class="number">1</span> :</span><br><span class="line">      (priority &gt; arg.priority ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(</span><br><span class="line">      <span class="string">&quot;[%d] Prioritized %d&quot;</span>, priority, id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displaySequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Prioritized pt : sequence) &#123;</span><br><span class="line">      System.out.printf(<span class="string">&quot;(%d:%d)&quot;</span>, pt.id, pt.priority);</span><br><span class="line">      <span class="keyword">if</span>(++count % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndSentinel</span> <span class="keyword">extends</span> <span class="title">Prioritized</span> </span>&#123;</span><br><span class="line">    EndSentinel() &#123; <span class="keyword">super</span>(-<span class="number">1</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger seed =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">private</span> SplittableRandom rand =</span><br><span class="line">    <span class="keyword">new</span> SplittableRandom(seed.getAndAdd(<span class="number">10</span>));</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Prioritized&gt; queue;</span><br><span class="line">  Producer(Queue&lt;Prioritized&gt; q) &#123;</span><br><span class="line">    queue = q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rand.ints(<span class="number">10</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">      .mapToObj(Prioritized::<span class="keyword">new</span>)</span><br><span class="line">      .peek(p -&gt; <span class="keyword">new</span> Nap(rand.nextDouble() / <span class="number">10</span>))</span><br><span class="line">      .forEach(p -&gt; queue.add(p));</span><br><span class="line">    queue.add(<span class="keyword">new</span> Prioritized.EndSentinel());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> PriorityBlockingQueue&lt;Prioritized&gt; q;</span><br><span class="line">  <span class="keyword">private</span> SplittableRandom rand =</span><br><span class="line">    <span class="keyword">new</span> SplittableRandom(<span class="number">47</span>);</span><br><span class="line">  Consumer(PriorityBlockingQueue&lt;Prioritized&gt; q) &#123;</span><br><span class="line">    <span class="keyword">this</span>.q = q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Prioritized pt = q.take();</span><br><span class="line">        System.out.println(pt);</span><br><span class="line">        <span class="keyword">if</span>(pt <span class="keyword">instanceof</span> Prioritized.EndSentinel) &#123;</span><br><span class="line">          pt.displaySequence();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Nap(rand.nextDouble() / <span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PriorityBlockingQueue&lt;Prioritized&gt; queue =</span><br><span class="line">      <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">    CompletableFuture.runAsync(<span class="keyword">new</span> Producer(queue));</span><br><span class="line">    CompletableFuture.runAsync(<span class="keyword">new</span> Producer(queue));</span><br><span class="line">    CompletableFuture.runAsync(<span class="keyword">new</span> Producer(queue));</span><br><span class="line">    CompletableFuture.runAsync(<span class="keyword">new</span> Consumer(queue))</span><br><span class="line">      .join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[15] Prioritized 2</span></span><br><span class="line"><span class="comment">[17] Prioritized 1</span></span><br><span class="line"><span class="comment">[17] Prioritized 5</span></span><br><span class="line"><span class="comment">[16] Prioritized 6</span></span><br><span class="line"><span class="comment">[14] Prioritized 9</span></span><br><span class="line"><span class="comment">[12] Prioritized 0</span></span><br><span class="line"><span class="comment">[11] Prioritized 4</span></span><br><span class="line"><span class="comment">[11] Prioritized 12</span></span><br><span class="line"><span class="comment">[13] Prioritized 13</span></span><br><span class="line"><span class="comment">[12] Prioritized 16</span></span><br><span class="line"><span class="comment">[14] Prioritized 18</span></span><br><span class="line"><span class="comment">[15] Prioritized 23</span></span><br><span class="line"><span class="comment">[18] Prioritized 26</span></span><br><span class="line"><span class="comment">[16] Prioritized 29</span></span><br><span class="line"><span class="comment">[12] Prioritized 17</span></span><br><span class="line"><span class="comment">[11] Prioritized 30</span></span><br><span class="line"><span class="comment">[11] Prioritized 24</span></span><br><span class="line"><span class="comment">[10] Prioritized 15</span></span><br><span class="line"><span class="comment">[10] Prioritized 22</span></span><br><span class="line"><span class="comment">[8] Prioritized 25</span></span><br><span class="line"><span class="comment">[8] Prioritized 11</span></span><br><span class="line"><span class="comment">[8] Prioritized 10</span></span><br><span class="line"><span class="comment">[6] Prioritized 31</span></span><br><span class="line"><span class="comment">[3] Prioritized 7</span></span><br><span class="line"><span class="comment">[2] Prioritized 20</span></span><br><span class="line"><span class="comment">[1] Prioritized 3</span></span><br><span class="line"><span class="comment">[0] Prioritized 19</span></span><br><span class="line"><span class="comment">[0] Prioritized 8</span></span><br><span class="line"><span class="comment">[0] Prioritized 14</span></span><br><span class="line"><span class="comment">[0] Prioritized 21</span></span><br><span class="line"><span class="comment">[-1] Prioritized 28</span></span><br><span class="line"><span class="comment">(0:12)(2:15)(1:17)(3:1)(4:11)</span></span><br><span class="line"><span class="comment">(5:17)(6:16)(7:3)(8:0)(9:14)</span></span><br><span class="line"><span class="comment">(10:8)(11:8)(12:11)(13:13)(14:0)</span></span><br><span class="line"><span class="comment">(15:10)(16:12)(17:12)(18:14)(19:0)</span></span><br><span class="line"><span class="comment">(20:2)(21:0)(22:10)(23:15)(24:11)</span></span><br><span class="line"><span class="comment">(25:8)(26:18)(27:-1)(28:-1)(29:16)</span></span><br><span class="line"><span class="comment">(30:11)(31:6)(32:-1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>与前面的示例一样，<strong>Prioritized</strong> 对象的创建顺序在 <strong>sequence</strong> 的 <strong>list</strong> 对象上所记入，以便与实际执行顺序进行比较。 <strong>EndSentinel</strong> 是用于告知 <strong>Consumer</strong> 对象关闭的特殊类型。</p><p><strong>Producer</strong> 使用 <strong>AtomicInteger</strong> 变量为 <strong>SplittableRandom</strong> 设置随机生成种子，以便不同的 <strong>Producer</strong> 生成不同的队列。 这是必需的，因为多个生产者并行创建，如果不是这样，创建过程并不会是线程安全的。</p><p><strong>Producer</strong> 和 <strong>Consumer</strong> 通过 <strong>PriorityBlockingQueue</strong> 相互连接。因为阻塞队列的性质提供了所有必要的同步，因为阻塞队列的性质提供了所有必要的同步，请注意，显式同步是并不需要的 — 从队列中读取数据时，你不用考虑队列中是否有任何元素，因为队列在没有元素时将阻塞读取。</p><h3 id="无锁集合"><a href="#无锁集合" class="headerlink" title="无锁集合"></a>无锁集合</h3><p><a href="./12-Collections.md">集合</a> 章节强调集合是基本的编程工具，这也要求包含并发性。因此，早期的集合比如 <strong>Vector</strong> 和 <strong>Hashtable</strong> 有许多使用 <strong>synchronized</strong> 机制的方法。当这些集合不是在多线程应用中使用时，这就导致了不可接收的开销。在 Java 1.2 版本中，新的集合库是非同步的，而给 <strong>Collection</strong> 类赋予了各种 <strong>static</strong> <strong>synchronized</strong> 修饰的方法来同步不同的集合类型。虽然这是一个改进，因为它让你可以选择是否对集合使用同步，但是开销仍然基于同步锁定。 Java 5 版本添加新的集合类型，专门用于增加线程安全性能，使用巧妙的技术来消除锁定。</p><p>无锁集合有一个有趣的特性：只要读取者仅能看到已完成修改的结果，对集合的修改就可以同时发生在读取发生时。这是通过一些策略实现的。为了让你了解它们是如何工作的，我们来看看其中的一些。</p><h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>使用“复制”策略，修改是在数据结构一部分的单独副本（或有时是整个数据的副本）上进行的，并且在整个修改过程期间这个副本是不可见的。仅当修改完成时，修改后的结构才与“主”数据结构安全地交换，然后读取者才会看到修改。</p><p>在 <strong>CopyOnWriteArrayList</strong> ，写入操作会复制整个底层数组。保留原来的数组，以便在修改复制的数组时可以线程安全地进行读取。当修改完成后，原子操作会将其交换到新数组中，以便新的读取操作能够看到新数组内容。 <strong>CopyOnWriteArrayList</strong> 的其中一个好处是，当多个迭代器遍历和修改列表时，它不会抛出 <strong>ConcurrentModificationException</strong> 异常，因此你不用就像过去必须做的那样，编写特殊的代码来防止此类异常。</p><p><strong>CopyOnWriteArraySet</strong> 使用 <strong>CopyOnWriteArrayList</strong> 来实现其无锁行为。</p><p><strong>ConcurrentHashMap</strong> 和 <strong>ConcurrentLinkedQueue</strong> 使用类似的技术来允许并发读写，但是只复制和修改集合的一部分，而不是整个集合。然而，读取者仍然不会看到任何不完整的修改。<strong>ConcurrentHashMap</strong> <strong>不会抛出 concurrentmodificationexception</strong> 异常。</p><h4 id="比较并交换-CAS"><a href="#比较并交换-CAS" class="headerlink" title="比较并交换 (CAS)"></a>比较并交换 (CAS)</h4><p>在 比较并交换 (CAS) 中，你从内存中获取一个值，并在计算新值时保留原始值。然后使用 CAS 指令，它将原始值与当前内存中的值进行比较，如果这两个值是相等的，则将内存中的旧值替换为计算新值的结果，所有操作都在一个原子操作中完成。如果原始值比较失败，则不会进行交换，因为这意味着另一个线程同时修改了内存。在这种情况下，你的代码必须再次尝试，获取一个新的原始值并重复该操作。</p><p>如果内存仅轻量竞争，CAS 操作几乎总是在没有重复尝试的情况下完成，因此它非常快。相反，<strong>synchronized</strong> 操作需要考虑每次获取和释放锁的成本，这要昂贵得多，而且没有额外的好处。随着内存竞争的增加，使用 CAS 的操作会变慢，因为它必须更频繁地重复自己的操作，但这是对更多资源竞争的动态响应。这确实是一种优雅的方法。</p><p>最重要的是，许多现代处理器的汇编语言中都有一条 CAS 指令，并且也被 JVM 中的 CAS 操作(例如 <strong>Atomic</strong> 类中的操作)所使用。CAS 指令在硬件层面中是原子性的，并且与你所期望的操作一样快。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>本附录主要是为了让你在遇到底层并发代码时能对此有一定的了解，尽管本文还远没对这个主题进行全面的讨论。为此，你需要先从阅读由 Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea (Addison-Wesley 出版社, 2006)所著作的 <em>Java Concurrency in Practice</em> （国内译名：Java 并发编程实战）开始了解。理想情况下，这本书会完全吓跑你在 Java 中尝试去编写底层并发代码。如果没有，那么你几乎肯定患上了达克效应(DunningKruger Effect)，这是一种认知偏差，“你知道的越少，对自己的能力就越有信心”。请记住，当前的语言设计人员仍然在清理早期语言设计人员过于自信造成的混乱(例如，查看 Thread 类中有多少方法被弃用，而 volatile 直到 Java 5 才正确工作)。</p><p>以下是并发编程的步骤:</p><ol><li>不要使用它。想一些其他方法来使你写的程序变的更快。</li><li>如果你必须使用它，请使用在 <a href="./24-Concurrent-Programming.md">并发编程</a> - parallel Streams and CompletableFutures 中展示的现代高级工具。</li><li>不要在任务间共享变量，在任务之间必须传递的任何信息都应该使用 Java.util.concurrent 库中的并发数据结构。</li><li>如果必须在任务之间共享变量，请使用 java.util.concurrent.atomic 里面其中一种类型，或在任何直接或间接访问这些变量的方法上应用 synchronized。 当你不这样做时，很容易被愚弄，以为你已经把所有东西都包括在内。 说真的，尝试使用步骤 3。</li><li>如果步骤 4 产生的结果太慢，你可以尝试使用 volatile 或其他技术来调整代码，但是如果你正在阅读本书并认为你已经准备好尝试这些方法，那么你就超出了你的深度。 返回步骤＃1。</li></ol><p>通常可以只使用 java.util.concurrent 库组件来编写并发程序，完全避免来自应用 volatile 和 synchronized 的挑战。注意，我可以通过 <a href="./24-Concurrent-Programming.md">并发编程</a> 中的示例来做到这一点。</p><blockquote id="fn_1"><sup>1</sup>. 在某些平台上，特别是 Windows ，默认值可能非常难以查明。你可以使用 -Xss 标志调整堆栈大小。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 引自 Brian Goetz, Java Concurrency in Practice 一书的作者 , 该书由 Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea 联合著作 (Addison-Wesley 出版社, 2006)。↩<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. 请注意，在 64 位处理器上可能不会发生这种情况，从而消除了这个问题。<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. 这个测试的推论是，“如果某人表示线程是容易并且简单的，请确保这个人没有对你的项目做出重要的决策。如果那个人已经做出，那么你就已经陷入麻烦之中了。”<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. 这在即将产生的 C++ 的标准中得到了补救。<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-并发底层原理&quot;&gt;&lt;a href=&quot;#附录-并发底层原理&quot; class=&quot;headerlink&quot; title=&quot;附录:并发底层原理&quot;&gt;&lt;/a&gt;附录:并发底层原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;尽管不建议你自己编写底层 Java 并发代码，但是这样通常</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-javadoc/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-javadoc/</id>
    <published>2022-06-23T15:31:23.683Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-文档注释"><a href="#附录-文档注释" class="headerlink" title="附录:文档注释"></a>附录:文档注释</h1><p>编写代码文档的最大问题可能是维护该文档。如果文档和代码是分开的，那么每次更改代码时更改文档都会变得很繁琐。解决方案似乎很简单：将代码链接到文档。最简单的方法是将所有内容放在同一个文件中。然而，要完成这完整的画面，您需要一个特殊的注释语法来标记文档，以及一个工具来将这些注释提取为有用的表单中。这就是 Java 所做的。</p><p>提取注释的工具称为 Javadoc，它是 JDK 安装的一部分。它使用 Java 编译器中的一些技术来寻找特殊的注释标记。它不仅提取由这些标记所标记的信息，还提取与注释相邻的类名或方法名。通过这种方式，您就可以用最少的工作量来生成合适的程序文档。</p><p>Javadoc 输出为一个 html 文件，您可以使用 web 浏览器查看它。对于 Javadoc，您有一个简单的标准来创建文档，因此您可以期望所有 Java libraries 都有文档。</p><p>此外，您可以编写自己的 Javadoc 处理程序 doclet，对于 Javadoc（例如，以不同的格式生成输出）。</p><p>以下是对 Javadoc 基础知识的介绍和概述。在 JDK 文档中可以找到完整的描述。</p><h2 id="句法规则"><a href="#句法规则" class="headerlink" title="句法规则"></a>句法规则</h2><p>所有 Javadoc 指令都发生在以 <strong>/**</strong> 开头(但仍然以 <strong>*/</strong> 结尾)的注释中。</p><p>使用 Javadoc 有两种主要方法:</p><p>嵌入 HTML 或使用“doc 标签”。独立的 doc 标签是指令它以 <strong>@</strong> 开头，放在注释行的开头。(然而，前面的 <strong>*</strong> 将被忽略。)可能会出现内联 doc 标签</p><p>Javadoc 注释中的任何位置，也可以，以一个 <strong>@</strong> 开头，但是被花括号包围。</p><p>有三种类型的注释文档，它们对应于注释前面的元素:类、字段或方法。也就是说，类注释出现在类定义之前，字段注释出现在字段定义之前，方法注释出现在方法定义之前。举个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javadoc/Documentation1.java</span></span><br><span class="line"><span class="comment">/** 一个类注释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Documentation1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 一个属性注释 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/** 一个方法注释 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Javadoc 处理注释文档仅适用于 <strong>公共</strong> 和 <strong>受保护</strong> 的成员。</p><p>默认情况下，将忽略对 <strong>私有成员</strong> 和包访问成员的注释（请参阅<a href="/docs/book/07-Implementation-Hiding.md">“隐藏实现”</a>一章），并且您将看不到任何输出。</p><p>这是有道理的，因为仅客户端程序员的观点是，在文件外部可以使用 <strong>公共成员</strong> 和 <strong>受保护成员</strong> 。 您可以使用 <strong>-private</strong> 标志和包含 <strong>私人</strong> 成员。</p><p>要通过 Javadoc 处理前面的代码，命令是：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc Documentation1.java</span><br></pre></td></tr></table></figure><p>这将产生一组 HTML 文件。 如果您在浏览器中打开 index.html，您将看到结果与所有其他 Java 文档具有相同的标准格式，因此用户对这种格式很熟悉，并可以轻松地浏览你的类。</p><h2 id="内嵌-HTML"><a href="#内嵌-HTML" class="headerlink" title="内嵌 HTML"></a>内嵌 HTML</h2><p>Javadoc 传递未修改的 HTML 代码，用以生成的 HTML 文档。这使你可以充分利用 HTML。但是，这样做的主要目的是让你格式化代码，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javadoc/Documentation2.java</span></span><br><span class="line"><span class="comment">/** &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* System.out.println(new Date());</span></span><br><span class="line"><span class="comment">* &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Documentation2</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>您你也可以像在其他任何 Web 文档中一样使用 HTML 来格式化说明中的文字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javadoc/Documentation3.java</span></span><br><span class="line"><span class="comment">/** You can &lt;em&gt;even&lt;/em&gt; insert a list:</span></span><br><span class="line"><span class="comment">* &lt;ol&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt; Item one</span></span><br><span class="line"><span class="comment">* &lt;li&gt; Item two</span></span><br><span class="line"><span class="comment">* &lt;li&gt; Item three</span></span><br><span class="line"><span class="comment">* &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Documentation3</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>请注意，在文档注释中，Javadoc 删除了行首的星号以及前导空格。 Javadoc 重新格式化了所有内容，使其符合标准文档的外观。不要将诸如 \<h1\>或 \<hr\>之类的标题用作嵌入式 HTML，因为 Javadoc 会插入自己的标题，后插入的标题将对其生成的文档产生干扰。</hr\></h1\></p><p>所有类型的注释文档（类，字段和方法）都可以支持嵌入式 HTML。</p><h2 id="示例标签"><a href="#示例标签" class="headerlink" title="示例标签"></a>示例标签</h2><p>以下是一些可用于代码文档的 Javadoc 标记。在尝试使用 Javadoc 进行任何认真的操作之前，请查阅 JDK 文档中的 Javadoc 参考，以了解使用 Javadoc 的所有不同方法。</p><h3 id="see"><a href="#see" class="headerlink" title="@see"></a>@see</h3><p>这个标签可以将其他的类连接到文档中，Javadoc 将使用 @see 标记超链接到其他文档中，形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@see</span> classname</span><br><span class="line"><span class="meta">@see</span> fully-qualified-classname</span><br><span class="line"><span class="meta">@see</span> fully-qualified-classname#method-name</span><br></pre></td></tr></table></figure><p>每个都向生成的文档中添加超链接的“另请参阅”条目。 Javadoc 不会检查超链接的有效性。</p><h3 id="link-package-class-member-label"><a href="#link-package-class-member-label" class="headerlink" title="{@link package.class#member label}"></a>{@link package.class#member label}</h3><p>和 @see 非常相似，不同之处在于它可以内联使用，并使用标签作为超链接文本，而不是“另请参阅”。</p><h3 id="docRoot"><a href="#docRoot" class="headerlink" title="{@docRoot}"></a>{@docRoot}</h3><p>生成文档根目录的相对路径。对于显式超链接到文档树中的页面很有用。</p><h3 id="inheritDoc"><a href="#inheritDoc" class="headerlink" title="{@inheritDoc}"></a>{@inheritDoc}</h3><p>将文档从此类的最近基类继承到当前文档注释中。</p><h3 id="version"><a href="#version" class="headerlink" title="@version"></a>@version</h3><p>其形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@version</span> version-information</span><br></pre></td></tr></table></figure><p>其中 version-information 是你认为适合包含的任何重要信息。当在 Javadoc 命令行上放置 -version 标志时，特别在生成的 HTML 文档中用于生成 version 信息。</p><h3 id="author"><a href="#author" class="headerlink" title="@author"></a>@author</h3><p>其形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@author author-information</span><br></pre></td></tr></table></figure><p>author-information 大概率是你的名字，但是一样可以包含你的 email 地址或者其他合适的信息。当在 Javadoc 命令行上放置 -author 标志的时候，在生成的 HTML 文档中特别注明了作者信息。</p><p>你可以对作者列表使用多个作者标签，但是必须连续放置它们。所有作者信息都集中在生成的 HTML 中的单个段落中。</p><h3 id="since"><a href="#since" class="headerlink" title="@since"></a>@since</h3><p>此标记指示此代码的版本开始使用特定功能。例如，它出现在 HTML Java 文档中，以指示功能首次出现的 JDK 版本。</p><h3 id="param"><a href="#param" class="headerlink" title="@param"></a>@param</h3><p>这将生成有关方法参数的文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> parameter-name description</span><br></pre></td></tr></table></figure><p>其中 parameter-name 是方法参数列表中的标识符，description 是可以在后续行中继续的文本。当遇到新的文档标签时，说明被视为完成。@param 标签的可以任意使用，大概每个参数一个。</p><h3 id="return"><a href="#return" class="headerlink" title="@return"></a>@return</h3><p>这记录了返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@return</span> description</span><br></pre></td></tr></table></figure><p>其中 description 给出了返回值的含义。它可延续到后面的行内。</p><h3 id="throws"><a href="#throws" class="headerlink" title="@throws"></a>@throws</h3><p>一个方法可以产生许多不同类型的异常，所有这些异常都需要描述。异常标记的形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@throws</span> fully-qualified-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> <span class="title">description</span></span></span><br></pre></td></tr></table></figure><p>fully-qualified-class-name 给出明确的异常分类名称，并且 description （可延续到后面的行内）告诉你为什么这特定类型的异常会在方法调用后出现。</p><h3 id="deprecated"><a href="#deprecated" class="headerlink" title="@deprecated"></a>@deprecated</h3><p>这表示已被改进的功能取代的功能。deprecated 标记表明你不再使用此特定功能，因为将来有可能将其删除。标记为@不赞成使用的方法会导致编译器在使用时发出警告。在 Java 5 中，@deprecated Javadoc 标记已被 @Deprecated 注解取代（在<a href>注解</a>一章中进行了描述）。</p><h2 id="文档示例"><a href="#文档示例" class="headerlink" title="文档示例"></a>文档示例</h2><p><strong>objects/HelloDate.java</strong> 是带有文档注释的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javadoc/HelloDateDoc.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/** The first On Java 8 example program.</span></span><br><span class="line"><span class="comment"> * Displays a String and today&#x27;s date.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bruce Eckel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> www.MindviewInc.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 5.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDateDoc</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Entry point to class &amp; application.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args array of String arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> exceptions No exceptions thrown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, it&#x27;s: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Hello, it&#x27;s:</span></span><br><span class="line"><span class="comment">Tue May 09 06:07:27 MDT 2017</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>你可以在 Java 标准库的源代码中找到许多 Javadoc 注释文档的示例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-文档注释&quot;&gt;&lt;a href=&quot;#附录-文档注释&quot; class=&quot;headerlink&quot; title=&quot;附录:文档注释&quot;&gt;&lt;/a&gt;附录:文档注释&lt;/h1&gt;&lt;p&gt;编写代码文档的最大问题可能是维护该文档。如果文档和代码是分开的，那么每次更改代码时更改文档都会变得很</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-io-streams/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-io-streams/</id>
    <published>2022-06-23T15:31:23.681Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-流式-IO"><a href="#附录-流式-IO" class="headerlink" title="附录:流式 IO"></a>附录:流式 IO</h1><blockquote><p>Java 7 引入了一种简单明了的方式来读写文件和操作目录。大多情况下，<a href="./17-Files.md">文件</a>这一章所介绍的那些库和技术就足够你用了。但是，如果你必须面对一些特殊的需求和比较底层的操作，或者处理一些老版本的代码，那么你就必须了解本附录中的内容。</p></blockquote><p>对于编程语言的设计者来说，实现良好的输入/输出（I/O）系统是一项比较艰难的任务，不同实现方案的数量就可以证明这点。其中的挑战似乎在于要涵盖所有的可能性，你不仅要覆盖到不同的 I/O 源和 I/O 接收器（如文件、控制台、网络连接等），还要实现多种与它们进行通信的方式（如顺序、随机访问、缓冲、二进制、字符、按行和按字等）。</p><p>Java 类库的设计者通过创建大量的类来解决这一难题。一开始，你可能会对 Java I/O 系统提供了如此多的类而感到不知所措。Java 1.0 之后，Java 的 I/O 类库发生了明显的改变，在原来面向字节的类中添加了面向字符和基于 Unicode 的类。在 Java 1.4 中，为了改进性能和功能，又添加了 <code>nio</code> 类（全称是 “new I/O”，Java 1.4 引入，到现在已经很多年了）。这部分在<a href="./Appendix-New-IO.md">附录：新 I/O</a> 中介绍。</p><p>因此，要想充分理解 Java I/O 系统以便正确运用它，我们需要学习一定数量的类。另外，理解 I/O 类库的演化过程也很有必要，因为如果缺乏历史的眼光，很快我们就会对什么时候该使用哪些类，以及什么时候不该使用它们而感到困惑。</p><p>编程语言的 I/O 类库经常使用<strong>流</strong>这个抽象概念，它将所有数据源或者数据接收器表示为能够产生或者接收数据片的对象。</p><blockquote><p><strong>注意</strong>：Java 8 函数式编程中的 <code>Stream</code> 类和这里的 I/O stream 没有任何关系。这又是另一个例子，如果再给设计者一次重来的机会，他们将使用不同的术语。</p></blockquote><p>I/O 流屏蔽了实际的 I/O 设备中处理数据的细节：</p><ol><li>字节流对应原生的二进制数据；</li><li>字符流对应字符数据，它会自动处理与本地字符集之间的转换；</li><li>缓冲流可以提高性能，通过减少底层 API 的调用次数来优化 I/O。</li></ol><p>从 JDK 文档的类层次结构中可以看到，Java 类库中的 I/O 类分成了输入和输出两部分。在设计 Java 1.0 时，类库的设计者们就决定让所有与输入有关系的类都继承自 <code>InputStream</code>，所有与输出有关系的类都继承自 <code>OutputStream</code>。所有从 <code>InputStream</code> 或 <code>Reader</code> 派生而来的类都含有名为 <code>read()</code> 的基本方法，用于读取单个字节或者字节数组。同样，所有从 <code>OutputStream</code> 或 <code>Writer</code> 派生而来的类都含有名为 <code>write()</code> 的基本方法，用于写单个字节或者字节数组。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。</p><p>我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供所期望的功能（这是<strong>装饰器设计模式</strong>）。为了创建一个流，你却要创建多个对象，这也是 Java I/O 类库让人困惑的主要原因。</p><p>这里我只会提供这些类的概述，并假定你会使用 JDK 文档来获取它们的详细信息（比如某个类的所以方法的详细列表）。</p><h2 id="输入流类型"><a href="#输入流类型" class="headerlink" title="输入流类型"></a>输入流类型</h2><p><code>InputStream</code> 表示那些从不同数据源产生输入的类，如<a href="#table-io-1">表 I/O-1</a> 所示，这些数据源包括：</p><ol><li>字节数组；</li><li><code>String</code> 对象；</li><li>文件；</li><li>“管道”，工作方式与实际生活中的管道类似：从一端输入，从另一端输出；</li><li>一个由其它种类的流组成的序列，然后我们可以把它们汇聚成一个流；</li><li>其它数据源，如 Internet 连接。</li></ol><p>每种数据源都有相应的 <code>InputStream</code> 子类。另外，<code>FilterInputStream</code> 也属于一种 <code>InputStream</code>，它的作用是为“装饰器”类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起，这个我们稍后再讨论。</p><p><span id="table-io-1"><strong>表 I/O-1 <code>InputStream</code> 类型</strong></span></p><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:left">功能</th><th style="text-align:left">构造器参数</th><th style="text-align:left">如何使用</th></tr></thead><tbody><tr><td style="text-align:center"><code>ByteArrayInputStream</code></td><td style="text-align:left">允许将内存的缓冲区当做 <code>InputStream</code> 使用</td><td style="text-align:left">缓冲区，字节将从中取出</td><td style="text-align:left">作为一种数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用接口</td></tr><tr><td style="text-align:center"><code>StringBufferInputStream</code></td><td style="text-align:left">将 <code>String</code> 转换成 <code>InputStream</code></td><td style="text-align:left">字符串。底层实现实际使用 <code>StringBuffer</code></td><td style="text-align:left">作为一种数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用接口</td></tr><tr><td style="text-align:center"><code>FileInputStream</code></td><td style="text-align:left">用于从文件中读取信息</td><td style="text-align:left">字符串，表示文件名、文件或 <code>FileDescriptor</code> 对象</td><td style="text-align:left">作为一种数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用接口</td></tr><tr><td style="text-align:center"><code>PipedInputStream</code></td><td style="text-align:left">产生用于写入相关 <code>PipedOutputStream</code> 的数据。实现“管道化”概念</td><td style="text-align:left"><code>PipedOutputSteam</code></td><td style="text-align:left">作为多线程中的数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用接口</td></tr><tr><td style="text-align:center"><code>SequenceInputStream</code></td><td style="text-align:left">将两个或多个 <code>InputStream</code> 对象转换成一个 <code>InputStream</code></td><td style="text-align:left">两个 <code>InputStream</code> 对象或一个容纳 <code>InputStream</code> 对象的容器 <code>Enumeration</code></td><td style="text-align:left">作为一种数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用接口</td></tr><tr><td style="text-align:center"><code>FilterInputStream</code></td><td style="text-align:left">抽象类，作为“装饰器”的接口。其中，“装饰器”为其它的 <code>InputStream</code> 类提供有用的功能。见<a href="#table-io-3">表 I/O-3</a></td><td style="text-align:left">见<a href="#table-io-3">表 I/O-3</a></td><td style="text-align:left">见<a href="#table-io-3">表 I/O-3</a></td></tr></tbody></table></div><h2 id="输出流类型"><a href="#输出流类型" class="headerlink" title="输出流类型"></a>输出流类型</h2><p>如<a href="#table-io-2">表 I/O-2</a> 所示，该类别的类决定了输出所要去往的目标：字节数组（但不是 <code>String</code>，当然，你也可以用字节数组自己创建）、文件或管道。</p><p>另外，<code>FilterOutputStream</code> 为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来，这些稍后会讨论。</p><p><span id="table-io-2"><strong>表 I/O-2：<code>OutputStream</code> 类型</strong></span></p><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:left">功能</th><th style="text-align:left">构造器参数</th><th style="text-align:left">如何使用</th></tr></thead><tbody><tr><td style="text-align:center"><code>ByteArrayOutputStream</code></td><td style="text-align:left">在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区</td><td style="text-align:left">缓冲区初始大小（可选）</td><td style="text-align:left">用于指定数据的目的地：将其与 <code>FilterOutputStream</code> 对象相连以提供有用接口</td></tr><tr><td style="text-align:center"><code>FileOutputStream</code></td><td style="text-align:left">用于将信息写入文件</td><td style="text-align:left">字符串，表示文件名、文件或 <code>FileDescriptor</code> 对象</td><td style="text-align:left">用于指定数据的目的地：将其与 <code>FilterOutputStream</code> 对象相连以提供有用接口</td></tr><tr><td style="text-align:center"><code>PipedOutputStream</code></td><td style="text-align:left">任何写入其中的信息都会自动作为相关 <code>PipedInputStream</code> 的输出。实现“管道化”概念</td><td style="text-align:left"><code>PipedInputStream</code></td><td style="text-align:left">指定用于多线程的数据的目的地：将其与 <code>FilterOutputStream</code> 对象相连以提供有用接口</td></tr><tr><td style="text-align:center"><code>FilterOutputStream</code></td><td style="text-align:left">抽象类，作为“装饰器”的接口。其中，“装饰器”为其它 <code>OutputStream</code> 提供有用功能。见<a href="#table-io-4">表 I/O-4</a></td><td style="text-align:left">见<a href="#table-io-4">表 I/O-4</a></td><td style="text-align:left">见<a href="#table-io-4">表 I/O-4</a></td></tr></tbody></table></div><h2 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h2><p>装饰器在<a href="./20-Generics.md">泛型</a>这一章引入。Java I/O 类库需要多种不同功能的组合，这正是使用装饰器模式的原因所在<sup><a href="#fn_1" id="reffn_1">1</a></sup>。而之所以存在 <strong>filter</strong>（过滤器）类，是因为让抽象类 <strong>filter</strong> 作为所有装饰器类的基类。装饰器必须具有和它所装饰对象相同的接口，但它也可以扩展接口，不过这种情况只发生在个别 <strong>filter</strong> 类中。</p><p>但是，装饰器模式也有一个缺点：在编写程序的时候，它给我们带来了相当多的灵活性（因为我们可以很容易地对属性进行混搭），但它同时也增加了代码的复杂性。Java I/O 类库操作不便的原因在于：我们必须创建许多类（“核心” I/O 类型加上所有的装饰器）才能得到我们所希望的单个 I/O 对象。</p><p><code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 是用来提供装饰器类接口以控制特定输入流 <code>InputStream</code> 和 输出流 <code>OutputStream</code> 的两个类，但它们的名字并不是很直观。<code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 分别从 I/O 类库中的基类 <code>InputStream</code> 和 <code>OutputStream</code> 派生而来，这两个类是创建装饰器的必要条件（这样它们才能为所有被装饰的对象提供统一接口）。</p><h3 id="通过-FilterInputStream-从-InputStream-读取"><a href="#通过-FilterInputStream-从-InputStream-读取" class="headerlink" title="通过 FilterInputStream 从 InputStream 读取"></a>通过 <code>FilterInputStream</code> 从 <code>InputStream</code> 读取</h3><p><code>FilterInputStream</code> 类能够完成两件截然不同的事情。其中，<code>DataInputStream</code> 允许我们读取不同的基本数据类型和 <code>String</code> 类型的对象（所有方法都以 “read” 开头，例如 <code>readByte()</code>、<code>readFloat()</code>等等）。搭配其对应的 <code>DataOutputStream</code>，我们就可以通过数据“流”将基本数据类型的数据从一个地方迁移到另一个地方。具体是那些“地方”是由<a href="#table-io-1">表 I/O-1</a> 中的那些类决定的。</p><p>其它 <code>FilterInputStream</code> 类则在内部修改 <code>InputStream</code> 的行为方式：是否缓冲，是否保留它所读过的行（允许我们查询行数或设置行数），以及是否允许把单个字符推回输入流等等。最后两个类看起来就像是为了创建编译器提供的（它们被添加进来可能是为了对“用 Java 构建编译器”实现提供支持），因此我们在一般编程中不会用到它们。</p><p>在实际应用中，不管连接的是什么 I/O 设备，我们基本上都会对输入进行缓冲。所以当初 I/O 类库如果能默认都让输入进行缓冲，同时将无缓冲输入作为一种特殊情况（或者只是简单地提供一个方法调用），这样会更加合理，而不是像现在这样迫使我们基本上每次都得手动添加缓冲。</p><p><span id="table-io-3"><strong>表 I/O-3：<code>FilterInputStream</code> 类型</strong></span></p><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:left">功能</th><th style="text-align:left">构造器参数</th><th style="text-align:left">如何使用</th></tr></thead><tbody><tr><td style="text-align:center"><code>DataInputStream</code></td><td style="text-align:left">与 <code>DataOutputStream</code> 搭配使用，按照移植方式从流读取基本数据类型（<code>int</code>、<code>char</code>、<code>long</code> 等）</td><td style="text-align:left"><code>InputStream</code></td><td style="text-align:left">包含用于读取基本数据类型的全部接口</td></tr><tr><td style="text-align:center"><code>BufferedInputStream</code></td><td style="text-align:left">使用它可以防止每次读取时都得进行实际写操作。代表“使用缓冲区”</td><td style="text-align:left"><code>InputStream</code>，可以指定缓冲区大小（可选）</td><td style="text-align:left">本质上不提供接口，只是向进程添加缓冲功能。与接口对象搭配</td></tr><tr><td style="text-align:center"><code>LineNumberInputStream</code></td><td style="text-align:left">跟踪输入流中的行号，可调用 <code>getLineNumber()</code> 和 <code>setLineNumber(int)</code></td><td style="text-align:left"><code>InputStream</code></td><td style="text-align:left">仅增加了行号，因此可能要与接口对象搭配使用</td></tr><tr><td style="text-align:center"><code>PushbackInputStream</code></td><td style="text-align:left">具有能弹出一个字节的缓冲区，因此可以将读到的最后一个字符回退</td><td style="text-align:left"><code>InputStream</code></td><td style="text-align:left">通常作为编译器的扫描器，我们可能永远也不会用到</td></tr></tbody></table></div><h3 id="通过-FilterOutputStream-向-OutputStream-写入"><a href="#通过-FilterOutputStream-向-OutputStream-写入" class="headerlink" title="通过 FilterOutputStream 向 OutputStream 写入"></a>通过 <code>FilterOutputStream</code> 向 <code>OutputStream</code> 写入</h3><p>与 <code>DataInputStream</code> 对应的是 <code>DataOutputStream</code>，它可以将各种基本数据类型和 <code>String</code> 类型的对象格式化输出到“流”中，。这样一来，任何机器上的任何 <code>DataInputStream</code> 都可以读出它们。所有方法都以 “write” 开头，例如 <code>writeByte()</code>、<code>writeFloat()</code> 等等。</p><p><code>PrintStream</code> 最初的目的就是为了以可视化格式打印所有基本数据类型和 <code>String</code> 类型的对象。这和 <code>DataOutputStream</code> 不同，后者的目的是将数据元素置入“流”中，使 <code>DataInputStream</code> 能够可移植地重构它们。</p><p><code>PrintStream</code> 内有两个重要方法：<code>print()</code> 和 <code>println()</code>。它们都被重载了，可以打印各种各种数据类型。<code>print()</code> 和 <code>println()</code> 之间的差异是，后者在操作完毕后会添加一个换行符。</p><p><code>PrintStream</code> 可能会造成一些问题，因为它捕获了所有 <code>IOException</code>（因此，我们必须使用 <code>checkError()</code> 自行测试错误状态，如果出现错误它会返回 <code>true</code>）。另外，<code>PrintStream</code> 没有处理好国际化问题。这些问题都在 <code>PrintWriter</code> 中得到了解决，这在后面会讲到。</p><p><code>BufferedOutputStream</code> 是一个修饰符，表明这个“流”使用了缓冲技术，因此每次向流写入的时候，不是每次都会执行物理写操作。我们在进行输出操作的时候可能会经常用到它。</p><p><span id="table-io-4"><strong>表 I/O-4：<code>FilterOutputStream</code> 类型</strong></span></p><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:left">功能</th><th style="text-align:left">构造器参数</th><th style="text-align:left">如何使用</th></tr></thead><tbody><tr><td style="text-align:center"><code>DataOutputStream</code></td><td style="text-align:left">与 <code>DataInputStream</code> 搭配使用，因此可以按照移植方式向流中写入基本数据类型（<code>int</code>、<code>char</code>、<code>long</code> 等）</td><td style="text-align:left"><code>OutputStream</code></td><td style="text-align:left">包含用于写入基本数据类型的全部接口</td></tr><tr><td style="text-align:center"><code>PrintStream</code></td><td style="text-align:left">用于产生格式化输出。其中 <code>DataOutputStream</code> 处理数据的存储，<code>PrintStream</code> 处理显示</td><td style="text-align:left"><code>OutputStream</code>，可以用 <code>boolean</code> 值指示是否每次换行时清空缓冲区（可选）</td><td style="text-align:left">应该是对 <code>OutputStream</code> 对象的 <code>final</code> 封装。可能会经常用到它</td></tr><tr><td style="text-align:center"><code>BufferedOutputStream</code></td><td style="text-align:left">使用它以避免每次发送数据时都进行实际的写操作。代表“使用缓冲区”。可以调用 <code>flush()</code> 清空缓冲区</td><td style="text-align:left"><code>OutputStream</code>，可以指定缓冲区大小（可选）</td><td style="text-align:left">本质上并不提供接口，只是向进程添加缓冲功能。与接口对象搭配</td></tr></tbody></table></div><h2 id="Reader-和-Writer"><a href="#Reader-和-Writer" class="headerlink" title="Reader 和 Writer"></a>Reader 和 Writer</h2><p>Java 1.1 对基本的 I/O 流类库做了重大的修改。你初次遇到 <code>Reader</code> 和 <code>Writer</code> 时，可能会以为这两个类是用来替代 <code>InputStream</code> 和 <code>OutputStream</code> 的，但实际上并不是这样。尽管一些原始的“流”类库已经过时了（如果使用它们，编译器会发出警告），但是 <code>InputStream</code> 和 <code>OutputStream</code> 在面向字节 I/O 这方面仍然发挥着极其重要的作用，而 <code>Reader</code> 和 <code>Writer</code> 则提供兼容 Unicode 和面向字符 I/O 的功能。另外：</p><ol><li><p>Java 1.1 往 <code>InputStream</code> 和 <code>OutputStream</code> 的继承体系中又添加了一些新类，所以这两个类显然是不会被取代的；</p></li><li><p>有时我们必须把来自“字节”层级结构中的类和来自“字符”层次结构中的类结合起来使用。为了达到这个目的，需要用到“适配器（adapter）类”：<code>InputStreamReader</code> 可以把 <code>InputStream</code> 转换为 <code>Reader</code>，而 <code>OutputStreamWriter</code> 可以把 <code>OutputStream</code> 转换为 <code>Writer</code>。</p></li></ol><p>设计 <code>Reader</code> 和 <code>Writer</code> 继承体系主要是为了国际化。老的 I/O 流继承体系仅支持 8 比特的字节流，并且不能很好地处理 16 比特的 Unicode 字符。由于 Unicode 用于字符国际化（Java 本身的 <code>char</code> 也是 16 比特的 Unicode），所以添加 <code>Reader</code> 和 <code>Writer</code> 继承体系就是为了让所有的 I/O 操作都支持 Unicode。另外，新类库的设计使得它的操作比旧类库要快。</p><h3 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h3><p>几乎所有原始的 Java I/O 流类都有相应的 <code>Reader</code> 和 <code>Writer</code> 类来提供原生的 Unicode 操作。但是在某些场合，面向字节的 <code>InputStream</code> 和 <code>OutputStream</code> 才是正确的解决方案。特别是 <code>java.util.zip</code> 类库就是面向字节而不是面向字符的。因此，最明智的做法是尽量<strong>尝试</strong>使用 <code>Reader</code> 和 <code>Writer</code>，一旦代码没法成功编译，你就会发现此时应该使用面向字节的类库了。</p><p>下表展示了在两个继承体系中，信息的来源和去处（即数据物理上来自哪里又去向哪里）之间的对应关系：</p><div class="table-container"><table><thead><tr><th style="text-align:center">来源与去处：Java 1.0 类</th><th style="text-align:center">相应的 Java 1.1 类</th></tr></thead><tbody><tr><td style="text-align:center"><code>InputStream</code></td><td style="text-align:center"><code>Reader</code> <br> 适配器：<code>InputStreamReader</code></td></tr><tr><td style="text-align:center"><code>OutputStream</code></td><td style="text-align:center"><code>Writer</code> <br> 适配器：<code>OutputStreamWriter</code></td></tr><tr><td style="text-align:center"><code>FileInputStream</code></td><td style="text-align:center"><code>FileReader</code></td></tr><tr><td style="text-align:center"><code>FileOutputStream</code></td><td style="text-align:center"><code>FileWriter</code></td></tr><tr><td style="text-align:center"><code>StringBufferInputStream</code>（已弃用）</td><td style="text-align:center"><code>StringReader</code></td></tr><tr><td style="text-align:center">（无相应的类）</td><td style="text-align:center"><code>StringWriter</code></td></tr><tr><td style="text-align:center"><code>ByteArrayInputStream</code></td><td style="text-align:center"><code>CharArrayReader</code></td></tr><tr><td style="text-align:center"><code>ByteArrayOutputStream</code></td><td style="text-align:center"><code>CharArrayWriter</code></td></tr><tr><td style="text-align:center"><code>PipedInputStream</code></td><td style="text-align:center"><code>PipedReader</code></td></tr><tr><td style="text-align:center"><code>PipedOutputStream</code></td><td style="text-align:center"><code>PipedWriter</code></td></tr></tbody></table></div><p>总的来说，这两个不同的继承体系中的接口即便不能说完全相同，但也是非常相似的。</p><h3 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h3><p>对于 <code>InputStream</code> 和 <code>OutputStream</code> 来说，我们会使用 <code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 的装饰器子类来修改“流”以满足特殊需要。<code>Reader</code> 和 <code>Writer</code> 的类继承体系沿用了相同的思想——但是并不完全相同。</p><p>在下表中，左右之间对应关系的近似程度现比上一个表格更加粗略一些。造成这种差别的原因是类的组织形式不同，<code>BufferedOutputStream</code> 是 <code>FilterOutputStream</code> 的子类，但 <code>BufferedWriter</code> 却不是 <code>FilterWriter</code> 的子类（尽管 <code>FilterWriter</code> 是抽象类，但却没有任何子类，把它放在表格里只是占个位置，不然你可能奇怪 <code>FilterWriter</code> 上哪去了）。然而，这些类的接口却又十分相似。</p><div class="table-container"><table><thead><tr><th style="text-align:left">过滤器：Java 1.0 类</th><th style="text-align:left">相应 Java 1.1 类</th></tr></thead><tbody><tr><td style="text-align:left"><code>FilterInputStream</code></td><td style="text-align:left"><code>FilterReader</code></td></tr><tr><td style="text-align:left"><code>FilterOutputStream</code></td><td style="text-align:left"><code>FilterWriter</code> (抽象类，没有子类)</td></tr><tr><td style="text-align:left"><code>BufferedInputStream</code></td><td style="text-align:left"><code>BufferedReader</code>（也有 <code>readLine()</code>)</td></tr><tr><td style="text-align:left"><code>BufferedOutputStream</code></td><td style="text-align:left"><code>BufferedWriter</code></td></tr><tr><td style="text-align:left"><code>DataInputStream</code></td><td style="text-align:left">使用 <code>DataInputStream</code>（ 如果必须用到 <code>readLine()</code>，那你就得使用 <code>BufferedReader</code>。否则，一般情况下就用 <code>DataInputStream</code></td></tr><tr><td style="text-align:left"><code>PrintStream</code></td><td style="text-align:left"><code>PrintWriter</code></td></tr><tr><td style="text-align:left"><code>LineNumberInputStream</code></td><td style="text-align:left"><code>LineNumberReader</code></td></tr><tr><td style="text-align:left"><code>StreamTokenizer</code></td><td style="text-align:left"><code>StreamTokenizer</code>（使用具有 <code>Reader</code> 参数的构造器）</td></tr><tr><td style="text-align:left"><code>PushbackInputStream</code></td><td style="text-align:left"><code>PushbackReader</code></td></tr></tbody></table></div><p>有一条限制需要明确：一旦要使用 <code>readLine()</code>，我们就不应该用 <code>DataInputStream</code>（否则，编译时会得到使用了过时方法的警告），而应该使用 <code>BufferedReader</code>。除了这种情况之外的情形中，<code>DataInputStream</code> 仍是 I/O 类库的首选成员。</p><p>为了使用时更容易过渡到 <code>PrintWriter</code>，它提供了一个既能接受 <code>Writer</code> 对象又能接受任何 <code>OutputStream</code> 对象的构造器。<code>PrintWriter</code> 的格式化接口实际上与 <code>PrintStream</code> 相同。</p><p>Java 5 添加了几种 <code>PrintWriter</code> 构造器，以便在将输出写入时简化文件的创建过程，你马上就会见到它们。</p><p>其中一种 <code>PrintWriter</code> 构造器还有一个执行<strong>自动 flush</strong><sup><a href="#fn_2" id="reffn_2">2</a></sup> 的选项。如果构造器设置了该选项，就会在每个 <code>println()</code> 调用之后，自动执行 flush。</p><h3 id="未发生改变的类"><a href="#未发生改变的类" class="headerlink" title="未发生改变的类"></a>未发生改变的类</h3><p>有一些类在 Java 1.0 和 Java 1.1 之间未做改变。</p><div class="table-container"><table><thead><tr><th>以下这些 Java 1.0 类在 Java 1.1 中没有相应类</th></tr></thead><tbody><tr><td><code>DataOutputStream</code></td></tr><tr><td><code>File</code></td></tr><tr><td><code>RandomAccessFile</code></td></tr><tr><td><code>SequenceInputStream</code></td></tr></tbody></table></div><p>特别是 <code>DataOutputStream</code>，在使用时没有任何变化；因此如果想以可传输的格式存储和检索数据，请用 <code>InputStream</code> 和 <code>OutputStream</code> 继承体系。</p><h2 id="RandomAccessFile-类"><a href="#RandomAccessFile-类" class="headerlink" title="RandomAccessFile 类"></a>RandomAccessFile 类</h2><p><code>RandomAccessFile</code> 适用于由大小已知的记录组成的文件，所以我们可以使用 <code>seek()</code> 将文件指针从一条记录移动到另一条记录，然后对记录进行读取和修改。文件中记录的大小不一定都相同，只要我们能确定那些记录有多大以及它们在文件中的位置即可。</p><p>最初，我们可能难以相信 <code>RandomAccessFile</code> 不是 <code>InputStream</code> 或者 <code>OutputStream</code> 继承体系中的一部分。除了实现了 <code>DataInput</code> 和 <code>DataOutput</code> 接口（<code>DataInputStream</code> 和 <code>DataOutputStream</code> 也实现了这两个接口）之外，它和这两个继承体系没有任何关系。它甚至都不使用 <code>InputStream</code> 和 <code>OutputStream</code> 类中已有的任何功能。它是一个完全独立的类，其所有的方法（大多数都是 <code>native</code> 方法）都是从头开始编写的。这么做是因为 <code>RandomAccessFile</code> 拥有和别的 I/O 类型本质上不同的行为，因为我们可以在一个文件内向前和向后移动。在任何情况下，它都是自我独立的，直接继承自 <code>Object</code>。</p><p>从本质上来讲，<code>RandomAccessFile</code> 的工作方式类似于把 <code>DataIunputStream</code> 和 <code>DataOutputStream</code> 组合起来使用。另外它还有一些额外的方法，比如使用 <code>getFilePointer()</code> 可以得到当前文件指针在文件中的位置，使用 <code>seek()</code> 可以移动文件指针，使用 <code>length()</code> 可以得到文件的长度。另外，其构造器还需要传入第二个参数（和 C 语言中的 <code>fopen()</code> 相同）用来表示我们是准备对文件进行 “随机读”（r）还是“读写”（rw）。它并不支持只写文件，从这点来看，如果当初 <code>RandomAccessFile</code> 能设计成继承自 <code>DataInputStream</code>，可能也是个不错的实现方式。</p><p>在 Java 1.4 中，<code>RandomAccessFile</code> 的大多数功能（但不是全部）都被 nio 中的<strong>内存映射文件</strong>（mmap）取代，详见<a href="./Appendix-New-IO.md">附录：新 I/O</a>。</p><h2 id="IO-流典型用途"><a href="#IO-流典型用途" class="headerlink" title="IO 流典型用途"></a>IO 流典型用途</h2><p>尽管我们可以用不同的方式来组合 I/O 流类，但常用的也就其中几种。你可以下面的例子可以作为 I/O 典型用法的基本参照（在你确定无法使用<a href="./17-Files.md">文件</a>这一章所述的库之后）。</p><p>在这些示例中，异常处理都被简化为将异常传递给控制台，但是这样做只适用于小型的示例和工具。在你自己的代码中，你需要考虑更加复杂的错误处理方式。</p><h3 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h3><p>如果想要打开一个文件进行字符输入，我们可以使用一个 <code>FileInputReader</code> 对象，然后传入一个 <code>String</code> 或者 <code>File</code> 对象作为文件名。为了提高速度，我们希望对那个文件进行缓冲，那么我们可以将所产生的引用传递给一个 <code>BufferedReader</code> 构造器。<code>BufferedReader</code> 提供了 <code>line()</code> 方法，它会产生一个 <code>Stream&lt;String&gt;</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iostreams/BufferedInputFile.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(filename))) &#123;</span><br><span class="line">            <span class="keyword">return</span> in.lines()</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(</span><br><span class="line">                read(<span class="string">&quot;BufferedInputFile.java&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Collectors.joining()</code> 在其内部使用了一个 <code>StringBuilder</code> 来累加其运行结果。该文件会通过 <code>try-with-resources</code> 子句自动关闭。</p><h3 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h3><p>下面示例中，从 <code>BufferedInputFile.read()</code> 读入的 <code>String</code> 被用来创建一个 <code>StringReader</code> 对象。然后调用其 <code>read()</code> 方法，每次读取一个字符，并把它显示在控制台上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iostreams/MemoryInput.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">    <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringReader in = <span class="keyword">new</span> StringReader(</span><br><span class="line">                BufferedInputFile.read(<span class="string">&quot;MemoryInput.java&quot;</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>read()</code> 是以 <code>int</code> 形式返回下一个字节，所以必须类型转换为 <code>char</code> 才能正确打印。</p><h3 id="格式化内存输入"><a href="#格式化内存输入" class="headerlink" title="格式化内存输入"></a>格式化内存输入</h3><p>要读取格式化数据，我们可以使用 <code>DataInputStream</code>，它是一个面向字节的 I/O 类（不是面向字符的）。这样我们就必须使用 <code>InputStream</code> 类而不是 <code>Reader</code> 类。我们可以使用 <code>InputStream</code> 以字节形式读取任何数据（比如一个文件），但这里使用的是字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iostreams/FormattedMemoryInput.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                    BufferedInputFile.read(</span><br><span class="line">                        <span class="string">&quot;FormattedMemoryInput.java&quot;</span>)</span><br><span class="line">                            .getBytes()))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                System.out.write((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\nEnd of stream&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayInputStream</code> 必须接收一个字节数组，所以这里我们调用了 <code>String.getBytes()</code> 方法。所产生的的 <code>ByteArrayInputStream</code> 是一个适合传递给 <code>DataInputStream</code> 的 <code>InputStream</code>。</p><p>如果我们用 <code>readByte()</code> 从 <code>DataInputStream</code> 一次一个字节地读取字符，那么任何字节的值都是合法结果，因此返回值不能用来检测输入是否结束。取而代之的是，我们可以使用 <code>available()</code> 方法得到剩余可用字符的数量。下面例子演示了怎么一次一个字节地读取文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iostreams/TestEOF.java</span></span><br><span class="line"><span class="comment">// Testing for end of file</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream(<span class="string">&quot;TestEOF.java&quot;</span>)))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">                System.out.write(in.readByte());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>available()</code> 的工作方式会随着所读取媒介类型的不同而有所差异，它的字面意思就是“在没有阻塞的情况下所能读取的字节数”。对于文件，能够读取的是整个文件；但是对于其它类型的“流”，可能就不是这样，所以要谨慎使用。</p><p>我们也可以通过捕获异常来检测输入的末尾。但是，用异常作为控制流是对异常的一种错误使用方式。</p><h3 id="基本文件的输出"><a href="#基本文件的输出" class="headerlink" title="基本文件的输出"></a>基本文件的输出</h3><p><code>FileWriter</code> 对象用于向文件写入数据。实际使用时，我们通常会用 <code>BufferedWriter</code> 将其包装起来以增加缓冲的功能（可以试试移除此包装来感受一下它对性能的影响——缓冲往往能显著地增加 I/O 操作的性能）。在本例中，为了提供格式化功能，它又被装饰成了 <code>PrintWriter</code>。按照这种方式创建的数据文件可作为普通文本文件来读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iostreams/BasicFileOutput.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">&quot;BasicFileOutput.dat&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> StringReader(</span><br><span class="line">                     BufferedInputFile.read(</span><br><span class="line">                         <span class="string">&quot;BasicFileOutput.java&quot;</span>)));</span><br><span class="line">                PrintWriter out = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                    <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)))</span><br><span class="line">        ) &#123;</span><br><span class="line">            in.lines().forEach(out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Show the stored file:</span></span><br><span class="line">        System.out.println(BufferedInputFile.read(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try-with-resources</code> 语句会自动 flush 并关闭文件。</p><h3 id="文本文件输出快捷方式"><a href="#文本文件输出快捷方式" class="headerlink" title="文本文件输出快捷方式"></a>文本文件输出快捷方式</h3><p>Java 5 在 <code>PrintWriter</code> 中添加了一个辅助构造器，有了它，你在创建并写入文件时，就不必每次都手动执行一些装饰的工作。下面的代码使用这种快捷方式重写了 <code>BasicFileOutput.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iostreams/FileOutputShortcut.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputShortcut</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">&quot;FileOutputShortcut.dat&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> StringReader(BufferedInputFile.read(</span><br><span class="line">                    <span class="string">&quot;FileOutputShortcut.java&quot;</span>)));</span><br><span class="line">            <span class="comment">// Here&#x27;s the shortcut:</span></span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(file)</span><br><span class="line">        ) &#123;</span><br><span class="line">            in.lines().forEach(out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(BufferedInputFile.read(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方式仍具备了缓冲的功能，只是现在不必自己手动添加缓冲了。但遗憾的是，其它常见的写入任务都没有快捷方式，因此典型的 I/O 流依旧涉及大量冗余的代码。本书<a href="./17-Files.md">文件</a>一章中介绍的另一种方式，对此类任务进行了极大的简化。</p><h3 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h3><p><code>PrintWriter</code> 是用来对可读的数据进行格式化。但如果要输出可供另一个“流”恢复的数据，我们可以用 <code>DataOutputStream</code> 写入数据，然后用 <code>DataInputStream</code> 恢复数据。当然，这些流可能是任何形式，在下面的示例中使用的是一个文件，并且对读写都进行了缓冲。注意 <code>DataOutputStream</code> 和 <code>DataInputStream</code> 是面向字节的，因此要使用 <code>InputStream</code> 和 <code>OutputStream</code> 体系的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iostreams/StoringAndRecoveringData.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Data.txt&quot;</span>)))</span><br><span class="line">        ) &#123;</span><br><span class="line">            out.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">            out.writeUTF(<span class="string">&quot;That was pi&quot;</span>);</span><br><span class="line">            out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">            out.writeUTF(<span class="string">&quot;Square root of 2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Data.txt&quot;</span>)))</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(in.readDouble());</span><br><span class="line">            <span class="comment">// Only readUTF() will recover the</span></span><br><span class="line">            <span class="comment">// Java-UTF String properly:</span></span><br><span class="line">            System.out.println(in.readUTF());</span><br><span class="line">            System.out.println(in.readDouble());</span><br><span class="line">            System.out.println(in.readUTF());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.14159</span><br><span class="line">That was pi</span><br><span class="line">1.41413</span><br><span class="line">Square root of 2</span><br></pre></td></tr></table></figure><p>如果我们使用 <code>DataOutputStream</code> 进行数据写入，那么 Java 就保证了即便读和写数据的平台多么不同，我们仍可以使用 <code>DataInputStream</code> 准确地读取数据。这一点很有价值，众所周知，人们曾把大量精力耗费在数据的平台相关性问题上。但现在，只要两个平台上都有 Java，就不会存在这样的问题<sup><a href="#fn_3" id="reffn_3">3</a></sup>。</p><p>当我们使用 <code>DastaOutputStream</code> 时，写字符串并且让 <code>DataInputStream</code> 能够恢复它的唯一可靠方式就是使用 UTF-8 编码，在这个示例中是用 <code>writeUTF()</code> 和 <code>readUTF()</code> 来实现的。UTF-8 是一种多字节格式，其编码长度根据实际使用的字符集会有所变化。如果我们使用的只是 ASCII 或者几乎都是 ASCII 字符（只占 7 比特），那么就显得及其浪费空间和带宽，所以 UTF-8 将 ASCII 字符编码成一个字节的形式，而非 ASCII 字符则编码成两到三个字节的形式。另外，字符串的长度保存在 UTF-8 字符串的前两个字节中。但是，<code>writeUTF()</code> 和 <code>readUTF()</code> 使用的是一种适用于 Java 的 UTF-8 变体（JDK 文档中有这些方法的详尽描述），因此如果我们用一个非 Java 程序读取用 <code>writeUTF()</code> 所写的字符串时，必须编写一些特殊的代码才能正确读取。</p><p>有了 <code>writeUTF()</code> 和 <code>readUTF()</code>，我们就可以在 <code>DataOutputStream</code> 中把字符串和其它数据类型混合使用。因为字符串完全可以作为 Unicode 格式存储，并且可以很容易地使用 <code>DataInputStream</code> 来恢复它。</p><p><code>writeDouble()</code> 将 <code>double</code> 类型的数字存储在流中，并用相应的 <code>readDouble()</code> 恢复它（对于其它的书类型，也有类似的方法用于读写）。但是为了保证所有的读方法都能够正常工作，我们必须知道流中数据项所在的确切位置，因为极有可能将保存的 <code>double</code> 数据作为一个简单的字节序列、<code>char</code> 或其它类型读入。因此，我们必须：要么为文件中的数据采用固定的格式；要么将额外的信息保存到文件中，通过解析额外信息来确定数据的存放位置。注意，对象序列化和 XML （二者都在<a href="Appendix-Object-Serialization.md">附录：对象序列化</a>中介绍）是存储和读取复杂数据结构的更简单的方式。</p><h3 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h3><p>使用 <code>RandomAccessFile</code> 就像是使用了一个 <code>DataInputStream</code> 和 <code>DataOutputStream</code> 的结合体（因为它实现了相同的接口：<code>DataInput</code> 和 <code>DataOutput</code>）。另外，我们还可以使用 <code>seek()</code> 方法移动文件指针并修改对应位置的值。</p><p>在使用 <code>RandomAccessFile</code> 时，你必须清楚文件的结构，否则没法正确使用它。<code>RandomAccessFile</code> 有一套专门的方法来读写基本数据类型的数据和 UTF-8 编码的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iostreams/UsingRandomAccessFile.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">&quot;rtest.dat&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            RandomAccessFile rf =</span><br><span class="line">                <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">                System.out.println(</span><br><span class="line">                    <span class="string">&quot;Value &quot;</span> + i + <span class="string">&quot;: &quot;</span> + rf.readDouble());</span><br><span class="line">            System.out.println(rf.readUTF());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            RandomAccessFile rf =</span><br><span class="line">                <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">                rf.writeDouble(i * <span class="number">1.414</span>);</span><br><span class="line">            rf.writeUTF(<span class="string">&quot;The end of the file&quot;</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            RandomAccessFile rf =</span><br><span class="line">                <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            rf.seek(<span class="number">5</span> * <span class="number">8</span>);</span><br><span class="line">            rf.writeDouble(<span class="number">47.0001</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Value 0: 0.0</span><br><span class="line">Value 1: 1.414</span><br><span class="line">Value 2: 2.828</span><br><span class="line">Value 3: 4.242</span><br><span class="line">Value 4: 5.656</span><br><span class="line">Value 5: 7.069999999999999</span><br><span class="line">Value 6: 8.484</span><br><span class="line">The end of the file</span><br><span class="line">Value 0: 0.0</span><br><span class="line">Value 1: 1.414</span><br><span class="line">Value 2: 2.828</span><br><span class="line">Value 3: 4.242</span><br><span class="line">Value 4: 5.656</span><br><span class="line">Value 5: 47.0001</span><br><span class="line">Value 6: 8.484</span><br><span class="line">The end of the file</span><br></pre></td></tr></table></figure><p><code>display()</code> 方法打开了一个文件，并以 <code>double</code> 值的形式显示了其中的七个元素。在 <code>main()</code> 中，首先创建了文件，然后打开并修改了它。因为 <code>double</code> 总是 8 字节长，所以如果要用 <code>seek()</code> 定位到第 5 个（从 0 开始计数） <code>double</code> 值，则要传入的地址值应该为 <code>5*8</code>。</p><p>正如前面所诉，虽然 <code>RandomAccess</code> 实现了 <code>DataInput</code> 和 <code>DataOutput</code> 接口，但实际上它和 I/O 继承体系中的其它部分是分离的。它不支持装饰，故而不能将其与 <code>InputStream</code> 及 <code>OutputStream</code> 子类中的任何一个组合起来，所以我们也没法给它添加缓冲的功能。</p><p>该类的构造器还有第二个必选参数：我们可以指定让 <code>RandomAccessFile</code> 以“只读”（r）方式或“读写”<br>（rw）方式打开文件。</p><p>除此之外，还可以使用 <code>nio</code> 中的“内存映射文件”代替 <code>RandomAccessFile</code>，这在<a href="Appendix-New-IO.md">附录：新 I/O</a>中有介绍。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>Java 的 I/O 流类库的确能够满足我们的基本需求：我们可以通过控制台、文件、内存块，甚至因特网进行读写。通过继承，我们可以创建新类型的输入和输出对象。并且我们甚至可以通过重新定义“流”所接受对象类型的 <code>toString()</code> 方法，进行简单的扩展。当我们向一个期望收到字符串的方法传送一个非字符串对象时，会自动调用对象的 <code>toString()</code> 方法（这是 Java 中有限的“自动类型转换”功能之一）。</p><p>在 I/O 流类库的文档和设计中，仍留有一些没有解决的问题。例如，我们打开一个文件用于输出，如果在我们试图覆盖这个文件时能抛出一个异常，这样会比较好（有的编程系统只有当该文件不存在时，才允许你将其作为输出文件打开）。在 Java 中，我们应该使用一个 <code>File</code> 对象来判断文件是否存在，因为如果我们用 <code>FileOutputStream</code> 或者 <code>FileWriter</code> 打开，那么这个文件肯定会被覆盖。</p><p>I/O 流类库让我们喜忧参半。它确实挺有用的，而且还具有可移植性。但是如果我们没有理解“装饰器”模式，那么这种设计就会显得不是很直观。所以，它的学习成本相对较高。而且它并不完善，比如说在过去，我不得不编写相当数量的代码去实现一个读取文本文件的工具——所幸的是，Java 7 中的 nio 消除了此类需求。</p><p>一旦你理解了装饰器模式，并且开始在某些需要这种灵活性的场景中使用该类库，那么你就开始能从这种设计中受益了。到那时候，为此额外多写几行代码的开销应该不至于让人觉得太麻烦。但还是请务必检查一下，确保使用<a href="./17-Files.md">文件</a>一章中的库和技术没法解决问题后，再考虑使用本章的 I/O 流库。</p><blockquote id="fn_1"><sup>1</sup>. 很难说这就是一个很好的设计选择，尤其是与其它编程语言中简单的 I/O 类库相比较。但它确实是如此选择的一个正当理由。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 译者注：“flush” 直译是“清空”，意思是把缓冲中的数据清空，输送到对应的目的地（如文件和屏幕）。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. XML 是另一种方式，可以解决在不同计算平台之间移动数据，而不依赖于所有平台上都有 Java 这一问题。XML 将在<a href="./Appendix-Object-Serialization.md">附录：对象序列化</a>一章中进行介绍。<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-流式-IO&quot;&gt;&lt;a href=&quot;#附录-流式-IO&quot; class=&quot;headerlink&quot; title=&quot;附录:流式 IO&quot;&gt;&lt;/a&gt;附录:流式 IO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java 7 引入了一种简单明了的方式来读写文件和操作目录。大多情</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-data-compression/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-data-compression/</id>
    <published>2022-06-23T15:31:23.679Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-数据压缩"><a href="#附录-数据压缩" class="headerlink" title="附录:数据压缩"></a>附录:数据压缩</h1><p>Java I/O 类库提供了可以读写压缩格式流的类。你可以将其他 I/O 类包装起来用于提供压缩功能。</p><p>这些类不是从 <strong>Reader</strong> 和 <strong>Writer</strong> 类派生的，而是 <strong>InputStream</strong> 和 <strong>OutputStream</strong> 层级结构的一部分。这是由于压缩库处理的是字节，而不是字符。但是，你可能会被迫混合使用两种类型的流（请记住，你可以使用 <strong>InputStreamReader</strong> 和 <strong>OutputStreamWriter</strong>，这两个类可以在字节类型和字符类型之间轻松转换）。</p><div class="table-container"><table><thead><tr><th>压缩类</th><th>功能</th></tr></thead><tbody><tr><td><strong>CheckedInputStream</strong></td><td><code>getCheckSum()</code> 可以对任意 <strong>InputStream</strong> 计算校验和（而不只是解压）</td></tr><tr><td><strong>CheckedOutputStream</strong></td><td><code>getCheckSum()</code> 可以对任意 <strong>OutputStream</strong> 计算校验和（而不只是压缩）</td></tr><tr><td><strong>DeflaterOutputStream</strong></td><td>压缩类的基类</td></tr><tr><td><strong>ZipOutputStream</strong></td><td><strong>DeflaterOutputStream</strong> 类的一种，用于压缩数据到 Zip 文件结构</td></tr><tr><td><strong>GZIPOutputStream</strong></td><td><strong>DeflaterOutputStream</strong> 类的一种，用于压缩数据到 GZIP 文件结构</td></tr><tr><td><strong>InflaterInputStream</strong></td><td>解压类的基类</td></tr><tr><td><strong>ZipInputStream</strong></td><td><strong>InflaterInputStream</strong> 类的一种，用于解压 Zip 文件结构的数据</td></tr><tr><td><strong>GZIPInputStream</strong></td><td><strong>InflaterInputStream</strong> 类的一种，用于解压 GZIP 文件结构的数据</td></tr></tbody></table></div><p>尽管存在很多压缩算法，但是 Zip 和 GZIP 可能是最常见的。你可以使用许多用于读取和写入这些格式的工具，来轻松操作压缩数据。</p><h2 id="使用-Gzip-简单压缩"><a href="#使用-Gzip-简单压缩" class="headerlink" title="使用 Gzip 简单压缩"></a>使用 Gzip 简单压缩</h2><p>GZIP 接口十分简单，因此当你有一个需要压缩的数据流（而不是一个包含不同数据分片的容器）时，使用 GZIP 更为合适。如下是一个压缩单个文件的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compression/GZIPcompress.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// &#123;java GZIPcompress GZIPcompress.java&#125;</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPcompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;Usage: \nGZIPcompress file\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;\tUses GZIP compression to compress &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;the file to test.gz&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                InputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">                BufferedOutputStream out =</span><br><span class="line">                        <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                                        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.gz&quot;</span>)))</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Writing file&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>)</span><br><span class="line">                out.write(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reading file&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                BufferedReader in2 = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>))))</span><br><span class="line">        ) &#123;</span><br><span class="line">            in2.lines().forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用压缩类非常简单，你只需要把你的输出流包装在 <strong>GZIPOutputStream</strong> 或 <strong>ZipOutputStream</strong> 中，将输入流包装在 <strong>GZIPInputStream</strong> 或 <strong>ZipInputStream</strong>。其他的一切就只是普通的 I/O 读写。这是面向字符流和面向字节流的混合示例；in 使用 Reader 类，而 <strong>GZIPOutputStreams</strong> 构造函数只能接受 <strong>OutputStream</strong> 对象，而不能接受 <strong>Writer</strong> 对象。当打开文件的时候，<strong>GZIPInputStream</strong> 会转换成为 <strong>Reader</strong>。</p><h2 id="使用-zip-多文件存储"><a href="#使用-zip-多文件存储" class="headerlink" title="使用 zip 多文件存储"></a>使用 zip 多文件存储</h2><p>支持 Zip 格式的库比 GZIP 库更广泛。有了它，你可以轻松存储多个文件，甚至还有一个单独的类可以轻松地读取 Zip 文件。该库使用标准 Zip 格式，因此它可以与当前可在 Internet 上下载的所有 Zip 工具无缝协作。以下示例与前一个示例具有相同的形式，但它可以根据需要处理任意数量的命令行参数。此外，它还显示了 <strong>Checksum</strong> 类计算和验证文件的校验和。有两种校验和类型：Adler32（更快）和 CRC32（更慢但更准确）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compression/ZipCompress.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Uses Zip compression to compress any</span></span><br><span class="line"><span class="comment">// number of files given on the command line</span></span><br><span class="line"><span class="comment">// &#123;java ZipCompress ZipCompress.java&#125;</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipCompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                FileOutputStream f =</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.zip&quot;</span>);</span><br><span class="line">                CheckedOutputStream csum =</span><br><span class="line">                        <span class="keyword">new</span> CheckedOutputStream(f, <span class="keyword">new</span> Adler32());</span><br><span class="line">                ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">                BufferedOutputStream out =</span><br><span class="line">                        <span class="keyword">new</span> BufferedOutputStream(zos)</span><br><span class="line">        ) &#123;</span><br><span class="line">            zos.setComment(<span class="string">&quot;A test of Java Zipping&quot;</span>);</span><br><span class="line">            <span class="comment">// No corresponding getComment(), though.</span></span><br><span class="line">            <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Writing file &quot;</span> + arg);</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                        InputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(arg))</span><br><span class="line">                ) &#123;</span><br><span class="line">                    zos.putNextEntry(<span class="keyword">new</span> ZipEntry(arg));</span><br><span class="line">                    <span class="keyword">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>)</span><br><span class="line">                        out.write(c);</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Checksum valid only after the file is closed!</span></span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;Checksum: &quot;</span> + csum.getChecksum().getValue());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now extract the files:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Reading file&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                FileInputStream fi =</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.zip&quot;</span>);</span><br><span class="line">                CheckedInputStream csumi =</span><br><span class="line">                        <span class="keyword">new</span> CheckedInputStream(fi, <span class="keyword">new</span> Adler32());</span><br><span class="line">                ZipInputStream in2 = <span class="keyword">new</span> ZipInputStream(csumi);</span><br><span class="line">                BufferedInputStream bis =</span><br><span class="line">                        <span class="keyword">new</span> BufferedInputStream(in2)</span><br><span class="line">        ) &#123;</span><br><span class="line">            ZipEntry ze;</span><br><span class="line">            <span class="keyword">while</span> ((ze = in2.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Reading file &quot;</span> + ze);</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="keyword">while</span> ((x = bis.read()) != -<span class="number">1</span>)</span><br><span class="line">                    System.out.write(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (args.length == <span class="number">1</span>)</span><br><span class="line">                System.out.println(</span><br><span class="line">                        <span class="string">&quot;Checksum: &quot;</span> + csumi.getChecksum().getValue());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Alternative way to open and read Zip files:</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                ZipFile zf = <span class="keyword">new</span> ZipFile(<span class="string">&quot;test.zip&quot;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            Enumeration e = zf.entries();</span><br><span class="line">            <span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line">                ZipEntry ze2 = (ZipEntry) e.nextElement();</span><br><span class="line">                System.out.println(<span class="string">&quot;File: &quot;</span> + ze2);</span><br><span class="line">                <span class="comment">// ... and extract the data as before</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于要添加到存档的每个文件，必须调用 <code>putNextEntry()</code> 并传递 <strong>ZipEntry</strong> 对象。 <strong>ZipEntry</strong> 对象包含一个扩展接口，用于获取和设置 Zip 文件中该特定条目的所有可用数据：名称，压缩和未压缩大小，日期，CRC 校验和，额外字段数据，注释，压缩方法以及它是否是目录条目。但是，即使 Zip 格式有设置密码的方法，Java 的 Zip 库也不支持。虽然 <strong>CheckedInputStream</strong> 和 <strong>CheckedOutputStream</strong> 都支持 Adler32 和 CRC32 校验和，但 <strong>ZipEntry</strong> 类仅支持 CRC 接口。这是对基础 Zip 格式的限制，但它可能会限制你使用更快的 Adler32。</p><p>要提取文件，<strong>ZipInputStream</strong> 有一个 <code>getNextEntry()</code> 方法，这个方法在有文件存在的情况下调用，会返回下一个 <strong>ZipEntry</strong>。作为一个更简洁的替代方法，你可以使用 <strong>ZipFile</strong> 对象读取该文件，该对象具有方法 entries() 返回一个包裹 <strong>ZipEntries</strong> 的 <strong>Enumeration</strong>。</p><p>要读取校验和，你必须以某种方式访问关联的 <strong>Checksum</strong> 对象。这里保留了对 <strong>CheckedOutputStream</strong> 和 <strong>CheckedInputStream</strong> 对象的引用，但你也可以保持对 <strong>Checksum</strong> 对象的引用。 Zip 流中的一个令人困惑的方法是 <code>setComment()</code>。如 <strong>ZipCompress</strong> 所示。在 Java 中，你可以在编写文件时设置注释，但是没有办法恢复 <strong>ZipInputStream</strong> 中的注释。注释似乎仅通过 <strong>ZipEntry</strong> 在逐个条目的基础上完全支持。</p><p>使用 GZIP 或 Zip 库时，你不仅被限制于文件——你可以压缩任何内容，包括通过网络连接发送的数据。</p><h2 id="Java-的-jar"><a href="#Java-的-jar" class="headerlink" title="Java 的 jar"></a>Java 的 jar</h2><p>Zip 格式也用于 JAR（Java ARchive）文件格式，这是一种将一组文件收集到单个压缩文件中的方法，就像 Zip 一样。但是，与 Java 中的其他所有内容一样，JAR 文件是跨平台的，因此你不必担心平台问题。你还可以将音频和图像文件像类文件一样包含在其中。</p><p>JAR 文件由一个包含压缩文件集合的文件和一个描述它们的“清单（manifest）”组成。（你可以创建自己的清单文件；否则，jar 程序将为你执行此操作。）你可以在 JDK 文档中，找到更多关于 JAR 清单的信息。</p><p>JDK 附带的 jar 工具会自动压缩你选择的文件。你可以在命令行上调用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar [options] destination [manifest] inputfile(s)</span><br></pre></td></tr></table></figure><p>选项是一组字母（不需要连字符或任何其他指示符）。 Unix / Linux 用户会注意到这些选项与 tar 命令选项的相似性。这些是：</p><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td><strong>c</strong></td><td>创建一个新的或者空的归档文件</td></tr><tr><td><strong>t</strong></td><td>列出内容目录</td></tr><tr><td><strong>x</strong></td><td>提取所有文件</td></tr><tr><td><strong>x</strong> file</td><td>提取指定的文件</td></tr><tr><td><strong>f</strong></td><td>这代表着，“传递文件的名称。”如果你不使用它，jar 假定它的输入将来自标准输入，或者，如果它正在创建一个文件，它的输出将转到标准输出。</td></tr><tr><td><strong>m</strong></td><td>代表第一个参数是用户创建的清单文件的名称。</td></tr><tr><td><strong>v</strong></td><td>生成详细的输出用于表述 jar 所作的事情</td></tr><tr><td><strong>0</strong></td><td>仅存储文件;不压缩文件（用于创建放在类路径中的 JAR 文件）。</td></tr><tr><td><strong>M</strong></td><td>不要自动创建清单文件</td></tr></tbody></table></div><p>如果放入 JAR 文件的文件中包含子目录，则会自动添加该子目录，包括其所有子目录等。还会保留路径信息。</p><p>以下是一些调用 jar 的典型方法。以下命令创建名为 myJarFile 的 JAR 文件。 jar 包含当前目录中的所有类文件，以及自动生成的清单文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cf myJarFile.jar *.class</span><br></pre></td></tr></table></figure><p>下一个命令与前面的示例类似，但它添加了一个名为 myManifestFile.mf 的用户创建的清单文件。 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cmf myJarFile.jar myManifestFile.mf *.class</span><br></pre></td></tr></table></figure><p>这个命令输出了 myJarFile.jar 中的文件目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tf myJarFile.jar</span><br></pre></td></tr></table></figure><p>如下添加了一个“verbose”的标志，用于生成更多关于 myJarFile.jar 中文件的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tvf myJarFile.jar</span><br></pre></td></tr></table></figure><p>假设 audio，classes 和 image 都是子目录，它将所有子目录组合到文件 myApp.jar 中。还包括“verbose”标志，以便在 jar 程序工作时提供额外的反馈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvf myApp.jar audio classes image</span><br></pre></td></tr></table></figure><p>如果你在创建 JAR 文件时使用了 0（零） 选项，该文件将会被替换在你的类路径（CLASSPATH）中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;</span><br></pre></td></tr></table></figure><p>然后 Java 可以搜索到 lib1.jar 和 lib2.jar 的类文件。</p><p>jar 工具不像 Zip 实用程序那样通用。例如，你无法将文件添加或更新到现有 JAR 文件；只能从头开始创建 JAR 文件。</p><p>此外，你无法将文件移动到 JAR 文件中，在移动文件时将其删除。</p><p>但是，在一个平台上创建的 JAR 文件可以通过任何其他平台上的 jar 工具透明地读取（这个问题有时会困扰 Zip 实用程序）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-数据压缩&quot;&gt;&lt;a href=&quot;#附录-数据压缩&quot; class=&quot;headerlink&quot; title=&quot;附录:数据压缩&quot;&gt;&lt;/a&gt;附录:数据压缩&lt;/h1&gt;&lt;p&gt;Java I/O 类库提供了可以读写压缩格式流的类。你可以将其他 I/O 类包装起来用于提供压缩功能</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-benefits-and-costs-of-static-type-checking/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-benefits-and-costs-of-static-type-checking/</id>
    <published>2022-06-23T15:31:23.676Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-静态语言类型检查"><a href="#附录-静态语言类型检查" class="headerlink" title="附录:静态语言类型检查"></a>附录:静态语言类型检查</h1><blockquote><p>这是一本我多年来撰写的经过编辑过的论文集，论文集试图将静态检查语言和动态语言之间的争论放到一个正确的角度。还有一个前言部分，描述了我最近对这个话题的思考和见解。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="静态类型检查和测试"><a href="#静态类型检查和测试" class="headerlink" title="静态类型检查和测试"></a>静态类型检查和测试</h2><h2 id="如何提升打字"><a href="#如何提升打字" class="headerlink" title="如何提升打字"></a>如何提升打字</h2><h2 id="生产力的成本"><a href="#生产力的成本" class="headerlink" title="生产力的成本"></a>生产力的成本</h2><h2 id="静态和动态"><a href="#静态和动态" class="headerlink" title="静态和动态"></a>静态和动态</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-静态语言类型检查&quot;&gt;&lt;a href=&quot;#附录-静态语言类型检查&quot; class=&quot;headerlink&quot; title=&quot;附录:静态语言类型检查&quot;&gt;&lt;/a&gt;附录:静态语言类型检查&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这是一本我多年来撰写的经过编辑过的论文集，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/06/23/ch1/appendices/app-becoming-a-programmer/"/>
    <id>http://example.com/2022/06/23/ch1/appendices/app-becoming-a-programmer/</id>
    <published>2022-06-23T15:31:23.675Z</published>
    <updated>2019-12-21T09:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录-成为一名程序员"><a href="#附录-成为一名程序员" class="headerlink" title="附录:成为一名程序员"></a>附录:成为一名程序员</h1><blockquote><p>我分别于2003，2006，2007和2009年撰写的博客文章混搭</p></blockquote><h2 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h2><p>这是一条相当漫长和曲折的道路。我在高一学代数时(1971年)，有个非常古怪的老师有一台计算机，还弄到了一台配有一个300波特的音频电话耦合器的ASR-33电传打字机，我学会了如何执行命令并得到响应，以及一个可以在高中区使用的HP-1000计算机上的帐户。我们能够创建和运行BASIC程序并将它们保存在打孔磁带上。我对此非常着迷，所以尽可能地把它带回家后在晚上写程序。我写了一个赛马模拟游戏—HOSRAC.BAS，用星号来代表马的移动，由于是在纸上打印输出，所以需要一点想象力。</p><p>我的朋友丹尼尔（就是设计我的书封面的人）有一个兄弟，他有段时间通过向酒吧和餐馆提供弹球机来赚钱。他有一台投币式街机（老虎机），最早的《乓》游戏之一，我对此全然不知，到现在我还忍受不了这东西（现在我几乎不玩电脑游戏，这样看来我可能是个没有幽默的人，但似乎编程比玩电脑游戏更有趣、更具挑战性。）</p><p>后来我在高中参与了摄影和新闻工作，在大学的第一年就主修新闻学。我觉得自己已经从学校学到了足够多的东西，又转修了物理学。后来我在加州大学欧文分校完成了物理学位，如果我当时选择了一个特定的工程领域，修了足够的工程课就能拿到双专业，但我试图走得更远一些，所以最后我获得的本科学位是 “应用物理”。作为一名本科生，我多多少少学习了一些可以自娱自乐，但又没有任何深度的计算机编程课程。我个人认为在这些课程细细熏陶下，帮我打下了一定的基础，但事实我理解的这些东西没有任何深度。我不知道计算机、编译器或解释器有什么区别（只是对编译器和解释器一点点的理解）。对我来说计算机是绝对可靠的，而且我从来没有想过在程序语言和操作系统中会有出现错误的可能。</p><p>后来我去了在加州州立理工大学攻读研究生，主要有三点原因</p><ol><li><p>我真的非常喜欢物理学这个领域</p></li><li><p>他们接受了我，甚至给了我一份教学工作和奖学金 </p></li><li><p>出乎意料的是他们给我的工作时间不止一个夏天</p></li></ol><p>而我完全没做好上班的准备。</p><p>作为一名物理专业的学生，我学习的是太阳能发电系统，当时太阳能发电系统很大 (如果你的房子上装了太阳能或生意上是关于太阳能系统，加州就会给予税收抵免，因此也兴起很多生意)，加州理工大学也承诺会在工程系开设相应的课程。然而因为学校没有提供必要的课程，要想获得在太阳能工程的学位得花好几年时间。所以我学习了研究生其他的工程课，包括介绍机械，太阳能，电气和电子工程。我上的课是非电气工程专业的电气工程导论。最常见的研究生工程课程是计算机工程专业，所以最后我拿了那个学位。我还上了艺术课，几门舞蹈课，还有一些计算机科学课程 (Pascal和数据结构)，在计算机工程中，我终于弄清楚了处理器的工作流程，从那以后我一直带着一个处理器在身上。这些就是我学的计算机基础知识。</p><p>刚开始工作的时候，凭借着一堆硬件和相对简单低水平的编程，做了一名计算机工程师。因为C语言似乎是理想的嵌入式系统语言，于是我开始自学，并慢慢开始了解更多关于编程语言的东西。我们在这家公司从源代码构建编译器，这让我大开眼界。 (想象一下一个编译器只是另一个软件的一部分!）</p><p>当我去华盛顿大学海洋学院为Tom Keffer后来创建了“疯狗浪”）工作时，我们决定使用C++。我只有一本Stroustrup写的非初学者书可以参考，最终不得不通过检查C++预处理器生成的中间C代码来了解语言的功能。这个过程非常痛苦，但学习的效果很好。从那以后我就用相同的方式学习，因为它让我学习了如何剖析一种语言，并看到它本质的能力，与此同时开始有了批判性思维。 </p><p>我并没有理解清楚所有的概念。只是在之后的日子里不断反复，我所知道的一切需要时间才能消化吸收。如果我现在能很容易地理解一个新概念，那只是因为它是我已经知道的积累概念的一个变种。在加州理工大学招收非计算机本科学历的计算机科学研究生项目中，学生们曾经说他们花了一年的时间才弄清楚他们对计算机的困惑(他们正在沉浸程序之中)。当人们学习计算机时，他们往往会对自己抱有不切实际的期望，通常是他们听说学计算机编程的好处，就希望在几周内找到一份高薪的工作。但是，最好的学习过程是先对计算机感兴趣，随着时间的推移，学习的越来越多，自然的就开始自学。</p><p>这些就是我主要做的事，尽管我通过学计算机工程有还算扎实的基础，但我没上过编程课，而是通过自学。在此期间我也在不断地学习新事物，在这个行业里，不断学习是非常重要的一部分。</p><h2 id="码农生涯"><a href="#码农生涯" class="headerlink" title="码农生涯"></a>码农生涯</h2><p>我会定期收到有关职业建议的请求，所以我尝试在这里回答一下这个问题。</p><p>人们提出的问题通常是错误的问题：“我应该学习 C++ 还是 Java ？”在本文中，我将尝试阐述我对选择计算机职业所涉及的真正问题的看法。</p><p>请注意，我在这里并不是和那些已经知道自己使命的人聊（译者注：指计划成为程序员或者已经从业的程序员，暗指这里是讲给外行的小白的）。因为无论别人怎么说，你都要去做，因为它已经渗入你的血液，并且你将无法摆脱它。你已经知道答案了：你当然会学到 C++ ，Java ，shell 脚本，Python 和许多其他语言和技术。即使你只有14岁，你也已经知道其中几种语言。</p><p>问我这个问题的人可能来自另一职业。也许他们来自 Web 开发等领域，他们已经发现 HTML 只是一种类似编程，他们想尝试构建更实质的内容。但是，我特别希望，如果你提出这个问题，你就已经意识到，要在计算机领域取得成功，你必须教自己如何学习，并且永不停止学习。</p><p>随着我做的越来越多，在我看来，软件越发比其他任何东西都更像写作。而且我们还没有弄清怎样成为一个好的作家，我们只知道何时我们喜欢别人写的东西。这不是像一些工程那样，我们要做的只是将某些东西放到一端，然后转动曲柄。诱人的是将软件视为确定性的，这就是我们想要的，这就是我们不断推出工具来帮助我们实现所需行为的原因。但是我的经验不断表明事实是相反的：它更多地是关于人而不是过程，并且它在确定性机器上运行的事实变得越来越没有影响力（指运行环境受机器影响，与机器相关这个事实），就像海森堡原理（不确定性原理：不可能同时知道一个粒子的位置和它的速度）不会在人类规模上影响事物一样。</p><p>在我青年时期，父亲是建造民居的，我偶尔会为他工作，大部分时间都从事艰苦的工作，有时还得悬挂石膏板。他和他的木匠会告诉我说，他们是为了我才把这些工作交给了我 —— 为了不让我从事这项工作。这确实是有效的。</p><p>因此，我也可以用比喻说，建造软件就像盖房子一样。我们并不是指每个在房屋上工作的人都一样。有混凝土泥瓦匠，屋顶工，水管工，电工，石膏板工人，抹灰工，瓷砖铺砌工，普通劳工，粗木匠，精整木匠，当然还有总承包商。这些中的每一个都需要一套不同的技能，这需要花费不同的时间和精力 房屋建造也受制于繁荣和萧条的周期，例如编程。为了快速起步，你可能需要当普通劳工或石膏板工人工作，在那里你可以在没有太多学习曲线的情况下开始获得报酬。只要需求旺盛，你就可以稳定工作，而且如果没有足够的人来工作，你的薪水甚至可能会上涨。但是一旦经济低迷，木匠甚至总承包商就可以自己将石膏板挂起来。</p><p>当 Internet 刚兴起时，你所要做的就是花一些时间学习 HTML ，就可以找到一份工作并赚到很多钱。但是，当情况恶化时，你很快就会发现需要的技能层次结构很深，HTML 程序员（例如劳工和石膏板工）排在第一位，而高技能的码农和木匠则被保留。</p><p>我想在这里说的是：除非你准备致力于终身学习，否则请不要从事这项业务。有时，编程似乎是一份报酬丰厚，值得信赖的工作，但确保这一点的唯一方法是，始终使自己变得更有价值。</p><p>当然，也可以找到例外。总会有一些人只学习一种语言，并且足够精通，甚至足够聪明，那么可以在不用多学很多其他知识的情况下继续工作。但是他们靠运气生存，最终很脆弱。为了减少自身的脆弱性，必须通过阅读，参加用户组，会议和研讨会来不断提高自己的能力。你在该领域的走得越深，你的价值就越大，这意味着你的工作前景更稳定，并且可以获得更高的薪水。</p><p>另一种方法是从总体上看待该领域，并找到一个你能成为专家的点。例如，我的兄弟对软件感兴趣，并且涉足软件，但是他的业务是安装计算机，维修计算机和升级计算机。他一直都很细致，因此，当他安装或修理计算机时，你会知道计算机状态良好。不仅是软件，而且一直到电缆，电缆都整齐地捆扎在一起，并且不成束。他的工作多到做不完，而且他从不关心网络泡沫破灭。毋庸置疑，他是不可能失业的。</p><p>我在大学待了很长时间，并以各种方式设法度过了难关。我甚至开始在加州大学洛杉矶分校攻读博士学位。这里的课程很短，我欣慰地说是因为我不再爱上大学了，而我在大学待了这么长时间的原因是因为我非常喜欢。但是我喜欢的通常是跑偏的东西。例如艺术，舞蹈课程，在大学报社工作，以及我参加的少数计算机编程课程（由于我是物理本科生和计算机工程专业的研究生，所以也算跑偏）。尽管我在学业上还算是出色的（具有讽刺意味的是，当时许多不接受我作为学生的大学现在都在课程中使用我的书），但我确实很享受大学生的生活，并且完成了博士学位。我可能会走上简单的道路，最终成为一名教授。</p><p>但是事实证明，我从大学获得的最大价值一部分来自那些跑偏的课程，这些课程使我的思维超出了“我们已经知道的东西”。我认为在计算机领域尤其如此，因为你总是通过编程来实现其他目标，而你对该目标越了解，你的表现就会越好（我学习了一些欧洲研究生课程，这些课程要求结合其他一些专业研究计算，通过解决这个领域相关的问题，你就会形成一种新的理论体系并可以将它用在别处）。</p><p>我还认为，不仅编程，多了解一些其它的知识，还可以大大提高你的解决问题的能力（就像了解一种以上的编程语言可以极大地提高你的编程能力一样）。在很多情况下，我遇到过仅接受过计算机科学训练的人，他们的思维似乎比其他背景（例如数学或物理学）的人更受限制，但其实这些人（数学或物理学领域的人）才更需要严格的思维。</p><p>在我组织的一次会议上，主题之一是为理想的求职者提供一系列功能：</p><ul><li>将学习作为一种生活方式。例如，学习一种以上的语言；没有什么比学习另一种语言更能吸引你的眼球。</li><li>知道在哪里以及如何获得新知识。</li><li>研究现有技术。</li><li>我们是工具使用者，即要善于利用工具。</li><li>学习做最简单的事情。</li><li>了解业务（阅读杂志。从 <em>fast company</em>（国外一家商业杂志）开始，该公司的文章非常简短有趣。然后你就会知道是否要阅读其他的）</li><li>应对错误负责。 “我用着没事”是不可接受的策略。查找自己的错误。</li><li>成为领导者：那些沟通和鼓舞别人的人。</li><li>你在为谁服务？</li><li>没有正确的答案……但总是更好的方法。展示和讨论你的代码，不要有情感上的依恋。你不是你的代码。</li><li>这是通往完美的渐进旅程。</li></ul><p>承担一切可能的风险，最好的风险是那些可怕的风险，但是在尝试时你会比想象中的更加活跃。最好不要刻意去预测某个特定的结果，因为如果你过于重视某个结果，就会经常错过真正的可能性。应该“让我们做一点实验，看看会把我们带到哪里”。这些实验是我最好的冒险。</p><p>有些人对这个答案感到失望，然后回答“是的，这都是非常有趣和有用的。但是实际上，我应该学习什么？ C++ 还是 Java ？”，以防这些问题，我将在这里重复一遍：我知道似乎所有的 1 和 0 都应该使一切具有确定性因此此类问题应该有一个简单的答案，但事实并非如此。这与做出选择并完成选择无关，这是有关持续学习和有时需要大胆的选择。相信我，这样你的生活会更加令人兴奋。</p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://norvig.com/21-days.html">Teach Yourself Programming In Ten Years</a>, by Peter Norvig.</li><li><a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html">How To Be A Programmer</a>, by Robert Read.</li><li>A <a href="http://news.stanford.edu/news/2005/june15/jobs-061505.html">speech by Steve Jobs</a> to inspire a group of graduating college students.</li><li>Kathy Sierra: <a href="https://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html">Does College Matter</a>?</li><li>Paul Graham <a href="http://www.paulgraham.com/college.html">on College</a>.</li><li>Joel Spolsky: <a href="https://www.joelonsoftware.com/2005/01/02/advice-for-computer-science-college-students/">Advice for Computer Science College Students</a>.</li><li>James Shore: <a href="https://www.jamesshore.com/Blog/Five-Design-Skills.html">Five Design Skills Every Programmer Should Have</a>.</li><li>Steve Yegge: <a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html">The Truth About Interviewing</a>.</li></ul><h2 id="百分之五的神话"><a href="#百分之五的神话" class="headerlink" title="百分之五的神话"></a>百分之五的神话</h2><h2 id="重在动手"><a href="#重在动手" class="headerlink" title="重在动手"></a>重在动手</h2><h2 id="像打字般编程"><a href="#像打字般编程" class="headerlink" title="像打字般编程"></a>像打字般编程</h2><h2 id="做你喜欢的事"><a href="#做你喜欢的事" class="headerlink" title="做你喜欢的事"></a>做你喜欢的事</h2><p><em>“1960年，一位研究人员对1500名商学院学生进行了访谈，并将他们分为两类：那些为了钱财来这里上学的人，1245人，以及那些打算利用学位做他们非常关心的事情的人，255人。二十年后，研究人员再次访谈了这些毕业生，发现其中有101位百万富翁，除了其中一位，所有百万富翁都来自追求他们喜欢做的事的那255人！”</em></p><p>“现在你可能觉得你对巴洛克时期的冰岛诗歌，或者蝴蝶收集，或者高尔夫，抑或是对社会正义的热情，会因为要养家糊口而让你和你喜欢做的事分道扬镳，并非一定要如此。弗拉基米尔·纳博科夫（Vladimir Nabokov）是本世纪最伟大的小说家之一，他对蝴蝶收藏的热情远远超过写作。事实上，他的第一个大学教学工作是关于鳞翅类昆虫。在过去40年里，对40万美国群众的研究表明，即使是部分的、零散的追求培养你的激情，也可以帮助你充分利用你目前的能力，激励你培养新的能力。”—摘自《The Other 90%》 Robert K.Cooper</p><p>当然你可以看Po Bronson写的《 What Should I Do With My Life?》这本书，对这些想法进行更多的探索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录-成为一名程序员&quot;&gt;&lt;a href=&quot;#附录-成为一名程序员&quot; class=&quot;headerlink&quot; title=&quot;附录:成为一名程序员&quot;&gt;&lt;/a&gt;附录:成为一名程序员&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我分别于2003，2006，2007和2009年撰</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ZeroBasisLeetcode</title>
    <link href="http://example.com/2022/06/17/ZeroBasisLeetcode/"/>
    <id>http://example.com/2022/06/17/ZeroBasisLeetcode/</id>
    <published>2022-06-17T14:50:00.000Z</published>
    <updated>2022-06-17T17:20:33.998Z</updated>
    
    <content type="html"><![CDATA[<p><strong>九天零基础力扣</strong></p><h1 id="第一天函数"><a href="#第一天函数" class="headerlink" title="第一天函数"></a>第一天函数</h1><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>一般的在线评测系统中，我们要手写输入输出函数，而在lc中只要实现函数就可以了</p><h2 id="刷题步骤"><a href="#刷题步骤" class="headerlink" title="刷题步骤"></a>刷题步骤</h2><p><strong> </strong><strong style="color: rgb(236, 40, 52);">第 1 步：阅读题目；</strong></p><p> <strong style="color: rgb(255, 191, 15);">第 2 步：参考示例；</strong></p><p> <strong style="color: rgb(0, 209, 0);">第 4 步：根据题意，实现函数的功能；</strong></p><p> <strong style="color: rgb(88, 38, 188);">第 5 步：本地数据测试；</strong></p><p> <strong style="color: rgb(166, 166, 166);">第 6 步：提交；</strong></p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>       调用函数的一方不需要了解函数的具体实现，对于它来说，这部分是一个 "黑盒子"，从而使得程序结构更加清晰。 C语言在设计中考虑了函数的 <strong style="color: rgb(68, 17, 12);">高效性</strong> 和 <strong style="color: rgb(68, 17, 12);">易用性</strong> 两个原则。函数的实现应该尽量简短，因为函数可以套函数，一个程序应该尽量由许多小的函数组成，而不是由少量较大函数组成。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="整数乘法371-两整数之和-力扣（LeetCode）"><a href="#整数乘法371-两整数之和-力扣（LeetCode）" class="headerlink" title="整数乘法371. 两整数之和 - 力扣（LeetCode）"></a>整数乘法<a href="https://leetcode.cn/problems/sum-of-two-integers/">371. 两整数之和 - 力扣（LeetCode）</a></h3><blockquote><p>给你两个整数 <code>a</code> 和 <code>b</code> ，<strong>不使用</strong> 运算符 <code>+</code> 和 <code>-</code> ，计算并返回两整数之和。</p></blockquote><p>  实现一个函数multiply，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p><p>​       (1) 这里int是C/C++中的一种类型，代表整数，即 Integer，传入参数是两个整数； 题目要求返回两个整数的乘积，并且要求不能用*，那如果我用了会怎么样？答案是并不会怎么样，因为平台不会去对它做语法分析，只是调用了你的函数，提供一些输入数据，如果输出数据和它给定的相同，就算通过。作为你接触算法的第一道题，其实这些条件都无所谓的，能过就行，他只检测输入输出，不检测你实际代码。 </p><p>​       (2) 对于新人来说，把<strong>问题过掉比问题</strong>本身更重要，题数的增加，是信心的增加，信心比什么都重要，有了信心，你才能继续往下走，只要你能往下推进，你就能继续学习，继续学习你迟早会学到相应的算法。好了，过了这题以后，把这道题放入你的重刷列表，等你对算法有一定理解以后再来用题目要求的方法来过了它。</p><h3 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h3><blockquote><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p><p>示例 1:</p><p>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3<br>示例 2:</p><p>输入: dividend = 7, divisor = -3<br>输出: -2<br>解释: 7/-3 = truncate(-2.33333..) = -2</p><p>提示：</p><p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p></blockquote><h3 id="次幂函数"><a href="#次幂函数" class="headerlink" title="次幂函数"></a>次幂函数</h3><h3 id="开方函数"><a href="#开方函数" class="headerlink" title="开方函数"></a>开方函数</h3><h3 id="最值函数"><a href="#最值函数" class="headerlink" title="最值函数"></a>最值函数</h3><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;九天零基础力扣&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一天函数&quot;&gt;&lt;a href=&quot;#第一天函数&quot; class=&quot;headerlink&quot; title=&quot;第一天函数&quot;&gt;&lt;/a&gt;第一天函数&lt;/h1&gt;&lt;h2 id=&quot;输入和输出&quot;&gt;&lt;a href=&quot;#输入和输</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>六月集训</title>
    <link href="http://example.com/2022/05/31/text/"/>
    <id>http://example.com/2022/05/31/text/</id>
    <published>2022-05-31T05:22:47.000Z</published>
    <updated>2022-06-02T16:59:35.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>[TOC]</p><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1、顺序存储"><a href="#1、顺序存储" class="headerlink" title="1、顺序存储"></a>1、顺序存储</h2><p>  顺序存储结构，是指用一段地址连续的存储单元依次存储线性表的数据元素。<br><img src="https://img-blog.csdnimg.cn/2021052910070993.gif#pic_center" alt="img"></p><h2 id="2、存储方式"><a href="#2、存储方式" class="headerlink" title="2、存储方式"></a>2、存储方式</h2><p>  在编程语言中，用一维数组来实现顺序存储结构，在C语言中，把第一个数据元素存储到下标为 0 的位置中，把第 2 个数据元素存储到下标为 1 的位置中，以此类推。</p><h2 id="3、长度和容量"><a href="#3、长度和容量" class="headerlink" title="3、长度和容量"></a>3、长度和容量</h2><p>  数组的长度指的是数组当前有多少个元素，数组的容量指的是数组最大能够存放多少个元素。如果数组元素大于最大能存储的范围，在程序上是不允许的，可能会产生意想不到的问题，实现上是需要规避的。<br><img src="https://img-blog.csdnimg.cn/67912e8fc2a34566b5da5a0fe7ef49a6.png#pic_center" alt="img"><br>  如上图所示，数组的长度为 5，即红色部分；容量为 8，即红色 加 蓝色部分。</p><h2 id="4、数据结构定义"><a href="#4、数据结构定义" class="headerlink" title="4、数据结构定义"></a>4、<a href="https://so.csdn.net/so/search?q=数据结构&amp;spm=1001.2101.3001.7020">数据结构</a>定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DataType int        <span class="comment">// (1)</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span> &#123;</span></span><br><span class="line">    DataType data[MAXN];    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">// (3)</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) 数组类型为<code>DataType</code>，定义为<code>int</code>；</li><li>( 2 ) (2)(2) <code>SeqList</code>定义的就是一个最多存放<code>MAXN</code>个元素的数组，<code>MAXN</code>代表数组容量；</li><li>( 3 ) (3)(3) <code>length</code>代表数组长度，即当前的元素个数。</li></ul><h1 id="二、常用接口实现"><a href="#二、常用接口实现" class="headerlink" title="二、常用接口实现"></a>二、常用接口实现</h1><h2 id="1、只读接口"><a href="#1、只读接口" class="headerlink" title="1、只读接口"></a>1、只读接口</h2><h3 id="1）索引"><a href="#1）索引" class="headerlink" title="1）索引"></a>1）索引</h3><p>  <strong>索引</strong> 就是通过 <strong>数组下标</strong> 寻找 <strong>数组元素</strong> 的过程。C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">SeqListIndex</span><span class="params">(struct SeqList *sq, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sq-&gt;data[i];          <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) 调用方需要注意 i i<em>i</em> 的取值必须为非负整数，且小于数组最大长度。否则有可能导致异常，引发崩溃。</li><li>索引的算法时间复杂度为 O ( 1 ) O(1)<em>O</em>(1)。<br><img src="https://img-blog.csdnimg.cn/f1aa18a5b4514e25b97587036ccf9442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA6Iux6ZuE5ZOq6YeM5Ye65p2l,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></li></ul><h3 id="2）查找"><a href="#2）查找" class="headerlink" title="2）查找"></a>2）查找</h3><p>  <strong>查找</strong> 就是通过 <strong>数组元素</strong> 寻找 <strong>数组下标</strong> 的过程，是索引的逆过程。<br>  对于有序数组，可以采用 二分 进行查找，时间复杂度为 O ( l o g 2 n ) O(log_2n)<em>O</em>(<em>l<strong>o</strong>g</em>2​<em>n</em>)；对于无序数组，只能通过遍历比较，由于元素可能不在数组中，可能遍历全表，所以查找的最坏时间复杂度为 O ( n ) O(n)<em>O</em>(<em>n</em>)。<br>  简单介绍一个线性查找的例子，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">SeqListFind</span><span class="params">(struct SeqList *sq, DataType dt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sq-&gt;length; ++i) &#123; <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span>(sq-&gt;data[i] == dt) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;                 <span class="comment">// (2)</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                        <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) 遍历数组元素；</li><li>( 2 ) (2)(2) 对数组元素 和 传入的数据进行判等，一旦发现相等就返回对应数据的下标；</li><li>( 3 ) (3)(3) 当数组遍历完还是找不到，说明这个数据肯定是不存在的，直接返回 − 1 -1−1。<br><img src="https://img-blog.csdnimg.cn/1204116368f0428c8901711a8ec26851.gif#pic_center" alt="img"></li></ul><h3 id="3）获取长度"><a href="#3）获取长度" class="headerlink" title="3）获取长度"></a>3）获取长度</h3><p>  获取 <strong>数组的长度</strong> 指的是查询当前有多少元素。可以直接用结构体的内部变量。C语言代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">SeqListGetLength</span><span class="params">(struct SeqList *sq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sq-&gt;length; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="2、可写接口"><a href="#2、可写接口" class="headerlink" title="2、可写接口"></a>2、可写接口</h2><h3 id="1）插入"><a href="#1）插入" class="headerlink" title="1）插入"></a>1）插入</h3><p>  插入接口定义为：在数组的第 k k<em>k</em> 个元素前插入一个数 v v<em>v</em>。由于数组是连续存储的，那么从 k k<em>k</em> 个元素往后的元素都必须往后移动一位，当 k = 0 k=0<em>k</em>=0 时，所有元素都必须移动，所以最坏时间复杂度为 O ( n ) O(n)<em>O</em>(<em>n</em>)。C语言代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqListInsert</span><span class="params">(struct SeqList *sq, <span class="keyword">int</span> k, DataType v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(sq-&gt;length == MAXN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                        <span class="comment">// (1) </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(i = sq-&gt;length; i &gt; k; --i) &#123;</span><br><span class="line">        sq-&gt;data[i] = sq-&gt;data[i<span class="number">-1</span>];     <span class="comment">// (2) </span></span><br><span class="line">    &#125;</span><br><span class="line">    sq-&gt;data[k] = v;                     <span class="comment">// (3) </span></span><br><span class="line">    sq-&gt;length ++;                       <span class="comment">// (4) </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                            <span class="comment">// (5) </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) 当元素个数已满时，返回 0 00 代表插入失败；</li><li>( 2 ) (2)(2) 从第 k k<em>k</em> 个数开始，每个数往后移动一个位置，注意必须逆序；</li><li>( 3 ) (3)(3) 将第 k k<em>k</em> 个数变成 v v<em>v</em>；</li><li>( 4 ) (4)(4) 插入了一个数，数组长度加一；</li><li>( 5 ) (5)(5) 返回 1 11 代表插入成功；</li></ul><h3 id="2）删除"><a href="#2）删除" class="headerlink" title="2）删除"></a>2）删除</h3><p>  删除接口定义为：将数组的第 k k<em>k</em> 个元素删除。由于数组是连续存储的，那么第 k k<em>k</em> 个元素删除，往后的元素势必要往前移动一位，当 k = 0 k=0<em>k</em>=0 时，所有元素都必须移动，所以最坏时间复杂度为 O ( n ) O(n)<em>O</em>(<em>n</em>)。C语言代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqListDelete</span><span class="params">(struct SeqList *sq, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(sq-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                        <span class="comment">// (1) </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(i = k; i &lt; sq-&gt;length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        sq-&gt;data[i] = sq-&gt;data[i+<span class="number">1</span>];     <span class="comment">// (2) </span></span><br><span class="line">    &#125; </span><br><span class="line">    sq-&gt;length --;                       <span class="comment">// (3) </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                            <span class="comment">// (4)  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) 返回0代表删除失败；</li><li>( 2 ) (2)(2) 从前往后；</li><li>( 3 ) (3)(3) 数组长度减一；</li><li>( 4 ) (4)(4) 返回1代表删除成功；</li></ul><h1 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h1><h2 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h2><p>  1）无须为表示表中元素逻辑关系而增加额外的存储空间；<br>  2）随机存取元素时可以达到 O ( 1 ) O(1)<em>O</em>(1)，效率高；</p><h2 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h2><p>  1）插入和删除时需要移动大量元素；<br>  2）必须一开始就确定存储空间的容量；</p><h1 id="四、数组相关算法"><a href="#四、数组相关算法" class="headerlink" title="四、数组相关算法"></a>四、数组相关算法</h1><h2 id="1、线性枚举"><a href="#1、线性枚举" class="headerlink" title="1、线性枚举"></a>1、线性枚举</h2><h3 id="1）问题描述"><a href="#1）问题描述" class="headerlink" title="1）问题描述"></a>1）问题描述</h3><blockquote><p>  给定一个长度为 n ( 1 ≤ n ≤ 1 0 5 ) n(1 \le n \le 10^5)<em>n</em>(1≤<em>n</em>≤105) 的整型数组，求所有数组元素中的其中的最小值。</p></blockquote><h3 id="2）动图演示"><a href="#2）动图演示" class="headerlink" title="2）动图演示"></a>2）动图演示</h3><p><img src="https://img-blog.csdnimg.cn/2021052910070993.gif#pic_center" alt="img"></p><h3 id="3）示例说明"><a href="#3）示例说明" class="headerlink" title="3）示例说明"></a>3）示例说明</h3><p>  蓝色的数据代表的是数组数据，红色的数据代表当前枚举到的数据，这样就可以遍历所有的数据进行逻辑处理了。</p><h3 id="4）算法描述"><a href="#4）算法描述" class="headerlink" title="4）算法描述"></a>4）算法描述</h3><p>  遍历数组，进行条件判断，条件满足则执行逻辑。这里的条件就是 <strong>枚举到的数</strong> 是否小于 <strong>当前最小值</strong>，执行逻辑为 将 <strong>当前枚举到的数</strong> 赋值给 <strong>当前最小值</strong>；</p><h3 id="5）源码详解"><a href="#5）源码详解" class="headerlink" title="5）源码详解"></a>5）源码详解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, min = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;     <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; min) &#123;             <span class="comment">// (2)</span></span><br><span class="line">            min = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;                         <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) 遍历数组中所有的数；</li><li>( 2 ) (2)(2) 如果 <strong>当前枚举到的数</strong> 比记录的变量<code>min</code>小，则将它赋值给<code>min</code>；否则，不做任何处理；</li><li>( 3 ) (3)(3) 最后，<code>min</code>中存储的就是整个数组的最小值。</li></ul><h2 id="2、前缀和差分"><a href="#2、前缀和差分" class="headerlink" title="2、前缀和差分"></a>2、前缀和差分</h2><h3 id="1）问题描述-1"><a href="#1）问题描述-1" class="headerlink" title="1）问题描述"></a>1）问题描述</h3><blockquote><p>  给定一个 n ( n ≤ 1 0 5 ) n (n \le 10^5)<em>n</em>(<em>n</em>≤105) 个元素的整型数组 a i a<em>i<em>a**i</em>，再给出 m ( m ≤ 1 0 5 ) m(m \le 10^5)<em>m</em>(<em>m</em>≤105) 次询问，每次询问是一个区间 [ l , r ] [l, r][<em>l</em>,<em>r</em>]，求 h ( l , r ) = ∑ k = l r a k h(l,r) = \sum</em>{k=l}^r a_k<em>h</em>(<em>l</em>,<em>r</em>)=∑<em>k</em>=<em>l<strong>r</strong>a**k</em></p></blockquote><h3 id="2）动图演示-1"><a href="#2）动图演示-1" class="headerlink" title="2）动图演示"></a>2）动图演示</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/1acb76c5164888d7dda3f2da46823db7.gif#pic_center" alt="img"></p><h3 id="3）样例分析"><a href="#3）样例分析" class="headerlink" title="3）样例分析"></a>3）样例分析</h3><p>  如上图所示，只需要记录一个前缀和，然后就可以通过一次减法将区间的值计算出来。时间复杂度 O ( 1 ) O(1)<em>O</em>(1)。这种就是差分的思想。</p><h3 id="4）算法描述-1"><a href="#4）算法描述-1" class="headerlink" title="4）算法描述"></a>4）算法描述</h3><p>  第一个枚举，利用一个数组<code>sum</code>，存储前 i i<em>i</em> 个元素的和。<br>  第二个枚举，读入 m m<em>m</em> 组数据 l , r l, r<em>l</em>,<em>r</em>，对每组数据，通过 O ( 1 ) O(1)<em>O</em>(1) 获取答案，即 s u m r − s u m l − 1 sum<em>r - sum</em>{l-1}<em>s<strong>u</strong>m**r</em>​−<em>s<strong>u</strong>m**l</em>−1​。</p><h3 id="5）源码详解-1"><a href="#5）源码详解-1" class="headerlink" title="5）源码详解"></a>5）源码详解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">prefixSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> m, <span class="keyword">int</span> *l, <span class="keyword">int</span> *r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *ret;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        sum[i] = nums[i];</span><br><span class="line">        <span class="keyword">if</span>(i) </span><br><span class="line">            sum[i] += sum[i<span class="number">-1</span>];                 <span class="comment">// (1) </span></span><br><span class="line">    &#125;</span><br><span class="line">    ret = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>( m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );    <span class="comment">// (2) </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> leftsum = l[i]==<span class="number">0</span>? <span class="number">0</span> : sum[l[i]<span class="number">-1</span>]; <span class="comment">// (3) </span></span><br><span class="line">    <span class="keyword">int</span> rightsum = sum[r[i]];</span><br><span class="line">    ret[i] = rightsum - leftsum;            <span class="comment">// (4) </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) 计算前缀和；</li><li>( 2 ) (2)(2) 需要返回的数组；</li><li>( 3 ) (3)(3) 这里是为了防止数组下标越界；</li><li>( 4 ) (4)(4) 核心 O ( 1 ) O(1)<em>O</em>(1) 的差分计算；</li></ul><h2 id="3、双指针"><a href="#3、双指针" class="headerlink" title="3、双指针"></a>3、双指针</h2><h3 id="1）问题描述-2"><a href="#1）问题描述-2" class="headerlink" title="1）问题描述"></a>1）问题描述</h3><blockquote><p>  给定一个长度为 n ( 1 ≤ n ≤ 1 0 7 ) n (1 \le n \le 10^7)<em>n</em>(1≤<em>n</em>≤107) 的字符串 s s<em>s</em>，求一个最长的满足所有字符不重复的子串。</p></blockquote><h3 id="2）动图演示-2"><a href="#2）动图演示-2" class="headerlink" title="2）动图演示"></a>2）动图演示</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/78e200e3cbf8d09dc04b8faa0aa20402.gif#pic_center" alt="img"></p><h3 id="3）样例说明"><a href="#3）样例说明" class="headerlink" title="3）样例说明"></a>3）样例说明</h3><p>  维护两个指针 i i<em>i</em> 和 j j<em>j</em>，区间 [ i , j ] [i, j][<em>i</em>,<em>j</em>] 内的子串，应该时刻保持其中所有字符不重复，一旦发现重复字符，就需要自增 i i<em>i</em>（即执行 i = i + 1 i = i + 1<em>i</em>=<em>i</em>+1）；否则，执行 j = j + 1 j = j + 1<em>j</em>=<em>j</em>+1，直到 j j<em>j</em> 不能再增加为止。<br>  过程中，记录合法情况下 j − i + 1 j - i + 1<em>j</em>−<em>i</em>+1 的最大值。</p><h3 id="4）算法描述-2"><a href="#4）算法描述-2" class="headerlink" title="4）算法描述"></a>4）算法描述</h3><p>  如上文所述，这种利用问题特性，通过两个指针，不断调整区间，从而求出问题最优解的算法就叫 “尺取法”，由于利用的是两个指针，所以又叫 “双指针” 算法。<br>  这里 “尺” 的含义，主要还是因为这类问题，最终要求解的都是连续的序列（子串），就好比一把尺子一样，故而得名。</p><blockquote><p>算法描述如下：<br>  1）初始化 i = 0 i=0<em>i</em>=0, j = i − 1 j=i-1<em>j</em>=<em>i</em>−1，代表一开始 “尺子” 的长度为 0；<br>  2）增加 “尺子” 的长度，即 j = j + 1 j = j +1<em>j</em>=<em>j</em>+1；<br>  3）判断当前这把 “尺子” [ i , j ] [i, j][<em>i</em>,<em>j</em>] 是否满足题目给出的条件：<br>    3.a）如果不满足，则减小 “尺子” 长度，即 i = i + 1 i = i + 1<em>i</em>=<em>i</em>+1，回到 3）；<br>    3.b）如果满足，记录最优解，回到 2）；</p></blockquote><ul><li>上面这段文字描述的比较官方，其实这个算法的核心，只有一句话：满足条件时， j j<em>j</em>++；不满足条件时， i i<em>i</em>++；</li><li>如图所示，当区间 [ i , j ] [i, j][<em>i</em>,<em>j</em>] 满足条件时，用蓝色表示，此时 j j<em>j</em> 自增；反之闪红，此时 i i<em>i</em> 自增。<br><img src="https://img-blog.csdnimg.cn/img_convert/17c50a301d13627d7e760e1301245ecd.gif#pic_center" alt="在这里插入图片描述"></li></ul><h3 id="5）源码详解-2"><a href="#5）源码详解-2" class="headerlink" title="5）源码详解"></a>5）源码详解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmaxlen</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> *str, <span class="keyword">int</span>&amp; l, <span class="keyword">int</span>&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">-1</span>, len;   <span class="comment">// 1)</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));           <span class="comment">// 2)</span></span><br><span class="line">    <span class="keyword">while</span> (j++ &lt; n - <span class="number">1</span>) &#123;              <span class="comment">// 3)</span></span><br><span class="line">        ++h[ str[j] ];                 <span class="comment">// 4)</span></span><br><span class="line">        <span class="keyword">while</span> (h[ str[j] ] &gt; <span class="number">1</span>) &#123;      <span class="comment">// 5)</span></span><br><span class="line">            --h[ str[i] ];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        len = j - i + <span class="number">1</span>;              </span><br><span class="line">        <span class="keyword">if</span>(len &gt; ans)                  <span class="comment">// 6)</span></span><br><span class="line">            ans = len, l = i, r = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><ul><li>1）初始化 <code>i = 0, j = -1</code>，代表 s [ i : j ] s[i:j]<em>s</em>[<em>i</em>:<em>j</em>] 为一个空串，从空串开始枚举；</li><li>2）需要维护一个哈希表，哈希表记录的是当前枚举的区间 s [ i : j ] s[i:j]<em>s</em>[<em>i</em>:<em>j</em>] 中每个字符的个数；</li><li>3）只推进子串的右端点；</li><li>4）在哈希表中记录字符的个数；</li><li>5）当 <code>h[ str[j] ] &gt; 1</code>满足时，代表出现了重复字符<code>str[j]</code>，这时候左端点 i i<em>i</em> 推进，直到没有重复字符为止；</li><li>6）记录当前最优解的长度 <code>j - i + 1</code>，更新；</li><li>这个算法执行完毕，我们就可以得到最长不重复子串的长度为 a n s ans<em>a<strong>n</strong>s</em>，并且 i i<em>i</em> 和 j j<em>j</em> 这两个指针分别只自增 n n<em>n</em> 次，两者自增相互独立，是一个相加而非相乘的关系，所以这个算法的时间复杂度为 O ( n ) O(n)<em>O</em>(<em>n</em>) 。</li></ul><h2 id="4、二分枚举"><a href="#4、二分枚举" class="headerlink" title="4、二分枚举"></a>4、二分枚举</h2><h3 id="1）问题描述-3"><a href="#1）问题描述-3" class="headerlink" title="1）问题描述"></a>1）问题描述</h3><blockquote><p>  给定一个 n ( n ≤ 1 0 6 ) n(n \le 10^6)<em>n</em>(<em>n</em>≤106) 个元素的有序整型数组和一个 t a r g e t target<em>t<strong>a</strong>r<strong>g</strong>e**t</em> 值，求在 O ( l o g 2 n ) O(log_2n)<em>O</em>(<em>l<strong>o</strong>g</em>2<em>n</em>) 的时间内找到值为 t a r g e t target<em>t<strong>a</strong>r<strong>g</strong>e**t</em> 的整型的数组下标，不存在则返回 -1。</p></blockquote><h3 id="2）动图演示-3"><a href="#2）动图演示-3" class="headerlink" title="2）动图演示"></a>2）动图演示</h3><p><img src="https://img-blog.csdnimg.cn/f73c48a1f7554ef0a919d4ec027960f8.gif#pic_center" alt="img"></p><h3 id="3）样例说明-1"><a href="#3）样例说明-1" class="headerlink" title="3）样例说明"></a>3）样例说明</h3><p>  需要找值为 5 55 的这个元素。<br>  黄色箭头 代表都是左区间端点 l l<em>l</em>，红色箭头 代表右区间端点 r r<em>r</em>。蓝色的数据为数组数据，绿色的数字代表的是数组下标，初始化 l = 0 l = 0<em>l</em>=0，r = 7 r = 7<em>r</em>=7，由于数组有序，则可以直接折半，令 m i d = ( l + r ) / 2 = 3 mid = (l + r) / 2 = 3<em>m<strong>i</strong>d</em>=(<em>l</em>+<em>r</em>)/2=3，则 5 55 一定落入区间 [ 0 , 3 ] [0, 3][0,3]，这时候令 r = 3 r = 3<em>r</em>=3，继续执行，直到 l &gt; r l &gt; r<em>l</em>&gt;<em>r</em> 结束迭代。<br>  最后，当 m i d = 2 mid=2<em>m<strong>i</strong>d</em>=2 时，找到数据 5。</p><h3 id="4）算法描述-3"><a href="#4）算法描述-3" class="headerlink" title="4）算法描述"></a>4）算法描述</h3><p>  a）令初始情况下，数组下标从 0 开始，且数组长度为 n n<em>n</em>，则定义一个区间，它的左端点是 l = 0 l=0<em>l</em>=0，右端点是 r = n − 1 r = n-1<em>r</em>=<em>n</em>−1；<br>  b）生成一个区间中点 m i d = ( l + r ) / 2 mid = (l + r) / 2<em>m<strong>i</strong>d</em>=(<em>l</em>+<em>r</em>)/2，并且判断 m i d mid<em>m<strong>i</strong>d</em> 对应的数组元素和给定的目标值的大小关系，主要有三种：<br>    b.1）目标值 等于 数组元素，直接返回 m i d mid<em>m<strong>i</strong>d</em>；<br>    b.2）目标值 大于 数组元素，则代表目标值应该出现在区间 [ m i d + 1 , r ] [mid+1, r][<em>m<strong>i</strong>d</em>+1,<em>r</em>]，迭代左区间端点：l = m i d + 1 l = mid + 1<em>l</em>=<em>m<strong>i</strong>d</em>+1；<br>    b.3）目标值 小于 数组元素，则代表目标值应该出现在区间 [ l , m i d − 1 ] [l, mid-1][<em>l</em>,<em>m<strong>i</strong>d</em>−1]，迭代右区间端点：r = m i d − 1 r = mid - 1<em>r</em>=<em>m<strong>i</strong>d</em>−1；<br>  c）如果这时候 l &gt; r l &gt; r<em>l</em>&gt;<em>r</em>，则说明没有找到目标值，返回 − 1 -1−1；否则，回到 b）继续迭代。</p><h3 id="5）源码详解-3"><a href="#5）源码详解-3" class="headerlink" title="5）源码详解"></a>5）源码详解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = numsSize - <span class="number">1</span>;         <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;                      <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;          <span class="comment">// (3)</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;   </span><br><span class="line">            <span class="keyword">return</span> mid;                  <span class="comment">// (4)</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid]) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;                 <span class="comment">// (5)</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[mid]) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;                 <span class="comment">// (6)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                           <span class="comment">// (7)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) 初始化区间左右端点；</li><li>( 2 ) (2)(2) 一直迭代左右区间的端点，直到 <strong>左端点 大于 右端点</strong> 结束；</li><li>( 3 ) (3)(3) <code>&gt;&gt; 1</code>等价于除 2，也就是这里<code>mid</code>代表的是<code>l</code>和<code>r</code>的中点；</li><li>( 4 ) (4)(4) <code>nums[mid] == target</code>表示正好找到了这个数，则直接返回下标<code>mid</code>；</li><li>( 5 ) (5)(5) <code>target &gt; nums[mid]</code>表示<code>target</code>这个数在区间 [ m i d + 1 , r ] [mid+1, r][<em>m<strong>i</strong>d</em>+1,<em>r</em>] 中，所以才有左区间赋值如下：<code>l = mid + 1;</code></li><li>( 6 ) (6)(6) <code>target &lt; nums[mid]</code>表示<code>target</code>这个数在区间 [ l , m i d − 1 ] [l, mid - 1][<em>l</em>,<em>m<strong>i</strong>d</em>−1] 中，所以才有右区间赋值如下：<code>r = mid - 1;</code></li><li>( 7 ) (7)(7) 这一步呼应了 ( 2 ) (2)(2)，表示这不到给定的数，直接返回 <code>-1</code>；</li></ul><h2 id="5、三分枚举"><a href="#5、三分枚举" class="headerlink" title="5、三分枚举"></a>5、三分枚举</h2><blockquote><p>  <strong>三分枚举</strong> 类似 <strong>二分枚举</strong> 的思想，也是将区间一下子砍掉一块基本完全不可能的块，从而减小算法的时间复杂度。只不过 <strong>二分枚举</strong> 解决的是 单调性 问题。而 <strong>三分枚举</strong> 解决的是 极值问题。</p></blockquote><h2 id="6、插入排序"><a href="#6、插入排序" class="headerlink" title="6、插入排序"></a>6、插入排序</h2><h3 id="1）问题描述-4"><a href="#1）问题描述-4" class="headerlink" title="1）问题描述"></a>1）问题描述</h3><blockquote><p>  给定一个 n n<em>n</em> 个元素的数组，数组下标从 0 00 开始，采用<strong>「 插入排序 」</strong>将数组按照 <strong>「升序」</strong>排列。</p></blockquote><h3 id="2）动图演示-4"><a href="#2）动图演示-4" class="headerlink" title="2）动图演示"></a>2）动图演示</h3><p><img src="https://img-blog.csdnimg.cn/4d5d54dcbc7b47b18c45e0a23b906780.gif#pic_center" alt="img"></p><h3 id="3）样例说明-2"><a href="#3）样例说明-2" class="headerlink" title="3）样例说明"></a>3）样例说明</h3><div class="table-container"><table><thead><tr><th>图示</th><th>含义</th></tr></thead><tbody><tr><td>■ 的柱形</td><td>代表尚未排好序的数</td></tr><tr><td>■ 的柱形</td><td>代表正在执行 比较 和 移动 的数</td></tr><tr><td>■ 的柱形</td><td>代表已经排好序的数</td></tr><tr><td>■ 的柱形</td><td>代表待执行插入的数</td></tr></tbody></table></div><blockquote><p>  我们看到，首先需要将 <strong>「第二个元素」</strong> 和 <strong>「第一个元素」</strong> 进行 <strong>「比较」</strong>，如果 <strong>前者</strong> 小于等于 <strong>后者</strong>，则将 <strong>后者</strong> 进行向后 <strong>「移动」</strong>，<strong>前者</strong> 则执行插入；<br>  然后，进行第二轮<strong>「比较」</strong>，即 <strong>「第三个元素」</strong> 和 <strong>「第二个元素」、「第一个元素」</strong> 进行 <strong>「比较」</strong>， 直到 <strong>「前三个元素」</strong> 保持有序 。<br>  最后，经过一定轮次的<strong>「比较」</strong> 和 <strong>「移动」</strong>之后，一定可以保证所有元素都是 <strong>「升序」</strong> 排列的。</p></blockquote><h3 id="4）算法描述-4"><a href="#4）算法描述-4" class="headerlink" title="4）算法描述"></a>4）算法描述</h3><blockquote><p>整个算法的执行过程分以下几步：<br>  <strong>1）</strong> 循环迭代变量 i = 1 → n − 1 i = 1 \to n-1<em>i</em>=1→<em>n</em>−1；<br>  <strong>2）</strong> 每次迭代，令 x = a [ i ] x = a[i]<em>x</em>=<em>a</em>[<em>i</em>]，j = i − 1 j = i-1<em>j</em>=<em>i</em>−1，循环执行比较 x x<em>x</em> 和 a [ j ] a[j]<em>a</em>[<em>j</em>]，如果产生 x ≤ a [ j ] x \le a[j]<em>x</em>≤<em>a</em>[<em>j</em>] 则执行 a [ j + 1 ] = a [ j ] a[j+1] = a[j]<em>a</em>[<em>j</em>+1]=<em>a</em>[<em>j</em>]。然后执行 j = j + 1 j = j + 1<em>j</em>=<em>j</em>+1，继续执行 <strong>2）</strong>；否则，跳出循环，回到 <strong>1）</strong>。</p></blockquote><h3 id="5）源码详解-4"><a href="#5）源码详解-4" class="headerlink" title="5）源码详解"></a>5）源码详解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;       <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">int</span> i, j; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i];                  <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;    <span class="comment">// (3)</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt;= a[j]) &#123;            <span class="comment">// (4)</span></span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];         <span class="comment">// (5)</span></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;                 <span class="comment">// (6)</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = x;                    <span class="comment">// (7)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        Input(n, a);</span><br><span class="line">        InsertSort(n, a);</span><br><span class="line">        Output(n, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) <code>void InsertSort(int n, int *a)</code>为 <strong>插入排序</strong> 的实现，代表对<code>a[]</code>数组进行升序排序。</li><li>( 2 ) (2)(2) 此时<code>a[i]</code>前面的 <code>i-1</code>个数都认为是排好序的，令<code>x = a[i]</code>；</li><li>( 3 ) (3)(3) 逆序的枚举所有的已经排好序的数；</li><li>( 4 ) (4)(4) 如果枚举到的数<code>a[j]</code>比需要插入的数<code>x</code>大，则当前数往后挪一个位置；</li><li>( 5 ) (5)(5) 执行挪位置的 O ( 1 ) O(1)<em>O</em>(1) 操作；</li><li>( 6 ) (6)(6) 否则，跳出循环；</li><li>( 7 ) (7)(7) 将<code>x</code>插入到合适位置；</li></ul><h2 id="7、选择排序"><a href="#7、选择排序" class="headerlink" title="7、选择排序"></a>7、选择排序</h2><h3 id="1）问题描述-5"><a href="#1）问题描述-5" class="headerlink" title="1）问题描述"></a>1）问题描述</h3><blockquote><p>  给定一个 n n<em>n</em> 个元素的数组，数组下标从 0 00 开始，采用<strong>「 选择排序 」</strong>将数组按照 <strong>「升序」</strong>排列。</p></blockquote><h3 id="2）动图演示-5"><a href="#2）动图演示-5" class="headerlink" title="2）动图演示"></a>2）动图演示</h3><p><img src="https://img-blog.csdnimg.cn/1b1ec4fcf6024ad4a659fab5f21a7075.gif#pic_center" alt="img"></p><h3 id="3）样例说明-3"><a href="#3）样例说明-3" class="headerlink" title="3）样例说明"></a>3）样例说明</h3><div class="table-container"><table><thead><tr><th>图示</th><th>含义</th></tr></thead><tbody><tr><td>■ 的柱形</td><td>代表尚未排好序的数</td></tr><tr><td>■ 的柱形</td><td>代表正在执行 比较 的数</td></tr><tr><td>■ 的柱形</td><td>代表已经排好序的数</td></tr><tr><td>■ 的柱形</td><td>有两种：1、记录最小元素 2、执行交换的元素</td></tr></tbody></table></div><blockquote><p>  我们发现，首先从 <strong>「第一个元素」</strong> 到 <strong>「最后一个元素」</strong> 中选择出一个 <strong>「最小的元素」</strong>，和 <strong>「第一个元素」</strong> 进行 <strong>「交换」</strong>；<br>  然后，从 <strong>「第二个元素」</strong> 到 <strong>「最后一个元素」</strong> 中选择出一个 <strong>「最小的元素」</strong>，和 <strong>「第二个元素」</strong> 进行 <strong>「交换」</strong>。<br>  最后，一定可以保证所有元素都是 <strong>「升序」</strong> 排列的。</p></blockquote><h3 id="4）算法描述-5"><a href="#4）算法描述-5" class="headerlink" title="4）算法描述"></a>4）算法描述</h3><blockquote><p>整个算法的执行过程分以下几步：<br>  <strong>1）</strong> 循环迭代变量 i = 0 → n − 1 i = 0 \to n-1<em>i</em>=0→<em>n</em>−1；<br>  <strong>2）</strong> 每次迭代，令 m i n = i min = i<em>m<strong>i</strong>n</em>=<em>i</em>，j = i + 1 j = i+1<em>j</em>=<em>i</em>+1；<br>  <strong>3）</strong> 循环执行比较 a [ j ] a[j]<em>a</em>[<em>j</em>] 和 a [ m i n ] a[min]<em>a</em>[<em>m<strong>i</strong>n</em>]，如果产生 a [ j ] &lt; a [ m i n ] a[j] \lt a[min]<em>a</em>[<em>j</em>]&lt;<em>a</em>[<em>m<strong>i</strong>n</em>] 则执行 m i n = j min = j<em>m<strong>i</strong>n</em>=<em>j</em>。执行 j = j + 1 j = j + 1<em>j</em>=<em>j</em>+1，继续执行这一步，直到 j = = n j == n<em>j</em>==<em>n</em>；<br>  <strong>4）</strong> 交换 a [ i ] a[i]<em>a</em>[<em>i</em>] 和 a [ m i n ] a[min]<em>a</em>[<em>m<strong>i</strong>n</em>]，回到 <strong>1）</strong>。</p></blockquote><h3 id="5）源码详解-5"><a href="#5）源码详解-5" class="headerlink" title="5）源码详解"></a>5）源码详解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;  <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;     <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">int</span> min = i;                 <span class="comment">// (3)</span></span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; n; ++j) &#123;   <span class="comment">// (4)</span></span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[min]) &#123;</span><br><span class="line">                min = j;             <span class="comment">// (5)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Swap(&amp;a[i], &amp;a[min]);        <span class="comment">// (6) </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        Input(n, a);</span><br><span class="line">        SelectionSort(n, a);</span><br><span class="line">        Output(n, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) <code>void SelectionSort(int n, int *a)</code>为选择排序的实现，代表对<code>a[]</code>数组进行升序排序。</li><li>( 2 ) (2)(2) 从首元素个元素开始进行 n − 1 n-1<em>n</em>−1 次跌迭代。</li><li>( 3 ) (3)(3) 首先，记录<code>min</code>代表当前第 i i<em>i</em> 轮迭代的最小元素的下标为 i i<em>i</em>。</li><li>( 4 ) (4)(4) 然后，迭代枚举第 i + 1 i+1<em>i</em>+1 个元素到 最后的元素。</li><li>( 5 ) (5)(5) 选择一个最小的元素，并且存储下标到<code>min</code>中。</li><li>( 6 ) (6)(6) 将 第 i i<em>i</em> 个元素 和 最小的元素 进行交换。</li></ul><h2 id="8、冒泡排序"><a href="#8、冒泡排序" class="headerlink" title="8、冒泡排序"></a>8、冒泡排序</h2><h3 id="1）问题描述-6"><a href="#1）问题描述-6" class="headerlink" title="1）问题描述"></a>1）问题描述</h3><blockquote><p>  给定一个 n n<em>n</em> 个元素的数组，数组下标从 0 00 开始，采用<strong>「 冒泡排序 」</strong>将数组按照 <strong>「升序」</strong>排列。</p></blockquote><h3 id="2）动图演示-6"><a href="#2）动图演示-6" class="headerlink" title="2）动图演示"></a>2）动图演示</h3><p><img src="https://img-blog.csdnimg.cn/99f37fb95391458484b78d40005d07f5.gif#pic_center" alt="img"></p><h3 id="3）样例说明-4"><a href="#3）样例说明-4" class="headerlink" title="3）样例说明"></a>3）样例说明</h3><div class="table-container"><table><thead><tr><th>图示</th><th>含义</th></tr></thead><tbody><tr><td>■ 的柱形</td><td>代表尚未排好序的数</td></tr><tr><td>■ 的柱形</td><td>代表正在执行比较的两个数</td></tr><tr><td>■ 的柱形</td><td>代表已经排好序的数</td></tr></tbody></table></div><blockquote><p>  我们看到，首先需要将 <strong>「第一个元素」</strong> 和 <strong>「第二个元素」</strong> 进行 <strong>「比较」</strong>，如果 <strong>前者</strong> 大于 <strong>后者</strong>，则进行 <strong>「交换」</strong>，然后再比较 <strong>「第二个元素」</strong> 和 <strong>「第三个元素」</strong> ，以此类推，直到 <strong>「最大的那个元素」</strong> 被移动到 <strong>「最后的位置」</strong> 。<br>  然后，进行第二轮<strong>「比较」</strong>，直到 <strong>「次大的那个元素」</strong> 被移动到 <strong>「倒数第二的位置」</strong> 。<br>  最后，经过一定轮次的<strong>「比较」</strong> 和 <strong>「交换」</strong>之后，一定可以保证所有元素都是 <strong>「升序」</strong> 排列的。</p></blockquote><h3 id="4）算法描述-6"><a href="#4）算法描述-6" class="headerlink" title="4）算法描述"></a>4）算法描述</h3><blockquote><p>整个算法的执行过程分以下几步：<br>  <strong>1）</strong> 循环迭代变量 i = 0 → n − 1 i = 0 \to n-1<em>i</em>=0→<em>n</em>−1；<br>  <strong>2）</strong> 每次迭代，令 j = i j = i<em>j</em>=<em>i</em>，循环执行比较 a [ j ] a[j]<em>a</em>[<em>j</em>] 和 a [ j + 1 ] a[j+1]<em>a</em>[<em>j</em>+1]，如果产生 a [ j ] &gt; a [ j + 1 ] a[j] \gt a[j+1]<em>a</em>[<em>j</em>]&gt;<em>a</em>[<em>j</em>+1] 则交换两者的值。然后执行 j = j + 1 j = j + 1<em>j</em>=<em>j</em>+1，这时候对 j j<em>j</em> 进行判断，如果 j ≥ n − 1 j \ge n-1<em>j</em>≥<em>n</em>−1，则回到 <strong>1）</strong>，否则继续执行 <strong>2）</strong>。</p></blockquote><h3 id="5）源码详解-6"><a href="#5）源码详解-6" class="headerlink" title="5）源码详解"></a>5）源码详解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span> </span>&#123;             <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">bool</span> swapped;</span><br><span class="line">    <span class="keyword">int</span> last = n;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;                     <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last - <span class="number">1</span>; ++i) &#123;  <span class="comment">// (3)</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i+<span class="number">1</span>]) &#123;              <span class="comment">// (4)</span></span><br><span class="line">                Swap(&amp;a[i], &amp;a[i+<span class="number">1</span>]);        <span class="comment">// (5)</span></span><br><span class="line">                swapped = <span class="literal">true</span>;              <span class="comment">// (6)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --last;</span><br><span class="line">    &#125;<span class="keyword">while</span> (swapped);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        Input(n, a);</span><br><span class="line">        BubbleSort(n, a);</span><br><span class="line">        Output(n, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950</span></span><br></pre></td></tr></table></figure><ul><li>( 1 ) (1)(1) <code>void BubbleSort(int n, int *a)</code>为冒泡排序的实现，代表对<code>a[]</code>数组进行升序排序。</li><li>( 2 ) (2)(2) <code>swapped</code>标记本轮迭代下来，是否有元素产生了交换。</li><li>( 3 ) (3)(3) 每次冒泡的结果，会执行<code>last</code>的自减，所以待排序的元素会越来越少。</li><li>( 4 ) (4)(4) 如果发现两个相邻元素产生逆序，则将它们进行交换。保证右边的元素一定不比左边的小。</li><li>( 5 ) (5)(5) <code>swap</code>实现了元素的交换，这里需要用<code>&amp;</code>转换成地址作为传参。</li><li>( 6 ) (6)(6) 标记更新。一旦标记更新，则代表进行了交换，所以下次迭代必须继续。</li></ul><hr><p>  关于 <strong>「 顺序表 」</strong> 的内容到这里就结束了。</p><p>  有关<a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><strong>🌳《画解数据结构》🌳</strong> </a>的源码均开源，链接如下：<a href="https://github.com/WhereIsHeroFrom/Code_Templates/tree/master/数据结构/画解数据结构">《画解数据结构》</a></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/网页捕获_1-6-2022_14033_blog.csdn.net.jpeg" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220603005920.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++快速入门</title>
    <link href="http://example.com/2022/05/02/c-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/05/02/c-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-02T10:02:11.000Z</published>
    <updated>2022-05-10T15:58:28.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-标准输入输出"><a href="#c-标准输入输出" class="headerlink" title="c++标准输入输出"></a>c++标准输入输出</h1><ul><li>头文件iostream</li><li>cout是标准输出流变量</li><li>&lt;&lt;是运算符 加入o是输出流对象 x是一个数据 0&lt;&lt;x</li><li>cout是标准名字空间std的一个名字 必须加上<strong>名字空间限定</strong>std::cout</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;HELLO WORLD\n&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a\n&quot;</span>&lt;&lt;a;</span><br><span class="line"><span class="function">ofstream <span class="title">oF</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>)</span></span>;</span><br><span class="line">oF &lt;&lt; <span class="number">3.14</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; <span class="string">&quot;helllo world&quot;</span>;</span><br><span class="line">oF.<span class="built_in">close</span>();</span><br><span class="line"><span class="function">ifstream <span class="title">iF</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line">string str;</span><br><span class="line">iF &gt;&gt; d &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用变量和引用形参"><a href="#引用变量和引用形参" class="headerlink" title="引用变量和引用形参"></a>引用变量和引用形参</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;instream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">int</span> &amp;r=d;</span><br><span class="line">    cout&lt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用变量是其他变量的别名，如同一个人的外号或者小名</p><p>既然是引用，定义比那两点时候就必须指明其引用是哪个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a=3;int &amp;r=a;</span><br></pre></td></tr></table></figure><p>函数的引用形参：引用实参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swap(a,b)</span><br><span class="line"></span><br><span class="line">swap(int &amp;x,int&amp;y)&#123;</span><br><span class="line">int t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数的默认形参"><a href="#函数的默认形参" class="headerlink" title="函数的默认形参"></a>函数的默认形参</h1><ul><li>函数形参可以有默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void print(char ch,int n=1);</span><br></pre></td></tr></table></figure><p>默认形参必须在非默认形参右边</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(y,x=1.z=3);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> n = <span class="number">3</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">AA</span></span><br><span class="line"><span class="comment">AAA</span></span><br><span class="line"><span class="comment">AAA</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载</span></span><br><span class="line"><span class="comment">//c++允许作用域里面有同名函数，只要形参不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">11</span>, <span class="number">11</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.22</span>, <span class="number">12.1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>通用算法，函数模板 也叫<strong>泛型算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; add&lt;string&gt;(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; world&quot;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; add&lt;<span class="keyword">double</span>&gt;(<span class="number">1.1</span>, <span class="number">23.1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>是一个用户定义类型 表示的是符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">&quot;hello&quot;</span>,<span class="built_in">s2</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">string s = &quot;hello&quot;, s2(&quot;world&quot;);</span><br><span class="line">cout &lt;&lt; s.size() &lt;&lt; endl;</span><br><span class="line">string s3 = s.substr(1, 3);</span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">string s4 = s + &quot;  &quot; + s2;</span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//索引修改</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>向量类似数组可以动态增长</p><p>是一个类模板 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">23</span>);<span class="comment">//+</span></span><br><span class="line">    cout &lt;&lt; v[<span class="number">4</span>];</span><br><span class="line">    v.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">//报错cout &lt;&lt; v[4];</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>; *p = <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; p&lt;&lt;<span class="string">&#x27;\t&#x27;</span>&lt;&lt;*p;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i]&lt;&lt;<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">get_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_score</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> score; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(string n)</span> </span>&#123; name = n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_score</span><span class="params">(<span class="keyword">double</span> s)</span> </span>&#123; score = s; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">student stu;</span><br><span class="line">stu.<span class="built_in">set_name</span>(<span class="string">&quot;Li Ping&quot;</span>);</span><br><span class="line">stu.<span class="built_in">set_score</span>(<span class="number">78.5</span>);</span><br><span class="line">stu.<span class="built_in">print</span>();   <span class="comment">// print(&amp;stu);</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; stu.<span class="built_in">get_name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu.<span class="built_in">get_score</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">访问</th><th style="text-align:left">public</th><th style="text-align:left">protected</th><th style="text-align:left">private</th></tr></thead><tbody><tr><td style="text-align:left">同一个类</td><td style="text-align:left">yes</td><td style="text-align:left">yes</td><td style="text-align:left">yes</td></tr><tr><td style="text-align:left">派生类</td><td style="text-align:left">yes</td><td style="text-align:left">yes</td><td style="text-align:left">no</td></tr><tr><td style="text-align:left">外部的类</td><td style="text-align:left">yes</td><td style="text-align:left">no</td><td style="text-align:left">no</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">width = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">height = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span><span class="keyword">public</span> Shape &#123;<span class="comment">//继承语法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (width * height);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Rectangle Rect;</span><br><span class="line">Rect.<span class="built_in">setHeight</span>(<span class="number">5</span>);</span><br><span class="line">Rect.<span class="built_in">setWidth</span>(<span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; Rect.<span class="built_in">getArea</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载-1"><a href="#函数重载-1" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">printData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// 输出浮点数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line">   <span class="comment">// 输出字符串</span></span><br><span class="line">   <span class="keyword">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><html><head><script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDJW4jsPlNKgv6jFm3B5Edp5ywgdqLWdmc&sensor=false"></script><script>function initialize(){var mapProp = {  center:new google.maps.LatLng(51.508742,-0.120850),  zoom:5,  mapTypeId:google.maps.MapTypeId.ROADMAP  };var map=new google.maps.Map(document.getElementById("googleMap"),mapProp);}google.maps.event.addDomListener(window, 'load', initialize);</script></head><body><div id="googleMap" style="width:500px;height:380px;"></div></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-标准输入输出&quot;&gt;&lt;a href=&quot;#c-标准输入输出&quot; class=&quot;headerlink&quot; title=&quot;c++标准输入输出&quot;&gt;&lt;/a&gt;c++标准输入输出&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;头文件iostream&lt;/li&gt;
&lt;li&gt;cout是标准输出流变量&lt;/li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>git出现的问题</title>
    <link href="http://example.com/2022/04/11/git%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/04/11/git%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-11T15:22:08.000Z</published>
    <updated>2022-04-29T23:52:24.654Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习使用vscode的源代码管理时候同步时出现了fatal: unable to access ‘xxxx: Failed to connect to github.com port 443 after 21098 ms: Timed out这个错误。</p><span id="more"></span><p>提示含义是通过443端口连接github.com错误。</p><p>解决办法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy#删除配置</span><br><span class="line">git config --global http.proxy 127.0.0.1:xxxx#根据自己的代理插件设置全局端口</span><br><span class="line">git config --local http.proxy 127.0.0.1:xxxx #为某个 git 项目单独设置代理</span><br></pre></td></tr></table></figure><p>比如我用某个小猫默认的7080</p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220411232828.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天学习使用vscode的源代码管理时候同步时出现了fatal: unable to access ‘xxxx: Failed to connect to github.com port 443 after 21098 ms: Timed out这个错误。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="踩过的坑" scheme="http://example.com/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java SE</title>
    <link href="http://example.com/2022/02/21/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/02/21/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-21T05:47:24.000Z</published>
    <updated>2022-06-23T12:25:00.682Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220330163928.png" alt></p><h1 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h1><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220330175504.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd test</span><br><span class="line">copy nul a.txt</span><br><span class="line">echo 123&gt;a.txt</span><br><span class="line">del a.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>constant</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final type barName=valie;</span><br></pre></td></tr></table></figure><h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><p>局部变量 成员变量 静态变量</p><p>局部变量在方法语句块</p><p>成员变量 对象 类内部，方法外面 从属对象 会自动默认初始化</p><p>静态变量 类内部 static修饰 从属类</p><h2 id="primitive-data-type"><a href="#primitive-data-type" class="headerlink" title="primitive data type"></a>primitive data type</h2><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220412220904.png" alt></p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>byte 一字节 -127-127</p><p>short 2字节 -2^15-2^15-1</p><p>int 4字节 2^31-2^32-1</p><p>long 8字节 -2^63</p><p>十进制 八进制以0开头 十六进制以0x 0X 二进制0b oB开头</p><h4 id="floating-point-number"><a href="#floating-point-number" class="headerlink" title="floating point number"></a>floating point number</h4><p>float四字节 double八字节</p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>true false</p><p>一个字节或者四个字节</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220412225528.png" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220412230002.png" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220412230014.png" alt></p><h3 id="强制转换类-cast"><a href="#强制转换类-cast" class="headerlink" title="强制转换类 cast"></a>强制转换类 cast</h3><p>（type）var</p><h3 id="Scanner处理键盘输入"><a href="#Scanner处理键盘输入" class="headerlink" title="Scanner处理键盘输入"></a>Scanner处理键盘输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scanner1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s =<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">        String uname =s.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入你的年龄&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age=s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名&quot;</span>+uname);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String name=<span class="keyword">new</span> string(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">String name=<span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[]value=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b,&#x27;</span>c&#125;;</span><br><span class="line">String s3=<span class="keyword">new</span> String(value);</span><br><span class="line"><span class="keyword">byte</span>[]bytes=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">String s4=<span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure><h3 id="统计单词数量"><a href="#统计单词数量" class="headerlink" title="统计单词数量"></a>统计单词数量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str=&quot;hello world abc hello hello hello hello hello&quot;;</span><br><span class="line">        System.out.println();</span><br><span class="line">        HelloWorld he=new HelloWorld();</span><br><span class="line">        int count=he.wordCount(str,&quot;hello&quot;);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">;    &#125;</span><br><span class="line">    public int wordCount(String art,String word)&#123;</span><br><span class="line">        //1先把文章打散成数组</span><br><span class="line">        String[] words = art.split(&quot; &quot;);</span><br><span class="line">        int res=0;</span><br><span class="line">        for (int i = 0; i &lt; words.length; i++) &#123;</span><br><span class="line">            if(words[i].equalsIgnoreCase(word))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="scanner"><a href="#scanner" class="headerlink" title="scanner"></a>scanner</h3><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(name.equals(name_1)&amp;&amp;password_1.equals(password))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="遍历charAt"><a href="#遍历charAt" class="headerlink" title="遍历charAt"></a>遍历charAt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">           System.out.println(line.charAt(i));</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="stringBuilder的添加和反转"><a href="#stringBuilder的添加和反转" class="headerlink" title="stringBuilder的添加和反转"></a>stringBuilder的添加和反转</h3><p>append和reverse</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">     StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line"><span class="comment">//hellojava</span></span><br><span class="line"><span class="comment">//avajolleh</span></span><br><span class="line"></span><br><span class="line">stringbuilder转为string</span><br><span class="line">    string s =sb.tostring（）；</span><br><span class="line"> string转为stringbuilder</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br></pre></td></tr></table></figure><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">快捷和补全</span><br><span class="line">单行ctrl+/</span><br><span class="line">多行ctrl+shitft+/</span><br><span class="line"></span><br><span class="line">CTRL+alt+L格式化</span><br><span class="line"></span><br><span class="line">快速生成main（）方法 psvm</span><br><span class="line">输入语句sout</span><br><span class="line"></span><br><span class="line">内容辅助CTRL+shifr+space\</span><br><span class="line">自动生成构造器</span><br><span class="line">insert+alt</span><br><span class="line">查看错误alt+enter</span><br><span class="line">看源码ctrl+左键</span><br></pre></td></tr></table></figure><h1 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h1><p>数组必须初始化使用</p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220618150304.png" alt></p><ul><li>静态 type name = new type【length】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] =new int [5];</span><br><span class="line">int [] arr =new int [5];</span><br><span class="line">int []arr=&#123;551,2,377&#125;;</span><br></pre></td></tr></table></figure><p>数组的扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span> [a.length*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    temp[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line">a=temp;</span><br><span class="line">a[a.length-<span class="number">2</span>]=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针思想"><a href="#双指针思想" class="headerlink" title="双指针思想"></a>双指针思想</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int a[]=&#123;12,231,3421,33,3131,234&#125;;</span><br><span class="line">int b[]=&#123;321,31,345,23,54,7676&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       while (i&lt;a.length||j&lt;b.length)&#123;</span><br><span class="line">    if(i==a.length)&#123;</span><br><span class="line">        c[i+j]=b[j];</span><br><span class="line">        j++;continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j==b.length)&#123;</span><br><span class="line">        c[i+j]=a[i];</span><br><span class="line">        i++;continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[i]&gt;b[j])&#123;</span><br><span class="line">        c[i+j]=b[j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        c[i+j]=a[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="arrayList-集合（超级数组）"><a href="#arrayList-集合（超级数组）" class="headerlink" title="arrayList 集合（超级数组）"></a>arrayList 集合（超级数组）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        ArrayList&lt;String&gt; array =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(array);</span><br><span class="line">        array.add(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;java&quot;</span>);array.add(<span class="string">&quot;java good&quot;</span>);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">        array.add(<span class="number">1</span>,<span class="string">&quot;syr&quot;</span>);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">        </span><br><span class="line">        []</span><br><span class="line">[hello world, java, java good]</span><br><span class="line">[hello world, syr, java, java good]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>arraylist基本常用方法</p><div class="table-container"><table><thead><tr><th>public boolean remove(obiect o)</th><th>删除指定元素</th></tr></thead><tbody><tr><td>public  E remove(int index)</td><td>删除索引元素，返回被删元素</td></tr><tr><td>public E set(int index,E element)</td><td>修改，返回被修改的元素</td></tr><tr><td>public E get（int index）</td><td>返沪索引元素</td></tr><tr><td>public int size（）</td><td>返回集合的元素</td></tr></tbody></table></div><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h1 id="方法method"><a href="#方法method" class="headerlink" title="方法method"></a>方法method</h1><p>Java方法是语句的集合，它们在一起执行一个功能。</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> type <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法重载overload"><a href="#方法重载overload" class="headerlink" title="方法重载overload"></a>方法重载overload</h2><ul><li>多个方法在一个类</li><li>方法具有相同的方法名</li><li>返回类型或者数量不同</li></ul><p>一个类中定义多个名称相同，但是参数泪飙不同的的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fangfa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">123</span>,<span class="number">2131</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">12.1</span>,<span class="number">23.1</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">123</span>,<span class="number">231</span>,<span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int add</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">2254</span></span><br><span class="line"><span class="number">35.2</span></span><br><span class="line"><span class="number">386</span></span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span>...nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>StackOverflowError</p><p>大量占用系统堆栈</p><h1 id="包装类和自动拆装箱"><a href="#包装类和自动拆装箱" class="headerlink" title="包装类和自动拆装箱"></a>包装类和自动拆装箱</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220621204705.png" alt></p><h1 id="类和对象（Object-Oriented-Programing）"><a href="#类和对象（Object-Oriented-Programing）" class="headerlink" title="类和对象（Object Oriented Programing）"></a>类和对象（Object Oriented Programing）</h1><p>类是java基本的组成结构</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">car</span></span>&#123;</span><br><span class="line">    <span class="comment">//每个文件必须有一个public class，名字与文件名相同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tyre</span></span>&#123;&#125;<span class="comment">//可以定义多个class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">engine</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">seat</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>对于一个类来说有三种成员</p><h3 id="field属性-成员变量"><a href="#field属性-成员变量" class="headerlink" title="field属性  成员变量"></a>field属性  成员变量</h3><p>属性用于定义这个类或者更类对象包含的数据或者静态特征</p><p>修饰符 type name=默认</p><h3 id="method方法"><a href="#method方法" class="headerlink" title="method方法"></a>method方法</h3><p>方法从属于类和对象</p><p>修饰符 返回类型 name（）{</p><h2 id="构造方法-构造器-constructor"><a href="#构造方法-构造器-constructor" class="headerlink" title="构造方法 构造器 constructor"></a>构造方法 构造器 constructor</h2><p>构造器能用于对象的初始化，而不是创建对象</p><ul><li>构造器用new关键字调用</li><li>构造器虽然没有返回值，但不能定义返回值类型 </li><li>如果没有定义构造器，则编译器会自动定义一个无参的构造方法，如果一定义的则编译器不会自动添加</li><li>构造器的方法名必须与类名字相同 </li></ul><p>课堂练习可以生成具有特定坐标的点对象 提供可以计算点到另外一点距离的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 第五章面向对象.构造器.点;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line"></span><br><span class="line">    Point (<span class="keyword">double</span> _x,<span class="keyword">double</span> _y)&#123;</span><br><span class="line">        x=_x;y=_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt((x-p.x)*(y-p.y)+(y-p.y)*(y-p.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Point p1=<span class="keyword">new</span> Point(<span class="number">3.0</span>,<span class="number">4.0</span>);</span><br><span class="line">        Point origin =<span class="keyword">new</span> Point(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line">        System.out.println(p1.getDistance(origin));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h2><h2 id="jvm虚拟机"><a href="#jvm虚拟机" class="headerlink" title="jvm虚拟机"></a>jvm虚拟机</h2><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417123127.png" alt></p><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417123413.png" alt></p><h3 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h3><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417123605.png" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417130828.png" alt></p><h3 id="Garbage-Collection垃圾回收机制"><a href="#Garbage-Collection垃圾回收机制" class="headerlink" title="Garbage Collection垃圾回收机制"></a>Garbage Collection垃圾回收机制</h3><p>垃圾回收过程</p><p>发现无用的对象 回收无用对象占用内存空间 无用对象为没有任何引用</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>1引用计数法</p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417132400.png" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417132717.png" alt></p><h3 id="通用的分代垃圾回收机制"><a href="#通用的分代垃圾回收机制" class="headerlink" title="通用的分代垃圾回收机制"></a>通用的分代垃圾回收机制</h3><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417132912.png" alt></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>创建大量的无用对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str=&quot;&quot;;</span><br><span class="line">for(int i=0;i&lt;11000:i++)&#123;</span><br><span class="line">str+=i;//相当于产生了11000个string对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态集合类的使用"><a href="#静态集合类的使用" class="headerlink" title="静态集合类的使用"></a>静态集合类的使用</h4><p>hassomap vector list等这些最容易出现，这些静态变量的生命周期</p><p>各种连接对象 监听器使用不当</p><p>可以用system.gc()但是只是通知jvm</p><p>object可以用finalize方法，是java给程序员的</p><h3 id="this关键词"><a href="#this关键词" class="headerlink" title="this关键词"></a>this关键词</h3><p>就是当前对象的地址</p><p>this用法</p><ul><li>普通方法中 this总是指向调用该方法的对象</li><li>构造方法中，this总是指向正要初始化的对象</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417200700.png" alt></p><h3 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h3><p>构造方法用于对象的普通属性的初始化</p><p><strong>静态初始快中，用于初始化类，初始化静态属性</strong></p><p><strong>静态初始化快中不能直接访问非static成员</strong></p><p><strong>变量分类</strong></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417204817.png" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417204921.png" alt></p><p>包机制package import</p><p>相当于文件夹对文件的作用，用于管理类，解决类的重名问题</p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220417210539.png" alt></p><h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><h2 id="继承extends"><a href="#继承extends" class="headerlink" title="继承extends"></a>继承extends</h2><p>代码复用，方便建模</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 第五章面向对象.extends1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student s1 =<span class="keyword">new</span> Student(<span class="string">&quot;songyuran&quot;</span>,<span class="number">11</span>,<span class="string">&quot;CS&quot;</span>);</span><br><span class="line">    s1.xuexi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persin</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xiuxi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Persin</span></span>&#123;</span><br><span class="line">    String major;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xuexi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xuexi&quot;</span>);</span><br><span class="line">        rest();</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> height,String major)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.height=height;</span><br><span class="line">        <span class="keyword">this</span>.major=major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="instanceof判断类型"><a href="#instanceof判断类型" class="headerlink" title="instanceof判断类型"></a>instanceof判断类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 instanceof Person//true</span><br><span class="line">s1 instanceof Student//true</span><br></pre></td></tr></table></figure><ul><li><p>父类 又叫超类 基类  子类：派生类</p></li><li><p>接口有多继承</p></li></ul><h3 id="方法重写override"><a href="#方法重写override" class="headerlink" title="方法重写override"></a>方法重写override</h3><p>子类重写父亲的方法，替换父类行为，重写是实现多态的必要条件</p><p>  == 方法名字 形参列表</p><p>  《=返回值类型和声明异常类型，子类小于等于父类</p><p>  》=子类大于父类</p><h3 id="final关键词"><a href="#final关键词" class="headerlink" title="final关键词"></a>final关键词</h3><ul><li>修饰变量</li><li>修饰方法 不可被子类重写，但是可以重载，final class a{}</li><li>修饰类 不可被继承</li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合比较灵活，继承只能有一个父类，组合可以有多个属性</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>三大特征之一</p><p>提高安全 复用 高内聚低耦合</p><h3 id="封装的实现关键词访问限制修饰符"><a href="#封装的实现关键词访问限制修饰符" class="headerlink" title="封装的实现关键词访问限制修饰符"></a><strong>封装的实现关键词访问限制修饰符</strong></h3><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220522120656.png" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220522141733.png" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220522121248.png" alt></p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220522142618.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> text.b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u=<span class="keyword">new</span> User(<span class="number">99</span>,<span class="string">&quot;宋宇然&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(u.getId());</span><br><span class="line">        System.out.println(u.getName());</span><br><span class="line">        System.out.println(u.isMan());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> text.b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> man;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> man;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMan</span><span class="params">(<span class="keyword">boolean</span> man)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.man = man;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUserInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        System.out.println(man);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">boolean</span> man)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.man = man;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多态polymorphism"><a href="#多态polymorphism" class="headerlink" title="多态polymorphism"></a>多态polymorphism</h2><p>同一种方法调用 不同对象行为完全不同</p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220522144328.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;叫了一声&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wangwang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeDoor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;see door&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;miaomiao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPolym</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        animaCry(<span class="keyword">new</span> DOg());</span><br><span class="line">        animalCry(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalCry</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        a.shout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的转型casting"><a href="#对象的转型casting" class="headerlink" title="对象的转型casting"></a>对象的转型casting</h2><p>父类引用指向子类叫向上转型，属于自动</p><p>反之</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPolym</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal=<span class="keyword">new</span> Dog();</span><br><span class="line">        animal.shout();</span><br><span class="line">        <span class="comment">//不能运行animal.seeDoor();需要强制转换</span></span><br><span class="line">        Dog d =(Dog)animal;</span><br><span class="line">        d.seeDoor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalCry</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        a.shout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220522153115.png" alt></p><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>所有类是Object的子类</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="toString返回地址"><a href="#toString返回地址" class="headerlink" title="toString返回地址"></a><strong>toString</strong>返回地址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tosting</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String pwd;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名&quot;</span>+name+<span class="string">&quot;密码&quot;</span>+pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            tosting to=<span class="keyword">new</span> tosting();</span><br><span class="line">        System.out.println(to.toString());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220520221445.png" alt></p><h2 id="equals和"><a href="#equals和" class="headerlink" title="equals和=="></a>equals和==</h2><p>==代表对方是否相同，type和地址</p><p>equals()比较内容相同</p><p>equals()默认比较两个对象的hashcode</p><p>可以重写equals</p><h3 id="重写equals"><a href="#重写equals" class="headerlink" title="重写equals()"></a>重写equals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String pwd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestObject</span><span class="params">(<span class="keyword">int</span> id,String name,String pwd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.pwd=pwd;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==o)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="keyword">null</span>||getclass()!=o.getClass())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> id==that.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;用户名:&quot;</span> +name+<span class="string">&quot;密码:&quot;</span>+pwd;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestObject t= <span class="keyword">new</span> TestObject(<span class="number">1001</span>,<span class="string">&quot;zhangshan,&quot;</span><span class="number">123456</span>);</span><br><span class="line">        TestObject t2=<span class="keyword">new</span> TestObject(<span class="number">1001</span>,<span class="string">&quot;zhangwu,&quot;</span><span class="number">123123123</span>);</span><br><span class="line">        System.out.println(t.equals(t2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super可以看作直接父类对象的引用</p><p>在一个类中，若是构造方法第一行没有第哦啊用super或者this java默认调用</p><ul><li>在子类的方法中，访问父类的成员变量</li><li>在子类的成语方法中，访问父亲的成员方法</li><li>在子类的构造方法中访问父类的构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><p>抽象方法和抽象类</p><p><strong>抽象方法</strong> <em>**</em></p><p>使用abstract修饰方法 没有方法体 只有声明</p><p>定义是一种规范 就是告诉子类必须要给抽象方法具体实现</p><p><strong>抽象类</strong></p><p>包含抽象方法的类叫抽象类</p><p>通过抽象类可以严格限制子类的设计，使得子类之间梗通用</p><p><img src="https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220522160952.png" alt></p><h2 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h2><p>是一组规范，所以类要遵守</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><a href></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://kaguranotamashii-1308648145.cos.ap-beijing.myqcloud.com/20220330163928.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;DOS&quot;&gt;&lt;a href=&quot;#DOS&quot; class=</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>One Java</title>
    <link href="http://example.com/2022/02/21/ch1/"/>
    <id>http://example.com/2022/02/21/ch1/</id>
    <published>2022-02-21T05:47:24.000Z</published>
    <updated>2022-06-23T15:30:32.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-对象的概念"><a href="#第-1-章-对象的概念" class="headerlink" title="第 1 章 对象的概念"></a>第 1 章 对象的概念</h1><blockquote><p>“我们没有意识到惯用语言的结构有多大的力量。可以毫不夸张地说，它通过语义反应机制奴役我们。语言表现出来并在无意识中给我们留下深刻印象的结构会自动投射到我们周围的世界。” — Alfred Korzybski (1930)</p></blockquote><p>计算机革命的起源来自机器。编程语言就像是那台机器。它不仅是我们思维放大的工具与另一种表达媒介，更像是我们思想的一部分。语言的灵感来自其他形式的表达，如写作，绘画，雕塑，动画和电影制作。编程语言就是创建应用程序的思想结构。</p><p>面向对象编程（Object-Oriented Programming OOP）是一种编程思维方式和编码架构。本章讲述 OOP 的基本概述。如果读者对此不太理解，可先行跳过本章。等你具备一定编程基础后，请务必再回头看。只有这样你才能深刻理解面向对象编程的重要性及设计方式。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>所有编程语言都提供抽象机制。从某种程度上来说，问题的复杂度直接取决于抽象的类型和质量。这里的“类型”意思是：抽象的内容是什么？汇编语言是对底层机器的轻微抽象。接着出现的“命令式”语言（如 FORTRAN，BASIC 和 C）是对汇编语言的抽象。与汇编相比，这类语言已有了长足的改进，但它们的抽象原理依然要求我们着重考虑计算机的结构，而非问题本身的结构。</p><p>程序员必须要在机器模型（“解决方案空间”）和实际解决的问题模型（“问题空间”）之间建立起一种关联。这个过程既费精力，又脱离编程语言本身的范畴。这使得程序代码很难编写，维护代价高昂。同时还造就了一门副产业的“编程方法”学科。</p><p>为机器建模的另一个方法是为要解决的问题制作模型。对一些早期语言来说，如 LISP 和 APL，它们的做法是“从不同的角度观察世界”——“所有问题都归纳为列表”或“所有问题都归纳为算法”。PROLOG 则将所有<br>问题都归纳为决策链。对于这些语言，我们认为它们一部分是“基于约束”的编程，另一部分则是专为<br>处理图形符号设计的（后者被证明限制性太强）。每种方法都有自己特殊的用途，适合解决某一类的问题。只要超出了它们力所能及的范围，就会显得非常笨拙。</p><p>面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。由于这种表达非常具有普遍性，所以不必受限于特定类型的问题。我们将问题空间中的元素以及它们在解决方案空间的表示称作“对象”（<strong>Object</strong>）。当然，还有一些在问题空间没有对应的对象体。通过添加新的对象类型，程序可进行灵活的调整，以便与特定的问题配合。所以当你在阅读描述解决方案的代码时，也是在阅读问题的表述。与我们以前见过的相比，这无疑是一种更加灵活、更加强大的语言抽象方法。总之，OOP 允许我们根据问题来描述问题，而不是根据运行解决方案的计算机。然而，它仍然与计算机有联系，每个对象都类似一台小计算机：它们有自己的状态并且可以进行特定的操作。这与现实世界的“对象”或者“物体”相似：它们都有自己的特征和行为。</p><p>Smalltalk 作为第一个成功的面向对象并影响了 Java 的程序设计语言 ，<em>Alan Kay</em> 总结了其五大基本特征。通过这些特征，我们可理解“纯粹”的面向对象程序设计方法是什么样的：</p><blockquote><ol><li><strong>万物皆对象</strong>。你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。理论上讲，你总是可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表示为一个对象。</li><li><strong>程序是一组对象，通过消息传递来告知彼此该做什么</strong>。要请求调用一个对象的方法，你需要向该对象发送消息。</li><li><strong>每个对象都有自己的存储空间，可容纳其他对象</strong>。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。</li><li><strong>每个对象都有一种类型</strong>。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。</li><li><strong>同一类所有对象都能接收相同的消息</strong>。这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给”形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是 OOP 最重要的概念之一。</li></ol></blockquote><p><em>Grady Booch</em> 提供了对对象更简洁的描述：一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>亚里士多德（<em>Aristotle</em>）大概是第一个认真研究“类型”的哲学家，他曾提出过“鱼类和鸟类”这样的概念。所有对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分。这种思想被首次应用于第一个面向对象编程语言 Simula-67，它在程序中使用基本关键字 <strong>class</strong> 来引入新的类型（class 和 type 通常可互换使用，有些人对它们进行了进一步区分，他们强调 type 决定了接口，而 class 是那个接口的一种特殊实现方式）。</p><p>Simula 是一个很好的例子。正如这个名字所暗示的，它的作用是“模拟”（Simulate）类似“银行出纳员”这样的经典问题。在这个例子里，我们有一系列出纳员、客户、帐号、交易和货币单位等许多”对象”。每类成员（元素）都具有一些通用的特征：每个帐号都有一定的余额；每名出纳都能接收客户的存款；等等。与此同时，每个成员都有自己的状态；每个帐号都有不同的余额；每名出纳都有一个名字。所以在计算机程序中，能用独一无二的实体分别表示出纳员、客户、帐号以及交易。这个实体便是“对象”，而且每个对象都隶属一个特定的“类”，那个类具有自己的通用特征与行为。</p><p>因此，在面向对象的程序设计中，尽管我们真正要做的是新建各种各样的数据“类型”（Type），但几乎所有面向对象的程序设计语言都采用了 <code>class</code> 关键字。当你看到 “type” 这个词的时候，请同时想到 <code>class</code>；反之亦然。</p><p>创建好一个类后，可根据情况生成许多对象。随后，可将那些对象作为要解决问题中存在的元素进行处理。事实上，当我们进行面向对象的程序设计时，面临的最大一项挑战性就是：如何在“问题空间”（问题实际存在的地方）的元素与“方案空间”（对实际问题进行建模的地方，如计算机）的元素之间建立理想的“一对一”的映射关系。</p><p>那么如何利用对象完成真正有用的工作呢？必须有一种办法能向对象发出请求，令其解决一些实际的问题，比如完成一次交易、在屏幕上画一些东西或者打开一个开关等等。每个对象仅能接受特定的请求。我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的对应关系是面向对象程序设计的基础。</p><p>下面让我们以电灯泡为例：</p><p><img src="../images/reader.png" alt="reader"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Light lt = <span class="keyword">new</span> Light();</span><br><span class="line">lt.on();</span><br></pre></td></tr></table></figure><p>在这个例子中，类型／类的名称是 <strong>Light</strong>，可向 <strong>Light</strong> 对象发出的请求包括包括打开 <code>on</code>、关闭 <code>off</code>、变得更明亮 <code>brighten</code> 或者变得更暗淡 <code>dim</code>。通过声明一个引用，如 <code>lt</code> 和 <code>new</code> 关键字，我们创建了一个 <strong>Light</strong> 类型的对象，再用等号将其赋给引用。</p><p>为了向对象发送消息，我们使用句点符号 <code>.</code> 将 <code>lt</code> 和消息名称 <code>on</code> 连接起来。可以看出，使用一些预先定义好的类时，我们在程序里采用的代码是非常简单直观的。</p><p>上图遵循 <strong>UML</strong>（Unified Modeling Language，统一建模语言）的格式。每个类由一个框表示，框的顶部有类型名称，框中间部分是要描述的任何数据成员，方法（属于此对象的方法，它们接收任何发送到该对象的消息）在框的底部。通常，只有类的名称和公共方法在 <strong>UML</strong> 设计图中显示，因此中间部分未显示，如本例所示。如果你只对类名感兴趣，则也不需要显示方法信息。</p><h2 id="服务提供"><a href="#服务提供" class="headerlink" title="服务提供"></a>服务提供</h2><p>在开发或理解程序设计时，我们可以将对象看成是“服务提供者”。你的程序本身将为用户提供服务，并且它能通过调用其他对象提供的服务来实现这一点。我们的最终目标是开发或调用工具库中已有的一些对象，提供理想的服务来解决问题。</p><p>那么问题来了：我们该选择哪个对象来解决问题呢？例如，你正在开发一个记事本程序。<em>你可能会想到在屏幕输入默认的记事本对象</em>，一个用于检测不同类型打印机并执行打印的对象。这些对象中的某些已经有了。那对于还没有的对象，我们该设计成啥样呢？这些对象需要提供哪些服务，以及还需要调用其他哪些对象？</p><p>我们可以将这些问题一一分解，抽象成一组服务。软件设计的基本原则是高内聚：每个组件的内部作用明确，功能紧密相关。然而经常有人将太多功能塞进一个对象中。例如：在支票打印模块中，你需要设计一个可以同时读取文本格式又能正确识别不同打印机型号的对象。正确的做法是提供三个或更多对象：一个对象检查所有排版布局的目录；一个或一组可以识别不同打印机型号的对象展示通用的打印界面；第三个对象组合上述两个服务来完成任务。这样，每个对象都提供了一组紧密的服务。在良好的面向对象设计中，每个对象功能单一且高效。这样的程序设计可以提高我们代码的复用性，同时也方便别人阅读和理解我们的代码。只有让人知道你提供什么服务，别人才能更好地将其应用到其他模块或程序中。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>我们可以把编程的侧重领域划分为研发和应用。应用程序员调用研发程序员构建的基础工具类来做快速开发。研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。这样可以有效地避免该工具类被错误的使用和更改，从而减少程序出错的可能。彼此职责划分清晰，相互协作。当应用程序员调用研发程序员开发的工具类时，双方建立了关系。应用程序员通过使用现成的工具类组装应用程序或者构建更大的工具库。如果工具类的创建者将类的内部所有信息都公开给调用者，那么有些使用规则就不容易被遵守。因为前者无法保证后者是否会按照正确的规则来使用，甚至是改变该工具类。只有设定访问控制，才能从根本上阻止这种情况的发生。</p><p>因此，使用访问控制的原因有以下两点：</p><ol><li><p>让应用程序员不要触摸他们不应该触摸的部分。（请注意，这也是一个哲学决策。部分编程语言认为如果程序员有需要，则应该让他们访问细节部分。）；</p></li><li><p>使类库的创建者（研发程序员）在不影响后者使用的情况下完善更新工具库。例如，我们开发了一个功能简单的工具类，后来发现可以通过优化代码来提高执行速度。假如工具类的接口和实现部分明确分开并受到保护，那我们就可以轻松地完成改造。</p></li></ol><p>Java 有三个显式关键字来设置类中的访问权限：<code>public</code>（公开），<code>private</code>(私有)和<code>protected</code>（受保护）。这些访问修饰符决定了谁能使用它们修饰的方法、变量或类。</p><ol><li><p><code>public</code>（公开）表示任何人都可以访问和使用该元素；</p></li><li><p><code>private</code>（私有）除了类本身和类内部的方法，外界无法直接访问该元素。<code>private</code> 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；</p></li><li><p><code>protected</code>（受保护）类似于 <code>private</code>，区别是子类（下一节就会引入继承的概念）可以访问 <code>protected</code> 的成员，但不能访问 <code>private</code> 成员；</p></li><li><p><code>default</code>（默认）如果你不使用前面的三者，默认就是 <code>default</code> 访问权限。<code>default</code> 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。</p></li></ol><h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><p>一个类经创建和测试后，理应是可复用的。然而很多时候，由于程序员没有足够的编程经验和远见，我们的代码复用性并不强。</p><p>代码和设计方案的复用性是面向对象程序设计的优点之一。我们可以通过重复使用某个类的对象来达到这种复用性。同时，我们也可以将一个类的对象作为另一个类的成员变量使用。新的类可以是由任意数量和任意类型的其他对象构成。这里涉及到“组合”和“聚合”的概念：</p><ul><li><p><strong>组合</strong>（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。</p></li><li><p><strong>聚合</strong>（Aggregation）动态的<strong>组合</strong>。</p></li></ul><p><img src="../images/1545758268350.png" alt="UML-example"></p><p>上图中实心三角形指向“ <strong>Car</strong> ”表示 <strong>组合</strong> 的关系；如果是 <strong>聚合</strong> 关系，可以使用空心三角形。</p><p>（<strong>译者注</strong>：组合和聚合都属于关联关系的一种，只是额外具有整体-部分的意义。至于是聚合还是组合，需要根据实际的业务需求来判断。可能相同超类和子类，在不同的业务场景，关联关系会发生变化。只看代码是无法区分聚合和组合的，具体是哪一种关系，只能从语义级别来区分。聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。）</p><p>使用“组合”关系给我们的程序带来极大的灵活性。通常新建的类中，成员对象会使用 <code>private</code> 访问权限，这样应用程序员则无法对其直接访问。我们就可以在不影响客户代码的前提下，从容地修改那些成员。我们也可以在“运行时”改变成员对象从而动态地改变程序的行为，这进一步增大了灵活性。下面一节要讲到的“继承”并不具备这种灵活性，因为编译器对通过继承创建的类进行了限制。</p><p>在面向对象编程中经常重点强调“继承”。在新手程序员的印象里，或许先入为主地认为“继承应当随处可见”。沿着这种思路产生的程序设计通常拙劣又复杂。相反，在创建新类时首先要考虑“组合”，因为它更简单灵活，而且设计更加清晰。等我们有一些编程经验后，一旦需要用到继承，就会明显意识到这一点。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>“继承”给面向对象编程带来极大的便利。它在概念上允许我们将各式各样的数据和功能封装到一起，这样便可恰当表达“问题空间”的概念，而不用受制于必须使用底层机器语言。</p><p>通过使用 <code>class</code> 关键字，这些概念形成了编程语言中的基本单元。遗憾的是，这么做还是有很多麻烦：在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。但我们若能利用现成的数据类型，对其进行“克隆”，再根据情况进行添加和修改，情况就显得理想多了。“继承”正是针对这个目标而设计的。但继承并不完全等价于克隆。在继承过程中，若原始类（正式名称叫作基类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。</p><p><img src="../images/1545763399825.png" alt="Inheritance-example"></p><p>这个图中的箭头从派生类指向基类。正如你将看到的，通常有多个派生类。类型不仅仅描述一组对象的约束，它还涉及其他类型。两种类型可以具有共同的特征和行为，但是一种类型可能包含比另一种类型更多的特征，并且还可以处理更多的消息（或者以不同的方式处理它们）。继承通过基类和派生类的概念来表达这种相似性。基类包含派生自它的类型之间共享的所有特征和行为。创建基类以表示思想的核心。从基类中派生出其他类型来表示实现该核心的不同方式。</p><p><img src="../images/1545764724202.png" alt="1545764724202"></p><p>例如，垃圾回收机对垃圾进行分类。基类是“垃圾”。每块垃圾都有重量、价值等特性，它们可以被切碎、熔化或分解。在此基础上，可以通过添加额外的特性(瓶子有颜色，钢罐有磁性)或行为(铝罐可以被压碎)派生出更具体的垃圾类型。此外，一些行为可以不同（纸张的价值取决于它的类型和状态）。使用继承，你将构建一个类型层次结构，来表示你试图解决的某种类型的问题。第二个例子是常见的“形状”例子，可能用于计算机辅助设计系统或游戏模拟。基类是“形状”，每个形状都有大小、颜色、位置等等。每个形状可以绘制、擦除、移动、着色等。由此，可以派生出（继承出）具体类型的形状——圆形、正方形、三角形等等——每个形状可以具有附加的特征和行为。</p><p><img src="../images/1545764780795.png" alt="1545764780795"></p><p>例如，某些形状可以翻转。有些行为可能不同，比如计算形状的面积。类型层次结构体现了形状之间的相似性和差异性。以相同的术语将解决方案转换成问题是有用的，因为你不需要在问题描述和解决方案描述之间建立许多中间模型。通过使用对象，类型层次结构成为了主要模型，因此你可以直接从真实世界中对系统的描述过渡到用代码对系统进行描述。事实上，有时候，那些善于寻找复杂解决方案的人会被面向对象设计的简单性难倒。从现有类型继承创建新类型。这种新类型不仅包含现有类型的所有成员（尽管私有成员被隐藏起来并且不可访问），而且更重要的是它复制了基类的接口。也就是说，基类对象接收的所有消息也能被派生类对象接收。根据类接收的消息，我们知道类的类型，因此派生类与基类是相同的类型。</p><p>在前面的例子中，“圆是形状”。这种通过继承的类型等价性是理解面向对象编程含义的基本门槛之一。因为基类和派生类都具有相同的基本接口，所以伴随此接口的必定有某些具体实现。也就是说，当对象接收到特定消息时，必须有可执行代码。如果继承一个类而不做其他任何事，则来自基类接口的方法直接进入派生类。这意味着派生类和基类不仅具有相同的类型，而且具有相同的行为，这么做没什么特别意义。</p><p>有两种方法可以区分新的派生类与原始的基类。第一种方法很简单：在派生类中添加新方法。这些新方法不是基类接口的一部分。这意味着基类不能满足你的所有需求，所以你添加了更多的方法。继承的这种简单而原始的用途有时是解决问题的完美解决方案。然而，还是要仔细考虑是否在基类中也要有这些额外的方法。这种设计的发现与迭代过程在面向对象程序设计中会经常发生。</p><p>尽管继承有时意味着你要在接口中添加新方法（尤其是在以 <strong>extends</strong> 关键字表示继承的 Java 中），但并非总需如此。第二种也是更重要地区分派生类和基类的方法是改变现有基类方法的行为，这被称为覆盖 (overriding)。要想覆盖一个方法，只需要在派生类中重新定义这个方法即可。</p><h3 id="“是一个”与”像是一个”的关系"><a href="#“是一个”与”像是一个”的关系" class="headerlink" title="“是一个”与”像是一个”的关系"></a>“是一个”与”像是一个”的关系</h3><p>对于继承可能会引发争论：继承应该只覆盖基类的方法(不应该添加基类中没有的方法)吗？如果这样的话，基类和派生类就是相同的类型了，因为它们具有相同的接口。这会造成，你可以用一个派生类对象完全替代基类对象，这叫作”纯粹替代”，也经常被称作”替代原则”。在某种意义上，这是一种处理继承的理想方式。我们经常把这种基类和派生类的关系称为是一个（is-a）关系，因为可以说”圆是一个形状”。判断是否继承，就看在你的类之间有无这种 is-a 关系。</p><p>有时你在派生类添加了新的接口元素，从而扩展接口。虽然新类型仍然可以替代基类，但是这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为像是一个(is-like-a)关系。新类型不但拥有旧类型的接口，而且包含其他方法，所以不能说新旧类型完全相同。</p><p><img src="../images/1545764820176.png" alt="1545764820176"></p><p>以空调为例，假设房间里已经安装好了制冷设备的控制器，即你有了控制制冷设备的接口。想象一下，现在空调坏了，你重新安装了一个既制冷又制热的热力泵。热力泵就像是一个（is-like-a）空调，但它可以做更多。因为当初房间的控制系统被设计成只能控制制冷设备，所以它只能与新对象(热力泵)的制冷部分通信。新对象的接口已经扩展了，现有控制系统却只知道原来的接口，一旦看到这个设计，你就会发现，作为基类的制冷系统不够一般化，应该被重新命名为”温度控制系统”，也应该包含制热功能，这样的话，我们就可以使用替代原则了。上图反映了在现实世界中进行设计时可能会发生的事情。</p><p>当你看到替代原则时，很容易会认为纯粹替代是唯一可行的方式，并且使用纯粹替代的设计是很好的。但有些时候，你会发现必须得在派生(扩展)类中添加新方法(提供新的接口)。只要仔细审视，你可以很明显地区分两种设计方式的使用场合。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>我们在处理类的层次结构时，通常把一个对象看成是它所属的基类，而不是把它当成具体类。通过这种方式，我们可以编写出不局限于特定类型的代码。在上个“形状”的例子中，“方法”（method）操纵的是通用“形状”，而不关心它们是“圆”、“正方形”、“三角形”还是某种尚未定义的形状。所有的形状都可以被绘制、擦除和移动，因此“方法”向其中的任何代表“形状”的对象发送消息都不必担心对象如何处理信息。</p><p>这样的代码不会受添加的新类型影响，并且添加新类型是扩展面向对象程序以处理新情况的常用方法。 例如，你可以通过通用的“形状”基类派生出新的“五角形”形状的子类，而不需要修改通用”形状”基类的方法。通过派生新的子类来扩展设计的这种能力是封装变化的基本方法之一。</p><p>这种能力改善了我们的设计，且减少了软件的维护代价。如果我们把派生的对象类型统一看成是它本身的基类（“圆”当作“形状”，“自行车”当作“车”，“鸬鹚”当作“鸟”等等），编译器（compiler）在编译时期就无法准确地知道什么“形状”被擦除，哪一种“车”在行驶，或者是哪种“鸟”在飞行。这就是关键所在：当程序接收这种消息时，程序员并不想知道哪段代码会被执行。“绘图”的方法可以平等地应用到每种可能的“形状”上，形状会依据自身的具体类型执行恰当的代码。</p><p>如果不需要知道执行了哪部分代码，那我们就能添加一个新的不同执行方式的子类而不需要更改调用它的方法。那么编译器在不确定该执行哪部分代码时是怎么做的呢？举个例子，下图的 <strong>BirdController</strong> 对象和通用 <strong>Bird</strong> 对象中，<strong>BirdController</strong> 不知道 <strong>Bird</strong> 的确切类型却还能一起工作。从 <strong>BirdController</strong> 的角度来看，这是很方便的，因为它不需要编写特别的代码来确定 <strong>Bird</strong> 对象的确切类型或行为。那么，在调用 <strong>move()</strong> 方法时是如何保证发生正确的行为（鹅走路、飞或游泳、企鹅走路或游泳）的呢？</p><p><img src="../images/1545839316314.png" alt="Bird-example"></p><p>这个问题的答案，是面向对象程序设计的妙诀：在传统意义上，编译器不能进行函数调用。由非 OOP 编译器产生的函数调用会引起所谓的<strong>早期绑定</strong>，这个术语你可能从未听说过，不会想过其他的函数调用方式。这意味着编译器生成对特定函数名的调用，该调用会被解析为将执行的代码的绝对地址。</p><p>通过继承，程序直到运行时才能确定代码的地址，因此发送消息给对象时，还需要其他一些方案。为了解决这个问题，面向对象语言使用<strong>后期绑定</strong>的概念。当向对象发送信息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码。</p><p>为了执行后期绑定，Java 使用一个特殊的代码位来代替绝对调用。这段代码使用对象中存储的信息来计算方法主体的地址（此过程在多态性章节中有详细介绍）。因此，每个对象的行为根据特定代码位的内容而不同。当你向对象发送消息时，对象知道该如何处理这条消息。在某些语言中，必须显式地授予方法后期绑定属性的灵活性。例如，C++ 使用 <strong>virtual</strong> 关键字。在这些语言中，默认情况下方法不是动态绑定的。在 Java 中，动态绑定是默认行为，不需要额外的关键字来实现多态性。</p><p>为了演示多态性，我们编写了一段代码，它忽略了类型的具体细节，只与基类对话。该代码与具体类型信息分离，因此更易于编写和理解。而且，如果通过继承添加了一个新类型（例如，一个六边形），那么代码对于新类型的 Shape 就像对现有类型一样有效。因此，该程序是可扩展的。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法与任何 <strong>Shape</strong> 对话，因此它与所绘制和擦除的对象的具体类型无关。如果程序的其他部分使用 <code>doSomething()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> Triangle();</span><br><span class="line">Line line = <span class="keyword">new</span> Line();</span><br><span class="line">doSomething(circle);</span><br><span class="line">doSomething(triangle);</span><br><span class="line">doSomething(line);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到无论传入的“形状”是什么，程序都正确的执行了。</p><p><img src="../images/1545841270997.png" alt="shape-example"></p><p>这是一个非常令人惊奇的编程技巧。分析下面这行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doSomething(circle);</span><br></pre></td></tr></table></figure><p>当预期接收 <strong>Shape</strong> 的方法被传入了 <strong>Circle</strong>，会发生什么。由于 <strong>Circle</strong> 也是一种 <strong>Shape</strong>，所<br>以 <code>doSomething(circle)</code> 能正确地执行。也就是说，<code>doSomething()</code> 能接收任意发送给 <strong>Shape</strong> 的消息。这是完全安全和合乎逻辑的事情。</p><p>这种把子类当成其基类来处理的过程叫做“向上转型”（<strong>upcasting</strong>）。在面向对象的编程里，经常利用这种方法来给程序解耦。再看下面的 <code>doSomething()</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shape.erase();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure><p>我们可以看到程序并未这样表达：“如果你是一个 Circle ，就这样做；如果你是一个 Square，就那样做…”。若那样编写代码，就需检查 Shape 所有可能的类型，如圆、矩形等等。这显然是非常麻烦的，而且每次添加了一种新的 Shape 类型后，都要相应地进行修改。在这里，我们只需说：“你是一种几何形状，我知道你能删掉 <code>erase()</code> 和绘制 <code>draw()</code>，你自己去做吧，注意细节。”</p><p>尽管我们没作出任何特殊指示，程序的操作也是完全正确和恰当的。我们知道，为 Circle 调用<code>draw()</code> 时执行的代码与为一个 Square 或 Line 调用 <code>draw()</code> 时执行的代码是不同的。但在将 <code>draw()</code> 信息发给一个匿名 Shape 时，根据 Shape 句柄当时连接的实际类型，会相应地采取正确的操作。这非常神奇，因为当 Java 编译器为 <code>doSomething()</code> 编译代码时，它并不知道自己要操作的准确类型是什么。</p><p>尽管我们确实可以保证最终会为 Shape 调用 <code>erase()</code> 和 <code>draw()</code>，但并不能确定特定的 Circle，Square 或者 Line 调用什么。最后，程序执行的操作却依然是正确的，这是怎么做到的呢？</p><p>发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。编译器和运行时系统会负责对所有细节的控制；我们只需知道要做什么，以及如何利用多态性来更好地设计程序。</p><h2 id="单继承结构"><a href="#单继承结构" class="headerlink" title="单继承结构"></a>单继承结构</h2><p>自从 C++ 引入以来，一个 OOP 问题变得尤为突出：是否所有的类都应该默认从一个基类继承呢？这个答案在 Java 中是肯定的（实际上，除 C++ 以外的几乎所有 OOP 语言中也是这样）。在 Java 中，这个最终基类的名字就是 <code>Object</code>。</p><p>Java 的单继承结构有很多好处。由于所有对象都具有一个公共接口，因此它们最终都属于同一个基类。相反的，对于 C++ 所使用的多继承的方案则是不保证所有的对象都属于同一个基类。从向后兼容的角度看，多继承的方案更符合 C 的模型，而且受限较少。</p><p>对于完全面向对象编程，我们必须要构建自己的层次结构，以提供与其他 OOP 语言同样的便利。我们经常会使用到新的类库和不兼容的接口。为了整合它们而花费大气力（有可能还要用上多继承）以获得 C++ 样的“灵活性”值得吗？如果从零开始，Java 这样的替代方案会是更好的选择。</p><p>另外，单继承的结构使得垃圾收集器的实现更为容易。这也是 Java 在 C++ 基础上的根本改进之一。</p><p>由于运行期的类型信息会存在于所有对象中，所以我们永远不会遇到判断不了对象类型的情况。这对于系统级操作尤其重要，例如<a href="#异常处理">异常处理</a>。同时，这也让我们的编程具有更大的灵活性。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>通常，我们并不知道解决某个具体问题需要的对象数量和持续时间，以及对象的存储方式。那么我们如何知悉程序在运行时需要分配的内存空间呢？</p><p>在面向对象的设计中，问题的解决方案有些过于轻率：创建一个新类型的对象来引用、容纳其他的对象。当然，我们也可以使用多数编程语言都支持的“数组”（array）。在 Java 中“集合”（Collection）的使用率更高。（也可称之为“容器”，但“集合”这个称呼更通用。）</p><p>“集合”这种类型的对象可以存储任意类型、数量的其他对象。它能根据需要自动扩容，我们不用关心过程是如何实现的。</p><p>还好，一般优秀的 OOP 语言都会将“集合”作为其基础包。在 C++ 中，“集合”是其标准库的一部分，通常被称为 STL（Standard Template Library，标准模板库）。SmallTalk 有一套非常完整的集合库。同样，Java 的标准库中也提供许多现成的集合类。</p><p>在一些库中，一两个泛型集合就能满足我们所有的需求了，而在其他一些类库（Java）中，不同类型的集合对应不同的需求：常见的有 List，常用于保存序列；Map，也称为关联数组，常用于将对象与其他对象关联）；Set，只能保存非重复的值；其他还包括如队列（Queue）、树（Tree）、栈（Stack）、堆（Heap）等等。从设计的角度来看，我们真正想要的是一个能够解决某个问题的集合。如果一种集合就满足所有需求，那么我们就不需要剩下的了。之所以选择集合有以下两个原因：</p><ol><li><p>集合可以提供不同类型的接口和外部行为。堆栈、队列的应用场景和集合、列表不同，它们中的一种提供的解决方案可能比其他灵活得多。</p></li><li><p>不同的集合对某些操作有不同的效率。例如，List 的两种基本类型：ArrayList 和 LinkedList。虽然两者具有相同接口和外部行为，但是在某些操作中它们的效率差别很大。在 ArrayList 中随机查找元素是很高效的，而 LinkedList 随机查找效率低下。反之，在 LinkedList 中插入元素的效率要比在 ArrayList 中高。由于底层数据结构的不同，每种集合类型在执行相同的操作时会表现出效率上的差异。</p></li></ol><p>我们可以一开始使用 LinkedList 构建程序，在优化系统性能时改用 ArrayList。通过对 List 接口的抽象，我们可以很容易地将 LinkedList 改为 ArrayList。</p><p>在 Java 5 泛型出来之前，集合中保存的是通用类型 <code>Object</code>。Java 单继承的结构意味着所有元素都基于 <code>Object</code> 类，所以在集合中可以保存任何类型的数据，易于重用。要使用这样的集合，我们先要往集合添加元素。由于 Java 5 版本前的集合只保存 <code>Object</code>，当我们往集合中添加元素时，元素便向上转型成了 <code>Object</code>，从而丢失自己原有的类型特性。这时我们再从集合中取出该元素时，元素的类型变成了 <code>Object</code>。那么我们该怎么将其转回原先具体的类型呢？这里，我们使用了强制类型转换将其转为更具体的类型，这个过程称为对象的“向下转型”。通过“向上转型”，我们知道“圆形”也是一种“形状”，这个过程是安全的。可是我们不能从“Object”看出其就是“圆形”或“形状”，所以除非我们能确定元素的具体类型信息，否则“向下转型”就是不安全的。也不能说这样的错误就是完全危险的，因为一旦我们转化了错误的类型，程序就会运行出错，抛出“运行时异常”（RuntimeException）。（后面的章节会提到） 无论如何，我们要寻找一种在取出集合元素时确定其具体类型的方法。另外，每次取出元素都要做额外的“向下转型”对程序和程序员都是一种开销。以某种方式创建集合，以确认保存元素的具体类型，减少集合元素“向下转型”的开销和可能出现的错误难道不好吗？这种解决方案就是：参数化类型机制（Parameterized Type Mechanism）。</p><p>参数化类型机制可以使得编译器能够自动识别某个 <code>class</code> 的具体类型并正确地执行。举个例子，对集合的参数化类型机制可以让集合仅接受“形状”这种类型的元素，并以“形状”类型取出元素。Java 5 版本支持了参数化类型机制，称之为“泛型”（Generic）。泛型是 Java 5 的主要特性之一。你可以按以下方式向 ArrayList 中添加 Shape（形状）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Shape&gt; shapes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>泛型的应用，让 Java 的许多标准库和组件都发生了改变。在本书的代码示例中，你也会经常看到泛型的身影。</p><h2 id="对象创建与生命周期"><a href="#对象创建与生命周期" class="headerlink" title="对象创建与生命周期"></a>对象创建与生命周期</h2><p>我们在使用对象时要注意的一个关键问题就是对象的创建和销毁方式。每个对象的生存都需要资源，尤其是内存。为了资源的重复利用，当对象不再被使用时，我们应该及时释放资源，清理内存。</p><p>在简单的编程场景下，对象的清理并不是问题。我们创建对象，按需使用，最后销毁它。然而，情况往往要比这更复杂：</p><p>假设，我们正在为机场设计一个空中交通管制的系统（该例也适用于仓库货柜管理、影带出租或者宠物寄养仓库系统）。第一步比较简单：创建一个用来保存飞机的集合，每当有飞机进入交通管制区域时，我们就创建一个“飞机”对象并将其加入到集合中，等到飞机离开时将其从这个集合中清除。与此同时，我们还需要一个记录飞机信息的系统，也许这些数据不像主要控制功能那样引人注意。比如，我们要记录所有飞机中的小型飞机的的信息（比如飞行计划)。此时，我们又创建了第二个集合来记录所有小型飞机。 每当创建一个“飞机”对象的时候，将其放入第一个集合；若它属于小型飞机，也必须同时将其放入第二个集合里。</p><p>现在问题开始棘手了：我们怎么知道何时该清理这些对象呢？当某一个系统处理完成，而其他系统可能还没有处理完成。这样的问题在其他的场景下也可能发生。在 C++ 程序设计中，当使用完一个对象后，必须明确将其删除，这就让问题变复杂了。</p><p>对象的数据在哪？它的生命周期是怎么被控制的？ 在 C++ 设计中采用的观点是效率第一，因此它将选择权交给了程序员。为了获得最大的运行时速度，程序员可以在编写程序时，通过将对象放在栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间。这些区域的对象会被优先分配内存和释放。这种控制在某些情况下非常有用。</p><p>然而相对的，我们也牺牲了程序的灵活性。因为在编写代码时，我们必须要弄清楚对象的数量、生存时间还有类型。如果我们要用它来解决一个相当普遍的问题时（如计算机辅助设计、仓库管理或空中交通管制等），限制就太大了。</p><p>第二种方法是在堆内存（Heap）中动态地创建对象。在这种方式下，直到程序运行我们才能确定需要创建的对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。 因为内存的占用是动态管理的，所以在运行时，在堆内存上开辟空间所需的时间可能比在栈内存上要长（但也不一定）。在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟堆内存空间的时间取决于内存机制的设计。</p><p>动态方法有这样一个一般性的逻辑假设：对象趋向于变得复杂，因此额外的内存查找和释放对对象的创建影响不大。（原文：<em>The dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object.</em>）此外，更好的灵活性对于问题的解决至关重要。</p><p>Java 使用动态内存分配。每次创建对象时，使用 <code>new</code> 关键字构建该对象的动态实例。这又带来另一个问题：对象的生命周期。较之堆内存，在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在堆内存创建对象的话，编译器是不知道它的生命周期的。在 C++ 中你必须以编程方式确定何时销毁对象，否则可能导致内存泄漏。Java 的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。垃圾收集器的存在带来了极大的便利，它减少了我们之前必须要跟踪的问题和编写相关代码的数量。因此，垃圾收集器提供了更高级别的保险，以防止潜在的内存泄漏问题，这个问题使得许多 C++ 项目没落。</p><p>Java 的垃圾收集器被设计用来解决内存释放的问题（虽然这不包括对象清理的其他方面）。垃圾收集器知道对象什么时候不再被使用并且自动释放内存。结合单继承和仅可在堆中创建对象的机制，Java 的编码过程比用 C++ 要简单得多。我们所要做的决定和要克服的障碍也会少很多！</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>自编程语言被发明以来，程序的错误处理一直都是个难题。因为很难设计出一个好的错误处理方案，所以许多编程语言都忽略了这个问题，把这个问题丢给了程序类库的设计者。他们提出了在许多情况下都可以工作但很容易被规避的半途而废的措施，通常只需忽略错误。多数错误处理方案的主要问题是：它们依赖程序员之间的约定俗成而不是语言层面的限制。换句话说，如果程序员赶时间或没想起来，这些方案就很容易被忘记。</p><p>异常处理机制将程序错误直接交给编程语言甚至是操作系统。“异常”（Exception）是一个从出错点“抛出”（thrown）后能被特定类型的异常处理程序捕获(catch)的一个对象。它不会干扰程序的正常运行，仅当程序出错的时候才被执行。这让我们的编码更简单：不用再反复检查错误了。另外，异常不像方法返回的错误值和方法设置用来表示发生错误的标志位那样可以被忽略。异常的发生是不会被忽略的，它终究会在某一时刻被处理。</p><p>最后，“异常机制”提供了一种可靠地从错误状况中恢复的方法，使得我们可以编写出更健壮的程序。有时你只要处理好抛出的异常情况并恢复程序的运行即可，无需退出。</p><p>Java 的异常处理机制在编程语言中脱颖而出。Java 从一开始就内置了异常处理，因此你不得不使用它。这是 Java 语言唯一接受的错误报告方法。如果没有编写适当的异常处理代码，你将会收到一条编译时错误消息。这种有保障的一致性有时会让程序的错误处理变得更容易。值得注意的是，异常处理并不是面向对象的特性。尽管在面向对象的语言中异常通常由对象表示，但是在面向对象语言之前也存在异常处理。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>面向过程程序包含数据定义和函数调用。要找到程序的意图，你必须要在脑中建立一个模型，弄清函数调用和更底层的概念。这些程序令人困扰，因为它们的表示更多地面向计算机而不是我们要解决的问题，这就是我们在设计程序时需要中间表示的原因。OOP 在面向过程编程的基础上增加了许多新的概念，所以有人会认为使用 Java 来编程会比同等的面向过程编程要更复杂。在这里，我想给大家一个惊喜：通常按照 Java 规范编写的程序会比面向过程程序更容易被理解。</p><p>你看到的是对象的概念，这些概念是站在“问题空间”的（而不是站在计算机角度的“解决方案空间”），以及发送消息给对象以指示该空间中的活动。面向对象编程的一个优点是：设计良好的 Java 程序代码更容易被人阅读理解。由于 Java 类库的复用性，通常程序要写的代码也会少得多。</p><p>OOP 和 Java 不一定适合每个人。评估自己的需求以及与现有方案作比较是很重要的。请充分考虑后再决定是不是选择 Java。如果在可预见的未来，Java 并不能很好的满足你的特定需求，那么你应该去寻找其他替代方案（特别是，我推荐看 Python）。如果你依然选择 Java 作为你的开发语言，我希望你至少应该清楚你选择的是什么，以及为什么选择这个方向。</p><h1 id="第-2-章-安装-Java-和本书用例"><a href="#第-2-章-安装-Java-和本书用例" class="headerlink" title="第 2 章 安装 Java 和本书用例"></a>第 2 章 安装 Java 和本书用例</h1><p>现在，我们来为这次阅读之旅做些准备吧！</p><p>在开始学习 Java 之前，你必须要先安装好 Java 和本书的源代码示例。因为考虑到可能有“专门的初学者”从本书开始学习编程，所以我会详细地教你如何使用命令行。 如果你已经有此方面的经验了，可以跳过这段安装说明。如果你对此处描述的任何术语或过程仍不清楚，还可以通过 <a href="https://google.com/">Google</a> 搜索找到答案。具体的问题或困难请试着在 <a href="https://stackoverflow.com/">StackOverflow</a> 上提问。或者去 <a href="https://youtube.com">YouTube</a> 看有没有相关的安装说明。</p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>首先你需要安装一个编辑器来创建和修改本书用例里的 Java 代码。有可能你还需要使用编辑器来更改系统配置文件。</p><p>相比一些重量级的 IDE（Integrated Development Environments，集成开发环境），如 Eclipse、NetBeans 和 IntelliJ IDEA (译者注：做项目强烈推荐 IDEA)，编辑器是一种更纯粹的文本编辑器。如果你已经有了一个用着顺手的 IDE，那就可以直接用了。为了方便后面的学习和统一下教学环境，我推荐大家使用 Atom 这个编辑器。大家可以在 <a href="https://atom.io">atom.io</a> 上下载。</p><p>Atom 是一个免费开源、易于安装且跨平台（支持 Window、Mac 和 Linux）的文本编辑器。内置支持 Java 文件。相比 IDE 的厚重，它比较轻量级，是学习本书的理想工具。Atom 包含了许多方便的编辑功能，相信你一定会爱上它！更多关于 Atom 使用的细节问题可以到它的网站上寻找。</p><p>还有很多其他的编辑器。有一种亚文化的群体，他们热衷于争论哪个更好用！如果你找到一个你更喜欢的编辑器，换一种使用也没什么难度。重要的是，你要找一个用着舒服的。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>如果你之前没有接触过编程，那么有可能对 Shell（命令行窗口） 不太熟悉。shell 的历史可以追溯到早期的计算时代，当时在计算机上的操作是都通过输入命令进行的，计算机通过回显响应。所有的操作都是基于文本的。</p><p>尽管和现在的图形用户界面相比，Shell 操作方式很原始。但是同时 shell 也为我们提供了许多有用的功能特性。在学习本书的过程中，我们会经常使用到 Shell，包括现在这部分的安装，还有运行 Java 程序。</p><p>Mac：单击聚光灯（屏幕右上角的放大镜图标），然后键入 <code>terminal</code>。单击看起来像小电视屏幕的应用程序（你也可以单击“return”）。这就启动了你的用户下的 shell 窗口。</p><p>windows：首先，通过目录打开 windows 资源管理器：</p><ul><li>Windows 7: 单击屏幕左下角的“开始”图标，输入“explorer”后按回车键。</li><li>Windows 8: 按 Windows+Q，输入 “explorer” 后按回车键。</li><li>Windows 10: 按 Windows+E 打开资源管理器，导航到所需目录，单击窗口左上角的“文件“选项卡，选择“打开 Window PowerShell”启动 Shell。</li></ul><p>Linux: 在 home 目录打开 Shell。</p><ul><li>Debian: 按 Alt+F2， 在弹出的对话框中输入“gnome-terminal”</li><li>Ubuntu: 在屏幕中鼠标右击，选择 “打开终端”，或者按住 Ctrl+Alt+T</li><li>Redhat: 在屏幕中鼠标右击，选择 “打开终端”</li><li>Fedora: 按 Alt+F2，在弹出的对话框中输入“gnome-terminal”</li></ul><p><strong>目录</strong></p><p>目录是 Shell 的基础元素之一。目录用来保存文件和其他目录。目录就好比树的分支。如果书籍是你系统上的一个目录，并且它有两个其他目录作为分支，例如数学和艺术，那么我们就可以说你有一个书籍目录，它包含数学和艺术两个子目录。注意：Windows 使用 <code>\</code> 而不是 <code>/</code> 来分隔路径。</p><p><strong>Shell 基本操作</strong></p><p>我在这展示的 Shell 操作和系统中大体相同。出于本书的原因，下面列举一些在 Shell 中的基本操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">更改目录： <span class="built_in">cd</span> &lt;路径&gt;</span><br><span class="line">          <span class="built_in">cd</span> .. 移动到上级目录</span><br><span class="line">          <span class="built_in">pushd</span> &lt;路径&gt; 记住来源的同时移动到其他目录，<span class="built_in">popd</span> 返回来源</span><br><span class="line"></span><br><span class="line">目录列举： ls 列举出当前目录下所有的文件和子目录名（不包含隐藏文件），</span><br><span class="line">             可以选择使用通配符 * 来缩小搜索范围。</span><br><span class="line">             示例(1)： 列举所有以“.java”结尾的文件，输入 ls *.java (Windows: dir *.java)</span><br><span class="line">             示例(2)： 列举所有以“F”开头，“.java”结尾的文件，输入ls F*.java (Windows: dir F*.java)</span><br><span class="line"></span><br><span class="line">创建目录：</span><br><span class="line">    Mac/Linux 系统：mkdir</span><br><span class="line">              示例：mkdir books</span><br><span class="line">    Windows   系统：md</span><br><span class="line">              示例：md books</span><br><span class="line"></span><br><span class="line">移除文件：</span><br><span class="line">    Mac/Linux 系统：rm</span><br><span class="line">              示例：rm somefile.java</span><br><span class="line">    Windows   系统：del</span><br><span class="line">              示例：del somefile.java</span><br><span class="line"></span><br><span class="line">移除目录：</span><br><span class="line">    Mac/Linux 系统：rm -r</span><br><span class="line">              示例：rm -r books</span><br><span class="line">    Windows   系统：deltree</span><br><span class="line">              示例：deltree books</span><br><span class="line"></span><br><span class="line">重复命令： !!  重复上条命令</span><br><span class="line">              示例：!n 重复倒数第n条命令</span><br><span class="line"></span><br><span class="line">命令历史：</span><br><span class="line">    Mac/Linux 系统：<span class="built_in">history</span></span><br><span class="line">    Windows   系统：按 F7 键</span><br><span class="line"></span><br><span class="line">文件解压：</span><br><span class="line">    Linux/Mac 都有命令行解压程序 unzip，你可以通过互联网为 Windows 安装命令行解压程序 unzip。</span><br><span class="line">    图形界面下（Windows 资源管理器，Mac Finder，Linux Nautilus 或其他等效软件）右键单击该文件，</span><br><span class="line">    在 Mac 上选择“open”，在 Linux 上选择“extract here”，或在 Windows 上选择“extract all…”。</span><br><span class="line">    要了解关于 shell 的更多信息，请在维基百科中搜索 Windows shell，Mac/Linux用户可搜索 bash shell。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Java-安装"><a href="#Java-安装" class="headerlink" title="Java 安装"></a>Java 安装</h2><p>为了编译和运行代码示例，首先你必须安装 JDK（Java Development Kit，JAVA 软件开发工具包）。本书中采用的是 JDK 8。</p><p><strong>Windows</strong></p><ol><li>以下为 Chocolatey 的<a href="https://chocolatey.org/">安装说明</a>。</li><li>在命令行提示符下输入下面的命令，等待片刻，结束后 Java 安装完成并自动完成环境变量设置。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install jdk8</span><br></pre></td></tr></table></figure><p><strong>Macintosh</strong></p><p>Mac 系统自带的 Java 版本太老，为了确保本书的代码示例能被正确执行，你必须将它先更新到 Java 8。我们需要管理员权限来运行下面的步骤：</p><ol><li>以下为 HomeBrew 的<a href="https://brew.sh/">安装说明</a>。安装完成后执行命令 <code>brew update</code> 更新到最新版本</li><li>在命令行下执行下面的命令来安装 Java。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install java</span><br></pre></td></tr></table></figure><p>当以上安装都完成后，如果你有需要，可以使用游客账户来运行本书中的代码示例。</p><p><strong>Linux</strong></p><ul><li><strong>Ubuntu/Debian</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install default-jdk</span><br></pre></td></tr></table></figure><ul><li><strong>Fedora/Redhat</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su-c <span class="string">&quot;yum install java-1.8.0-openjdk&quot;</span>(注：执行引号内的内容就可以安装)</span><br></pre></td></tr></table></figure><h2 id="校验安装"><a href="#校验安装" class="headerlink" title="校验安装"></a>校验安装</h2><p>打开新的命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>正常情况下 你应该看到以下类似信息(版本号信息可能不一样）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version <span class="string">&quot;1.8.0_112&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_112-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)</span><br></pre></td></tr></table></figure><p>如果提示命令找不到或者无法被识别，请根据安装说明重试；如果还不行，尝试到 <a href="https://stackoverflow.com/search?q=installing+java">StackOverflow</a> 寻找答案。</p><h2 id="安装和运行代码示例"><a href="#安装和运行代码示例" class="headerlink" title="安装和运行代码示例"></a>安装和运行代码示例</h2><p>当 Java 安装完毕，下一步就是安装本书的代码示例了。安装步骤所有平台一致：</p><ol><li>从 <a href="https://github.com/BruceEckel/OnJava8-Examples/archive/master.zip">GitHub 仓库</a>中下载本书代码示例</li><li>解压到你所选目录里。</li><li>使用 Windows 资源管理器，Mac Finder，Linux 的 Nautilus 或其他等效工具浏览，在该目录下打开 Shell。</li><li>如果你在正确的目录中，你应该看到该目录中名为 gradlew 和 gradlew.bat 的文件，以及许多其他文件和目录。目录与书中的章节相对应。</li><li>在 shell 中输入下面的命令运行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows 系统：</span><br><span class="line">     gradlew run</span><br><span class="line"></span><br><span class="line">Mac/Linux 系统：</span><br><span class="line">   ./gradlew run</span><br></pre></td></tr></table></figure><p>第一次安装时 Gradle 需要安装自身和其他的相关的包，请稍等片刻。安装完成后，后续的安装将会快很多。</p><p><strong>注意</strong>： 第一次运行 gradlew 命令时必须连接互联网。</p><p><strong>Gradle 基础任务</strong></p><p>本书构建的大量 Gradle 任务都可以自动运行。Gradle 使用约定大于配置的方式，简单设置即可具备高可用性。本书中“一起去骑行”的某些任务不适用于此或无法执行成功。以下是你通常会使用上的 Gradle 任务列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">编译本书中的所有 java 文件，除了部分错误示范的</span><br><span class="line">gradlew compileJava</span><br><span class="line"></span><br><span class="line">编译并执行 java 文件（某些文件是库组件）</span><br><span class="line">gradlew run</span><br><span class="line"></span><br><span class="line">执行所有的单元测试（在本书第16章会有详细介绍）</span><br><span class="line">gradlew <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">编译并运行一个具体的示例程序</span><br><span class="line">gradlew &lt;本书章节&gt;:&lt;示例名称&gt;</span><br><span class="line">示例：gradlew objects:HelloDate</span><br></pre></td></tr></table></figure><h1 id="第-3-章-万物皆对象"><a href="#第-3-章-万物皆对象" class="headerlink" title="第 3 章 万物皆对象"></a>第 3 章 万物皆对象</h1><blockquote><p>如果我们说另外一种不同的语言，我们会发觉一个不同的世界！— Ludwig Wittgenstein (1889-1951)</p></blockquote><p>相比 C++ ，Java 是一种更纯粹的面向对象编程语言。虽然它们都是混合语言，但在 Java 中，设计者们认为混合的作用并非像在 C++ 中那般重要。混合语言允许多种编程风格，这也是 C++ 支持向后兼容 C 的原因。正因为 C++ 是 C 语言的超集，所以它也同时包含了许多 C 语言不具备的特性，这使得 C++ 在某些方面过于复杂。</p><p>Java 语言假设你只进行面向对象编程。开始学习之前，我们需要将思维置于面向对象的世界。本章你将了解到 Java 程序的基本组成，学习在 Java 中万物（几乎）皆对象的思想。</p><h2 id="对象操纵"><a href="#对象操纵" class="headerlink" title="对象操纵"></a>对象操纵</h2><p>“名字代表什么？玫瑰即使不叫玫瑰，也依旧芬芳”。（引用自 莎士比亚，《罗密欧与朱丽叶》）。</p><p>所有的编程语言都会操纵内存中的元素。有时程序员必须要有意识地直接或间接地操纵它们。在 C/C++ 中，对象的操纵是通过指针来完成的。</p><p>Java 利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用” <sup><a href="#fn_1" id="reffn_1">1</a></sup>。 举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。换句话说，我们无需直接接触电视，就可通过遥控器（引用）自由地控制电视（对象）的频道和音量。此外，没有电视，遥控器也可以单独存在。就是说，你仅仅有一个“引用”并不意味着你必然有一个与之关联的“对象”。</p><p>下面来创建一个 <strong>String</strong> 引用，用于保存单词或语句。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure><p>这里我们只是创建了一个 <strong>String</strong> 对象的引用，而非对象。直接拿来使用会出现错误：因为此时你并没有给变量 <code>s</code> 赋值—指向任何对象。通常更安全的做法是：创建一个引用的同时进行初始化。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;asdf&quot;</span>;</span><br></pre></td></tr></table></figure><p>Java 语法允许我们使用带双引号的文本内容来初始化字符串。同样，其他类型的对象也有相应的初始化方式。</p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>“引用”用来关联“对象”。在 Java 中，通常我们使用<code>new</code>操作符来创建一个新对象。<code>new</code> 关键字代表：创建一个新的对象实例。所以，我们也可以这样来表示前面的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;asdf&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上展示了字符串对象的创建过程，以及如何初始化生成字符串。除了 <strong>String</strong> 类型以外，Java 本身自带了许多现成的数据类型。除此之外，我们还可以创建自己的数据类型。事实上，这是 Java 程序设计中的一项基本行为。在本书后面的学习中将会接触到。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有 5 个不同的地方可以存储数据：</p><ol><li><p><strong>寄存器</strong>（Registers）最快的存储区域，位于 CPU 内部 <sup><a href="#fn_2" id="reffn_2">2</a></sup>。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。</p></li><li><p><strong>栈内存</strong>（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java 系统必须准确地知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据，特别是对象引用，但 Java 对象却是保存在堆内存的。</p></li><li><p><strong>堆内存</strong>（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 <code>new</code> 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。</p></li><li><p><strong>常量存储</strong>（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 <sup><a href="#fn_3" id="reffn_3">3</a></sup>。</p></li><li><p><strong>非 RAM 存储</strong>（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。</p></li></ol><h3 id="基本类型的存储"><a href="#基本类型的存储" class="headerlink" title="基本类型的存储"></a>基本类型的存储</h3><p>有一组类型在 Java 中使用频率很高，它们需要特殊对待，这就是 Java 的基本类型。之所以这么说，是因为它们的创建并不是通过 <code>new</code> 关键字来产生。通常 <code>new</code> 出来的对象都是保存在堆内存中的，以此方式创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java 使用了和 C/C++ 一样的策略。也就是说，不是使用 <code>new</code> 创建变量，而是使用一个“自动”变量。 这个变量直接存储”值”，并置于栈内存中，因此更加高效。</p><p>Java 确定了每种基本类型的内存占用大小。 这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是 Java 更具可移植性的一个原因。</p><div class="table-container"><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">大小</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th><th style="text-align:center">包装类型</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">—</td><td style="text-align:center">—</td><td style="text-align:center">—</td><td style="text-align:center">Boolean</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16 bits</td><td style="text-align:center">Unicode 0</td><td style="text-align:center">Unicode 2<sup>16</sup> -1</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">8 bits</td><td style="text-align:center">-128</td><td style="text-align:center">+127</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16 bits</td><td style="text-align:center">- 2<sup>15</sup></td><td style="text-align:center">+ 2<sup>15</sup> -1</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32 bits</td><td style="text-align:center">- 2<sup>31</sup></td><td style="text-align:center">+ 2<sup>31</sup> -1</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64 bits</td><td style="text-align:center">- 2<sup>63</sup></td><td style="text-align:center">+ 2<sup>63</sup> -1</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32 bits</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64 bits</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">void</td><td style="text-align:center">—</td><td style="text-align:center">—</td><td style="text-align:center">—</td><td style="text-align:center">Void</td></tr></tbody></table></div><p>所有的数值类型都是有正/负符号的。布尔（boolean）类型的大小没有明确的规定，通常定义为取字面值 “true” 或 “false” 。基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">Character ch = <span class="keyword">new</span> Character(c);</span><br></pre></td></tr></table></figure><p>或者你也可以使用下面的形式，基本类型自动转换成包装类型（自动装箱）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character ch = <span class="keyword">new</span> Character(<span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure><p>相对的，包装类型转化为基本类型（自动拆箱）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = ch;</span><br></pre></td></tr></table></figure><p>个中原因将在以后的章节里解释。</p><h3 id="高精度数值"><a href="#高精度数值" class="headerlink" title="高精度数值"></a>高精度数值</h3><p>在 Java 中有两种类型的数据可用于高精度的计算。它们是 <code>BigInteger</code> 和 <code>BigDecimal</code>。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。</p><p>这两个类包含的方法提供的操作，与对基本类型执行的操作相似。也就是说，能对 int 或 float 做的运算，在 BigInteger 和 BigDecimal 这里也同样可以，只不过必须要通过调用它们的方法来实现而非运算符。此外，由于涉及到的计算量更多，所以运算速度会慢一些。诚然，我们牺牲了速度，但换来了精度。</p><p>BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。<br>BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。</p><p>关于这两个类的详细信息，请参考 JDK 官方文档。</p><h3 id="数组的存储"><a href="#数组的存储" class="headerlink" title="数组的存储"></a>数组的存储</h3><p>许多编程语言都支持数组类型。在 C 和 C++ 中使用数组是危险的，因为那些数组只是内存块。如果程序访问了内存块之外的数组或在初始化之前使用该段内存（常见编程错误），则结果是不可预测的。</p><p>Java 的设计主要目标之一是安全性，因此许多困扰 C 和 C++ 程序员的问题不会在 Java 中再现。在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。（并且 Java 经常可以优化这些操作）。</p><p>当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 <strong>null</strong> 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 <strong>null</strong> 的引用，则会在运行时报错。因此，在 Java 中就防止了数组操作的常规错误。</p><p>我们还可创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。本书稍后将详细介绍数组，特别是在数组章节中。</p><h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p>Java 中有两种类型的注释。第一种是传统的 C 风格的注释，以 <code>/*</code> 开头，可以跨越多行，到 <code>*/</code> 结束。注意，许多程序员在多行注释的每一行开头添加 <code>*</code>，所以你经常会看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是</span></span><br><span class="line"><span class="comment">* 跨越多行的</span></span><br><span class="line"><span class="comment">* 注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但请记住，<code>/*</code> 和 <code>*/</code> 之间的内容都是被忽略的。所以你将其改为下面这样也是没有区别的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是跨越多</span></span><br><span class="line"><span class="comment">行的注释 */</span></span><br></pre></td></tr></table></figure><p>第二种注释形式来自 C++ 。它是单行注释，以 <code>//</code> 开头并一直持续到行结束。这种注释方便且常用，因为直观简单。所以你经常看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br></pre></td></tr></table></figure><h2 id="对象清理"><a href="#对象清理" class="headerlink" title="对象清理"></a>对象清理</h2><p>在一些编程语言中，管理变量的生命周期需要大量的工作。一个变量需要存活多久？如果我们想销毁它，应该什么时候去做呢？变量生命周期的混乱会导致许多 bug，本小结向你介绍 Java 是如何通过释放存储来简化这个问题的。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>大多数程序语言都有作用域的概念。作用域决定了在该范围内定义的变量名的可见性和生存周期。在 C、 C++ 和 Java 中，作用域是由大括号 <code>&#123;&#125;</code> 的位置决定的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">// 仅 x 变量可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">96</span>;</span><br><span class="line">        <span class="comment">// x 和 q 变量皆可用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅 x 变量可用</span></span><br><span class="line">    <span class="comment">// 变量 q 不在作用域内</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 的变量只有在其作用域内才可用。缩进使得 Java 代码更易于阅读。由于 Java 是一种自由格式的语言，额外的空格、制表符和回车并不会影响程序的执行结果。在 Java 中，你不能执行以下操作，即使这在 C 和 C++ 中是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">96</span>; <span class="comment">// Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中， Java 编译器会在提示变量 x 已经被定义过了。因此，在 C/C++ 中将一个较大作用域的变量”隐藏”起来的做法，在 Java 中是不被允许的。 因为 Java 的设计者认为这样做会导致程序混乱。</p><h3 id="对象作用域"><a href="#对象作用域" class="headerlink" title="对象作用域"></a>对象作用域</h3><p>Java 对象与基本类型具有不同的生命周期。当我们使用 <code>new</code> 关键字来创建 Java 对象时，它的生命周期将会超出作用域。因此，下面这段代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作用域终点</span></span><br></pre></td></tr></table></figure><p>上例中，引用 s 在作用域终点就结束了。但是，引用 s 指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用 s 已超出了作用域的范围。在后面的章节中，我们还会学习怎么在编程中传递和复制对象的引用。</p><p>只要你需要，<code>new</code> 出来的对象就会一直存活下去。 相比在 C++ 编码中操作内存可能会出现的诸多问题，这些困扰在 Java 中都不复存在了。在 C++ 中你不仅要确保对象的内存在你操作的范围内存在，还必须在使用完它们之后，将其销毁。</p><p>那么问题来了：我们在 Java 中并没有主动清理这些对象，那么它是如何避免 C++ 中出现的内存被填满从而阻塞程序的问题呢？答案是：Java 的垃圾收集器会检查所有 <code>new</code> 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。</p><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型？你可能很自然地想到 <code>type</code> 关键字。但是，事实上大多数面向对象的语言都使用 <code>class</code> 关键字类来描述一种新的对象。 通常在 <code>class</code> 关键字的后面的紧跟类的的名称。如下代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATypeName</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 这里是类的内部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，我们引入了一个新的类型，尽管这个类里只有一行注释。但是我们一样可以通过 <code>new</code> 关键字来创建一个这种类型的对象。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATypeName a = <span class="keyword">new</span> ATypeName();</span><br></pre></td></tr></table></figure><p>到现在为止，我们还不能用这个对象来做什么事（即不能向它发送任何有意义的消息），除非我们在这个类里定义一些方法。</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>当我们创建好一个类之后，我们可以往类里存放两种类型的元素：方法（method）和字段（field）。类的字段可以是基本类型，也可以是引用类型。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上（通过之前介绍的创建对象的方法）。每个对象都有用来存储其字段的空间。通常，字段不在对象间共享。下面是一个具有某些字段的类的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataOnly</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">boolean</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类除了存储数据之外什么也不能做。但是，我们仍然可以通过下面的代码来创建它的一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataOnly data = <span class="keyword">new</span> DataOnly();</span><br></pre></td></tr></table></figure><p>我们必须通过这个对象的引用来指定字段值。格式：对象名称.方法名称或字段名称。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.i = <span class="number">47</span>;</span><br><span class="line">data.d = <span class="number">1.1</span>;</span><br><span class="line">data.b = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>如果你想修改对象内部包含的另一个对象的数据，可以通过这样的格式修改。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPlane.leftTank.capacity = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>你可以用这种方式嵌套许多对象（尽管这样的设计会带来混乱）。</p><h3 id="基本类型默认值"><a href="#基本类型默认值" class="headerlink" title="基本类型默认值"></a>基本类型默认值</h3><p>如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。</p><div class="table-container"><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">初始值</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">\u0000 (null)</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">(byte) 0</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">(short) 0</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">0L</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">0.0f</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">0.0d</td></tr></tbody></table></div><p>这些默认值仅在 Java 初始化类的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化（在 C++ 中不会），从而减少了 bug 的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。 所以，为了安全，我们最好始终显式地初始化变量。</p><p>这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。 因此，若在方法中定义的基本类型数据，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure><p>这里的变量 x 不会自动初始化为 0，因而在使用变量 x 之前，程序员有责任主动地为其赋值（和 C 、C++ 一致）。如果我们忘记了这一步， Java 将会提示我们“编译时错误，该变量可能尚未被初始化”。 这一点做的比 C++ 更好，在后者中，编译器只是提示警告，而在 Java 中则直接报错。</p><h3 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h3><p>在许多语言（如 C 和 C++）中，使用术语 <em>函数</em> (function) 用来命名子程序。在 Java 中，我们使用术语 <em>方法</em>（method）来表示“做某事的方式”。</p><p>在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。格式如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[返回类型] [方法名](<span class="comment">/*参数列表*/</span>)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称为<strong>方法签名</strong>（signature of the method）。签名作为方法的唯一标识。</p><p>Java 中的方法只能作为类的一部分创建。它只能被对象所调用 <sup><a href="#fn_4" id="reffn_4">4</a></sup>，并且该对象必须有权限来执行调用。若对象调用错误的方法，则程序将在编译时报错。</p><p>我们可以像下面这样调用一个对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[对象引用].[方法名](参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>若方法不带参数，例如一个对象引用 <code>a</code> 的方法 <code>f</code> 不带参数并返回 <strong>int</strong> 型结果，我们可以如下表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = a.f();</span><br></pre></td></tr></table></figure><p>上例中方法 <code>f</code> 的返回值类型必须和变量 <code>x</code> 的类型兼容 。调用方法的行为有时被称为向对象发送消息。面向对象编程可以总结为：向对象发送消息。</p><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><p>方法参数列表指定了传递给方法的信息。正如你可能猜到的，这些信息就像 Java 中的其他所有信息 ，以对象的形式传递。参数列表必须指定每个对象的类型和名称。同样，我们并没有直接处理对象，而是在传递对象引用 <sup><a href="#fn_5" id="reffn_5">5</a></sup> 。但是引用的类型必须是正确的。如果方法需要 String 参数，则必须传入 String，否则编译器将报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">storage</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.length() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法计算并返回某个字符串所占的字节数。参数 <code>s</code> 的类型为 <strong>String</strong> 。将 s 传递给 <code>storage()</code> 后，我们可以把它看作和任何其他对象一样，可以向它发送消息。在这里，我们调用 <code>length()</code> 方法，它是一个 String 方法，返回字符串中的字符数。字符串中每个字符的大小为 16 位或 2 个字节。你还看到了 <strong>return</strong> 关键字，它执行两项操作。首先，它意味着“方法执行结束”。其次，如果方法有返回值，那么该值就紧跟 <strong>return</strong> 语句之后。这里，返回值是通过计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.length() * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>产生的。在方法中，我们可以返回任何类型的数据。如果我们不想方法返回数据，则可以通过给方法标识 <code>void</code> 来表明这是一个无需返回值的方法。 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">flag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">naturalLogBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.718</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nothing2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当返回类型为 <strong>void</strong> 时， <strong>return</strong> 关键字仅用于退出方法，因此在方法结束处的 <strong>return</strong> 可被省略。我们可以随时从方法中返回，但若方法返回类型为非 <code>void</code>，则编译器会强制我们返回相应类型的值。</p><p>上面的描述可能会让你感觉程序只不过是一堆包含各种方法的对象，在这些方法中，将对象作为参数并发送消息给其他对象。大部分情况下确实如此。但在下一章的运算符中我们将会学习如何在方法中做出决策来完成更底层、详细的工作。对于本章，知道如何发送消息就够了。</p><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>在看到第一个 Java 程序之前，我们还必须理解其他几个问题。</p><h3 id="命名可见性"><a href="#命名可见性" class="headerlink" title="命名可见性"></a>命名可见性</h3><p>命名控制在任何一门编程语言中都是一个问题。如果你在两个模块中使用相同的命名，那么如何区分这两个名称，并防止两个名称发生“冲突”呢？在 C 语言编程中这是很具有挑战性的，因为程序通常是一个无法管理的名称海洋。C++ 将函数嵌套在类中，所以它们不会和嵌套在其他类中的函数名冲突。然而，C++ 还是允许全局数据和全局函数，因此仍有可能发生冲突。为了解决这个问题，C++ 使用附加的关键字引入了<em>命名空间</em>。</p><p>Java 采取了一种新的方法避免了以上这些问题：为一个类库生成一个明确的名称，Java 创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。因此我的域名是 MindviewInc.com，所以我将我的 foibles 类库命名为 com.mindviewinc.utility.foibles。反转域名后，<code>.</code> 用来代表子目录的划分。</p><p>在 Java 1.0 和 Java 1.1 中，域扩展名 com、 edu、 org 和 net 等按惯例大写，因此类库中会出现这样类似的名称：com.mindviewinc.utility.foibles。然而，在 Java 2 的开发过程中，他们发现这会导致问题，所以现在整个包名都是小写的。此机制意味着所有文件都自动存在于自己的命名空间中，文件中的每个类都具有唯一标识符。这样，Java 语言可以防止名称冲突。</p><p>使用反向 URL 是一种新的命名空间方法，在此之前尚未有其他语言这么做过。Java 中有许多这些“创造性”地解决问题的方法。正如你想象，如果我们未经测试就添加一个功能并用于生产，那么在将来发现该功能的问题再想纠正，通常为时已晚（有些错误太严重了就得从语言中删除新功能。）</p><p>使用反向 URL 将命名空间与文件路径相关联不会导致 BUG，但它却给源代码管理带来麻烦。例如在 <code>com.mindviewinc.utility.foibles</code> 这样的目录结构中，我们创建了 <code>com</code> 和 <code>mindviewinc</code> 空目录。它们存在的唯一目的就是用来表示这个反向的 URL。</p><p>这种方式似乎为我们在编写 Java 程序中的某个问题打开了大门。空目录填充了深层次结构，它们不仅用于表示反向 URL，还用于捕获其他信息。这些长路径基本上用于存储有关目录中的内容的数据。如果你希望以最初设计的方式使用目录，这种方法可以从“令人沮丧”到“令人抓狂”，对于生产级的 Java 代码，你必须使用专门为此设计的 IDE 来管理代码。例如 NetBeans，Eclipse 或 IntelliJ IDEA。实际上，这些 IDE 都为我们管理和创建深层次空目录结构。</p><p>对于这本书中的例子，我不想让深层次结构给你的学习带来额外的麻烦，这实际上需要你在开始之前学习熟悉一种重量级的 IDE。所以，我们的每个章节的示例都位于一个浅的子目录中，以章节标题为名。这导致我偶尔会与遵循深层次方法的工具发生冲突。</p><h3 id="使用其他组件"><a href="#使用其他组件" class="headerlink" title="使用其他组件"></a>使用其他组件</h3><p>无论何时在程序中使用预先定义好的类，编译器都必须找到该类。最简单的情况下，该类存在于被调用的源代码文件中。此时我们使用该类 —— 即使该类在文件的后面才会被定义（Java 消除了所谓的“前向引用”问题）。而如果一个类位于其他文件中，又会怎样呢？你可能认为编译器应该足够智能去找到它，但这样是有问题的。想象一下，假如你要使用某个类，但目录中存在多个同名的类（可能用途不同）。或者更糟糕的是，假设你正在编写程序，在构建过程中，你想将某个新类添加到类库中，但却与已有的类名称冲突。</p><p>要解决此问题，你必须通过使用 <strong>import</strong> 关键字来告诉 Java 编译器具体要使用的类。<strong>import</strong> 指示编译器导入一个包，也就是一个类库（在其他语言中，一个库不仅包含类，还可能包括函数和数据，但请记住 Java 中的所有代码都必须写在类里）。大多数时候，我们都在使用 Java 标准库中的组件。有了这些构件，你就不必写一长串的反转域名。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure><p>上例可以告诉编译器使用位于标准库 <strong>util</strong> 下的 ArrayList 类。但是，<strong>util</strong> 中包含许多类，我们可以使用通配符 <code>*</code> 来导入其中部分类，而无需显式得逐一声明这些类。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><p>本书中的示例很小，为简单起见，我们通常会使用 <code>.*</code> 形式略过导入。然而，许多教程书籍都会要求程序员逐一导入每个类。</p><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>类是对象的外观及行为方式的描述。通常只有在使用 <code>new</code> 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。</p><ol><li><p>有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。</p></li><li><p>创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。</p></li></ol><p><strong>static</strong> 关键字（从 C++ 采用）就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例 。 即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。相反，对于普通的非静态字段和方法，我们必须要先创建一个对象并使用该对象来访问字段或方法，因为非静态字段和方法必须与特定对象关联 <sup><a href="#fn_6" id="reffn_6">6</a></sup> 。</p><p>一些面向对象的语言使用类数据（class data）和类方法（class method），表示静态数据和方法只是作为类，而不是类的某个特定对象而存在的。有时 Java 文献也使用这些术语。</p><p>我们可以在类的字段或方法前添加 <code>static</code> 关键字来表示这是一个静态字段或静态方法。 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，即使你创建了两个 <code>StaticTest</code> 对象，但是静态变量 <code>i</code> 仍只占一份存储空间。两个对象都会共享相同的变量 <code>i</code>。 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br></pre></td></tr></table></figure><p><code>st1.i</code> 和 <code>st2.i</code> 指向同一块存储空间，因此它们的值都是 47。引用静态变量有两种方法。在前面的示例中，我们通过一个对象来定位它，例如 <code>st2.i</code>。我们也可以通过类名直接引用它，这种方式对于非静态成员则不可行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticTest.i++;</span><br></pre></td></tr></table></figure><p><code>++</code> 运算符将会使变量结果 + 1。此时 <code>st1.i</code> 和 <code>st2.i</code> 的值都变成了 48。</p><p>使用类名直接引用静态变量是首选方法，因为它强调了变量的静态属性。类似的逻辑也适用于静态方法。我们可以通过对象引用静态方法，就像使用任何方法一样，也可以通过特殊的语法方式 <code>Classname.method()</code> 来直接调用静态字段或方法 <sup><a href="#fn_7" id="reffn_7">7</a></sup>。 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      StaticTest.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，<code>Incrementable</code> 的 <code>increment()</code> 方法通过 <code>++</code> 运算符将静态数据 <code>i</code> 加 1。我们依然可以先实例化对象再调用该方法。 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Incrementable sf = <span class="keyword">new</span> Incrementable();</span><br><span class="line">sf.increment();</span><br></pre></td></tr></table></figure><p>当然了，首选的方法是直接通过类来调用它。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Incrementable.increment()；</span><br></pre></td></tr></table></figure><p>相比非静态的对象，<code>static</code> 属性改变了数据创建的方式。同样，当 <code>static</code> 关键字修饰方法时，它允许我们无需创建对象就可以直接通过类的引用来调用该方法。正如我们所知，<code>static</code> 关键字的这些特性对于应用程序入口点的 <code>main()</code> 方法尤为重要。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>最后，我们开始编写第一个完整的程序。我们使用 Java 标准库中的 <strong>Date</strong> 类来展示一个字符串和日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objects/HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, it&#x27;s: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在本书中，所有代码示例的第一行都是注释行，其中包含文件的路径信息（比如本章的目录名是 <strong>objects</strong>），后跟文件名。我的工具可以根据这些信息自动提取和测试书籍的代码，你也可以通过参考第一行注释轻松地在 Github 库中找到对应的代码示例。</p><p>如果你想在代码中使用一些额外的类库，那么就必须在程序文件的开始处使用 <strong>import</strong> 关键字来导入它们。之所以说是额外的，因为有一些类库已经默认自动导入到每个文件里了。例如：<code>java.lang</code> 包。</p><p>现在打开你的浏览器在 <a href="https://www.oracle.com/">Oracle</a> 上查看文档。如果你还没有从 <a href="https://www.oracle.com/">Oracle</a> 网站上下载 JDK 文档，那现在就去 <sup><a href="#fn_8" id="reffn_8">8</a></sup> 。查看包列表，你会看到 Java 附带的所有不同的类库。</p><p>选择 <code>java.lang</code>，你会看到该库中所有类的列表。由于 <code>java.lang</code> 隐式包含在每个 Java 代码文件中，因此这些类是自动可用的。<code>java.lang</code> 类库中没有 <strong>Date</strong> 类，所以我们必须导入其他的类库(即 Date 所在的类库)。如果你不清楚某个类所在的类库或者想查看类库中所有的类，那么可以在 Java 文档中选择 “Tree” 查看。</p><p>现在，我们可以找到 Java 附带的每个类。使用浏览器的“查找”功能查找 <strong>Date</strong>，搜索结果中将会列出 <strong>java.util.Date</strong>，我们就知道了 <strong>Date</strong> 在 <strong>util</strong> 库中，所以必须导入 <strong>java.util.*</strong> 才能使用 <strong>Date</strong>。</p><p>如果你在文档中选择 <strong>java.lang</strong>，然后选择 <strong>System</strong>，你会看到 <strong>System</strong> 类中有几个字段，如果你选择了 <strong>out</strong>，你会发现它是一个静态的 <strong>PrintStream</strong> 对象。 所以，即使我们不使用 <strong>new</strong> 创建， <strong>out</strong> 对象就已经存在并可以使用。 <strong>out</strong> 对象可以执行的操作取决于它的类型： <strong>PrintStream</strong> ，其在文档中是一个超链接，如果单击该链接，我们将可以看到 <strong>PrintStream</strong> 对应的方法列表（更多详情，将在本书后面介绍）。 现在我们重点说的是 <strong>println()</strong> 这个方法。 它的作用是 “将信息输出到控制台，并以换行符结束”。既然如此，我们可以这样编码来输出信息到控制台。 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;A String of things&quot;</span>);</span><br></pre></td></tr></table></figure><p>每个 java 源文件中允许有多个类。同时，源文件的名称必须要和其中一个类名相同，否则编译器将会报错。每个独立的程序应该包含一个 <code>main()</code> 方法作为程序运行的入口。其方法签名和返回类型如下。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字 <strong>public</strong> 表示方法可以被外界访问到。（ 更多详情将在 <strong>隐藏实现</strong> 章节讲到）<br><strong>main()</strong> 方法的参数是一个 字符串（<strong>String</strong>） 数组。 参数 <strong>args</strong> 并没有在当前的程序中使用到，但是 Java 编译器强制要求必须要有， 这是因为它们被用于接收从命令行输入的参数。</p><p>下面我们来看一段有趣的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure><p>上面的示例中，我们创建了一个日期（<strong>Date</strong>）类型的对象并将其转化为字符串类型，输出到控制台中。 一旦这一行语句执行完毕，我们就不再需要该日期对象了。这时，Java 垃圾回收器就可以将其占用的内存回收，我们无需去主动清除它们。</p><p>查看 JDK 文档时，我们可以看到在 <strong>System</strong> 类下还有很多其他有用的方法（ Java 的牛逼之处还在于，它拥有一个庞大的标准库资源）。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objects/ShowProperties.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowProperties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.getProperties().list(System.out);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;user.name&quot;</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果(前 20 行):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java.runtime.name=Java(TM) SE Runtime Environment</span><br><span class="line">sun.boot.library.path=C:\Program</span><br><span class="line">Files\Java\jdk1.8.0_112\jr...</span><br><span class="line">java.vm.version=25.112-b15</span><br><span class="line">java.vm.vendor=Oracle Corporation</span><br><span class="line">java.vendor.url=http://java.oracle.com/</span><br><span class="line">path.separator=;</span><br><span class="line">java.vm.name=Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line">file.encoding.pkg=sun.io</span><br><span class="line">user.script=</span><br><span class="line">user.country=US</span><br><span class="line">sun.java.launcher=SUN_STANDARD</span><br><span class="line">sun.os.patch.level=</span><br><span class="line">java.vm.specification.name=Java Virtual Machine</span><br><span class="line">Specification</span><br><span class="line">user.dir=C:\Users\Bruce\Documents\GitHub\on-ja...</span><br><span class="line">java.runtime.version=1.8.0_112-b15</span><br><span class="line">java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment</span><br><span class="line">java.endorsed.dirs=C:\Program</span><br><span class="line">Files\Java\jdk1.8.0_112\jr...</span><br><span class="line">os.arch=amd64</span><br><span class="line">java.io.tmpdir=C:\Users\Bruce\AppData\Local\Temp\</span><br></pre></td></tr></table></figure><p><code>main()</code> 方法中的第一行会输出所有的系统字段，也就是环境信息。 <strong>list()</strong> 方法将结果发送给它的参数 <strong>System.out</strong>。在本书的后面，我们还会接触到将结果输出到其他地方，例如文件中。另外，我们还可以请求特定的字段。该例中我们使用到了 <strong>user.name</strong> 和 <strong>java.library.path</strong>。</p><h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>要编译和运行本书中的代码示例，首先必须具有 Java 编程环境。 第二章的示例中描述了安装过程。如果你遵循这些说明，那么你将会在不受 Oracle 的限制的条件下用到 Java 开发工具包（JDK）。如果你使用其他开发系统，请查看该系统的文档以确定如何编译和运行程序。 第二章还介绍了如何安装本书的示例。</p><p>移动到子目录 <strong>objects</strong> 下并键入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloDate.java</span><br></pre></td></tr></table></figure><p>此命令不应产生任何响应。如果我们收到任何类型的错误消息，则表示未正确安装 JDK，那就得检查这些问题。</p><p>若执行不报错的话，此时可以键入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloDate</span><br></pre></td></tr></table></figure><p>我们将会得到正确的日期输出。这是我们编译和运行本书中每个程序（包含 <code>main()</code> 方法）的过程 <sup><a href="#fn_9" id="reffn_9">9</a></sup>。此外，本书的源代码在根目录中也有一个名为 <strong>build.gradle</strong> 的文件，其中包含用于自动构建，测试和运行本书文件的 <strong>Gradle</strong> 配置。当你第一次运行 <code>gradlew</code> 命令时，<strong>Gradle</strong> 将自动安装（前提是已安装 Java）。</p><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><p>Java 编程语言编码规范（Code Conventions for the Java Programming Language）<sup><a href="#fn_10" id="reffn_10">10</a></sup> 要求类名的首字母大写。 如果类名是由多个单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllTheColorsOfTheRainbow</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时称这种命名风格叫“驼峰命名法”。对于几乎所有其他方法，字段（成员变量）和对象引用名都采用驼峰命名的方式，但是它们的首字母不需要大写。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllTheColorsOfTheRainbow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anIntegerRepresentingColors;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeTheHueOfTheColor</span><span class="params">(<span class="keyword">int</span> newHue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Oracle 的官方类库中，花括号的位置同样遵循和本书中上述示例相同的规范。</p><h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><p>本章向你展示了简单的 Java 程序编写以及该语言相关的基本概念。到目前为止，我们的示例都只是些简单的顺序执行。在接下来的两章里，我们将会接触到 Java 的一些基本操作符，以及如何去控制程序执行的流程。</p><blockquote id="fn_1"><sup>1</sup>. 这里可能有争议。有人说这是一个指针，但这假定了一个潜在的实现。此外，Java 引用的语法更类似于 C++ 引用而非指针。在 《Thinking in Java》 的第 1 版中，我发明了一个新术语叫“句柄”（handle），因为 C++ 引用和 Java 引用有一些重要的区别。作为一个从 C++ 的过来人，我不想混淆 Java 可能的最大受众 —— C++ 程序员。在《Thinking in Java》的第 2 版中，我认为“引用”（reference）是更常用的术语，从 C++ 转过来的人除了引用的术语之外，还有很多东西需要处理，所以他们不妨双脚都跳进去。但是，也有些人甚至不同意“引用”。在某书中我读到一个观点：Java 支持引用传递的说法是完全错误的，因为 Java 对象标识符（根据该作者）实际上是“对象引用”（object references），并且一切都是值传递。所以你不是通过引用传递，而是“通过值传递对象引用。人们可以质疑我的这种解释的准确性，但我认为我的方法简化了对概念的理解而又没对语言造成伤害（嗯，语言专家可能会说我骗你，但我会说我只是对此进行了适当的抽象。）<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 大多数微处理器芯片都有额外的高速缓冲存储器，但这是按照传统存储器而不是寄存器。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. 一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. 静态方法，我们很快就能接触到，它可以在没有对象的情况下直接被类调用。<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. 通常除了前面提到的“特殊”数据类型 boolean、 char、 byte、 short、 int、 long、 float 和 double。通常来说，传递对象就意味者传递对象的引用。<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. 静态方法在使用之前不需要创建对象，因此它们不能直接调用非静态的成员或方法（因为非静态成员和方法必须要先实例化为对象才可以被使用）。<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. 在某些情况下，它还为编译器提供了更好的优化可能。<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. 请注意，此文档未包含在 JDK 中;你必须单独下载才能获得它。<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. 对于本书中编译和运行命令行的每个程序，你可能还需要设置 CLASSPATH 。<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. 为了保持本书的代码排版紧凑，我并没完全遵守规范，但我尽量会做到符合 Java 标准。<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><h1 id="第-4-章-运算符"><a href="#第-4-章-运算符" class="headerlink" title="第 4 章 运算符"></a>第 4 章 运算符</h1><blockquote><p>运算符操纵数据。</p></blockquote><p>Java 是从 C++ 的基础上做了一些改进和简化发展而成的。对于 C/C++ 程序员来说，Java 的运算符并不陌生。如果你已了解 C 或 C++，大可以跳过本章和下一章，直接阅读 Java 与 C/C++ 不同的地方。</p><p>如果理解这两章的内容对你来说还有点困难，那么我推荐你先了解下 《Thinking in C》 再继续后面的学习。 这本书现在可以在 <a href="http://www.OnJava8.com]">www.OnJava8.com</a> 上免费下载。它的内容包含音频讲座、幻灯片、练习和解答，专门用于帮助你快速掌握学习 Java 所需的基础知识。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>运算符接受一个或多个参数并生成新值。这个参数与普通方法调用的形式不同，但效果是相同的。加法 <code>+</code>、减法 <code>-</code>、乘法 <code>*</code>、除法 <code>/</code> 以及赋值 <code>=</code> 在任何编程语言中的工作方式都是类似的。所有运算符都能根据自己的运算对象生成一个值。除此以外，一些运算符可改变运算对象的值，这叫作“副作用”（<strong>Side Effect</strong>）。运算符最常见的用途就是修改自己的运算对象，从而产生副作用。但要注意生成的值亦可由没有副作用的运算符生成。</p><p>几乎所有运算符都只能操作基本类型（Primitives）。唯一的例外是 <code>=</code>、<code>==</code> 和 <code>!=</code>，它们能操作所有对象（这也是令人混淆的一个地方）。除此以外，<strong>String</strong> 类支持 <code>+</code> 和 <code>+=</code>。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>运算符的优先级决定了存在多个运算符时一个表达式各部分的运算顺序。Java 对运算顺序作出了特别的规定。其中，最简单的规则就是乘法和除法在加法和减法之前完成。程序员经常都会忘记其他优先级规则，所以应该用括号明确规定运算顺序。代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Precedence.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Precedence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x + y - <span class="number">2</span>/<span class="number">2</span> + z; <span class="comment">// [1]</span></span><br><span class="line">        <span class="keyword">int</span> b = x + (y - <span class="number">2</span>)/(<span class="number">2</span> + z); <span class="comment">// [2]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">b = 1</span><br></pre></td></tr></table></figure><p>这些语句看起来大致相同，但从输出中我们可以看出它们具有非常不同的含义，具体取决于括号的使用。</p><p>我们注意到，在 <code>System.out.println()</code> 语句中使用了 <code>+</code> 运算符。 但是在这里 <code>+</code> 代表的意思是字符串连接符。编译器会将 <code>+</code> 连接的非字符串尝试转换为字符串。上例中的输出结果说明了 a 和 b 都已经被转化成了字符串。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>运算符的赋值是由符号 <code>=</code> 完成的。它代表着获取 <code>=</code> 右边的值并赋给左边的变量。右边可以是任何常量、变量或者可产生一个返回值的表达式。但左边必须是一个明确的、已命名的变量。也就是说，必须要有一个物理的空间来存放右边的值。举个例子来说，可将一个常数赋给一个变量（A = 4），但不可将任何东西赋给一个常数（比如不能 4 = A）。</p><p>基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。举个例子，a = b ，如果 b 是基本类型，那么赋值操作会将 b 的值复制一份给变量 a， 此后若 a 的值发生改变是不会影响到 b 的。作为一名程序员，这应该成为我们的常识。</p><p>如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Assignment.java</span></span><br><span class="line"><span class="comment">// Assignment with objects is a bit tricky</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assignment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tank t1 = <span class="keyword">new</span> Tank();</span><br><span class="line">        Tank t2 = <span class="keyword">new</span> Tank();</span><br><span class="line">        t1.level = <span class="number">9</span>;</span><br><span class="line">        t2.level = <span class="number">47</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1: t1.level: &quot;</span> + t1.level +</span><br><span class="line">            <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        t1 = t2;</span><br><span class="line">        System.out.println(<span class="string">&quot;2: t1.level: &quot;</span> + t1.level +</span><br><span class="line">            <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        t1.level = <span class="number">27</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3: t1.level: &quot;</span> + t1.level +</span><br><span class="line">            <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1: t1.level: 9, t2.level: 47</span><br><span class="line">2: t1.level: 47, t2.level: 47</span><br><span class="line">3: t1.level: 27, t2.level: 27</span><br></pre></td></tr></table></figure><p>这是一个简单的 <code>Tank</code> 类，在 <code>main()</code> 方法创建了两个实例对象。 两个对象的 <code>level</code> 属性分别被赋予不同的值。 然后，t2 的值被赋予给 t1。在许多编程语言里，预期的结果是 t1 和 t2 的值会一直相对独立。但是，在 Java 中，由于赋予的只是对象的引用，改变 t1 也就改变了 t2。 这是因为 t1 和 t2 此时指向的是堆中同一个对象。（t1 原始对象的引用在 t2 赋值给其时丢失，它引用的对象会在垃圾回收时被清理）。</p><p>这种现象通常称为别名（aliasing），这是 Java 处理对象的一种基本方式。但是假若你不想出现这里的别名引起混淆的话，你可以这么做。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.level = t2.level;</span><br></pre></td></tr></table></figure><p>较之前的做法，这样做保留了两个单独的对象，而不是丢弃一个并将 t1 和 t2 绑定到同一个对象。但是这样的操作有点违背 Java 的设计原则。对象的赋值是个需要重视的环节，否则你可能收获意外的“惊喜”。</p><h3 id="方法调用中的别名现象"><a href="#方法调用中的别名现象" class="headerlink" title="方法调用中的别名现象"></a>方法调用中的别名现象</h3><p>当我们把对象传递给方法时，会发生别名现象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/PassObject.java</span></span><br><span class="line"><span class="comment">// 正在传递的对象可能不是你之前使用的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Letter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Letter y)</span> </span>&#123;</span><br><span class="line">        y.c = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Letter x = <span class="keyword">new</span> Letter();</span><br><span class="line">        x.c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1: x.c: &quot;</span> + x.c);</span><br><span class="line">        f(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;2: x.c: &quot;</span> + x.c);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: x.c: a</span><br><span class="line">2: x.c: z</span><br></pre></td></tr></table></figure><p>在许多编程语言中，方法 <code>f()</code> 似乎会在内部复制其参数 <strong>Letter y</strong>。但是一旦传递了一个引用，那么实际上 <code>y.c =&#39;z&#39;;</code> 是在方法 <code>f()</code> 之外改变对象。别名现象以及其解决方案是个复杂的问题，在附录中有包含：<a href="./Appendix-Passing-and-Returning-Objects.md">对象传递和返回</a>。意识到这一点，我们可以警惕类似的陷阱。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>Java 的基本算术运算符与其他大多编程语言是相同的。其中包括加号 <code>+</code>、减号 <code>-</code>、除号 <code>/</code>、乘号 <code>*</code> 以及取模 <code>%</code>（从整数除法中获得余数）。整数除法会直接砍掉小数，而不是进位。</p><p>Java 也用一种与 C++ 相同的简写形式同时进行运算和赋值操作，由运算符后跟等号表示，并且与语言中的所有运算符一致（只要有意义）。 可用 x += 4 来表示：将 x 的值加上 4 的结果再赋值给 x。更多代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/MathOps.java</span></span><br><span class="line"><span class="comment">// The mathematical operators</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathOps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a seeded random number generator:</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">// Choose value from 1 to 100:</span></span><br><span class="line">        j = rand.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;j : &quot;</span> + j);</span><br><span class="line">        k = rand.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;k : &quot;</span> + k);</span><br><span class="line">        i = j + k;</span><br><span class="line">        System.out.println(<span class="string">&quot;j + k : &quot;</span> + i);</span><br><span class="line">        i = j - k;</span><br><span class="line">        System.out.println(<span class="string">&quot;j - k : &quot;</span> + i);</span><br><span class="line">        i = k / j;</span><br><span class="line">        System.out.println(<span class="string">&quot;k / j : &quot;</span> + i);</span><br><span class="line">        i = k * j;</span><br><span class="line">        System.out.println(<span class="string">&quot;k * j : &quot;</span> + i);</span><br><span class="line">        i = k % j;</span><br><span class="line">        System.out.println(<span class="string">&quot;k % j : &quot;</span> + i);</span><br><span class="line">        j %= k;</span><br><span class="line">        System.out.println(<span class="string">&quot;j %= k : &quot;</span> + j);</span><br><span class="line">        <span class="comment">// 浮点运算测试</span></span><br><span class="line">        <span class="keyword">float</span> u, v, w; <span class="comment">// Applies to doubles, too</span></span><br><span class="line">        v = rand.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">&quot;v : &quot;</span> + v);</span><br><span class="line">        w = rand.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">&quot;w : &quot;</span> + w);</span><br><span class="line">        u = v + w;</span><br><span class="line">        System.out.println(<span class="string">&quot;v + w : &quot;</span> + u);</span><br><span class="line">        u = v - w;</span><br><span class="line">        System.out.println(<span class="string">&quot;v - w : &quot;</span> + u);</span><br><span class="line">        u = v * w;</span><br><span class="line">        System.out.println(<span class="string">&quot;v * w : &quot;</span> + u);</span><br><span class="line">        u = v / w;</span><br><span class="line">        System.out.println(<span class="string">&quot;v / w : &quot;</span> + u);</span><br><span class="line">        <span class="comment">// 下面的操作同样适用于 char,</span></span><br><span class="line">        <span class="comment">// byte, short, int, long, and double:</span></span><br><span class="line">        u += v;</span><br><span class="line">        System.out.println(<span class="string">&quot;u += v : &quot;</span> + u);</span><br><span class="line">        u -= v;</span><br><span class="line">        System.out.println(<span class="string">&quot;u -= v : &quot;</span> + u);</span><br><span class="line">        u *= v;</span><br><span class="line">        System.out.println(<span class="string">&quot;u *= v : &quot;</span> + u);</span><br><span class="line">        u /= v;</span><br><span class="line">        System.out.println(<span class="string">&quot;u /= v : &quot;</span> + u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">j : 59</span><br><span class="line">k : 56</span><br><span class="line">j + k : 115</span><br><span class="line">j - k : 3</span><br><span class="line">k / j : 0</span><br><span class="line">k * j : 3304</span><br><span class="line">k % j : 56</span><br><span class="line">j %= k : 3</span><br><span class="line">v : 0.5309454</span><br><span class="line">w : 0.0534122</span><br><span class="line">v + w : 0.5843576</span><br><span class="line">v - w : 0.47753322</span><br><span class="line">v * w : 0.028358962</span><br><span class="line">v / w : 9.940527</span><br><span class="line">u += v : 10.471473</span><br><span class="line">u -= v : 9.940527</span><br><span class="line">u *= v : 5.2778773</span><br><span class="line">u /= v : 9.940527</span><br></pre></td></tr></table></figure><p>为了生成随机数字，程序首先创建一个 <strong>Random</strong> 对象。不带参数的 <strong>Random</strong> 对象会利用当前的时间用作随机数生成器的“种子”（seed），从而为程序的每次执行生成不同的输出。在本书的示例中，重要的是每个示例末尾的输出尽可能一致，以便可以使用外部工具进行验证。所以我们通过在创建 <strong>Random</strong> 对象时提供种子（随机数生成器的初始化值，其始终为特定种子值产生相同的序列），让程序每次执行都生成相同的随机数，如此以来输出结果就是可验证的 <sup><a href="#fn_1" id="reffn_1">1</a></sup>。 若需要生成随机值，可删除代码示例中的种子参数。该对象通过调用方法 <code>nextInt()</code> 和 <code>nextFloat()</code>（还可以调用 <code>nextLong()</code> 或 <code>nextDouble()</code>），使用 <strong>Random</strong> 对象生成许多不同类型的随机数。<code>nextInt()</code> 的参数设置生成的数字的上限，下限为零，为了避免零除的可能性，结果偏移 1。</p><h3 id="一元加减运算符"><a href="#一元加减运算符" class="headerlink" title="一元加减运算符"></a>一元加减运算符</h3><p>一元加 <code>+</code> 减 <code>-</code> 运算符的操作和二元是相同的。编译器可自动识别使用何种方式解析运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = -a;</span><br></pre></td></tr></table></figure><p>上例的代码表意清晰，编译器可正确识别。下面再看一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = a * -b;</span><br></pre></td></tr></table></figure><p>虽然编译器可以正确的识别，但是程序员可能会迷惑。为了避免混淆，推荐下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = a * (-b);</span><br></pre></td></tr></table></figure><p>一元减号可以得到数据的负值。一元加号的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为 <strong>int</strong> 类型。</p><h2 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h2><p>和 C 语言类似，Java 提供了许多快捷运算方式。快捷运算可使代码可读性，可写性都更强。其中包括递增 <code>++</code> 和递减 <code>--</code>，意为“增加或减少一个单位”。举个例子来说，假设 a 是一个 <strong>int</strong> 类型的值，则表达式 <code>++a</code> 就等价于 <code>a = a + 1</code>。 递增和递减运算符不仅可以修改变量，还可以生成变量的值。</p><p>每种类型的运算符，都有两个版本可供选用；通常将其称为“前缀”和“后缀”。“前递增”表示 <code>++</code> 运算符位于变量或表达式的前面；而“后递增”表示 <code>++</code> 运算符位于变量的后面。类似地，“前递减”意味着 <code>--</code> 运算符位于变量的前面；而“后递减”意味着 <code>--</code> 运算符位于变量的后面。对于前递增和前递减（如 <code>++a</code> 或 <code>--a</code>），会先执行递增/减运算，再返回值。而对于后递增和后递减（如 <code>a++</code> 或 <code>a--</code>），会先返回值，再执行递增/减运算。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/AutoInc.java</span></span><br><span class="line"><span class="comment">// 演示 ++ 和 -- 运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoInc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;++i: &quot;</span> + ++i); <span class="comment">// 前递增</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i++: &quot;</span> + i++); <span class="comment">// 后递增</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;--i: &quot;</span> + --i); <span class="comment">// 前递减</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i--: &quot;</span> + i--); <span class="comment">// 后递减</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i: 1</span><br><span class="line">++i: 2</span><br><span class="line">i++: 2</span><br><span class="line">i: 3</span><br><span class="line">--i: 2</span><br><span class="line">i--: 2</span><br><span class="line">i: 1</span><br></pre></td></tr></table></figure><p>对于前缀形式，我们将在执行递增/减操作后获取值；使用后缀形式，我们将在执行递增/减操作之前获取值。它们是唯一具有“副作用”的运算符（除那些涉及赋值的以外） —— 它们修改了操作数的值。</p><p>C++ 名称来自于递增运算符，暗示着“比 C 更进一步”。在早期的 Java 演讲中，<em>Bill Joy</em>（Java 作者之一）说“<strong>Java = C++ —</strong>”（C++ 减减），意味着 Java 在 C++ 的基础上减少了许多不必要的东西，因此语言更简单。随着进一步地学习，我们会发现 Java 的确有许多地方相对 C++ 来说更简便，但是在其他方面，难度并不会比 C++ 小多少。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符会通过产生一个布尔（<strong>boolean</strong>）结果来表示操作数之间的关系。如果关系为真，则结果为 <strong>true</strong>，如果关系为假，则结果为 <strong>false</strong>。关系运算符包括小于 <code>&lt;</code>，大于 <code>&gt;</code>，小于或等于 <code>&lt;=</code>，大于或等于 <code>&gt;=</code>，等于 <code>==</code> 和不等于 <code>！=</code>。<code>==</code> 和 <code>!=</code> 可用于所有基本类型，但其他运算符不能用于基本类型 <strong>boolean</strong>，因为布尔值只能表示 <strong>true</strong> 或 <strong>false</strong>，所以比较它们之间的“大于”或“小于”没有意义。</p><h3 id="测试对象等价"><a href="#测试对象等价" class="headerlink" title="测试对象等价"></a>测试对象等价</h3><p>关系运算符 <code>==</code> 和 <code>!=</code> 同样适用于所有对象之间的比较运算，但它们比较的内容却经常困扰 Java 的初学者。下面是代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Equivalence.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer n1 = <span class="number">47</span>;</span><br><span class="line">        Integer n2 = <span class="number">47</span>;</span><br><span class="line">        System.out.println(n1 == n2);</span><br><span class="line">        System.out.println(n1 != n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>表达式 <code>System.out.println(n1 == n2)</code> 将会输出比较的结果。因为两个 <strong>Integer</strong> 对象相同，所以先输出 <strong>true</strong>，再输出 <strong>false</strong>。但是，尽管对象的内容一样，对象的引用却不一样。<code>==</code> 和 <code>!=</code> 比较的是对象引用，所以输出实际上应该是先输出 <strong>false</strong>，再输出 <strong>true</strong>（译者注：如果你把 47 改成 128，那么打印的结果就是这样，因为 Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 <code>==</code> 和 <code>!=</code> 比较也能能到正确的结果，但是不推荐用关系运算符比较，具体见 JDK 中的 Integer 类源码）。</p><p>那么怎么比较两个对象的内容是否相同呢？你必须使用所有对象（不包括基本类型）中都存在的 <code>equals()</code> 方法，下面是如何使用 <code>equals()</code> 方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/EqualsMethod.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer n1 = <span class="number">47</span>;</span><br><span class="line">        Integer n2 = <span class="number">47</span>;</span><br><span class="line">        System.out.println(n1.equals(n2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>上例的结果看起来是我们所期望的。但其实事情并非那么简单。下面我们来创建自己的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/EqualsMethod2.java</span></span><br><span class="line"><span class="comment">// 默认的 equals() 方法没有比较内容</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsMethod2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Value v1 = <span class="keyword">new</span> Value();</span><br><span class="line">        Value v2 = <span class="keyword">new</span> Value();</span><br><span class="line">        v1.i = v2.i = <span class="number">100</span>;</span><br><span class="line">        System.out.println(v1.equals(v2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>上例的结果再次令人困惑：结果是 <strong>false</strong>。原因： <code>equals()</code> 的默认行为是比较对象的引用而非具体内容。因此，除非你在新类中覆写 <code>equals()</code> 方法，否则我们将获取不到想要的结果。不幸的是，在学习 <a href="./08-Reuse.md">复用</a>（<strong>Reuse</strong>） 章节后我们才能接触到“覆写”（<strong>Override</strong>），并且直到 <a href="./Appendix-Collection-Topics.md">附录:集合主题</a>，才能知道定义 <code>equals()</code> 方法的正确方式，但是现在明白 <code>equals()</code> 行为方式也可能为你节省一些时间。</p><p>大多数 Java 库类通过覆写 <code>equals()</code> 方法比较对象的内容而不是其引用。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>每个逻辑运算符 <code>&amp;&amp;</code> （<strong>AND</strong>）、<code>||</code>（<strong>OR</strong>）和 <code>!</code>（<strong>非</strong>）根据参数的逻辑关系生成布尔值 <code>true</code> 或 <code>false</code>。下面的代码示例使用了关系运算符和逻辑运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Bool.java</span></span><br><span class="line"><span class="comment">// 关系运算符和逻辑运算符</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">int</span> i = rand.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> j = rand.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">        System.out.println(<span class="string">&quot;i &gt; j is &quot;</span> + (i &gt; j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i &lt; j is &quot;</span> + (i &lt; j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i &gt;= j is &quot;</span> + (i &gt;= j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i &lt;= j is &quot;</span> + (i &lt;= j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i == j is &quot;</span> + (i == j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i != j is &quot;</span> + (i != j));</span><br><span class="line">        <span class="comment">// 将 int 作为布尔处理不是合法的 Java 写法</span></span><br><span class="line">        <span class="comment">//- System.out.println(&quot;i &amp;&amp; j is &quot; + (i &amp;&amp; j));</span></span><br><span class="line">        <span class="comment">//- System.out.println(&quot;i || j is &quot; + (i || j));</span></span><br><span class="line">        <span class="comment">//- System.out.println(&quot;!i is &quot; + !i);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;(i &lt; 10) &amp;&amp; (j &lt; 10) is &quot;</span></span><br><span class="line">        + ((i &lt; <span class="number">10</span>) &amp;&amp; (j &lt; <span class="number">10</span>)) );</span><br><span class="line">        System.out.println(<span class="string">&quot;(i &lt; 10) || (j &lt; 10) is &quot;</span></span><br><span class="line">        + ((i &lt; <span class="number">10</span>) || (j &lt; <span class="number">10</span>)) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i = 58</span><br><span class="line">j = 55</span><br><span class="line">i &gt; j is true</span><br><span class="line">i &lt; j is false</span><br><span class="line">i &gt;= j is true</span><br><span class="line">i &lt;= j is false</span><br><span class="line">i == j is false</span><br><span class="line">i != j is true</span><br><span class="line">(i &lt; 10) &amp;&amp; (j &lt; 10) is false</span><br><span class="line">(i &lt; 10) || (j &lt; 10) is false</span><br></pre></td></tr></table></figure><p>在 Java 逻辑运算中，我们不能像 C/C++ 那样使用非布尔值， 而仅能使用 <strong>AND</strong>、 <strong>OR</strong>、 <strong>NOT</strong>。上面的例子中，我们将使用非布尔值的表达式注释掉了（你可以看到表达式前面是 //-）。但是，后续的表达式使用关系比较生成布尔值，然后对结果使用了逻辑运算。请注意，如果在预期为 <strong>String</strong> 类型的位置使用 <strong>boolean</strong> 类型的值，则结果会自动转为适当的文本格式（即 “true” 或 “false” 字符串）。</p><p>我们可以将前一个程序中 <strong>int</strong> 的定义替换为除 <strong>boolean</strong> 之外的任何其他基本数据类型。但请注意，<strong>float</strong> 类型的数值比较非常严格，只要两个数字的最小位不同则两个数仍然不相等；只要数字最小位是大于 0 的，那么它就不等于 0。</p><h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>逻辑运算符支持一种称为“短路”（short-circuiting）的现象。整个表达式会在运算到可以明确结果时就停止并返回结果，这意味着该逻辑表达式的后半部分不会被执行到。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators / ShortCircuit.java</span></span><br><span class="line"><span class="comment">// 逻辑运算符的短路行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCircuit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1(&quot;</span> + val + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + (val &lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2(&quot;</span> + val + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + (val &lt; <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test3(&quot;</span> + val + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + (val &lt; <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = test1(<span class="number">0</span>) &amp;&amp; test2(<span class="number">2</span>) &amp;&amp; test3(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;expression is &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test1(0)</span><br><span class="line">result: true</span><br><span class="line">test2(2)</span><br><span class="line">result: false</span><br><span class="line">expression is false</span><br></pre></td></tr></table></figure><p>每个测试都对参数执行比较并返回 <code>true</code> 或 <code>false</code>。同时控制台也会在方法执行时打印他们的执行状态。 下面的表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test1（<span class="number">0</span>）&amp;&amp; test2（<span class="number">2</span>）&amp;&amp; test3（<span class="number">2</span>）</span><br></pre></td></tr></table></figure><p>可能你的预期是程序会执行 3 个 <strong>test</strong> 方法并返回。我们来分析一下：第一个方法的结果返回 <code>true</code>，因此表达式会继续走下去。紧接着，第二个方法的返回结果是 <code>false</code>。这就代表这整个表达式的结果肯定为 <code>false</code>，所以就没有必要再判断剩下的表达式部分了。</p><p>所以，运用“短路”可以节省部分不必要的运算，从而提高程序潜在的性能。</p><h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><p>通常，当我们向程序中插入一个字面值常量（<strong>Literal</strong>）时，编译器会确切地识别它的类型。当类型不明确时，必须辅以字面值常量关联来帮助编译器识别。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Literals.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Literals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0x2f</span>; <span class="comment">// 16进制 (小写)</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;i1: &quot;</span> + Integer.toBinaryString(i1));</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0X2F</span>; <span class="comment">// 16进制 (大写)</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;i2: &quot;</span> + Integer.toBinaryString(i2));</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">0177</span>; <span class="comment">// 8进制 (前导0)</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;i3: &quot;</span> + Integer.toBinaryString(i3));</span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0xffff</span>; <span class="comment">// 最大 char 型16进制值</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;c: &quot;</span> + Integer.toBinaryString(c));</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">0x7f</span>; <span class="comment">// 最大 byte 型16进制值  10101111;</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;b: &quot;</span> + Integer.toBinaryString(b));</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">0x7fff</span>; <span class="comment">// 最大 short 型16进制值</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;s: &quot;</span> + Integer.toBinaryString(s));</span><br><span class="line">        <span class="keyword">long</span> n1 = <span class="number">200L</span>; <span class="comment">// long 型后缀</span></span><br><span class="line">        <span class="keyword">long</span> n2 = <span class="number">200l</span>; <span class="comment">// long 型后缀 (容易与数值1混淆)</span></span><br><span class="line">        <span class="keyword">long</span> n3 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 7 二进制字面值常量:</span></span><br><span class="line">        <span class="keyword">byte</span> blb = (<span class="keyword">byte</span>)<span class="number">0b00110101</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;blb: &quot;</span> + Integer.toBinaryString(blb));</span><br><span class="line">        <span class="keyword">short</span> bls = (<span class="keyword">short</span>)<span class="number">0B0010111110101111</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;bls: &quot;</span> + Integer.toBinaryString(bls));</span><br><span class="line">        <span class="keyword">int</span> bli = <span class="number">0b00101111101011111010111110101111</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;bli: &quot;</span> + Integer.toBinaryString(bli));</span><br><span class="line">        <span class="keyword">long</span> bll = <span class="number">0b00101111101011111010111110101111</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;bll: &quot;</span> + Long.toBinaryString(bll));</span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = <span class="number">1F</span>; <span class="comment">// float 型后缀</span></span><br><span class="line">        <span class="keyword">float</span> f3 = <span class="number">1f</span>; <span class="comment">// float 型后缀</span></span><br><span class="line">        <span class="keyword">double</span> d1 = <span class="number">1d</span>; <span class="comment">// double 型后缀</span></span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">1D</span>; <span class="comment">// double 型后缀</span></span><br><span class="line">        <span class="comment">// (long 型的字面值同样适用于十六进制和8进制 )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i1: 101111</span><br><span class="line">i2: 101111</span><br><span class="line">i3: 1111111</span><br><span class="line">c: 1111111111111111</span><br><span class="line">b: 1111111</span><br><span class="line">s: 111111111111111</span><br><span class="line">blb: 110101</span><br><span class="line">bls: 10111110101111</span><br><span class="line">bli: 101111101011111010111110101111</span><br><span class="line">bll: 101111101011111010111110101111</span><br></pre></td></tr></table></figure><p>在文本值的后面添加字符可以让编译器识别该文本值的类型。对于 <strong>Long</strong> 型数值，结尾使用大写 <code>L</code> 或小写 <code>l</code> 皆可（不推荐使用 <code>l</code>，因为容易与阿拉伯数值 1 混淆）。大写 <code>F</code> 或小写 <code>f</code> 表示 <strong>float</strong> 浮点数。大写 <code>D</code> 或小写 <code>d</code> 表示 <strong>double</strong> 双精度。</p><p>十六进制（以 16 为基数），适用于所有整型数据类型，由前导 <code>0x</code> 或 <code>0X</code> 表示，后跟 0-9 或 a-f （大写或小写）。如果我们在初始化某个类型的数值时，赋值超出其范围，那么编译器会报错（不管值的数字形式如何）。在上例的代码中，<strong>char</strong>、<strong>byte</strong> 和 <strong>short</strong> 的值已经是最大了。如果超过这些值，编译器将自动转型为 <strong>int</strong>，并且提示我们需要声明强制转换（强制转换将在本章后面定义），意味着我们已越过该类型的范围界限。</p><p>八进制（以 8 为基数）由 0~7 之间的数字和前导零 <code>0</code> 表示。</p><p>Java 7 引入了二进制的字面值常量，由前导 <code>0b</code> 或 <code>0B</code> 表示，它可以初始化所有的整数类型。</p><p>使用整型数值类型时，显示其二进制形式会很有用。在 Long 型和 Integer 型中这很容易实现，调用其静态的 <code>toBinaryString()</code> 方法即可。 但是请注意，若将较小的类型传递给 <strong>Integer.</strong><code>tobinarystring()</code> 时，类型将自动转换为 <strong>int</strong>。</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>Java 7 中有一个深思熟虑的补充：我们可以在数字字面量中包含下划线 <code>_</code>，以使结果更清晰。这对于大数值的分组特别有用。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Underscores.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Underscores</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">341_435_936.445_667</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        <span class="keyword">int</span> bin = <span class="number">0b0010_1111_1010_1111_1010_1111_1010_1111</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(bin));</span><br><span class="line">        System.out.printf(<span class="string">&quot;%x%n&quot;</span>, bin); <span class="comment">// [1]</span></span><br><span class="line">        <span class="keyword">long</span> hex = <span class="number">0x7f_e9_b7_aa</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%x%n&quot;</span>, hex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.41435936445667E8</span><br><span class="line">101111101011111010111110101111</span><br><span class="line">2fafafaf</span><br><span class="line">7fe9b7aa</span><br></pre></td></tr></table></figure><p>下面是合理使用的规则：</p><ol><li>仅限单 <code>_</code>，不能多条相连。</li><li>数值开头和结尾不允许出现 <code>_</code>。</li><li><code>F</code>、<code>D</code> 和 <code>L</code>的前后禁止出现 <code>_</code>。</li><li>二进制前导 <code>b</code> 和 十六进制 <code>x</code> 前后禁止出现 <code>_</code>。</li></ol><p>[1] 注意 <code>％n</code>的使用。熟悉 C 风格的程序员可能习惯于看到 <code>\n</code> 来表示换行符。问题在于它给你的是一个“Unix 风格”的换行符。此外，如果我们使用的是 Windows，则必须指定 <code>\r\n</code>。这种差异的包袱应该由编程语言来解决。这就是 Java 用 <code>％n</code> 实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用 <code>System.out.printf()</code> 或 <code>System.out.format()</code> 时。对于 <code>System.out.println()</code>，我们仍然必须使用 <code>\n</code>；如果你使用 <code>％n</code>，<code>println()</code> 只会输出 <code>％n</code> 而不是换行符。</p><h3 id="指数计数法"><a href="#指数计数法" class="headerlink" title="指数计数法"></a>指数计数法</h3><p>指数总是采用一种我认为很不直观的记号方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Exponents.java</span></span><br><span class="line"><span class="comment">// &quot;e&quot; 表示 10 的几次幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exponents</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 大写 E 和小写 e 的效果相同:</span></span><br><span class="line">        <span class="keyword">float</span> expFloat = <span class="number">1.39e-43f</span>;</span><br><span class="line">        expFloat = <span class="number">1.39E-43f</span>;</span><br><span class="line">        System.out.println(expFloat);</span><br><span class="line">        <span class="keyword">double</span> expDouble = <span class="number">47e47d</span>; <span class="comment">// &#x27;d&#x27; 是可选的</span></span><br><span class="line">        <span class="keyword">double</span> expDouble2 = <span class="number">47e47</span>; <span class="comment">// 自动转换为 double</span></span><br><span class="line">        System.out.println(expDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.39E-43</span><br><span class="line">4.7E48</span><br></pre></td></tr></table></figure><p>在科学与工程学领域，<strong>e</strong> 代表自然对数的基数，约等于 2.718 （Java 里用一种更精确的 <strong>double</strong> 值 <strong>Math.E</strong> 来表示自然对数）。指数表达式 “1.39 x e-43”，意味着 “1.39 × 2.718 的 -43 次方”。然而，自 FORTRAN 语言发明后，人们自然而然地觉得 e 代表 “10 的几次幂”。这种做法显得颇为古怪，因为 FORTRAN 最初是为科学与工程领域设计的。</p><p>理所当然，它的设计者应对这样的混淆概念持谨慎态度 <sup><a href="#fn_2" id="reffn_2">2</a></sup>。但不管怎样，这种特别的表达方法在 C，C++ 以及现在的 Java 中顽固地保留下来了。所以倘若习惯 e 作为自然对数的基数使用，那么在 Java 中看到类似“1.39e-43f”这样的表达式时，请转换你的思维，从程序设计的角度思考它；它真正的含义是 “1.39 × 10 的 -43 次方”。</p><p>注意如果编译器能够正确地识别类型，就不必使用后缀字符。对于下述语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> n3 = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>它并不存在含糊不清的地方，所以 200 后面的 L 大可省去。然而，对于下述语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f4 = <span class="number">1e-43f</span>; <span class="comment">//10 的幂数</span></span><br></pre></td></tr></table></figure><p>编译器通常会将指数作为 <strong>double</strong> 类型来处理，所以假若没有这个后缀字符 <code>f</code>，编译器就会报错，提示我们应该将 <strong>double</strong> 型转换成 <strong>float</strong> 型。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符允许我们操作一个整型数字中的单个二进制位。位运算符会对两个整数对应的位执行布尔代数，从而产生结果。</p><p>位运算源自 C 语言的底层操作。我们经常要直接操纵硬件，频繁设置硬件寄存器内的二进制位。Java 的设计初衷是电视机顶盒嵌入式开发，所以这种底层的操作仍被保留了下来。但是，你可能不会使用太多位运算。</p><p>若两个输入位都是 1，则按位“与运算符” <code>&amp;</code> 运算后结果是 1，否则结果是 0。若两个输入位里至少有一个是 1，则按位“或运算符” <code>|</code> 运算后结果是 1；只有在两个输入位都是 0 的情况下，运算结果才是 0。若两个输入位的某一个是 1，另一个不是 1，那么按位“异或运算符” <code>^</code> 运算后结果才是 1。按位“非运算符” <code>~</code> 属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。按位非运算后结果与输入位相反。例如输入 0，则输出 1；输入 1，则输出 0。</p><p>位运算符和逻辑运算符都使用了同样的字符，只不过数量不同。位短，所以位运算符只有一个字符。位运算符可与等号 <code>=</code> 联合使用以接收结果及赋值：<code>&amp;=</code>，<code>|=</code> 和 <code>^=</code> 都是合法的（由于 <code>~</code> 是一元运算符，所以不可与 <code>=</code> 联合使用）。</p><p>我们将 <strong>Boolean</strong> 类型被视为“单位值”（one-bit value），所以它多少有些独特的地方。我们可以对 boolean 型变量执行与、或、异或运算，但不能执行非运算（大概是为了避免与逻辑“非”混淆）。对于布尔值，位运算符具有与逻辑运算符相同的效果，只是它们不会中途“短路”。此外，针对布尔值进行的位运算为我们新增了一个“异或”逻辑运算符，它并未包括在逻辑运算符的列表中。在移位表达式中，禁止使用布尔值，原因将在下面解释。</p><h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。左移位运算符 <code>&lt;&lt;</code> 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。右移位运算符 <code>&gt;&gt;</code> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。Java 也添加了一种“不分正负”的右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。这一运算符是 C/C++ 没有的。</p><p>如果移动 <strong>char</strong>、<strong>byte</strong> 或 <strong>short</strong>，则会在移动发生之前将其提升为 <strong>int</strong>，结果为 <strong>int</strong>。仅使用右侧的 5 个低阶位。这可以防止我们移动超过 <strong>int</strong> 范围的位数。若对一个 <strong>long</strong> 值进行处理，最后得到的结果也是 <strong>long</strong>。</p><p>移位可以与等号 <code>&lt;&lt;=</code> 或 <code>&gt;&gt;=</code> 或 <code>&gt;&gt;&gt;=</code> 组合使用。左值被替换为其移位运算后的值。但是，问题来了，当无符号右移与赋值相结合时，若将其与 <strong>byte</strong> 或 <strong>short</strong> 一起使用的话，则结果错误。取而代之的是，它们被提升为 <strong>int</strong> 型并右移，但在重新赋值时被截断。在这种情况下，结果为 -1。下面是代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/URShift.java</span></span><br><span class="line"><span class="comment">// 测试无符号右移</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URShift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line">        i &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line">        <span class="keyword">long</span> l = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line">        l &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line">        <span class="keyword">short</span> s = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line">        s &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line">        <span class="keyword">byte</span> b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">        b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">        System.out.println(Integer.toBinaryString(b&gt;&gt;&gt;<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111111</span><br><span class="line">1111111111111111111111</span><br><span class="line">1111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">111111111111111111111111111111111111111111111111111111</span><br><span class="line">11111111111111111111111111111111</span><br><span class="line">11111111111111111111111111111111</span><br><span class="line">11111111111111111111111111111111</span><br><span class="line">11111111111111111111111111111111</span><br><span class="line">11111111111111111111111111111111</span><br><span class="line">1111111111111111111111</span><br></pre></td></tr></table></figure><p>在上例中，结果并未重新赋值给变量 <strong>b</strong> ，而是直接打印出来，因此一切正常。下面是一个涉及所有位运算符的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/BitManipulation.java</span></span><br><span class="line"><span class="comment">// 使用位运算符</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitManipulation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">int</span> i = rand.nextInt();</span><br><span class="line">        <span class="keyword">int</span> j = rand.nextInt();</span><br><span class="line">        printBinaryInt(<span class="string">&quot;-1&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;+1&quot;</span>, +<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxpos = <span class="number">2147483647</span>;</span><br><span class="line">        printBinaryInt(<span class="string">&quot;maxpos&quot;</span>, maxpos);</span><br><span class="line">        <span class="keyword">int</span> maxneg = -<span class="number">2147483648</span>;</span><br><span class="line">        printBinaryInt(<span class="string">&quot;maxneg&quot;</span>, maxneg);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i&quot;</span>, i);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;~i&quot;</span>, ~i);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;-i&quot;</span>, -i);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;j&quot;</span>, j);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i &amp; j&quot;</span>, i &amp; j);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i | j&quot;</span>, i | j);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i ^ j&quot;</span>, i ^ j);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i &lt;&lt; 5&quot;</span>, i &lt;&lt; <span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i &gt;&gt; 5&quot;</span>, i &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;(~i) &gt;&gt; 5&quot;</span>, (~i) &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i &gt;&gt;&gt; 5&quot;</span>, i &gt;&gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;(~i) &gt;&gt;&gt; 5&quot;</span>, (~i) &gt;&gt;&gt; <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">long</span> l = rand.nextLong();</span><br><span class="line">        <span class="keyword">long</span> m = rand.nextLong();</span><br><span class="line">        printBinaryLong(<span class="string">&quot;-1L&quot;</span>, -<span class="number">1L</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;+1L&quot;</span>, +<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">long</span> ll = <span class="number">9223372036854775807L</span>;</span><br><span class="line">        printBinaryLong(<span class="string">&quot;maxpos&quot;</span>, ll);</span><br><span class="line">        <span class="keyword">long</span> lln = -<span class="number">9223372036854775808L</span>;</span><br><span class="line">        printBinaryLong(<span class="string">&quot;maxneg&quot;</span>, lln);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l&quot;</span>, l);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;~l&quot;</span>, ~l);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;-l&quot;</span>, -l);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;m&quot;</span>, m);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l &amp; m&quot;</span>, l &amp; m);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l | m&quot;</span>, l | m);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l ^ m&quot;</span>, l ^ m);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l &lt;&lt; 5&quot;</span>, l &lt;&lt; <span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l &gt;&gt; 5&quot;</span>, l &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;(~l) &gt;&gt; 5&quot;</span>, (~l) &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l &gt;&gt;&gt; 5&quot;</span>, l &gt;&gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;(~l) &gt;&gt;&gt; 5&quot;</span>, (~l) &gt;&gt;&gt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBinaryInt</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">        s + <span class="string">&quot;, int: &quot;</span> + i + <span class="string">&quot;, binary:\n &quot;</span> +</span><br><span class="line">        Integer.toBinaryString(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBinaryLong</span><span class="params">(String s, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">        s + <span class="string">&quot;, long: &quot;</span> + l + <span class="string">&quot;, binary:\n &quot;</span> +</span><br><span class="line">        Long.toBinaryString(l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果（前 32 行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-1, int: -1, binary:</span><br><span class="line">11111111111111111111111111111111</span><br><span class="line">+1, int: 1, binary:</span><br><span class="line">1</span><br><span class="line">maxpos, int: 2147483647, binary:</span><br><span class="line">1111111111111111111111111111111</span><br><span class="line">maxneg, int: -2147483648, binary:</span><br><span class="line">10000000000000000000000000000000</span><br><span class="line">i, int: -1172028779, binary:</span><br><span class="line">10111010001001000100001010010101</span><br><span class="line">~i, int: 1172028778, binary:</span><br><span class="line"> 1000101110110111011110101101010</span><br><span class="line">-i, int: 1172028779, binary:</span><br><span class="line">1000101110110111011110101101011</span><br><span class="line">j, int: 1717241110, binary:</span><br><span class="line">1100110010110110000010100010110</span><br><span class="line">i &amp; j, int: 570425364, binary:</span><br><span class="line">100010000000000000000000010100</span><br><span class="line">i | j, int: -25213033, binary:</span><br><span class="line">11111110011111110100011110010111</span><br><span class="line">i ^ j, int: -595638397, binary:</span><br><span class="line">11011100011111110100011110000011</span><br><span class="line">i &lt;&lt; 5, int: 1149784736, binary:</span><br><span class="line">1000100100010000101001010100000</span><br><span class="line">i &gt;&gt; 5, int: -36625900, binary:</span><br><span class="line">11111101110100010010001000010100</span><br><span class="line">(~i) &gt;&gt; 5, int: 36625899, binary:</span><br><span class="line">10001011101101110111101011</span><br><span class="line">i &gt;&gt;&gt; 5, int: 97591828, binary:</span><br><span class="line">101110100010010001000010100</span><br><span class="line">(~i) &gt;&gt;&gt; 5, int: 36625899, binary:</span><br><span class="line">10001011101101110111101011</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>结尾的两个方法 <code>printBinaryInt()</code> 和 <code>printBinaryLong()</code> 分别操作一个 <strong>int</strong> 和 <strong>long</strong> 值，并转换为二进制格式输出，同时附有简要的文字说明。除了演示 <strong>int</strong> 和 <strong>long</strong> 的所有位运算符的效果之外，本示例还显示 <strong>int</strong> 和 <strong>long</strong> 的最小值、最大值、+1 和 -1 值，以便我们了解它们的形式。注意高位代表符号：0 表示正，1 表示负。上面显示了 <strong>int</strong> 部分的输出。数字的二进制表示称为有符号的两个补数。</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符，也称为条件运算符。这种运算符比较罕见，因为它有三个运算对象。但它确实属于运算符的一种，因为它最终也会生成一个值。这与本章后一节要讲述的普通 <strong>if-else</strong> 语句是不同的。下面是它的表达式格式：</p><p><strong>布尔表达式 ? 值 1 : 值 2</strong></p><p>若表达式计算为 <strong>true</strong>，则返回结果 <strong>值 1</strong> ；如果表达式的计算为 <strong>false</strong>，则返回结果 <strong>值 2</strong>。</p><p>当然，也可以换用普通的 <strong>if-else</strong> 语句（在后面介绍），但三元运算符更加简洁。作为三元运算符的创造者， C 自诩为一门简练的语言。三元运算符的引入多半就是为了高效编程，但假若我们打算频繁使用它的话，还是先多作一些思量： 它易于产生可读性差的代码。与 <strong>if-else</strong> 不同的是，三元运算符是有返回结果的。请看下面的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/TernaryIfElse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TernaryIfElse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ternary</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; <span class="number">10</span> ? i * <span class="number">100</span> : i * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">standardIfElse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ternary(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ternary(<span class="number">10</span>));</span><br><span class="line">        System.out.println(standardIfElse(<span class="number">9</span>));</span><br><span class="line">        System.out.println(standardIfElse(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">900</span><br><span class="line">100</span><br><span class="line">900</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>可以看出，<code>ternary()</code> 中的代码更简短。然而，<strong>standardIfElse()</strong> 中的代码更易理解且不要求更多的录入。所以我们在挑选三元运算符时，请务必权衡一下利弊。</p><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>这个运算符在 Java 里有一项特殊用途：连接字符串。这点已在前面展示过了。尽管与 <code>+</code> 的传统意义不符，但如此使用也还是比较自然的。这一功能看起来还不错，于是在 C++ 里引入了“运算符重载”机制，以便 C++ 程序员为几乎所有运算符增加特殊的含义。但遗憾得是，与 C++ 的一些限制结合以后，它变得复杂。这要求程序员在设计自己的类时必须对此有周全的考虑。虽然在 Java 中实现运算符重载机制并非难事（如 C# 所展示的，它具有简单的运算符重载），但因该特性过于复杂，因此 Java 并未实现它。</p><p>我们注意到运用 <code>String +</code> 时有一些有趣的现象。若表达式以一个 <strong>String</strong> 类型开头（编译器会自动将双引号 <code>&quot;&quot;</code> 标注的的字符序列转换为字符串），那么后续所有运算对象都必须是字符串。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/StringOperators.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOperators</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">1</span>, z = <span class="number">2</span>;</span><br><span class="line">        String s = <span class="string">&quot;x, y, z &quot;</span>;</span><br><span class="line">        System.out.println(s + x + y + z);</span><br><span class="line">        <span class="comment">// 将 x 转换为字符串</span></span><br><span class="line">        System.out.println(x + <span class="string">&quot; &quot;</span> + s);</span><br><span class="line">        s += <span class="string">&quot;(summed) = &quot;</span>;</span><br><span class="line">        <span class="comment">// 级联操作</span></span><br><span class="line">        System.out.println(s + (x + y + z));</span><br><span class="line">        <span class="comment">// Integer.toString()方法的简写:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x, y, z 012</span><br><span class="line">0 x, y, z</span><br><span class="line">x, y, z (summed) = 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上例中第 1 输出语句的执行结果是 <code>012</code> 而并非 <code>3</code>，这是因为编译器将其分别转换为其字符串形式然后与字符串变量 <strong>s</strong> 连接。在第 2 条输出语句中，编译器将开头的变量转换为了字符串，由此可以看出，这种转换与数据的位置无关，只要当中有一条数据是字符串类型，其他非字符串数据都将被转换为字符串形式并连接。最后一条输出语句，我们可以看出 <code>+=</code> 运算符可以拼接其右侧的字符串连接结果并重赋值给自身变量 <code>s</code>。括号 <code>()</code> 可以控制表达式的计算顺序，以便在显示 <strong>int</strong> 之前对其进行实际求和。</p><p>请注意主方法中的最后一个例子：我们经常会看到一个空字符串 <code>&quot;&quot;</code> 跟着一个基本类型的数据。这样可以隐式地将其转换为字符串，以代替繁琐的显式调用方法（如这里可以使用 <strong>Integer.toString()</strong>）。</p><h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><p>使用运算符时很容易犯的一个错误是，在还没搞清楚表达式的计算方式时就试图忽略括号 <code>()</code>。在 Java 中也一样。 在 C++ 中你甚至可能犯这样极端的错误.代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x = y) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，程序员原意是测试等价性 <code>==</code>，而非赋值 <code>=</code>。若变量 <strong>y</strong> 非 0 的话，在 C/C++ 中，这样的赋值操作总会返回 <code>true</code>。于是，上面的代码示例将会无限循环。而在 Java 中，这样的表达式结果并不会转化为一个布尔值。 而编译器会试图把这个 <strong>int</strong> 型数据转换为预期应接收的布尔类型。最后，我们将会在试图运行前收到编译期错误。因此，Java 天生避免了这种陷阱发生的可能。</p><p>唯一有种情况例外：当变量 <code>x</code> 和 <code>y</code> 都是布尔值，例如 <code>x=y</code> 是一个逻辑表达式。除此之外，之前的那个例子，很大可能是错误。</p><p>在 C/C++ 里，类似的一个问题还有使用按位“与” <code>&amp;</code> 和“或” <code>|</code> 运算，而非逻辑“与” <code>&amp;&amp;</code> 和“或” <code>||</code>。就象 <code>=</code> 和 <code>==</code> 一样，键入一个字符当然要比键入两个简单。在 Java 中，编译器同样可防止这一点，因为它不允许我们强行使用另一种并不符的类型。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>“类型转换”（Casting）的作用是“与一个模型匹配”。在适当的时候，Java 会将一种数据类型自动转换成另一种。例如，假设我们为 <strong>float</strong> 变量赋值一个整数值，计算机会将 <strong>int</strong> 自动转换成 <strong>float</strong>。我们可以在程序未自动转换时显式、强制地使此类型发生转换。</p><p>要执行强制转换，需要将所需的数据类型放在任何值左侧的括号内，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Casting.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Casting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">long</span> lng = (<span class="keyword">long</span>)i;</span><br><span class="line">        lng = i; <span class="comment">// 没有必要的类型提升</span></span><br><span class="line">        <span class="keyword">long</span> lng2 = (<span class="keyword">long</span>)<span class="number">200</span>;</span><br><span class="line">        lng2 = <span class="number">200</span>;</span><br><span class="line">        <span class="comment">// 类型收缩</span></span><br><span class="line">        i = (<span class="keyword">int</span>)lng2; <span class="comment">// Cast required</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诚然，你可以这样地去转换一个数值类型的变量。但是上例这种做法是多余的：因为编译器会在必要时自动提升 <strong>int</strong> 型数据为 <strong>long</strong> 型。</p><p>当然，为了程序逻辑清晰或提醒自己留意，我们也可以显式地类型转换。在其他情况下，类型转换型只有在代码编译时才显出其重要性。在 C/C++ 中，类型转换有时会让人头痛。在 Java 里，类型转换则是一种比较安全的操作。但是，若将数据类型进行“向下转换”（<strong>Narrowing Conversion</strong>）的操作（将容量较大的数据类型转换成容量较小的类型），可能会发生信息丢失的危险。此时，编译器会强迫我们进行转型，好比在提醒我们：该操作可能危险，若你坚持让我这么做，那么对不起，请明确需要转换的类型。 对于“向上转换”（<strong>Widening conversion</strong>），则不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。</p><p>除了布尔类型的数据，Java 允许任何基本类型的数据转换为另一种基本类型的数据。此外，类是不能进行类型转换的。为了将一个类转换为另一个类型，需要使用特殊的方法（后面将会学习到如何在父子类之间进行向上/向下转型，例如，“橡树”可以转换为“树”，反之亦然。而对于“岩石”是无法转换为“树”的）。</p><h3 id="截断和舍入"><a href="#截断和舍入" class="headerlink" title="截断和舍入"></a>截断和舍入</h3><p>在执行“向下转换”时，必须注意数据的截断和舍入问题。若从浮点值转换为整型值，Java 会做什么呢？例如：浮点数 29.7 被转换为整型值，结果会是 29 还是 30 呢？下面是代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/CastingNumbers.java</span></span><br><span class="line"><span class="comment">// 尝试转换 float 和 double 型数据为整型数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CastingNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> above = <span class="number">0.7</span>, below = <span class="number">0.4</span>;</span><br><span class="line">        <span class="keyword">float</span> fabove = <span class="number">0.7f</span>, fbelow = <span class="number">0.4f</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;(int)above: &quot;</span> + (<span class="keyword">int</span>)above);</span><br><span class="line">        System.out.println(<span class="string">&quot;(int)below: &quot;</span> + (<span class="keyword">int</span>)below);</span><br><span class="line">        System.out.println(<span class="string">&quot;(int)fabove: &quot;</span> + (<span class="keyword">int</span>)fabove);</span><br><span class="line">        System.out.println(<span class="string">&quot;(int)fbelow: &quot;</span> + (<span class="keyword">int</span>)fbelow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(int)above: 0</span><br><span class="line">(int)below: 0</span><br><span class="line">(int)fabove: 0</span><br><span class="line">(int)fbelow: 0</span><br></pre></td></tr></table></figure><p>因此，答案是，从 <strong>float</strong> 和 <strong>double</strong> 转换为整数值时，小数位将被截断。若你想对结果进行四舍五入，可以使用 <code>java.lang.Math</code> 的 <code>round()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/RoundingNumbers.java</span></span><br><span class="line"><span class="comment">// float 和 double 类型数据的四舍五入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundingNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> above = <span class="number">0.7</span>, below = <span class="number">0.4</span>;</span><br><span class="line">        <span class="keyword">float</span> fabove = <span class="number">0.7f</span>, fbelow = <span class="number">0.4f</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;Math.round(above): &quot;</span> + Math.round(above));</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;Math.round(below): &quot;</span> + Math.round(below));</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;Math.round(fabove): &quot;</span> + Math.round(fabove));</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;Math.round(fbelow): &quot;</span> + Math.round(fbelow));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.round(above): 1</span><br><span class="line">Math.round(below): 0</span><br><span class="line">Math.round(fabove): 1</span><br><span class="line">Math.round(fbelow): 0</span><br></pre></td></tr></table></figure><p>因为 <code>round()</code> 方法是 <code>java.lang</code> 的一部分，所以我们无需通过 <code>import</code> 就可以使用。</p><h3 id="类型提升"><a href="#类型提升" class="headerlink" title="类型提升"></a>类型提升</h3><p>你会发现，如果我们对小于 <strong>int</strong> 的基本数据类型（即 <strong>char</strong>、<strong>byte</strong> 或 <strong>short</strong>）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 <strong>int</strong>，并且结果值的类型为 <strong>int</strong>。若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。通常，表达式中最大的数据类型是决定表达式结果的数据类型。<strong>float</strong> 型和 <strong>double</strong> 型相乘，结果是 <strong>double</strong> 型的；<strong>int</strong> 和 <strong>long</strong> 相加，结果是 <strong>long</strong> 型。</p><h2 id="Java-没有-sizeof"><a href="#Java-没有-sizeof" class="headerlink" title="Java 没有 sizeof"></a>Java 没有 sizeof</h2><p>在 C/C++ 中，经常需要用到 <code>sizeof()</code> 方法来获取数据项被分配的字节大小。C/C++ 中使用 <code>sizeof()</code> 最有说服力的原因是为了移植性，不同数据在不同机器上可能有不同的大小，所以在进行大小敏感的运算时，程序员必须对这些类型有多大做到心中有数。例如，一台计算机可用 32 位来保存整数，而另一台只用 16 位保存。显然，在第一台机器中，程序可保存更大的值。所以，移植是令 C/C++ 程序员颇为头痛的一个问题。</p><p>Java 不需要 <code>sizeof()</code> 方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。我们不必考虑这个层次的移植问题 —— Java 本身就是一种“与平台无关”的语言。</p><h2 id="运算符总结"><a href="#运算符总结" class="headerlink" title="运算符总结"></a>运算符总结</h2><p>上述示例分别向我们展示了哪些基本类型能被用于特定的运算符。基本上，下面的代码示例是对上述所有示例的重复，只不过概括了所有的基本类型。这个文件能被正确地编译，因为我已经把编译不通过的那部分用注释 <code>//</code> 过滤了。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/AllOps.java</span></span><br><span class="line"><span class="comment">// 测试所有基本类型的运算符操作</span></span><br><span class="line"><span class="comment">// 看看哪些是能被 Java 编译器接受的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllOps</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 布尔值的接收测试：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boolTest</span><span class="params">(<span class="keyword">boolean</span> x, <span class="keyword">boolean</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算数运算符：</span></span><br><span class="line">        <span class="comment">//- x = x * y;</span></span><br><span class="line">        <span class="comment">//- x = x / y;</span></span><br><span class="line">        <span class="comment">//- x = x % y;</span></span><br><span class="line">        <span class="comment">//- x = x + y;</span></span><br><span class="line">        <span class="comment">//- x = x - y;</span></span><br><span class="line">        <span class="comment">//- x++;</span></span><br><span class="line">        <span class="comment">//- x--;</span></span><br><span class="line">        <span class="comment">//- x = +y;</span></span><br><span class="line">        <span class="comment">//- x = -y;</span></span><br><span class="line">        <span class="comment">// 关系运算符和逻辑运算符：</span></span><br><span class="line">        <span class="comment">//- f(x &gt; y);</span></span><br><span class="line">        <span class="comment">//- f(x &gt;= y);</span></span><br><span class="line">        <span class="comment">//- f(x &lt; y);</span></span><br><span class="line">        <span class="comment">//- f(x &lt;= y);</span></span><br><span class="line">        f(x == y);</span><br><span class="line">        f(x != y);</span><br><span class="line">        f(!y);</span><br><span class="line">        x = x &amp;&amp; y;</span><br><span class="line">        x = x || y;</span><br><span class="line">        <span class="comment">// 按位运算符：</span></span><br><span class="line">        <span class="comment">//- x = ~y;</span></span><br><span class="line">        x = x &amp; y;</span><br><span class="line">        x = x | y;</span><br><span class="line">        x = x ^ y;</span><br><span class="line">        <span class="comment">//- x = x &lt;&lt; 1;</span></span><br><span class="line">        <span class="comment">//- x = x &gt;&gt; 1;</span></span><br><span class="line">        <span class="comment">//- x = x &gt;&gt;&gt; 1;</span></span><br><span class="line">        <span class="comment">// 联合赋值：</span></span><br><span class="line">        <span class="comment">//- x += y;</span></span><br><span class="line">        <span class="comment">//- x -= y;</span></span><br><span class="line">        <span class="comment">//- x *= y;</span></span><br><span class="line">        <span class="comment">//- x /= y;</span></span><br><span class="line">        <span class="comment">//- x %= y;</span></span><br><span class="line">        <span class="comment">//- x &lt;&lt;= 1;</span></span><br><span class="line">        <span class="comment">//- x &gt;&gt;= 1;</span></span><br><span class="line">        <span class="comment">//- x &gt;&gt;&gt;= 1;</span></span><br><span class="line">        x &amp;= y;</span><br><span class="line">        x ^= y;</span><br><span class="line">        x |= y;</span><br><span class="line">        <span class="comment">// 类型转换：</span></span><br><span class="line">        <span class="comment">//- char c = (char)x;</span></span><br><span class="line">        <span class="comment">//- byte b = (byte)x;</span></span><br><span class="line">        <span class="comment">//- short s = (short)x;</span></span><br><span class="line">        <span class="comment">//- int i = (int)x;</span></span><br><span class="line">        <span class="comment">//- long l = (long)x;</span></span><br><span class="line">        <span class="comment">//- float f = (float)x;</span></span><br><span class="line">        <span class="comment">//- double d = (double)x;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">charTest</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">char</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算数运算符：</span></span><br><span class="line">        x = (<span class="keyword">char</span>)(x * y);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x / y);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x % y);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x + y);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x - y);</span><br><span class="line">        x++;</span><br><span class="line">        x--;</span><br><span class="line">        x = (<span class="keyword">char</span>) + y;</span><br><span class="line">        x = (<span class="keyword">char</span>) - y;</span><br><span class="line">        <span class="comment">// 关系和逻辑运算符：</span></span><br><span class="line">        f(x &gt; y);</span><br><span class="line">        f(x &gt;= y);</span><br><span class="line">        f(x &lt; y);</span><br><span class="line">        f(x &lt;= y);</span><br><span class="line">        f(x == y);</span><br><span class="line">        f(x != y);</span><br><span class="line">        <span class="comment">//- f(!x);</span></span><br><span class="line">        <span class="comment">//- f(x &amp;&amp; y);</span></span><br><span class="line">        <span class="comment">//- f(x || y);</span></span><br><span class="line">        <span class="comment">// 按位运算符：</span></span><br><span class="line">        x= (<span class="keyword">char</span>)~y;</span><br><span class="line">        x = (<span class="keyword">char</span>)(x &amp; y);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x | y);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x ^ y);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        x = (<span class="keyword">char</span>)(x &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 联合赋值：</span></span><br><span class="line">        x += y;</span><br><span class="line">        x -= y;</span><br><span class="line">        x *= y;</span><br><span class="line">        x /= y;</span><br><span class="line">        x %= y;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &amp;= y;</span><br><span class="line">        x ^= y;</span><br><span class="line">        x |= y;</span><br><span class="line">        <span class="comment">// 类型转换</span></span><br><span class="line">        <span class="comment">//- boolean bl = (boolean)x;</span></span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)x;</span><br><span class="line">        <span class="keyword">short</span> s = (<span class="keyword">short</span>)x;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)x;</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)x;</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>)x;</span><br><span class="line">        <span class="keyword">double</span> d = (<span class="keyword">double</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">byteTest</span><span class="params">(<span class="keyword">byte</span> x, <span class="keyword">byte</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算数运算符：</span></span><br><span class="line">        x = (<span class="keyword">byte</span>)(x* y);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x / y);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x % y);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x + y);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x - y);</span><br><span class="line">        x++;</span><br><span class="line">        x--;</span><br><span class="line">        x = (<span class="keyword">byte</span>) + y;</span><br><span class="line">        x = (<span class="keyword">byte</span>) - y;</span><br><span class="line">        <span class="comment">// 关系和逻辑运算符：</span></span><br><span class="line">        f(x &gt; y);</span><br><span class="line">        f(x &gt;= y);</span><br><span class="line">        f(x &lt; y);</span><br><span class="line">        f(x &lt;= y);</span><br><span class="line">        f(x == y);</span><br><span class="line">        f(x != y);</span><br><span class="line">        <span class="comment">//- f(!x);</span></span><br><span class="line">        <span class="comment">//- f(x &amp;&amp; y);</span></span><br><span class="line">        <span class="comment">//- f(x || y);</span></span><br><span class="line">        <span class="comment">//按位运算符：</span></span><br><span class="line">        x = (<span class="keyword">byte</span>)~y;</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x &amp; y);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x | y);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x ^ y);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        x = (<span class="keyword">byte</span>)(x &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 联合赋值：</span></span><br><span class="line">        x += y;</span><br><span class="line">        x -= y;</span><br><span class="line">        x *= y;</span><br><span class="line">        x /= y;</span><br><span class="line">        x %= y;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &amp;= y;</span><br><span class="line">        x ^= y;</span><br><span class="line">        x |= y;</span><br><span class="line">        <span class="comment">// 类型转换：</span></span><br><span class="line">        <span class="comment">//- boolean bl = (boolean)x;</span></span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>)x;</span><br><span class="line">        <span class="keyword">short</span> s = (<span class="keyword">short</span>)x;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)x;</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)x;</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>)x;</span><br><span class="line">        <span class="keyword">double</span> d = (<span class="keyword">double</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shortTest</span><span class="params">(<span class="keyword">short</span> x, <span class="keyword">short</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算术运算符：</span></span><br><span class="line">        x = (<span class="keyword">short</span>)(x * y);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x / y);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x % y);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x + y);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x - y);</span><br><span class="line">        x++;</span><br><span class="line">        x--;</span><br><span class="line">        x = (<span class="keyword">short</span>) + y;</span><br><span class="line">        x = (<span class="keyword">short</span>) - y;</span><br><span class="line">        <span class="comment">// 关系和逻辑运算符：</span></span><br><span class="line">        f(x &gt; y);</span><br><span class="line">        f(x &gt;= y);</span><br><span class="line">        f(x &lt; y);</span><br><span class="line">        f(x &lt;= y);</span><br><span class="line">        f(x == y);</span><br><span class="line">        f(x != y);</span><br><span class="line">        <span class="comment">//- f(!x);</span></span><br><span class="line">        <span class="comment">//- f(x &amp;&amp; y);</span></span><br><span class="line">        <span class="comment">//- f(x || y);</span></span><br><span class="line">        <span class="comment">// 按位运算符：</span></span><br><span class="line">        x = (<span class="keyword">short</span>) ~ y;</span><br><span class="line">        x = (<span class="keyword">short</span>)(x &amp; y);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x | y);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x ^ y);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        x = (<span class="keyword">short</span>)(x &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Compound assignment:</span></span><br><span class="line">        x += y;</span><br><span class="line">        x -= y;</span><br><span class="line">        x *= y;</span><br><span class="line">        x /= y;</span><br><span class="line">        x %= y;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &amp;= y;</span><br><span class="line">        x ^= y;</span><br><span class="line">        x |= y;</span><br><span class="line">        <span class="comment">// 类型转换：</span></span><br><span class="line">        <span class="comment">//- boolean bl = (boolean)x;</span></span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>)x;</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)x;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)x;</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)x;</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>)x;</span><br><span class="line">        <span class="keyword">double</span> d = (<span class="keyword">double</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">intTest</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算术运算符：</span></span><br><span class="line">        x = x * y;</span><br><span class="line">        x = x / y;</span><br><span class="line">        x = x % y;</span><br><span class="line">        x = x + y;</span><br><span class="line">        x = x - y;</span><br><span class="line">        x++;</span><br><span class="line">        x--;</span><br><span class="line">        x = +y;</span><br><span class="line">        x = -y;</span><br><span class="line">        <span class="comment">// 关系和逻辑运算符：</span></span><br><span class="line">        f(x &gt; y);</span><br><span class="line">        f(x &gt;= y);</span><br><span class="line">        f(x &lt; y);</span><br><span class="line">        f(x &lt;= y);</span><br><span class="line">        f(x == y);</span><br><span class="line">        f(x != y);</span><br><span class="line">        <span class="comment">//- f(!x);</span></span><br><span class="line">        <span class="comment">//- f(x &amp;&amp; y);</span></span><br><span class="line">        <span class="comment">//- f(x || y);</span></span><br><span class="line">        <span class="comment">// 按位运算符：</span></span><br><span class="line">        x = ~y;</span><br><span class="line">        x = x &amp; y;</span><br><span class="line">        x = x | y;</span><br><span class="line">        x = x ^ y;</span><br><span class="line">        x = x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        x = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        x = x &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 联合赋值：</span></span><br><span class="line">        x += y;</span><br><span class="line">        x -= y;</span><br><span class="line">        x *= y;</span><br><span class="line">        x /= y;</span><br><span class="line">        x %= y;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &amp;= y;</span><br><span class="line">        x ^= y;</span><br><span class="line">        x |= y;</span><br><span class="line">        <span class="comment">// 类型转换：</span></span><br><span class="line">        <span class="comment">//- boolean bl = (boolean)x;</span></span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>)x;</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)x;</span><br><span class="line">        <span class="keyword">short</span> s = (<span class="keyword">short</span>)x;</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)x;</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>)x;</span><br><span class="line">        <span class="keyword">double</span> d = (<span class="keyword">double</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">longTest</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算数运算符：</span></span><br><span class="line">        x = x * y;</span><br><span class="line">        x = x / y;</span><br><span class="line">        x = x % y;</span><br><span class="line">        x = x + y;</span><br><span class="line">        x = x - y;</span><br><span class="line">        x++;</span><br><span class="line">        x--;</span><br><span class="line">        x = +y;</span><br><span class="line">        x = -y;</span><br><span class="line">        <span class="comment">// 关系和逻辑运算符：</span></span><br><span class="line">        f(x &gt; y);</span><br><span class="line">        f(x &gt;= y);</span><br><span class="line">        f(x &lt; y);</span><br><span class="line">        f(x &lt;= y);</span><br><span class="line">        f(x == y);</span><br><span class="line">        f(x != y);</span><br><span class="line">        <span class="comment">//- f(!x);</span></span><br><span class="line">        <span class="comment">//- f(x &amp;&amp; y);</span></span><br><span class="line">        <span class="comment">//- f(x || y);</span></span><br><span class="line">        <span class="comment">// 按位运算符：</span></span><br><span class="line">        x = ~y;</span><br><span class="line">        x = x &amp; y;</span><br><span class="line">        x = x | y;</span><br><span class="line">        x = x ^ y;</span><br><span class="line">        x = x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        x = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        x = x &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 联合赋值：</span></span><br><span class="line">        x += y;</span><br><span class="line">        x -= y;</span><br><span class="line">        x *= y;</span><br><span class="line">        x /= y;</span><br><span class="line">        x %= y;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x &amp;= y;</span><br><span class="line">        x ^= y;</span><br><span class="line">        x |= y;</span><br><span class="line">        <span class="comment">// 类型转换：</span></span><br><span class="line">        <span class="comment">//- boolean bl = (boolean)x;</span></span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>)x;</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)x;</span><br><span class="line">        <span class="keyword">short</span> s = (<span class="keyword">short</span>)x;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)x;</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>)x;</span><br><span class="line">        <span class="keyword">double</span> d = (<span class="keyword">double</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">floatTest</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算数运算符：</span></span><br><span class="line">        x = x * y;</span><br><span class="line">        x = x / y;</span><br><span class="line">        x = x % y;</span><br><span class="line">        x = x + y;</span><br><span class="line">        x = x - y;</span><br><span class="line">        x++;</span><br><span class="line">        x--;</span><br><span class="line">        x = +y;</span><br><span class="line">        x = -y;</span><br><span class="line">        <span class="comment">// 关系和逻辑运算符：</span></span><br><span class="line">        f(x &gt; y);</span><br><span class="line">        f(x &gt;= y);</span><br><span class="line">        f(x &lt; y);</span><br><span class="line">        f(x &lt;= y);</span><br><span class="line">        f(x == y);</span><br><span class="line">        f(x != y);</span><br><span class="line">        <span class="comment">//- f(!x);</span></span><br><span class="line">        <span class="comment">//- f(x &amp;&amp; y);</span></span><br><span class="line">        <span class="comment">//- f(x || y);</span></span><br><span class="line">        <span class="comment">// 按位运算符：</span></span><br><span class="line">        <span class="comment">//- x = ~y;</span></span><br><span class="line">        <span class="comment">//- x = x &amp; y;</span></span><br><span class="line">        <span class="comment">//- x = x | y;</span></span><br><span class="line">        <span class="comment">//- x = x ^ y;</span></span><br><span class="line">        <span class="comment">//- x = x &lt;&lt; 1;</span></span><br><span class="line">        <span class="comment">//- x = x &gt;&gt; 1;</span></span><br><span class="line">        <span class="comment">//- x = x &gt;&gt;&gt; 1;</span></span><br><span class="line">        <span class="comment">// 联合赋值：</span></span><br><span class="line">        x += y;</span><br><span class="line">        x -= y;</span><br><span class="line">        x *= y;</span><br><span class="line">        x /= y;</span><br><span class="line">        x %= y;</span><br><span class="line">        <span class="comment">//- x &lt;&lt;= 1;</span></span><br><span class="line">        <span class="comment">//- x &gt;&gt;= 1;</span></span><br><span class="line">        <span class="comment">//- x &gt;&gt;&gt;= 1;</span></span><br><span class="line">        <span class="comment">//- x &amp;= y;</span></span><br><span class="line">        <span class="comment">//- x ^= y;</span></span><br><span class="line">        <span class="comment">//- x |= y;</span></span><br><span class="line">        <span class="comment">// 类型转换：</span></span><br><span class="line">        <span class="comment">//- boolean bl = (boolean)x;</span></span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>)x;</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)x;</span><br><span class="line">        <span class="keyword">short</span> s = (<span class="keyword">short</span>)x;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)x;</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)x;</span><br><span class="line">        <span class="keyword">double</span> d = (<span class="keyword">double</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doubleTest</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算术运算符：</span></span><br><span class="line">        x = x * y;</span><br><span class="line">        x = x / y;</span><br><span class="line">        x = x % y;</span><br><span class="line">        x = x + y;</span><br><span class="line">        x = x - y;</span><br><span class="line">        x++;</span><br><span class="line">        x--;</span><br><span class="line">        x = +y;</span><br><span class="line">        x = -y;</span><br><span class="line">        <span class="comment">// 关系和逻辑运算符：</span></span><br><span class="line">        f(x &gt; y);</span><br><span class="line">        f(x &gt;= y);</span><br><span class="line">        f(x &lt; y);</span><br><span class="line">        f(x &lt;= y);</span><br><span class="line">        f(x == y);</span><br><span class="line">        f(x != y);</span><br><span class="line">        <span class="comment">//- f(!x);</span></span><br><span class="line">        <span class="comment">//- f(x &amp;&amp; y);</span></span><br><span class="line">        <span class="comment">//- f(x || y);</span></span><br><span class="line">        <span class="comment">// 按位运算符：</span></span><br><span class="line">        <span class="comment">//- x = ~y;</span></span><br><span class="line">        <span class="comment">//- x = x &amp; y;</span></span><br><span class="line">        <span class="comment">//- x = x | y;</span></span><br><span class="line">        <span class="comment">//- x = x ^ y;</span></span><br><span class="line">        <span class="comment">//- x = x &lt;&lt; 1;</span></span><br><span class="line">        <span class="comment">//- x = x &gt;&gt; 1;</span></span><br><span class="line">        <span class="comment">//- x = x &gt;&gt;&gt; 1;</span></span><br><span class="line">        <span class="comment">// 联合赋值：</span></span><br><span class="line">        x += y;</span><br><span class="line">        x -= y;</span><br><span class="line">        x *= y;</span><br><span class="line">        x /= y;</span><br><span class="line">        x %= y;</span><br><span class="line">        <span class="comment">//- x &lt;&lt;= 1;</span></span><br><span class="line">        <span class="comment">//- x &gt;&gt;= 1;</span></span><br><span class="line">        <span class="comment">//- x &gt;&gt;&gt;= 1;</span></span><br><span class="line">        <span class="comment">//- x &amp;= y;</span></span><br><span class="line">        <span class="comment">//- x ^= y;</span></span><br><span class="line">        <span class="comment">//- x |= y;</span></span><br><span class="line">        <span class="comment">// 类型转换：</span></span><br><span class="line">        <span class="comment">//- boolean bl = (boolean)x;</span></span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>)x;</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)x;</span><br><span class="line">        <span class="keyword">short</span> s = (<span class="keyword">short</span>)x;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)x;</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)x;</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> ：<strong>boolean</strong> 类型的运算是受限的。你能为其赋值 <code>true</code> 或 <code>false</code>，也可测试它的值是否是 <code>true</code> 或 <code>false</code>。但你不能对其作加减等其他运算。</p><p>在 <strong>char</strong>，<strong>byte</strong> 和 <strong>short</strong> 类型中，我们可以看到算术运算符的“类型转换”效果。我们必须要显式强制类型转换才能将结果重新赋值为原始类型。对于 <strong>int</strong> 类型的运算则不用转换，因为默认就是 <strong>int</strong> 型。虽然我们不用再停下来思考这一切是否安全，但是两个大的 int 型整数相乘时，结果有可能超出 <strong>int</strong> 型的范围，这种情况下结果会发生溢出。下面的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operators/Overflow.java</span></span><br><span class="line"><span class="comment">// 厉害了！内存溢出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = Integer.MAX_VALUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;big = &quot;</span> + big);</span><br><span class="line">        <span class="keyword">int</span> bigger = big * <span class="number">4</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;bigger = &quot;</span> + bigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">big = 2147483647</span><br><span class="line">bigger = -4</span><br></pre></td></tr></table></figure><p>编译器没有报错或警告，运行时一切看起来都无异常。诚然，Java 是优秀的，但是还不足够优秀。</p><p>对于 <strong>char</strong>，<strong>byte</strong> 或者 <strong>short</strong>，混合赋值并不需要类型转换。即使为它们执行转型操作，也会获得与直接算术运算相同的结果。另外，省略类型转换可以使代码显得更加简练。总之，除 <strong>boolean</strong> 以外，其他任何两种基本类型间都可进行类型转换。当我们进行向下转换类型时，需要注意结果的范围是否溢出，否则我们就很可能在不知不觉中丢失精度。</p><h2 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h2><p>如果你已接触过一门 C 语法风格编程语言，那么你在学习 Java 的运算符时实际上没有任何曲线。如果你觉得有难度，那么我推荐你要先去 www.OnJava8.com 观看 《Thinking in C》 的视频教程来补充一些前置知识储备。</p><blockquote id="fn_1"><sup>1</sup>. 我在 <em>Pomona College</em> 大学读过两年本科，在那里 47 被称之为“魔法数字”（<em>magic number</em>），详见 <a href="https://en.wikipedia.org/wiki/47_(number">维基百科</a>&gt;) 。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <em>John Kirkham</em> 说过：“自 1960 年我开始在 IBM 1620 上开始编程起，至 1970 年之间，FORTRAN 一直都是一种全大写的编程语言。这可能是因为许多早期的输入设备都是旧的电传打字机，使用了 5 位波特码，没有小写字母的功能。指数符号中的 e 也总是大写的，并且从未与自然对数底数 e 混淆，自然对数底数 e 总是小写的。 e 简单地代表指数，通常 10 是基数。那时，八进制也被程序员广泛使用。虽然我从未见过它的用法，但如果我看到一个指数符号的八进制数，我会认为它是以 8 为基数的。我记得第一次看到指数使用小写字母 e 是在 20 世纪 70 年代末，我也发现它令人困惑。这个问题出现的时候，小写字母悄悄进入了 Fortran。如果你真的想使用自然对数底，我们实际上有一些函数要使用，但是它们都是大写的。”<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><h1 id="第-5-章-控制流"><a href="#第-5-章-控制流" class="headerlink" title="第 5 章 控制流"></a>第 5 章 控制流</h1><blockquote><p>程序必须在执行过程中控制它的世界并做出选择。 在 Java 中，你需要执行控制语句来做出选择。</p></blockquote><p>Java 使用了 C 的所有执行控制语句，因此对于熟悉 C/C++ 编程的人来说，这部分内容轻车熟路。大多数面向过程编程语言都有共通的某种控制语句。在 Java 中，涉及的关键字包括 <strong>if-else，while，do-while，for，return，break</strong> 和选择语句 <strong>switch</strong>。 Java 并不支持备受诟病的 <strong>goto</strong>（尽管它在某些特殊场景中依然是最行之有效的方法）。 尽管如此，在 Java 中我们仍旧可以进行类似的逻辑跳转，但较之典型的 <strong>goto</strong> 用法限制更多。</p><h2 id="true-和-false"><a href="#true-和-false" class="headerlink" title="true 和 false"></a>true 和 false</h2><p>所有的条件语句都利用条件表达式的“真”或“假”来决定执行路径。举例：<br><code>a == b</code>。它利用了条件表达式 <code>==</code> 来比较 <code>a</code> 与 <code>b</code> 的值是否相等。 该表达式返回 <code>true</code> 或 <code>false</code>。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/TrueFalse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrueFalse</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="number">1</span> == <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true false</span><br></pre></td></tr></table></figure><p>通过上一章的学习，我们知道任何关系运算符都可以产生条件语句。 <strong>注意</strong>：在 Java 中使用数值作为布尔值是非法的，即便这种操作在 C/C++ 中是被允许的（在这些语言中，“真”为非零，而“假”是零）。如果想在布尔测试中使用一个非布尔值，那么首先需要使用条件表达式来产生 <strong>boolean</strong> 类型的结果，例如 <code>if(a != 0)</code>。</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p><strong>if-else</strong> 语句是控制程序执行流程最基本的形式。 其中 <code>else</code> 是可选的，因此可以有两种形式的 <code>if</code>。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Boolean-expression)</span><br><span class="line">“statement”</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Boolean-expression)</span><br><span class="line">“statement”</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  “statement”</span><br></pre></td></tr></table></figure><p>布尔表达式（Boolean-expression）必须生成 <strong>boolean</strong> 类型的结果，执行语句 <code>statement</code> 既可以是以分号 <code>;</code> 结尾的一条简单语句，也可以是包含在大括号 <code>&#123;&#125;</code> 内的的复合语句 —— 封闭在大括号内的一组简单语句。 凡本书中提及“statement”一词，皆表示类似的执行语句。</p><p>下面是一个有关 <strong>if-else</strong> 语句的例子。<code>test()</code> 方法可以告知你两个数值之间的大小关系。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/IfElse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElse</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> testval, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(testval &gt; target)</span><br><span class="line">      result = +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(testval &lt; target) <span class="comment">// [1]</span></span><br><span class="line">      result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result = <span class="number">0</span>; <span class="comment">// Match</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    test(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    test(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">-1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><sub><strong>注解</strong>：<code>else if</code> 并非新关键字，它仅是 <code>else</code> 后紧跟的一条新 <code>if</code> 语句。</sub></p><p>Java 和 C/C++ 同属“自由格式”的编程语言，但通常我们会在 Java 控制流程语句中采用首部缩进的规范，以便代码更具可读性。</p><h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p><strong>while</strong>，<strong>do-while</strong> 和 <strong>for</strong> 用来控制循环语句（有时也称迭代语句）。只有控制循环的布尔表达式计算结果为 <code>false</code>，循环语句才会停止。</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p><strong>while</strong> 循环的形式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(Boolean-expression)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure><p>执行语句会在每一次循环前，判断布尔表达式返回值是否为 <code>true</code>。下例可产生随机数，直到满足特定条件。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/WhileTest.java</span></span><br><span class="line"><span class="comment">// 演示 while 循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">condition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = Math.random() &lt; <span class="number">0.99</span>;</span><br><span class="line">    System.out.print(result + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(condition())</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside &#x27;while&#x27;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Exited &#x27;while&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">...________...________...________...________...</span><br><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">true, Inside &#x27;while&#x27;</span><br><span class="line">false, Exited &#x27;while&#x27;</span><br></pre></td></tr></table></figure><p><code>condition()</code> 方法使用到了 <strong>Math</strong> 库的<strong>静态</strong>方法 <code>random()</code>。该方法的作用是产生 0 和 1 之间 (包括 0，但不包括 1) 的一个 <strong>double</strong> 值。</p><p><strong>result</strong> 的值是通过比较运算符 <code>&lt;</code> 产生的 <strong>boolean</strong> 类型的结果。当控制台输出 <strong>boolean</strong> 型值时，会自动将其转换为对应的文字形式 <code>true</code> 或 <code>false</code>。此处 <code>while</code> 条件表达式代表：“仅在 <code>condition()</code> 返回 <code>false</code> 时停止循环”。</p><h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p><strong>do-while</strong> 的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">statement</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(Boolean-expression)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>while</strong> 和 <strong>do-while</strong> 之间的唯一区别是：即使条件表达式返回结果为 <code>false</code>， <strong>do-while</strong> 语句也至少会执行一次。 在 <strong>while</strong> 循环体中，如布尔表达式首次返回的结果就为 <code>false</code>，那么循环体内的语句不会被执行。实际应用中，<strong>while</strong> 形式比 <strong>do-while</strong> 更为常用。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p><strong>for</strong> 循环可能是最常用的迭代形式。 该循环在第一次迭代之前执行初始化。随后，它会执行布尔表达式，并在每次迭代结束时，进行某种形式的步进。<strong>for</strong> 循环的形式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialization; Boolean-expression; step)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure><p>初始化 (initialization) 表达式、布尔表达式 (Boolean-expression) ，或者步进 (step) 运算，都可以为空。每次迭代之前都会判断布尔表达式的结果是否成立。一旦计算结果为 <code>false</code>，则跳出 <strong>for</strong> 循环体并继续执行后面代码。 每次循环结束时，都会执行一次步进。</p><p><strong>for</strong> 循环通常用于“计数”任务。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/ListCharacters.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListCharacters</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; <span class="number">128</span>; c++)</span><br><span class="line">      <span class="keyword">if</span>(Character.isLowerCase(c))</span><br><span class="line">        System.out.println(<span class="string">&quot;value: &quot;</span> + (<span class="keyword">int</span>)c +</span><br><span class="line">          <span class="string">&quot; character: &quot;</span> + c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果（前 10 行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">value: 97 character: a</span><br><span class="line">value: 98 character: b</span><br><span class="line">value: 99 character: c</span><br><span class="line">value: 100 character: d</span><br><span class="line">value: 101 character: e</span><br><span class="line">value: 102 character: f</span><br><span class="line">value: 103 character: g</span><br><span class="line">value: 104 character: h</span><br><span class="line">value: 105 character: i</span><br><span class="line">value: 106 character: j</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：变量 <strong>c</strong> 是在 <strong>for</strong> 循环执行时才被定义的，并不是在主方法的开头。<strong>c</strong> 的作用域范围仅在 <strong>for</strong> 循环体内。</p><p>传统的面向过程语言如 C 需要先在代码块（block）前定义好所有变量才能够使用。这样编译器才能在创建块时，为这些变量分配内存空间。在 Java 和 C++ 中，我们可以在整个块使用变量声明，并且可以在需要时才定义变量。 这种自然的编码风格使我们的代码更容易被人理解 <sup><a href="#fn_1" id="reffn_1">1</a></sup>。</p><p>上例使用了 <strong>java.lang.Character</strong> 包装类，该类不仅包含了基本类型 <code>char</code> 的值，还封装了一些有用的方法。例如这里就用到了静态方法 <code>isLowerCase()</code> 来判断字符是否为小写。</p><h4 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h4><p>在 Java 中逗号运算符（这里并非指我们平常用于分隔定义和方法参数的逗号分隔符）仅有一种用法：在 <strong>for</strong> 循环的初始化和步进控制中定义多个变量。我们可以使用逗号分隔多个语句，并按顺序计算这些语句。<strong>注意</strong>：要求定义的变量类型相同。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/CommaOperator.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommaOperator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = i + <span class="number">10</span>; i &lt; <span class="number">5</span>; i++, j = i * <span class="number">2</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot; j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1 j = 11</span><br><span class="line">i = 2 j = 4</span><br><span class="line">i = 3 j = 6</span><br><span class="line">i = 4 j = 8</span><br></pre></td></tr></table></figure><p>上例中 <strong>int</strong> 类型声明包含了 <code>i</code> 和 <code>j</code>。实际上，在初始化部分我们可以定义任意数量的同类型变量。<strong>注意</strong>：在 Java 中，仅允许 <strong>for</strong> 循环在控制表达式中定义变量。 我们不能将此方法与其他的循环语句和选择语句中一起使用。同时，我们可以看到：无论在初始化还是在步进部分，语句都是顺序执行的。</p><h2 id="for-in-语法"><a href="#for-in-语法" class="headerlink" title="for-in 语法"></a>for-in 语法</h2><p>Java 5 引入了更为简洁的“增强版 <strong>for</strong> 循环”语法来操纵数组和集合。（更多细节，可参考 <a href="./21-Arrays.md">数组</a> 和 <a href="./12-Collections.md">集合</a> 章节内容）。大部分文档也称其为 <strong>for-each</strong> 语法，但因为了不与 Java 8 新添的 <code>forEach()</code> 产生混淆，因此我称之为 <strong>for-in</strong> 循环。 （Python 已有类似的先例，如：<strong>for x in sequence</strong>）。<strong>注意</strong>：你可能会在其他地方看到不同叫法。</p><p><strong>for-in</strong> 无需你去创建 <strong>int</strong> 变量和步进来控制循环计数。 下面我们来遍历获取 <strong>float</strong> 数组中的元素。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/ForInFloat.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInFloat</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      f[i] = rand.nextFloat();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> x : f)</span><br><span class="line">      System.out.println(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.72711575</span><br><span class="line">0.39982635</span><br><span class="line">0.5309454</span><br><span class="line">0.0534122</span><br><span class="line">0.16020656</span><br><span class="line">0.57799757</span><br><span class="line">0.18847865</span><br><span class="line">0.4170137</span><br><span class="line">0.51660204</span><br><span class="line">0.73734957</span><br></pre></td></tr></table></figure><p>上例中我们展示了传统 <strong>for</strong> 循环的用法。接下来再来看下 <strong>for-in</strong> 的用法。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> x : f) &#123;</span><br></pre></td></tr></table></figure><p>这条语句定义了一个 <strong>float</strong> 类型的变量 <code>x</code>，继而将每一个 <code>f</code> 的元素赋值给它。</p><p>任何一个返回数组的方法都可以使用 <strong>for-in</strong> 循环语法来遍历元素。例如 <strong>String</strong> 类有一个方法 <code>toCharArray()</code>，返回值类型为 <strong>char</strong> 数组，我们可以很容易地在 <strong>for-in</strong> 循环中遍历它。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/ForInString.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInString</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: <span class="string">&quot;An African Swallow&quot;</span>.toCharArray())</span><br><span class="line">      System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A n   A f r i c a n   S w a l l o w</span><br></pre></td></tr></table></figure><p>很快我们能在 <a href="./12-Collections.md">集合</a> 章节里学习到，<strong>for-in</strong> 循环适用于任何可迭代（<em>iterable</em>）的 对象。</p><p>通常，<strong>for</strong> 循环语句都会在一个整型数值序列中步进。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br></pre></td></tr></table></figure><p>正因如此，除非先创建一个 <strong>int</strong> 数组，否则我们无法使用 <strong>for-in</strong> 循环来操作。为简化测试过程，我已在 <code>onjava</code> 包中封装了 <strong>Range</strong> 类，利用其 <code>range()</code> 方法可自动生成恰当的数组。</p><p>在 <a href="./07-Implementation-Hiding.md">封装</a>（Implementation Hiding）这一章里我们介绍了静态导入（static import），无需了解细节就可以直接使用。 有关静态导入的语法，可以在 <strong>import</strong> 语句中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/ForInInt.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Range.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInInt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">10</span>)) <span class="comment">// 0..9</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">5</span>, <span class="number">10</span>)) <span class="comment">// 5..9</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">5</span>, <span class="number">20</span>, <span class="number">3</span>)) <span class="comment">// 5..20 step 3</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">20</span>, <span class="number">5</span>, -<span class="number">3</span>)) <span class="comment">// Count down</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">5 6 7 8 9</span><br><span class="line">5 8 11 14 17</span><br><span class="line">20 17 14 11 8</span><br></pre></td></tr></table></figure><p><code>range()</code> 方法已被 <a href="./06-Housekeeping.md#方法重载">重载</a>（重载：同名方法，参数列表或类型不同）。上例中 <code>range()</code> 方法有多种重载形式：第一种产生从 0 至范围上限（不包含）的值；第二种产生参数一至参数二（不包含）范围内的整数值；第三种形式有一个步进值，因此它每次的增量为该值；第四种 <code>range()</code> 表明还可以递减。<code>range()</code> 无参方法是该生成器最简单的版本。有关内容会在本书稍后介绍。</p><p><code>range()</code> 的使用提高了代码可读性，让 <strong>for-in</strong> 循环在本书中适应更多的代码示例场景。</p><p>请注意，<code>System.out.print()</code> 不会输出换行符，所以我们可以分段输出同一行。</p><p><em>for-in</em> 语法可以节省我们编写代码的时间。 更重要的是，它提高了代码可读性以及更好地描述代码意图（获取数组的每个元素）而不是详细说明这操作细节（创建索引，并用它来选择数组元素） 本书推荐使用 <em>for-in</em> 语法。</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>在 Java 中有几个关键字代表无条件分支，这意味无需任何测试即可发生。这些关键字包括 <strong>return</strong>，<strong>break</strong>，<strong>continue</strong> 和跳转到带标签语句的方法，类似于其他语言中的 <strong>goto</strong>。</p><p><strong>return</strong> 关键字有两方面的作用：1.指定一个方法返回值 (在方法返回类型非 <strong>void</strong> 的情况下)；2.退出当前方法，并返回作用 1 中值。我们可以利用 <code>return</code> 的这些特点来改写上例 <code>IfElse.java</code> 文件中的 <code>test()</code> 方法。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/TestWithReturn.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithReturn</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> testval, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(testval &gt; target)</span><br><span class="line">      <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(testval &lt; target)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Match</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(test(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    System.out.println(test(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">    System.out.println(test(<span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">-1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这里不需要 <code>else</code>，因为该方法执行到 <code>return</code> 就结束了。</p><p>如果在方法签名中定义了返回值类型为 <strong>void</strong>，那么在代码执行结束时会有一个隐式的 <strong>return</strong>。 也就是说我们不用在总是在方法中显式地包含 <strong>return</strong> 语句。 <strong>注意</strong>：如果你的方法声明的返回值类型为非 <strong>void</strong> 类型，那么则必须确保每个代码路径都返回一个值。</p><h2 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h2><p>在任何迭代语句的主体内，都可以使用 <strong>break</strong> 和 <strong>continue</strong> 来控制循环的流程。 其中，<strong>break</strong> 表示跳出当前循环体。而 <strong>continue</strong> 表示停止本次循环，开始下一次循环。</p><p>下例向大家展示 <strong>break</strong> 和 <strong>continue</strong> 在 <strong>for</strong>、<strong>while</strong> 循环中的使用。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/BreakAndContinue.java</span></span><br><span class="line"><span class="comment">// Break 和 continue 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Range.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakAndContinue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">// [1]</span></span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">74</span>) <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">      <span class="keyword">if</span>(i % <span class="number">9</span> != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 下一次循环</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// 使用 for-in 循环:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">100</span>)) &#123; <span class="comment">// [2]</span></span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">74</span>) <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">      <span class="keyword">if</span>(i % <span class="number">9</span> != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 下一次循环</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  &quot;无限循环&quot;:</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; <span class="comment">// [3]</span></span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">int</span> j = i * <span class="number">27</span>;</span><br><span class="line">      <span class="keyword">if</span>(j == <span class="number">1269</span>) <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">      <span class="keyword">if</span>(i % <span class="number">10</span> != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 循环顶部</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 9 18 27 36 45 54 63 72</span><br><span class="line">0 9 18 27 36 45 54 63 72</span><br><span class="line">10 20 30 40</span><br></pre></td></tr></table></figure><p><sub><strong>[1]</strong> 在这个 <strong>for</strong> 循环中，<code>i</code> 的值永远不会达到 100，因为一旦 <code>i</code> 等于 74，<strong>break</strong> 语句就会中断循环。通常，只有在不知道中断条件何时满足时，才需要 <strong>break</strong>。因为 <code>i</code> 不能被 9 整除，<strong>continue</strong> 语句就会使循环从头开始。这使 <strong>i</strong> 递增)。如果能够整除，则将值显示出来。</sub><br><sub><strong>[2]</strong> 使用 <strong>for-in</strong> 语法，结果相同。</sub><br><sub><strong>[3]</strong> 无限 <strong>while</strong> 循环。循环内的 <strong>break</strong> 语句可中止循环。<strong>注意</strong>，<strong>continue</strong> 语句可将控制权移回循环的顶部，而不会执行 <strong>continue</strong> 之后的任何操作。 因此，只有当 <code>i</code> 的值可被 10 整除时才会输出。在输出中，显示值 0，因为 <code>0％9</code> 产生 0。还有一种无限循环的形式： <code>for(;;)</code>。 在编译器看来，它与 <code>while(true)</code> 无异，使用哪种完全取决于你的编程品味。</sub></p><h2 id="臭名昭著的-goto"><a href="#臭名昭著的-goto" class="headerlink" title="臭名昭著的 goto"></a>臭名昭著的 goto</h2><p><a href="https://en.wikipedia.org/wiki/Goto"><strong>goto</strong> 关键字</a> 很早就在程序设计语言中出现。事实上，<strong>goto</strong> 起源于<a href="https://en.wikipedia.org/wiki/Assembly_language">汇编</a>（assembly language）语言中的程序控制：“若条件 A 成立，则跳到这里；否则跳到那里”。如果你读过由编译器编译后的代码，你会发现在其程序控制中充斥了大量的跳转。较之汇编产生的代码直接运行在硬件 CPU 中，Java 也会产生自己的“汇编代码”（字节码），只不过它是运行在 Java 虚拟机里的（Java Virtual Machine）。</p><p>一个源码级别跳转的 <strong>goto</strong>，为何招致名誉扫地呢？若程序总是从一处跳转到另一处，还有什么办法能识别代码的控制流程呢？随着 <em>Edsger Dijkstra</em>发表著名的 “Goto 有害” 论（<em>Goto considered harmful</em>）以后，<strong>goto</strong> 便从此失宠。甚至有人建议将它从关键字中剔除。</p><p>正如上述提及的经典情况，我们不应走向两个极端。问题不在 <strong>goto</strong>，而在于过度使用 <strong>goto</strong>。在极少数情况下，<strong>goto</strong> 实际上是控制流程的最佳方式。</p><p>尽管 <strong>goto</strong> 仍是 Java 的一个保留字，但其并未被正式启用。可以说， Java 中并不支持 <strong>goto</strong>。然而，在 <strong>break</strong> 和 <strong>continue</strong> 这两个关键字的身上，我们仍能看出一些 <strong>goto</strong> 的影子。它们并不属于一次跳转，而是中断循环语句的一种方法。之所以把它们纳入 <strong>goto</strong> 问题中一起讨论，是由于它们使用了相同的机制：标签。</p><p>“标签”是后面跟一个冒号的标识符。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label1:</span><br></pre></td></tr></table></figure><p>对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方 —— 在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于 <strong>break</strong> 和 <strong>continue</strong> 关键字通常只中断当前循环，但若搭配标签一起使用，它们就会中断并跳转到标签所在的地方开始执行。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">label1:</span><br><span class="line">outer-iteration &#123;</span><br><span class="line">  inner-iteration &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// [1]</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">continue</span>; <span class="comment">// [2]</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">continue</span> label1; <span class="comment">// [3]</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">break</span> label1; <span class="comment">// [4]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><sub><strong>[1]</strong> <strong>break</strong> 中断内部循环，并在外部循环结束。</sub><br><sub><strong>[2]</strong> <strong>continue</strong> 移回内部循环的起始处。但在条件 3 中，<strong>continue label1</strong> 却同时中断内部循环以及外部循环，并移至 <strong>label1</strong> 处。</sub><br><sub><strong>[3]</strong> 随后，它实际是继续循环，但却从外部循环开始。</sub><br><sub><strong>[4]</strong> <strong>break label1</strong> 也会中断所有循环，并回到 <strong>label1</strong> 处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。</sub></p><p>下面是 <strong>for</strong> 循环的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/LabeledFor.java</span></span><br><span class="line"><span class="comment">// 搭配“标签 break”的 for 循环中使用 break 和 continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LabeledFor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    outer: <span class="comment">// 此处不允许存在执行语句</span></span><br><span class="line">    <span class="keyword">for</span>(; <span class="keyword">true</span> ;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">      inner: <span class="comment">// 此处不允许存在执行语句</span></span><br><span class="line">      <span class="keyword">for</span>(; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;break&quot;</span>);</span><br><span class="line">          i++; <span class="comment">// 否则 i 永远无法获得自增</span></span><br><span class="line">               <span class="comment">// 获得自增</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">7</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;continue outer&quot;</span>);</span><br><span class="line">          i++;  <span class="comment">// 否则 i 永远无法获得自增</span></span><br><span class="line">                <span class="comment">// 获得自增</span></span><br><span class="line">          <span class="keyword">continue</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">8</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;break outer&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(k == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;continue inner&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span> inner;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在此处无法 break 或 continue 标签</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">continue inner</span><br><span class="line">i = 1</span><br><span class="line">continue inner</span><br><span class="line">i = 2</span><br><span class="line">continue</span><br><span class="line">i = 3</span><br><span class="line">break</span><br><span class="line">i = 4</span><br><span class="line">continue inner</span><br><span class="line">i = 5</span><br><span class="line">continue inner</span><br><span class="line">i = 6</span><br><span class="line">continue inner</span><br><span class="line">i = 7</span><br><span class="line">continue outer</span><br><span class="line">i = 8</span><br><span class="line">break outer</span><br></pre></td></tr></table></figure><p>注意 <strong>break</strong> 会中断 <strong>for</strong> 循环，而且在抵达 <strong>for</strong> 循环的末尾之前，递增表达式不会执行。由于 <strong>break</strong> 跳过了递增表达式，所以递增会在 <code>i==3</code> 的情况下直接执行。在 <code>i==7</code> 的情况下，<code>continue outer</code> 语句也会到达循环顶部，而且也会跳过递增，所以它也是直接递增的。</p><p>如果没有 <strong>break outer</strong> 语句，就没有办法在一个内部循环里找到出外部循环的路径。这是由于 <strong>break</strong> 本身只能中断最内层的循环（对于 <strong>continue</strong> 同样如此）。 当然，若想在中断循环的同时退出方法，简单地用一个 <strong>return</strong> 即可。</p><p>下面这个例子向大家展示了带标签的 <strong>break</strong> 以及 <strong>continue</strong> 语句在 <strong>while</strong> 循环中的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/LabeledWhile.java</span></span><br><span class="line"><span class="comment">// 带标签的 break 和 conitue 在 while 循环中的使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LabeledWhile</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Outer while loop&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;continue outer&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;break&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">7</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;break outer&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Outer while loop</span><br><span class="line">i = 1</span><br><span class="line">continue</span><br><span class="line">i = 2</span><br><span class="line">i = 3</span><br><span class="line">continue outer</span><br><span class="line">Outer while loop</span><br><span class="line">i = 4</span><br><span class="line">i = 5</span><br><span class="line">break</span><br><span class="line">Outer while loop</span><br><span class="line">i = 6</span><br><span class="line">i = 7</span><br><span class="line">break outer</span><br></pre></td></tr></table></figure><p>同样的规则亦适用于 <strong>while</strong>：</p><ol><li><p>简单的一个 <strong>continue</strong> 会退回最内层循环的开头（顶部），并继续执行。</p></li><li><p>带有标签的 <strong>continue</strong> 会到达标签的位置，并重新进入紧接在那个标签后面的循环。</p></li><li><p><strong>break</strong> 会中断当前循环，并移离当前标签的末尾。</p></li><li><p>带标签的 <strong>break</strong> 会中断当前循环，并移离由那个标签指示的循环的末尾。</p></li></ol><p>大家要记住的重点是：在 Java 里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中 <strong>break</strong> 或 <strong>continue</strong>。</p><p><strong>break</strong> 和 <strong>continue</strong> 标签在编码中的使用频率相对较低 (此前的语言中很少使用或没有先例)，所以我们很少在代码里看到它们。</p><p>在 <em>Dijkstra</em> 的 <strong>“Goto 有害”</strong> 论文中，他最反对的就是标签，而非 <strong>goto</strong>。他观察到 BUG 的数量似乎随着程序中标签的数量而增加<sup><a href="#fn_2" id="reffn_2">2</a></sup>。标签和 <strong>goto</strong> 使得程序难以分析。但是，Java 标签不会造成这方面的问题，因为它们的应用场景受到限制，无法用于以临时方式传输控制。由此也引出了一个有趣的情形：对语言能力的限制，反而使它这项特性更加有价值。</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><strong>switch</strong> 有时也被划归为一种选择语句。根据整数表达式的值，<strong>switch</strong> 语句可以从一系列代码中选出一段去执行。它的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector) &#123;</span><br><span class="line"><span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> integral-value2 : statement;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> integral-value3 : statement;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> integral-value4 : statement;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> integral-value5 : statement;<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>integral-selector</strong> （整数选择因子）是一个能够产生整数值的表达式，<strong>switch</strong> 能够将这个表达式的结果与每个 <strong>integral-value</strong> （整数值）相比较。若发现相符的，就执行对应的语句（简单或复合语句，其中并不需要括号）。若没有发现相符的，就执行 <strong>default</strong> 语句。</p><p>在上面的定义中，大家会注意到每个 <strong>case</strong> 均以一个 <strong>break</strong> 结尾。这样可使执行流程跳转至 <strong>switch</strong> 主体的末尾。这是构建 <strong>switch</strong> 语句的一种传统方式，但 <strong>break</strong> 是可选的。若省略 <strong>break，</strong> 会继续执行后面的 <strong>case</strong> 语句的代码，直到遇到一个 <strong>break</strong> 为止。通常我们不想出现这种情况，但对有经验的程序员来说，也许能够善加利用。注意最后的 <strong>default</strong> 语句没有 <strong>break</strong>，因为执行流程已到了 <strong>break</strong> 的跳转目的地。当然，如果考虑到编程风格方面的原因，完全可以在 <strong>default</strong> 语句的末尾放置一个 <strong>break</strong>，尽管它并没有任何实际的作用。</p><p><strong>switch</strong> 语句是一种实现多路选择的干净利落的一种方式（比如从一系列执行路径中挑选一个）。但它要求使用一个选择因子，并且必须是 <strong>int</strong> 或 <strong>char</strong> 那样的整数值。例如，假若将一个字串或者浮点数作为选择因子使用，那么它们在 switch 语句里是不会工作的。对于非整数类型（Java 7 以上版本中的 String 型除外），则必须使用一系列 <strong>if</strong> 语句。 在<a href="./06-Housekeeping.md#枚举类型">下一章的结尾</a> 中，我们将会了解到<strong>枚举类型</strong>被用来搭配 <strong>switch</strong> 工作，并优雅地解决了这种限制。</p><p>下面这个例子可随机生成字母，并判断它们是元音还是辅音字母：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/VowelsAndConsonants.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 执行语句的演示</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VowelsAndConsonants</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = rand.nextInt(<span class="number">26</span>) + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>)c + <span class="string">&quot;, &quot;</span> + c + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">      <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>: System.out.println(<span class="string">&quot;vowel&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>: System.out.println(<span class="string">&quot;Sometimes vowel&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:  System.out.println(<span class="string">&quot;consonant&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">y, 121: Sometimes vowel</span><br><span class="line">n, 110: consonant</span><br><span class="line">z, 122: consonant</span><br><span class="line">b, 98: consonant</span><br><span class="line">r, 114: consonant</span><br><span class="line">n, 110: consonant</span><br><span class="line">y, 121: Sometimes vowel</span><br><span class="line">g, 103: consonant</span><br><span class="line">c, 99: consonant</span><br><span class="line">f, 102: consonant</span><br><span class="line">o, 111: vowel</span><br><span class="line">w, 119: Sometimes vowel</span><br><span class="line">z, 122: consonant</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>由于 <code>Random.nextInt(26)</code> 会产生 0 到 25 之间的一个值，所以在其上加上一个偏移量 <code>a</code>，即可产生小写字母。在 <strong>case</strong> 语句中，使用单引号引起的字符也会产生用于比较的整数值。</p><p>请注意 <strong>case</strong> 语句能够堆叠在一起，为一段代码形成多重匹配，即只要符合多种条件中的一种，就执行那段特别的代码。这时也应该注意将 <strong>break</strong> 语句置于特定 <strong>case</strong> 的末尾，否则控制流程会继续往下执行，处理后面的 <strong>case</strong>。在下面的语句中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = rand.nextInt(<span class="number">26</span>) + <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此处 <code>Random.nextInt()</code> 将产生 0~25 之间的一个随机 <strong>int</strong> 值，它将被加到 <code>a</code> 上。这表示 <code>a</code> 将自动被转换为 <strong>int</strong> 以执行加法。为了把 <code>c</code> 当作字符打印，必须将其转型为 <strong>char</strong>；否则，将会输出整数。</p><h2 id="switch-字符串"><a href="#switch-字符串" class="headerlink" title="switch 字符串"></a>switch 字符串</h2><p>Java 7 增加了在字符串上 <strong>switch</strong> 的用法。 下例展示了从一组 <strong>String</strong> 中选择可能值的传统方法，以及新式方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/StringSwitch.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSwitch</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="comment">// 老的方式: 使用 if-then 判断</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;red&quot;</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;green&quot;</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;GREEN&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;blue&quot;</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;yellow&quot;</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;YELLOW&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的方法: 字符串搭配 switch</span></span><br><span class="line">    <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;green&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;GREEN&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;yellow&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;YELLOW&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RED</span><br><span class="line">RED</span><br></pre></td></tr></table></figure><p>一旦理解了 <strong>switch</strong>，你会明白这其实就是一个逻辑扩展的语法糖。新的编码方式能使得结果更清晰，更易于理解和维护。</p><p>作为 <strong>switch</strong> 字符串的第二个例子，我们重新访问 <code>Math.random()</code>。 它是否产生从 0 到 1 的值，包括还是不包括值 1 呢？在数学术语中，它属于 (0,1)、 [0,1)、(0,1] 、[0,1] 中的哪种呢？（方括号表示“包括”，而括号表示“不包括”）</p><p>下面是一个可能提供答案的测试程序。 所有命令行参数都作为 <strong>String</strong> 对象传递，因此我们可以 <strong>switch</strong> 参数来决定要做什么。 那么问题来了：如果用户不提供参数 ，索引到 <code>args</code> 的数组就会导致程序失败。 解决这个问题，我们需要预先检查数组的长度，若长度为 0，则使用<strong>空字符串</strong> <code>&quot;&quot;</code> 替代；否则，选择 <code>args</code> 数组中的第一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/RandomBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.random() 会产生 0.0 和 1.0 吗？</span></span><br><span class="line"><span class="comment">// &#123;java RandomBounds lower&#125;</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomBounds</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TimedAbort(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">switch</span>(args.length == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : args[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;lower&quot;</span>:</span><br><span class="line">        <span class="keyword">while</span>(Math.random() != <span class="number">0.0</span>)</span><br><span class="line">          ; <span class="comment">// 保持重试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Produced 0.0!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;upper&quot;</span>:</span><br><span class="line">        <span class="keyword">while</span>(Math.random() != <span class="number">1.0</span>)</span><br><span class="line">          ; <span class="comment">// 保持重试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Produced 1.0!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Usage:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\tRandomBounds lower&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\tRandomBounds upper&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要运行该程序，请键入以下任一命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java RandomBounds lower</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">java RandomBounds upper</span><br></pre></td></tr></table></figure><p>使用 <code>onjava</code> 包中的 <strong>TimedAbort</strong> 类可使程序在三秒后中止。从结果来看，似乎 <code>Math.random()</code> 产生的随机值里不包含 0.0 或 1.0。 这就是该测试容易混淆的地方：若要考虑 0 至 1 之间所有不同 <strong>double</strong> 数值的可能性，那么这个测试的耗费的时间可能超出一个人的寿命了。 这里我们直接给出正确的结果：<code>Math.random()</code> 的结果集范围包含 0.0 ，不包含 1.0。 在数学术语中，可用 [0,1）来表示。由此可知，我们必须小心分析实验并了解它们的局限性。</p><h2 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h2><p>本章总结了我们对大多数编程语言中出现的基本特性的探索：计算，运算符优先级，类型转换，选择和迭代。 现在让我们准备好，开始步入面向对象和函数式编程的世界吧。 下一章的内容涵盖了 Java 编程中的重要问题：对象的<a href="./06-Housekeeping.md">初始化和清理</a>。紧接着，还会介绍<a href="./07-Implementation-Hiding.md">封装</a>（implementation hiding）的核心概念。</p><blockquote id="fn_1"><sup>1</sup>. 在早期的语言中，许多决策都是基于让编译器设计者的体验更好。 但在现代语言设计中，许多决策都是为了提高语言使用者的体验，尽管有时会有妥协 —— 这通常会让语言设计者后悔。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <strong>注意</strong>，此处观点似乎难以让人信服，很可能只是一个因认知偏差而造成的<a href="https://en.wikipedia.org/wiki/Correlation_does_not_imply_causation">因果关系谬误</a> 的例子。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><h1 id="第-6-章-初始化和清理"><a href="#第-6-章-初始化和清理" class="headerlink" title="第 6 章 初始化和清理"></a>第 6 章 初始化和清理</h1><p>“不安全”的编程是造成编程代价昂贵的罪魁祸首之一。有两个安全性问题：初始化和清理。C 语言中很多的 bug 都是因为程序员忘记初始化导致的。尤其是很多类库的使用者不知道如何初始化类库组件，甚至他们必须得去初始化。清理则是另一个特殊的问题，因为当你使用一个元素做完事后就不会去关心这个元素，所以你很容易忘记清理它。这样就造成了元素使用的资源滞留不会被回收，直到程序消耗完所有的资源（特别是内存）。</p><p>C++ 引入了构造器的概念，这是一个特殊的方法，每创建一个对象，这个方法就会被自动调用。Java 采用了构造器的概念，另外还使用了垃圾收集器（Garbage Collector, GC）去自动回收不再被使用的对象所占的资源。这一章将讨论初始化和清理的问题，以及在 Java 中对它们的支持。</p><h2 id="利用构造器保证初始化"><a href="#利用构造器保证初始化" class="headerlink" title="利用构造器保证初始化"></a>利用构造器保证初始化</h2><p>你可能想为每个类创建一个 <code>initialize()</code> 方法，该方法名暗示着在使用类之前需要先调用它。不幸的是，用户必须得记得去调用它。在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。下个挑战是如何命名构造器方法。存在两个问题：第一个是任何命名都可能与类中其他已有元素的命名冲突；第二个是编译器必须始终知道构造器方法名称，从而调用它。C++ 的解决方法看起来是最简单且最符合逻辑的，所以 Java 中使用了同样的方式：构造器名称与类名相同。在初始化过程中自动调用构造器方法是有意义的。</p><p>以下示例是包含了一个构造器的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/SimpleConstructor.java</span></span><br><span class="line"><span class="comment">// Demonstration of a simple constructor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span> </span>&#123;</span><br><span class="line">    Rock() &#123; <span class="comment">// 这是一个构造器</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Rock &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock</span><br></pre></td></tr></table></figure><p>现在，当创建一个对象时：<code>new Rock()</code> ，内存被分配，构造器被调用。构造器保证了对象在你使用它之前进行了正确的初始化。</p><p>有一点需要注意，构造器方法名与类名相同，不需要符合首字母小写的编程风格。在 C++ 中，无参构造器被称为默认构造器，这个术语在 Java 出现之前使用了很多年。但是，出于一些原因，Java 设计者们决定使用无参构造器这个名称，我（作者）认为这种叫法笨拙而且没有必要，所以我打算继续使用默认构造器。Java 8 引入了 <strong>default</strong> 关键字修饰方法，所以算了，我还是用无参构造器的叫法吧。</p><p>跟其他方法一样，构造器方法也可以传入参数来定义如何创建一个对象。之前的例子稍作修改，使得构造器接收一个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/SimpleConstructor2.java</span></span><br><span class="line"><span class="comment">// Constructors can have arguments</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock2</span> </span>&#123;</span><br><span class="line">    Rock2(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Rock &quot;</span> + i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConstructor2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Rock2(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rock <span class="number">0</span> Rock <span class="number">1</span> Rock <span class="number">2</span> Rock <span class="number">3</span> Rock <span class="number">4</span> Rock <span class="number">5</span> Rock <span class="number">6</span> Rock <span class="number">7</span></span><br></pre></td></tr></table></figure><p>如果类 <strong>Tree</strong> 有一个构造方法，只接收一个参数用来表示树的高度，那么你可以像下面这样创建一棵树:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tree t = <span class="keyword">new</span> Tree(<span class="number">12</span>); <span class="comment">// 12-foot 树</span></span><br></pre></td></tr></table></figure><p>如果 <strong>Tree(int)</strong> 是唯一的构造器，那么编译器就不允许你以其他任何方式创建 <strong>Tree</strong> 类型的对象。</p><p>构造器消除了一类重要的问题，使得代码更易读。例如，在上面的代码块中，你看不到对 <code>initialize()</code> 方法的显式调用，而从概念上来看，<code>initialize()</code> 方法应该与对象的创建分离。在 Java 中，对象的创建与初始化是统一的概念，二者不可分割。</p><p>构造器没有返回值，它是一种特殊的方法。但它和返回类型为 <code>void</code> 的普通方法不同，普通方法可以返回空值，你还能选择让它返回别的类型；而构造器没有返回值，却同时也没有给你选择的余地（<code>new</code> 表达式虽然返回了刚创建的对象的引用，但构造器本身却没有返回任何值）。如果它有返回值，并且你也可以自己选择让它返回什么，那么编译器就还得知道接下来该怎么处理那个返回值（这个返回值没有接收者）。</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>任何编程语言中都具备的一项重要特性就是命名。当你创建一个对象时，就会给此对象分配的内存空间命名。方法是行为的命名。你通过名字指代所有的对象，属性和方法。良好命名的系统易于理解和修改。就好比写散文——目的是与读者沟通。</p><p>将人类语言细微的差别映射到编程语言中会产生一个问题。通常，相同的词可以表达多种不同的含义——它们被”重载”了。特别是当含义的差别很小时，这会更加有用。你会说”清洗衬衫”、”清洗车”和”清洗狗”。而如果硬要这么说就会显得很愚蠢：”以洗衬衫的方式洗衬衫”、”以洗车的方式洗车”和”以洗狗的方式洗狗”，因为听众根本不需要区分行为的动作。大多数人类语言都具有”冗余”性，所以即使漏掉几个词，你也能明白含义。你不需要对每个概念都使用不同的词汇——可以从上下文推断出含义。</p><p>大多数编程语言（尤其是 C 语言）要求为每个方法（在这些语言中经常称为函数）提供一个独一无二的标识符。所以，你不能有一个 <code>print()</code> 函数既能打印整型，也能打印浮点型——每个函数名都必须不同。</p><p>在 Java (C++) 中，还有一个因素也促使了必须使用方法重载：构造器。因为构造器方法名肯定是与类名相同，所以一个类中只会有一个构造器名。那么你怎么通过不同的方式创建一个对象呢？例如，你想创建一个类，这个类的初始化方式有两种：一种是标准化方式，另一种是从文件中读取信息的方式。你需要两个构造器：无参构造器和有一个 <strong>String</strong> 类型参数的构造器，该参数传入文件名。两个构造器具有相同的名字——与类名相同。因此，方法重载是必要的，它允许方法具有相同的方法名但接收的参数不同。尽管方法重载对于构造器是重要的，但是也可以对任何方法很方便地进行重载。</p><p>下例展示了如何重载构造器和方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Overloading.java</span></span><br><span class="line"><span class="comment">// Both constructor and ordinary method overloading</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    Tree() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Planting a seedling&quot;</span>);</span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight) &#123;</span><br><span class="line">        height = initialHeight;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating new Tree that is &quot;</span> + height + <span class="string">&quot; feet tall&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tree is &quot;</span> + height + <span class="string">&quot; feet tall&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s + <span class="string">&quot;: Tree is &quot;</span> + height + <span class="string">&quot; feet tall&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Tree t = <span class="keyword">new</span> Tree(i);</span><br><span class="line">            t.info();</span><br><span class="line">            t.info(<span class="string">&quot;overloaded method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Tree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Creating <span class="keyword">new</span> Tree that is <span class="number">0</span> feet tall</span><br><span class="line">Tree is <span class="number">0</span> feet tall</span><br><span class="line">overloaded method: Tree is <span class="number">0</span> feet tall</span><br><span class="line">Creating <span class="keyword">new</span> Tree that is <span class="number">1</span> feet tall</span><br><span class="line">Tree is <span class="number">1</span> feet tall</span><br><span class="line">overloaded method: Tree is <span class="number">1</span> feet tall</span><br><span class="line">Creating <span class="keyword">new</span> Tree that is <span class="number">2</span> feet tall</span><br><span class="line">Tree is <span class="number">2</span> feet tall</span><br><span class="line">overloaded method: Tree is <span class="number">2</span> feet tall</span><br><span class="line">Creating <span class="keyword">new</span> Tree that is <span class="number">3</span> feet tall</span><br><span class="line">Tree is <span class="number">3</span> feet tall</span><br><span class="line">overloaded method: Tree is <span class="number">3</span> feet tall</span><br><span class="line">Creating <span class="keyword">new</span> Tree that is <span class="number">4</span> feet tall</span><br><span class="line">Tree is <span class="number">4</span> feet tall</span><br><span class="line">overloaded method: Tree is <span class="number">4</span> feet tall</span><br><span class="line">Planting a seedling</span><br></pre></td></tr></table></figure><p>一个 <strong>Tree</strong> 对象既可以是一颗树苗，使用无参构造器创建，也可以是一颗在温室中已长大的树，已经有一定高度，这时候，就需要使用有参构造器创建。</p><p>你也许想以多种方式调用 <code>info()</code> 方法。比如，如果你想打印额外的消息，就可以使用 <code>info(String)</code> 方法。如果你无话可说，就可以使用 <code>info()</code> 方法。用两个命名定义完全相同的概念看起来很奇怪，而使用方法重载，你就可以使用一个命名来定义一个概念。</p><h3 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h3><p>如果两个方法命名相同，Java 是怎么知道你调用的是哪个呢？有一条简单的规则：每个被重载的方法必须有独一无二的参数列表。你稍微思考下，就会很明了了，除了通过参数列表的不同来区分两个相同命名的方法，其他也没什么方式了。你甚至可以根据参数列表中的参数顺序来区分不同的方法，尽管这会造成代码难以维护。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OverloadingOrder.java</span></span><br><span class="line"><span class="comment">// Overloading based on the order of the arguments</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingOrder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;String: &quot;</span> + s + <span class="string">&quot;, int: &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int: &quot;</span> + i + <span class="string">&quot;, String: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="string">&quot;String first&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        f(<span class="number">99</span>, <span class="string">&quot;Int first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String: String first, <span class="keyword">int</span>: <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span>: <span class="number">99</span>, String: Int first</span><br></pre></td></tr></table></figure><p>两个 <code>f()</code> 方法具有相同的参数，但是参数顺序不同，根据这个就可以区分它们。</p><h3 id="重载与基本类型"><a href="#重载与基本类型" class="headerlink" title="重载与基本类型"></a>重载与基本类型</h3><p>基本类型可以自动从较小的类型转型为较大的类型。当这与重载结合时，这会令人有点困惑，下面是一个这样的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/PrimitiveOverloading.java</span></span><br><span class="line"><span class="comment">// Promotion of primitives and overloading</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveOverloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(char)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(byte)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(short)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(byte)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(short)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(short)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f4(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f4(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f4(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f4(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f5(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f5(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f5(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f6(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f6(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f7</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f7(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testConstVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;5: &quot;</span>);</span><br><span class="line">        f1(<span class="number">5</span>);f2(<span class="number">5</span>);f3(<span class="number">5</span>);f4(<span class="number">5</span>);f5(<span class="number">5</span>);f6(<span class="number">5</span>);f7(<span class="number">5</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> x = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;char: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;byte: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;short: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;int: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;long: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;float: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;double: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrimitiveOverloading p = <span class="keyword">new</span> PrimitiveOverloading();</span><br><span class="line">        p.testConstVal();</span><br><span class="line">        p.testChar();</span><br><span class="line">        p.testByte();</span><br><span class="line">        p.testShort();</span><br><span class="line">        p.testInt();</span><br><span class="line">        p.testLong();</span><br><span class="line">        p.testFloat();</span><br><span class="line">        p.testDouble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>: f1(<span class="keyword">int</span>)f2(<span class="keyword">int</span>)f3(<span class="keyword">int</span>)f4(<span class="keyword">int</span>)f5(<span class="keyword">long</span>)f6(<span class="keyword">float</span>)f7(<span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">char</span>: f1(<span class="keyword">char</span>)f2(<span class="keyword">int</span>)f3(<span class="keyword">int</span>)f4(<span class="keyword">int</span>)f5(<span class="keyword">long</span>)f6(<span class="keyword">float</span>)f7(<span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">byte</span>: f1(<span class="keyword">byte</span>)f2(<span class="keyword">byte</span>)f3(<span class="keyword">short</span>)f4(<span class="keyword">int</span>)f5(<span class="keyword">long</span>)f6(<span class="keyword">float</span>)f7(<span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">short</span>: f1(<span class="keyword">short</span>)f2(<span class="keyword">short</span>)f3(<span class="keyword">short</span>)f4(<span class="keyword">int</span>)f5(<span class="keyword">long</span>)f6(<span class="keyword">float</span>)f7(<span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">int</span>: f1(<span class="keyword">int</span>)f2(<span class="keyword">int</span>)f3(<span class="keyword">int</span>)f4(<span class="keyword">int</span>)f5(<span class="keyword">long</span>)f6(<span class="keyword">float</span>)f7(<span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">long</span>: f1(<span class="keyword">long</span>)f2(<span class="keyword">long</span>)f3(<span class="keyword">long</span>)f4(<span class="keyword">long</span>)f5(<span class="keyword">long</span>)f6(<span class="keyword">float</span>)f7(<span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">float</span>: f1(<span class="keyword">float</span>)f2(<span class="keyword">float</span>)f3(<span class="keyword">float</span>)f4(<span class="keyword">float</span>)f5(<span class="keyword">float</span>)f6(<span class="keyword">float</span>)f7(<span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">double</span>: f1(<span class="keyword">double</span>)f2(<span class="keyword">double</span>)f3(<span class="keyword">double</span>)f4(<span class="keyword">double</span>)f5(<span class="keyword">double</span>)f6(<span class="keyword">double</span>)f7(<span class="keyword">double</span>)</span><br></pre></td></tr></table></figure><p>如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。</p><h3 id="返回值的重载"><a href="#返回值的重载" class="headerlink" title="返回值的重载"></a>返回值的重载</h3><p>经常会有人困惑，”为什么只能通过类名和参数列表，不能通过方法的返回值区分方法呢?”。例如以下两个方法，它们有相同的命名和参数，但是很容易区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><p>有些情况下，编译器很容易就可以从上下文准确推断出该调用哪个方法，如 <code>int x = f()</code>。</p><p>但是，你可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用 <code>f()</code>，Java 编译器就不知道你想调用哪个方法，阅读者也不明所以。因为这个原因，所以你不能根据返回值类型区分重载的方法。为了支持新特性，Java 8 在一些具体情形下提高了猜测的准确度，但是通常来说并不起作用。</p><h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><p>如前文所说，一个无参构造器就是不接收参数的构造器，用来创建一个”默认的对象”。如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/DefaultConstructor.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird(); <span class="comment">// 默认的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式 <code>new Bird()</code> 创建了一个新对象，调用了无参构造器，尽管在 <strong>Bird</strong> 类中并没有显式的定义无参构造器。试想如果没有构造器，我们如何创建一个对象呢。但是,一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/NoSynthesis.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird2</span> </span>&#123;</span><br><span class="line">    Bird2(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">    Bird2(<span class="keyword">double</span> d) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSynthesis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- Bird2 b = new Bird2(); // No default</span></span><br><span class="line">        Bird2 b2 = <span class="keyword">new</span> Bird2(<span class="number">1</span>);</span><br><span class="line">        Bird2 b3 = <span class="keyword">new</span> Bird2(<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你调用了 <code>new Bird2()</code> ，编译器会提示找不到匹配的构造器。当类中没有构造器时，编译器会说”你一定需要构造器，那么让我为你创建一个吧”。但是如果类中有构造器，编译器会说”你已经写了构造器了，所以肯定知道你在做什么，如果你没有创建默认构造器，说明你本来就不需要”。</p><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>对于两个相同类型的对象 <strong>a</strong> 和 <strong>b</strong>，你可能在想如何调用这两个对象的 <code>peel()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/BananaPeel.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">peel</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaPeel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Banana a = <span class="keyword">new</span> Banana(), b = <span class="keyword">new</span> Banana();</span><br><span class="line">        a.peel(<span class="number">1</span>);</span><br><span class="line">        b.peel(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只有一个方法 <code>peel()</code> ，那么怎么知道调用的是对象 <strong>a</strong> 的 <code>peel()</code>方法还是对象 <strong>b</strong> 的 <code>peel()</code> 方法呢？编译器做了一些底层工作，所以你可以像这样编写代码。<code>peel()</code> 方法中第一个参数隐密地传入了一个指向操作对象的</p><p>引用。因此，上述例子中的方法调用像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Banana.peel(a, <span class="number">1</span>)</span><br><span class="line">Banana.peel(b, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这是在内部实现的，你不可以直接这么编写代码，编译器不会接受，但能说明到底发生了什么。假设现在在方法内部，你想获得对当前对象的引用。但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，有一个关键字: <strong>this</strong> 。<strong>this</strong> 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，<strong>this</strong> 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法，不要使用 <strong>this</strong>，直接调用即可，<strong>this</strong> 自动地应用于其他方法上了。因此你可以像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Apricot.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apricot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pick();</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>pit()</code> 方法中，你可以使用 <code>this.pick()</code>，但是没有必要。编译器自动为你做了这些。<strong>this</strong> 关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，用在 <strong>return</strong> 语句中返回对当前对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Leaf.java</span></span><br><span class="line"><span class="comment">// Simple use of the &quot;this&quot; keyword</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Leaf <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leaf x = <span class="keyword">new</span> Leaf();</span><br><span class="line">        x.increment().increment().increment().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = 3</span><br></pre></td></tr></table></figure><p>因为 <code>increment()</code> 通过 <strong>this</strong> 关键字返回当前对象的引用，因此在相同的对象上可以轻易地执行多次操作。</p><p><strong>this</strong> 关键字在向其他方法传递当前对象时也很有用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/PassingThis.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        Apple peeled = apple.getPeeled();</span><br><span class="line">        System.out.println(<span class="string">&quot;Yummy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Peeler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... remove peel</span></span><br><span class="line">        <span class="keyword">return</span> apple; <span class="comment">// Peeled</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassingThis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person().eat(<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yummy</span><br></pre></td></tr></table></figure><p><strong>Apple</strong> 因为某些原因（比如说工具类中的方法在多个类中重复出现，你不想代码重复），必须调用一个外部工具方法 <code>Peeler.peel()</code> 做一些行为。必须使用 <strong>this</strong> 才能将自身传递给外部方法。</p><h3 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h3><p>当你在一个类中写了多个构造器，有时你想在一个构造器中调用另一个构造器来避免代码重复。你通过 <strong>this</strong> 关键字实现这样的调用。</p><p>通常当你说 <strong>this</strong>，意味着”这个对象”或”当前对象”，它本身生成对当前对象的引用。在一个构造器中，当你给 <strong>this</strong> 一个参数列表时，它是另一层意思。它通过最直接的方式显式地调用匹配参数列表的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Flower.java</span></span><br><span class="line"><span class="comment">// Calling constructors with &quot;this&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">    String s = <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Flower(<span class="keyword">int</span> petals) &#123;</span><br><span class="line">        petalCount = petals;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor w/ int arg only, petalCount = &quot;</span> + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower(String ss) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor w/ string arg only, s = &quot;</span> + ss);</span><br><span class="line">        s = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower(String s, <span class="keyword">int</span> petals) &#123;</span><br><span class="line">        <span class="keyword">this</span>(petals);</span><br><span class="line">        <span class="comment">//- this(s); // Can&#x27;t call two!</span></span><br><span class="line">        <span class="keyword">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;no-arg constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPetalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- this(11); // Not inside constructor!</span></span><br><span class="line">        System.out.println(<span class="string">&quot;petalCount = &quot;</span> + petalCount + <span class="string">&quot; s = &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Flower x = <span class="keyword">new</span> Flower();</span><br><span class="line">        x.printPetalCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor w/ int arg only, petalCount = 47</span><br><span class="line">String &amp; int args</span><br><span class="line">no-arg constructor</span><br><span class="line">petalCount = 47 s = hi</span><br></pre></td></tr></table></figure><p>从构造器 <code>Flower(String s, int petals)</code> 可以看出，其中只能通过 <strong>this</strong> 调用一次构造器。另外，必须首先调用构造器，否则编译器会报错。这个例子同样展示了 <strong>this</strong> 的另一个用法。参数列表中的变量名 <strong>s</strong> 和成员变量名 <strong>s</strong> 相同，会引起混淆。你可以通过 <code>this.s</code> 表明你指的是成员变量 <strong>s</strong>，从而避免重复。你经常会在 Java 代码中看到这种用法，同时本书中也会多次出现这种写法。在 <code>printPetalCount()</code> 方法中，编译器不允许你在一个构造器之外的方法里调用构造器。</p><h3 id="static-的含义"><a href="#static-的含义" class="headerlink" title="static 的含义"></a>static 的含义</h3><p>记住了 <strong>this</strong> 关键字的内容，你会对 <strong>static</strong> 修饰的方法有更加深入的理解：<strong>static</strong> 方法中不会存在 <strong>this</strong>。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以被其他的静态方法和静态属性访问。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 <strong>this</strong>，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的 <strong>static</strong> 方法，就该重新考虑自己的设计了。然而，<strong>static</strong> 的概念很实用，许多时候都要用到它。至于它是否真的”面向对象”，就留给理论家去讨论吧。</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>程序员都了解初始化的重要性，但通常会忽略清理的重要性。毕竟，谁会去清理一个 <strong>int</strong> 呢？但是使用完一个对象就不管它并非总是安全的。Java 中有垃圾回收器回收无用对象占用的内存。但现在考虑一种特殊情况：你创建的对象不是通过 <strong>new</strong> 来分配内存的，而垃圾回收器只知道如何释放用 <strong>new</strong> 创建的对象的内存，所以它不知道如何回收不是 <strong>new</strong> 分配的内存。为了处理这种情况，Java 允许在类中定义一个名为 <code>finalize()</code> 的方法。</p><p>它的工作原理”假定”是这样的：当垃圾回收器准备回收对象的内存时，首先会调用其 <code>finalize()</code> 方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。所以如果你打算使用 <code>finalize()</code> ，就能在垃圾回收时做一些重要的清理工作。<code>finalize()</code> 是一个潜在的编程陷阱，因为一些程序员（尤其是 C++ 程序员）会一开始把它误认为是 C++ 中的析构函数（C++ 在销毁对象时会调用这个函数）。所以有必要明确区分一下：在 C++ 中，对象总是被销毁的（在一个 bug-free 的程序中），而在 Java 中，对象并非总是被垃圾回收，或者换句话说：</p><ol><li>对象可能不被垃圾回收。</li><li>垃圾回收不等同于析构。</li></ol><p>这意味着在你不再需要某个对象之前，如果必须执行某些动作，你得自己去做。Java 没有析构器或类似的概念，所以你必须得自己创建一个普通的方法完成这项清理工作。例如，对象在创建的过程中会将自己绘制到屏幕上。如果不是明确地从屏幕上将其擦除，它可能永远得不到清理。如果在 <code>finalize()</code> 方法中加入某种擦除功能，那么当垃圾回收发生时，<code>finalize()</code> 方法被调用（不保证一定会发生），图像就会被擦除，要是”垃圾回收”没有发生，图像则仍会保留下来。</p><p>也许你会发现，只要程序没有濒临内存用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，而垃圾回收器一直没有释放你创建的任何对象的内存，则当程序退出时，那些资源会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。</p><h3 id="finalize-的用途"><a href="#finalize-的用途" class="headerlink" title="finalize() 的用途"></a><code>finalize()</code> 的用途</h3><p>如果你不能将 <code>finalize()</code> 作为通用的清理方法，那么这个方法有什么用呢？</p><p>这引入了要记住的第 3 点：</p><ol><li>垃圾回收只与内存有关。</li></ol><p>也就是说，使用垃圾回收的唯一原因就是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是 <code>finalize()</code> 方法），它们也必须同内存及其回收有关。</p><p>但这是否意味着如果对象中包括其他对象，<code>finalize()</code> 方法就应该明确释放那些对象呢？不是，无论对象是如何创建的，垃圾回收器都会负责释放对象所占用的所有内存。这就将对 <code>finalize()</code> 的需求限制到一种特殊情况，即通过某种创建对象方式之外的方式为对象分配了存储空间。不过，你可能会想，Java 中万物皆对象，这种情况怎么可能发生？</p><p>看起来之所以有 <code>finalize()</code> 方法，是因为在分配内存时可能采用了类似 C 语言中的做法，而非 Java 中的通常做法。这种情况主要发生在使用”本地方法”的情况下，本地方法是一种用 Java 语言调用非 Java 语言代码的形式（关于本地方法的讨论，见本书电子版第 2 版的附录 B）。本地方法目前只支持 C 和 C++，但是它们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非 Java 代码中，也许会调用 C 的 <code>malloc()</code> 函数系列来分配存储空间，而且除非调用 <code>free()</code> 函数，不然存储空间永远得不到释放，造成内存泄露。但是，<code>free()</code> 是 C 和 C++ 中的函数，所以你需要在 <code>finalize()</code> 方法里用本地方法调用它。</p><p>读到这里，你可能明白了不会过多使用 <code>finalize()</code> 方法。对，它确实不是进行普通的清理工作的合适场所。那么，普通的清理工作在哪里执行呢？</p><h3 id="你必须实施清理"><a href="#你必须实施清理" class="headerlink" title="你必须实施清理"></a>你必须实施清理</h3><p>要清理一个对象，用户必须在需要清理的时候调用执行清理动作的方法。这听上去相当直接，但却与 C++ 中的”析构函数”的概念稍有抵触。在 C++ 中，所有对象都会被销毁，或者说应该被销毁。如果在 C++ 中创建了一个局部对象（在栈上创建，在 Java 中不行），此时的销毁动作发生在以”右花括号”为边界的、此对象作用域的末尾处。如果对象是用 <strong>new</strong> 创建的（类似于 Java 中），那么当程序员调用 C++ 的 <strong>delete</strong> 操作符时（Java 中不存在），就会调用相应的析构函数。如果程序员忘记调用 <strong>delete</strong>，那么永远不会调用析构函数，这样就会导致内存泄露，对象的其他部分也不会得到清理。这种 bug 很难跟踪，也是让 C++ 程序员转向 Java 的一个主要因素。相反，在 Java 中，没有用于释放对象的 <strong>delete</strong>，因为垃圾回收器会帮助你释放存储空间。甚至可以肤浅地认为，正是由于垃圾回收的存在，使得 Java 没有析构函数。然而，随着学习的深入，你会明白垃圾回收器的存在并不能完全替代析构函数（而且绝对不能直接调用 <code>finalize()</code>，所以这也不是一种解决方案）。如果希望进行除释放存储空间之外的清理工作，还是得明确调用某个恰当的 Java 方法：这就等同于使用析构函数了，只是没有它方便。</p><p>记住，无论是”垃圾回收”还是”终结”，都不保证一定会发生。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。</p><h3 id="终结条件"><a href="#终结条件" class="headerlink" title="终结条件"></a>终结条件</h3><p>通常，不能指望 <code>finalize()</code> ，你必须创建其他的”清理”方法，并明确地调用它们。所以看起来，<code>finalize()</code> 只对大部分程序员很难用到的一些晦涩内存清理里有用了。但是，<code>finalize()</code> 还有一个有趣的用法，它不依赖于每次都要对 <code>finalize()</code> 进行调用，这就是对象终结条件的验证。</p><p>当对某个对象不感兴趣时——也就是它将被清理了，这个对象应该处于某种状态，这种状态下它占用的内存可以被安全地释放掉。例如，如果对象代表了一个打开的文件，在对象被垃圾回收之前程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的 bug。<code>finalize()</code> 可以用来最终发现这个情况，尽管它并不总是被调用。如果某次 <code>finalize()</code> 的动作使得 bug 被发现，那么就可以据此找出问题所在——这才是人们真正关心的。以下是个简单的例子，示范了 <code>finalize()</code> 的可能使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/TerminationCondition.java</span></span><br><span class="line"><span class="comment">// Using finalize() to detect a object that</span></span><br><span class="line"><span class="comment">// hasn&#x27;t been properly cleaned up</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> checkedOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Book(<span class="keyword">boolean</span> checkOut) &#123;</span><br><span class="line">        checkedOut = checkOut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkedOut) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: checked out&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Normally, you&#x27;ll also do this:</span></span><br><span class="line">        <span class="comment">// super.finalize(); // Call the base-class version</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminationCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book novel = <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Proper cleanup:</span></span><br><span class="line">        novel.checkIn();</span><br><span class="line">        <span class="comment">// Drop the reference, forget to clean up:</span></span><br><span class="line">        <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Force garbage collection &amp; finalization:</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">1</span>); <span class="comment">// One second delay</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: checked out</span><br></pre></td></tr></table></figure><p>本例的终结条件是：所有的 <strong>Book</strong> 对象在被垃圾回收之前必须被登记。但在 <code>main()</code> 方法中，有一本书没有登记。要是没有 <code>finalize()</code> 方法来验证终结条件，将会很难发现这个 bug。</p><p>你可能注意到使用了 <code>@Override</code>。<code>@</code> 意味着这是一个注解，注解是关于代码的额外信息。在这里，该注解告诉编译器这不是偶然地重定义在每个对象中都存在的 <code>finalize()</code> 方法——程序员知道自己在做什么。编译器确保你没有拼错方法名，而且确保那个方法存在于基类中。注解也是对读者的提醒，<code>@Override</code> 在 Java 5 引入，在 Java 7 中改善，本书通篇会出现。</p><p>注意，<code>System.gc()</code> 用于强制进行终结动作。但是即使不这么做，只要重复地执行程序（假设程序将分配大量的存储空间而导致垃圾回收动作的执行），最终也能找出错误的 <strong>Book</strong> 对象。</p><p>你应该总是假设基类版本的 <code>finalize()</code> 也要做一些重要的事情，使用 <strong>super</strong> 调用它，就像在 <code>Book.finalize()</code> 中看到的那样。本例中，它被注释掉了，因为它需要进行异常处理，而我们到现在还没有涉及到。</p><h3 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h3><p>如果你以前用过的语言，在堆上分配对象的代价十分高昂，你可能自然会觉得 Java 中所有对象（基本类型除外）在堆上分配的方式也十分高昂。然而，垃圾回收器能很明显地提高对象的创建速度。这听起来很奇怪——存储空间的释放影响了存储空间的分配，但这确实是某些 Java 虚拟机的工作方式。这也意味着，Java 从堆空间分配的速度可以和其他语言在栈上分配空间的速度相媲美。</p><p>例如，你可以把 C++ 里的堆想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须复用。在某些 Java 虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个新对象，它就向前移动一格。这意味着对象存储空间的分配速度特别快。Java 的”堆指针”只是简单地移动到尚未分配的区域，所以它的效率与 C++ 在栈上分配空间的效率相当。当然实际过程中，在簿记工作方面还有少量额外开销，但是这部分开销比不上查找可用空间开销大。</p><p>你可能意识到了，Java 中的堆并非完全像传送带那样工作。要是那样的话，势必会导致频繁的内存页面调度——将其移进移出硬盘，因此会显得需要拥有比实际需要更多的内存。页面调度会显著影响性能。最终，在创建了足够多的对象后，内存资源被耗尽。其中的秘密在于垃圾回收器的介入。当它工作时，一边回收内存，一边使堆中的对象紧凑排列，这样”堆指针”就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。</p><p>要想理解 Java 中的垃圾回收，先了解其他系统中的垃圾回收机制将会很有帮助。一种简单但速度很慢的垃圾回收机制叫做<em>引用计数</em>。每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加 1。当引用离开作用域或被置为 <strong>null</strong> 时，引用计数减 1。因此，管理引用计数是一个开销不大但是在程序的整个生命周期频繁发生的负担。垃圾回收器会遍历含有全部对象的列表，当发现某个对象的引用计数为 0 时，就释放其占用的空间（但是，引用计数模式经常会在计数为 0 时立即释放对象）。这个机制存在一个缺点：如果对象之间存在循环引用，那么它们的引用计数都不为 0，就会出现应该被回收但无法被回收的情况。对垃圾回收器而言，定位这样的循环引用所需的工作量极大。引用计数常用来说明垃圾回收的工作方式，但似乎从未被应用于任何一种 Java 虚拟机实现中。</p><p>在更快的策略中，垃圾回收器并非基于引用计数。它们依据的是：对于任意”活”的对象，一定能最终追溯到其存活在栈或静态存储区中的引用。这个引用链条可能会穿过数个对象层次，由此，如果从栈或静态存储区出发，遍历所有的引用，你将会发现所有”活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是该对象包含的所有引用，如此反复进行，直到访问完”根源于栈或静态存储区的引用”所形成的整个网络。你所访问过的对象一定是”活”的。注意，这解决了对象间循环引用的问题，这些对象不会被发现，因此也就被自动回收了。</p><p>在这种方式下，Java 虚拟机采用了一种<em>自适应</em>的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的 Java 虚拟机实现。其中有一种做法叫做停止-复制（stop-and-copy）。顾名思义，这需要先暂停程序的运行（不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的就是需要被垃圾回收的。另外，当对象被复制到新堆时，它们是一个挨着一个紧凑排列，然后就可以按照前面描述的那样简单、直接地分配新空间了。</p><p>当对象从一处复制到另一处，所有指向它的引用都必须修正。位于栈或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想象成一个表格，将旧地址映射到新地址）。</p><p>这种所谓的”复制回收器”效率低下主要因为两个原因。其一：得有两个堆，然后在这两个分离的堆之间来回折腾，得维护比实际需要多一倍的空间。某些 Java 虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。</p><p>其二在于复制本身。一旦程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处，这很浪费。为了避免这种状况，一些 Java 虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种模式（即”自适应”）。这种模式称为标记-清扫（mark-and-sweep），Sun 公司早期版本的 Java 虚拟机一直使用这种技术。对一般用途而言，”标记-清扫”方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。</p><p>“标记-清扫”所依据的思路仍然是从栈和静态存储区出发，遍历所有的引用，找出所有存活的对象。但是，每当找到一个存活对象，就给对象设一个标记，并不回收它。只有当标记过程完成后，清理动作才开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。”标记-清扫”后剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就需要重新整理剩下的对象。</p><p>“停止-复制”指的是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会暂停。在 Oracle 公司的文档中会发现，许多参考文献将垃圾回收视为低优先级的后台进程，但是早期版本的 Java 虚拟机并不是这么实现垃圾回收器的。当可用内存较低时，垃圾回收器会暂停程序。同样，”标记-清扫”工作也必须在程序暂停的情况下才能进行。</p><p>如前文所述，这里讨论的 Java 虚拟机中，内存分配以较大的”块”为单位。如果对象较大，它会占用单独的块。严格来说，”停止-复制”要求在释放旧对象之前，必须先将所有存活对象从旧堆复制到新堆，这导致了大量的内存复制行为。有了块，垃圾回收器就可以把对象复制到废弃的块。每个块都有年代数来记录自己是否存活。通常，如果块在某处被引用，其年代数加 1，垃圾回收器会对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会复制（只是年代数会增加），含有小型对象的那些块则被复制并整理。Java 虚拟机会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到”标记-清扫”方式。同样，Java 虚拟机会跟踪”标记-清扫”的效果，如果堆空间出现很多碎片，就会切换回”停止-复制”方式。这就是”自适应”的由来，你可以给它个啰嗦的称呼：”自适应的、分代的、停止-复制、标记-清扫”式的垃圾回收器。</p><p>Java 虚拟机中有许多附加技术用来提升速度。尤其是与加载器操作有关的，被称为”即时”（Just-In-Time, JIT）编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码，所以不需要 JVM 来进行翻译，因此运行得更快。当需要装载某个类（通常是创建该类的第一个对象）时，编译器会先找到其 <strong>.class</strong> 文件，然后将该类的字节码装入内存。你可以让即时编译器编译所有代码，但这种做法有两个缺点：一是这种加载动作贯穿整个程序生命周期内，累加起来需要花更多时间；二是会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这会导致页面调度，从而一定降低程序速度。另一种做法称为<em>惰性评估</em>，意味着即时编译器只有在必要的时候才编译代码。这样，从未被执行的代码也许就压根不会被 JIT 编译。新版 JDK 中的 Java HotSpot 技术就采用了类似的做法，代码每被执行一次就优化一些，所以执行的次数越多，它的速度就越快。</p><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p>Java 尽量保证所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，这种保证会以编译时错误的方式呈现，所以如果写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会得到一条错误信息，告诉你 <strong>i</strong> 可能尚未初始化。编译器可以为 <strong>i</strong> 赋一个默认值，但是未初始化的局部变量更有可能是程序员的疏忽，所以采用默认值反而会掩盖这种失误。强制程序员提供一个初始值，往往能帮助找出程序里的 bug。</p><p>要是类的成员变量是基本类型，情况就会变得有些不同。正如在”万物皆对象”一章中所看到的，类的每个基本类型数据成员保证都会有一个初始值。下面的程序可以验证这类情况，并显示它们的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/InitialValues.java</span></span><br><span class="line"><span class="comment">// Shows default initial values</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> t;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    InitialValues reference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInitialValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Data type Initial value&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;boolean &quot;</span> + t);</span><br><span class="line">        System.out.println(<span class="string">&quot;char[&quot;</span> + c + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;byte &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;short &quot;</span> + s);</span><br><span class="line">        System.out.println(<span class="string">&quot;int &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;long &quot;</span> + l);</span><br><span class="line">        System.out.println(<span class="string">&quot;float &quot;</span> + f);</span><br><span class="line">        System.out.println(<span class="string">&quot;double &quot;</span> + d);</span><br><span class="line">        System.out.println(<span class="string">&quot;reference &quot;</span> + reference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InitialValues().printInitialValues();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Data type Initial value</span><br><span class="line"><span class="keyword">boolean</span> <span class="keyword">false</span></span><br><span class="line"><span class="keyword">char</span>[NUL]</span><br><span class="line"><span class="keyword">byte</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">short</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">long</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">float</span> <span class="number">0.0</span></span><br><span class="line"><span class="keyword">double</span> <span class="number">0.0</span></span><br><span class="line">reference <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>可见尽管数据成员的初值没有给出，但它们确实有初值（char 值为 0，所以显示为空白）。所以这样至少不会出现”未初始化变量”的风险了。</p><p>在类里定义一个对象引用时，如果不将其初始化，那么引用就会被赋值为 <strong>null</strong>。</p><h3 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h3><p>怎么给一个变量赋初值呢？一种很直接的方法是在定义类成员变量的地方为其赋值。以下代码修改了 InitialValues 类成员变量的定义，直接提供了初值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/InitialValues2.java</span></span><br><span class="line"><span class="comment">// Providing explicit initial values</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialValues2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> bool = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">long</span> lng = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.14159</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以用同样的方式初始化非基本类型的对象。如果 <strong>Depth</strong> 是一个类，那么可以像下面这样创建一个对象并初始化它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Measurement.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Depth</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Measurement</span> </span>&#123;</span><br><span class="line">    Depth d = <span class="keyword">new</span> Depth();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有为 <strong>d</strong> 赋予初值就尝试使用它，就会出现运行时错误，告诉你产生了一个异常（详细见”异常”章节）。</p><p>你也可以通过调用某个方法来提供初值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/MethodInit.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = f();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以带有参数，但这些参数不能是未初始化的类成员变量。因此，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/MethodInit2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInit2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = f();</span><br><span class="line">    <span class="keyword">int</span> j = g(i);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是你不能这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/MethodInit3.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInit3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//- int j = g(i); // Illegal forward reference</span></span><br><span class="line">    <span class="keyword">int</span> i = f();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以，编译器恰当地对”向前引用”发出了警告。</p><p>这种初始化方式简单直观，但有个限制：类 <strong>InitialValues</strong> 的每个对象都有相同的初值，有时这的确是我们需要的，但有时却需要更大的灵活性。</p><h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><p>可以用构造器进行初始化，这种方式给了你更大的灵活性，因为你可以在运行时调用方法进行初始化。但是，这无法阻止自动初始化的进行，他会在构造器被调用之前发生。因此，如果使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Counter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    Counter() &#123;</span><br><span class="line">        i = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>i</strong> 首先会被初始化为 <strong>0</strong>，然后变为 <strong>7</strong>。对于所有的基本类型和引用，包括在定义时已明确指定初值的变量，这种情况都是成立的。因此，编译器不会强制你一定要在构造器的某个地方或在使用它们之前初始化元素——初始化早已得到了保证。,</p><h3 id="初始化的顺序"><a href="#初始化的顺序" class="headerlink" title="初始化的顺序"></a>初始化的顺序</h3><p>在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OrderOfInitialization.java</span></span><br><span class="line"><span class="comment">// Demonstrates initialization order</span></span><br><span class="line"><span class="comment">// When the constructor is called to create a</span></span><br><span class="line"><span class="comment">// Window object, you&#x27;ll see a message:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    Window(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Window(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>); <span class="comment">// Before constructor</span></span><br><span class="line"></span><br><span class="line">    House() &#123;</span><br><span class="line">        <span class="comment">// Show that we&#x27;re in the constructor:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> Window(<span class="number">33</span>); <span class="comment">// Reinitialize w3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>); <span class="comment">// After constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>); <span class="comment">// At end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House h = <span class="keyword">new</span> House();</span><br><span class="line">        h.f(); <span class="comment">// Shows that construction is done</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Window(1)</span><br><span class="line">Window(2)</span><br><span class="line">Window(3)</span><br><span class="line">House()</span><br><span class="line">Window(33)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure><p>在 <strong>House</strong> 类中，故意把几个 <strong>Window</strong> 对象的定义散布在各处，以证明它们全都会在调用构造器或其他方法之前得到初始化。此外，<strong>w3</strong> 在构造器中被再次赋值。</p><p>由输出可见，引用 <strong>w3</strong> 被初始化了两次：一次在调用构造器前，一次在构造器调用期间（第一次引用的对象将被丢弃，并作为垃圾回收）。这乍一看可能觉得效率不高，但保证了正确的初始化。试想，如果定义了一个重载构造器，在其中没有初始化 <strong>w3</strong>，同时在定义 <strong>w3</strong> 时没有赋予初值，那会产生怎样的后果呢？</p><h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>无论创建多少个对象，静态数据都只占用一份存储区域。<strong>static</strong> 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 <strong>null</strong>。</p><p>如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。</p><p>下面例子显示了静态存储区是何时初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/StaticInitialization.java</span></span><br><span class="line"><span class="comment">// Specifying initial values in a class definition</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span> </span>&#123;</span><br><span class="line">    Bowl(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Bowl bowl1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Table() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">        bowl2.f1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Bowl bowl2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span> </span>&#123;</span><br><span class="line">    Bowl bowl3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> Bowl bowl4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    Cupboard() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">        bowl4.f1(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Bowl bowl5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main creating new Cupboard()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupboard();</span><br><span class="line">        System.out.println(<span class="string">&quot;main creating new Cupboard()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupboard();</span><br><span class="line">        table.f2(<span class="number">1</span>);</span><br><span class="line">        cupboard.f3(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">    <span class="keyword">static</span> Cupboard cupboard = <span class="keyword">new</span> Cupboard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Bowl(1)</span><br><span class="line">Bowl(2)</span><br><span class="line">Table()</span><br><span class="line">f1(1)</span><br><span class="line">Bowl(4)</span><br><span class="line">Bowl(5)</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">main creating new Cupboard()</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">main creating new Cupboard()</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">f2(1)</span><br><span class="line">f3(1)</span><br></pre></td></tr></table></figure><p><strong>Bowl</strong> 类展示类的创建，而 <strong>Table</strong> 和 <strong>Cupboard</strong> 在它们的类定义中包含 <strong>Bowl</strong> 类型的静态数据成员。注意，在静态数据成员定义之前，<strong>Cupboard</strong> 类中先定义了一个 <strong>Bowl</strong> 类型的非静态成员 <strong>b3</strong>。</p><p>由输出可见，静态初始化只有在必要时刻才会进行。如果不创建 <strong>Table</strong> 对象，也不引用 <strong>Table.bowl1</strong> 或 <strong>Table.bowl2</strong>，那么静态的 <strong>Bowl</strong> 类对象 <strong>bowl1</strong> 和 <strong>bowl2</strong> 永远不会被创建。只有在第一个 Table 对象被创建（或被访问）时，它们才会被初始化。此后，静态对象不会再次被初始化。</p><p>初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对象，从输出中可以看出。要执行 <code>main()</code> 方法，必须加载 <strong>StaticInitialization</strong> 类，它的静态属性 <strong>table</strong> 和 <strong>cupboard</strong> 随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的 <strong>Bowl</strong> 对象，所以 <strong>Bowl</strong> 类也会被加载。因此，在这个特殊的程序中，所有的类都会在 <code>main()</code> 方法之前被加载。实际情况通常并非如此，因为在典型的程序中，不会像本例中所示的那样，将所有事物通过 <strong>static</strong> 联系起来。</p><p>概括一下创建对象的过程，假设有个名为 <strong>Dog</strong> 的类：</p><ol><li>即使没有显式地使用 <strong>static</strong> 关键字，构造器实际上也是静态方法。所以，当首次创建 <strong>Dog</strong> 类型的对象或是首次访问 <strong>Dog</strong> 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 <strong>Dog.class</strong>。</li><li>当加载完 <strong>Dog.class</strong> 后（后面会学到，这将创建一个 <strong>Class</strong> 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 <strong>Class</strong> 对象时初始化一次。</li><li>当用 <code>new Dog()</code> 创建对象时，首先会在堆上为 <strong>Dog</strong> 对象分配足够的存储空间。</li><li>分配的存储空间首先会被清零，即会将 <strong>Dog</strong> 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 <strong>null</strong>。</li><li>执行所有出现在字段定义处的初始化动作。</li><li>执行构造器。你将会在”复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。</li></ol><h3 id="显式的静态初始化"><a href="#显式的静态初始化" class="headerlink" title="显式的静态初始化"></a>显式的静态初始化</h3><p>你可以将一组静态初始化动作放在类里面一个特殊的”静态子句”（有时叫做静态块）中。像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Spoon.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来像个方法，但实际上它只是一段跟在 <strong>static</strong> 关键字后面的代码块。与其他静态初始化动作一样，这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员（甚至不需要创建该类的对象）时。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ExplicitStatic.java</span></span><br><span class="line"><span class="comment">// Explicit static initialization with &quot;static&quot; clause</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span> </span>&#123;</span><br><span class="line">    Cup(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cup(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cups</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Cup cup1;</span><br><span class="line">    <span class="keyword">static</span> Cup cup2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cup1 = <span class="keyword">new</span> Cup(<span class="number">1</span>);</span><br><span class="line">        cup2 = <span class="keyword">new</span> Cup(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cups() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cups()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        Cups.cup1.f(<span class="number">99</span>); <span class="comment">// [1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static Cups cups1 = new Cups(); // [2]</span></span><br><span class="line">    <span class="comment">// static Cups cups2 = new Cups(); // [2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inside main</span><br><span class="line">Cup(1)</span><br><span class="line">Cup(2)</span><br><span class="line">f(99)</span><br></pre></td></tr></table></figure><p>无论是通过标为 [1] 的行访问静态的 <strong>cup1</strong> 对象，还是把标为 [1] 的行去掉，让它去运行标为 [2] 的那行代码（去掉 [2] 的注释），<strong>Cups</strong> 的静态初始化动作都会执行。如果同时注释 [1] 和 [2] 处，那么 <strong>Cups</strong> 的静态初始化就不会进行。此外，把标为 [2] 处的注释都去掉还是只去掉一个，静态初始化只会执行一次。</p><h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3><p>Java 提供了被称为<em>实例初始化</em>的类似语法，用来初始化每个对象的非静态变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Mugs.java</span></span><br><span class="line"><span class="comment">// Instance initialization</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mug</span> </span>&#123;</span><br><span class="line">    Mug(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mugs</span> </span>&#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line">    &#123; <span class="comment">// [1]</span></span><br><span class="line">        mug1 = <span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">        mug2 = <span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mugs() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mugs(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Mugs();</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs() completed&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Mugs(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs(1) completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Inside main</span><br><span class="line">Mug(1)</span><br><span class="line">Mug(2)</span><br><span class="line">mug1 &amp; mug2 initialized</span><br><span class="line">Mugs()</span><br><span class="line">new Mugs() completed</span><br><span class="line">Mug(1)</span><br><span class="line">Mug(2)</span><br><span class="line">mug1 &amp; mug2 initialized</span><br><span class="line">Mugs(int)</span><br><span class="line">new Mugs(1) completed</span><br></pre></td></tr></table></figure><p>看起来它很像静态代码块，只不过少了 <strong>static</strong> 关键字。这种语法对于支持”匿名内部类”（参见”内部类”一章）的初始化是必须的，但是你也可以使用它保证某些操作一定会发生，而不管哪个构造器被调用。从输出看出，实例初始化子句是在两个构造器之前执行的。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方括号下标操作符 [] 来定义和使用的。要定义一个数组引用，只需要在类型名加上方括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1;</span><br></pre></td></tr></table></figure><p>方括号也可放在标识符的后面，两者的含义是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[];</span><br></pre></td></tr></table></figure><p>这种格式符合 C 和 C++ 程序员的习惯。不过前一种格式或许更合理，毕竟它表明类型是”一个 <strong>int</strong> 型数组”。本书中采用这种格式。</p><p>编译器不允许指定数组的大小。这又把我们带回有关”引用”的问题上。你所拥有的只是对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但是也可以使用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号括起来的值组成。这种情况下，存储空间的分配（相当于使用 <strong>new</strong>） 将由编译器负责。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>那么为什么在还没有数组的时候定义一个数组引用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a2;</span><br></pre></td></tr></table></figure><p>在 Java 中可以将一个数组赋值给另一个数组，所以可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2 = a1;</span><br></pre></td></tr></table></figure><p>其实真正做的只是复制了一个引用，就像下面演示的这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArraysOfPrimitives.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysOfPrimitives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] a2;</span><br><span class="line">        a2 = a1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a2.length; i++) &#123;</span><br><span class="line">            a2[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a1.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a1[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + a1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1[0] = 2;</span><br><span class="line">a1[1] = 3;</span><br><span class="line">a1[2] = 4;</span><br><span class="line">a1[3] = 5;</span><br><span class="line">a1[4] = 6;</span><br></pre></td></tr></table></figure><p><strong>a1</strong> 初始化了，但是 <strong>a2</strong> 没有；这里，<strong>a2</strong> 在后面被赋给另一个数组。由于 <strong>a1</strong> 和 <strong>a2</strong> 是相同数组的别名，因此通过 <strong>a2</strong> 所做的修改在 <strong>a1</strong> 中也能看到。</p><p>所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 <strong>length</strong>，告诉你这个数组有多少个元素，你不能对其修改。与 C 和 C++ 类似，Java 数组计数也是从 0 开始的，所能使用的最大下标数是 <strong>length - 1</strong>。超过这个边界，C 和 C++ 会默认接受，允许你访问所有内存，许多声名狼藉的 bug 都是由此而生。但是 Java 在你访问超出这个边界时，会报运行时错误（异常），从而避免此类问题。</p><h3 id="动态数组创建"><a href="#动态数组创建" class="headerlink" title="动态数组创建"></a>动态数组创建</h3><p>如果在编写程序时，不确定数组中需要多少个元素，那么该怎么办呢？你可以直接使用 <strong>new</strong> 在数组中创建元素。下面例子中，尽管创建的是基本类型数组，<strong>new</strong> 仍然可以工作（不能用 <strong>new</strong> 创建单个的基本类型数组）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArrayNew.java</span></span><br><span class="line"><span class="comment">// Creating arrays with new</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.println(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">length of a = 18</span><br><span class="line">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure><p>数组的大小是通过 <code>Random.nextInt()</code> 随机确定的，这个方法会返回 0 到输入参数之间的一个值。 由于随机性，很明显数组的创建确实是在运行时进行的。此外，程序输出表明，数组元素中的基本数据类型值会自动初始化为空值（对于数字和字符是 0；对于布尔型是 <strong>false</strong>）。<code>Arrays.toString()</code> 是 <strong>java.util</strong> 标准类库中的方法，会产生一维数组的可打印版本。</p><p>本例中，数组也可以在定义的同时进行初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br></pre></td></tr></table></figure><p>如果可能的话，应该尽量这么做。</p><p>如果你创建了一个非基本类型的数组，那么你创建的是一个引用数组。以整型的包装类型 <strong>Integer</strong> 为例，它是一个类而非基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArrayClassObj.java</span></span><br><span class="line"><span class="comment">// Creating an array of nonprimitive objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayClassObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        Integer[] a = <span class="keyword">new</span> Integer[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.println(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = rand.nextInt(<span class="number">500</span>); <span class="comment">// Autoboxing</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">length of a = 18</span><br><span class="line">[55, 193, 361, 461, 429, 368, 200, 22, 207, 288, 128, 51, 89, 309, 278, 498, 361, 20]</span><br></pre></td></tr></table></figure><p>这里，即使使用 new 创建数组之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[rand.nextInt(<span class="number">20</span>)];</span><br></pre></td></tr></table></figure><p>它只是一个引用数组，直到通过创建新的 <strong>Integer</strong> 对象（通过自动装箱），并把对象赋值给引用，初始化才算结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = rand.nextInt(<span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>如果忘记了创建对象，但试图使用数组中的空引用，就会在运行时产生异常。</p><p>也可以用花括号括起来的列表来初始化数组，有两种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArrayInit.java</span></span><br><span class="line"><span class="comment">// Array initialization</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] a = &#123;</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// Autoboxing</span></span><br><span class="line">        &#125;;</span><br><span class="line">        Integer[] b = <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// Autoboxing</span></span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3]</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><p>在这两种形式中，初始化列表的最后一个逗号是可选的（这一特性使维护长列表变得更容易）。</p><p>尽管第一种形式很有用，但是它更加受限，因为它只能用于数组定义处。第二种和第三种形式可以用在任何地方，甚至用在方法的内部。例如，你创建了一个 <strong>String</strong> 数组，将其传递给另一个类的 <code>main()</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/DynamicArray.java</span></span><br><span class="line"><span class="comment">// Array initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Other.main(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;fiddle&quot;</span>, <span class="string">&quot;de&quot;</span>, <span class="string">&quot;dum&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s: args) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiddle de dum</span><br></pre></td></tr></table></figure><p><code>Other.main()</code> 的参数是在调用处创建的，因此你甚至可以在方法调用处提供可替换的参数。</p><h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p>你可以以一种类似 C 语言中的可变参数列表（C 通常把它称为”varargs”）来创建和调用方法。这可以应用在参数个数或类型未知的场合。由于所有的类都最后继承于 <strong>Object</strong> 类（随着本书的进展，你会对此有更深的认识），所以你可以创建一个以 Object 数组为参数的方法，并像下面这样调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/VarArgs.java</span></span><br><span class="line"><span class="comment">// Using array syntax to create variable argument lists</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printArray(<span class="keyword">new</span> Object[] &#123;<span class="number">47</span>, (<span class="keyword">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> Object[] &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> Object[] &#123;<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">47 3.14 11.11</span><br><span class="line">one two three</span><br><span class="line">A@15db9742 A@6d06d69c A@7852e922</span><br></pre></td></tr></table></figure><p><code>printArray()</code> 的参数是 <strong>Object</strong> 数组，使用 for-in 语法遍历和打印数组的每一项。标准 Java 库能输出有意义的内容，但这里创建的是类的对象，打印出的内容是类名，后面跟着一个 <strong>@</strong> 符号以及多个十六进制数字。因而，默认行为（如果没有定义 <code>toString()</code> 方法的话，后面会讲这个方法）就是打印类名和对象的地址。</p><p>你可能看到像上面这样编写的 Java 5 之前的代码，它们可以产生可变的参数列表。在 Java 5 中，这种期盼已久的特性终于添加了进来，就像在 <code>printArray()</code> 中看到的那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/NewVarArgs.java</span></span><br><span class="line"><span class="comment">// Using array syntax to create variable argument lists</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewVarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Can take individual elements:</span></span><br><span class="line">        printArray(<span class="number">47</span>, (<span class="keyword">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="number">47</span>, <span class="number">3.14F</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        printArray(<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A());</span><br><span class="line">        <span class="comment">// Or an array:</span></span><br><span class="line">        printArray((Object[]) <span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        printArray(); <span class="comment">// Empty list is OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">47 3.14 11.11</span><br><span class="line">47 3.14 11.11</span><br><span class="line">one two three</span><br><span class="line">A@15db9742 A@6d06d69c A@7852e922</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p>有了可变参数，你就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你填充数组。你获取的仍然是一个数组，这就是为什么 <code>printArray()</code> 可以使用 for-in 迭代数组的原因。但是，这不仅仅只是从元素列表到数组的自动转换。注意程序的倒数第二行，一个 <strong>Integer</strong> 数组（通过自动装箱创建）被转型为一个 <strong>Object</strong> 数组（为了移除编译器的警告），并且传递给了 <code>printArray()</code>。显然，编译器会发现这是一个数组，不会执行转换。因此，如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法会把它们当作可变参数列表来接受。</p><p>程序的最后一行表明，可变参数的个数可以为 0。当具有可选的尾随参数时，这一特性会有帮助：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OptionalTrailingArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTrailingArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> required, String... trailing)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;required: &quot;</span> + required + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s: trailing) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required: 1 one</span><br><span class="line">required: 2 two three</span><br><span class="line">required: 0</span><br></pre></td></tr></table></figure><p>这段程序展示了如何使用除了 <strong>Object</strong> 类之外类型的可变参数列表。这里，所有的可变参数都是 <strong>String</strong> 对象。可变参数列表中可以使用任何类型的参数，包括基本类型。下面例子展示了可变参数列表变为数组的情形，并且如果列表中没有任何元素，那么转变为大小为 0 的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/VarargType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarargType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.print(args.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot; length &quot;</span> + args.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">        System.out.print(args.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot; length &quot;</span> + args.length)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f();</span><br><span class="line">        g(<span class="number">1</span>);</span><br><span class="line">        g();</span><br><span class="line">        System.out.println(<span class="string">&quot;int[]: &quot;</span>+ <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>].getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class [Ljava.lang.Character; length 1</span><br><span class="line">class [Ljava.lang.Character; length 0</span><br><span class="line">class [I length 1</span><br><span class="line">class [I length 0</span><br><span class="line">int[]: class [I</span><br></pre></td></tr></table></figure><p><code>getClass()</code> 方法属于 Object 类，将在”类型信息”一章中全面介绍。它会产生对象的类，并在打印该类时，看到表示该类类型的编码字符串。前导的 <strong>[</strong> 代表这是一个后面紧随的类型的数组，<strong>I</strong> 表示基本类型 <strong>int</strong>；为了进行双重检查，我在最后一行创建了一个 <strong>int</strong> 数组，打印了其类型。这样也验证了使用可变参数列表不依赖于自动装箱，而使用的是基本类型。</p><p>然而，可变参数列表与自动装箱可以和谐共处，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/AutoboxingVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoboxingVarargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer i: args) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        f(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        f(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">4 5 6 7 8 9</span><br><span class="line">10 11 12</span><br></pre></td></tr></table></figure><p>注意吗，你可以在单个参数列表中将类型混合在一起，自动装箱机制会有选择地把 <strong>int</strong> 类型的参数提升为 <strong>Integer</strong>。</p><p>可变参数列表使得方法重载更加复杂了，尽管乍看之下似乎足够安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OverloadingVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Character c: args) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i: args) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Long... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        f(<span class="number">1</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">        f(<span class="number">0L</span>);</span><br><span class="line">        <span class="comment">//- f(); // Won&#x27;s compile -- ambiguous</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">first a b c</span><br><span class="line">second 1</span><br><span class="line">second 2 1</span><br><span class="line">second 0</span><br><span class="line">third</span><br></pre></td></tr></table></figure><p>在每种情况下，编译器都会使用自动装箱来匹配重载的方法，然后调用最明确匹配的方法。</p><p>但是如果调用不含参数的 <code>f()</code>，编译器就无法知道应该调用哪个方法了。尽管这个错误可以弄清楚，但是它可能会使客户端程序员感到意外。</p><p>你可能会通过在某个方法中增加一个非可变参数解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OverloadingVarargs2.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>{WillNotCompile}</strong> 注释把该文件排除在了本书的 Gradle 构建之外。如果你手动编译它，会得到下面的错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OverloadingVarargs2.java:14:error:reference to f is ambiguous f(&#x27;a&#x27;, &#x27;b&#x27;);</span><br><span class="line">\^</span><br><span class="line">both method f(float, Character...) in OverloadingVarargs2 and method f(Character...) in OverloadingVarargs2 match 1 error</span><br></pre></td></tr></table></figure><p>如果你给这两个方法都添加一个非可变参数，就可以解决问题了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OverloadingVarargs3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c, Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br></pre></td></tr></table></figure><p>你应该总是在重载方法的一个版本上使用可变参数列表，或者压根不用它。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>Java 5 中添加了一个看似很小的特性 <strong>enum</strong> 关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便地处理。以前，你需要创建一个整数常量集，但是这些值并不会将自身限制在这个常量集的范围内，因此使用它们更有风险，而且更难使用。枚举类型属于非常普遍的需求，C、C++ 和其他许多语言都已经拥有它了。在 Java 5 之前，Java 程序员必须了解许多细节并格外仔细地去达成 <strong>enum</strong> 的效果。现在 Java 也有了 <strong>enum</strong>，并且它的功能比 C/C++ 中的完备得多。下面是个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Spiciness.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Spiciness</span> </span>&#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个名为 <strong>Spiciness</strong> 的枚举类型，它有 5 个值。由于枚举类型的实例是常量，因此按照命名惯例，它们都用大写字母表示（如果名称中含有多个单词，使用下划线分隔）。</p><p>要使用 <strong>enum</strong>，需要创建一个该类型的引用，然后将其赋值给某个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/SimpleEnumUse.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEnumUse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Spiciness howHot = Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MEDIUM</span><br></pre></td></tr></table></figure><p>在你创建 <strong>enum</strong> 时，编译器会自动添加一些有用的特性。例如，它会创建 <code>toString()</code> 方法，以便你方便地显示某个 <strong>enum</strong> 实例的名称，这从上面例子中的输出可以看出。编译器还会创建 <code>ordinal()</code> 方法表示某个特定 <strong>enum</strong> 常量的声明顺序，<code>static values()</code> 方法按照 enum 常量的声明顺序，生成这些常量值构成的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/EnumOrder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumOrder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Spiciness s: Spiciness.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NOT, ordinal 0</span><br><span class="line">MILD, ordinal 1</span><br><span class="line">MEDIUM, ordinal 2</span><br><span class="line">HOT, ordinal 3</span><br><span class="line">FLAMING, ordinal 4</span><br></pre></td></tr></table></figure><p>尽管 <strong>enum</strong> 看起来像是一种新的数据类型，但是这个关键字只是在生成 <strong>enum</strong> 的类时，产生了某些编译器行为，因此在很大程度上你可以将 <strong>enum</strong> 当作其他任何类。事实上，<strong>enum</strong> 确实是类，并且具有自己的方法。</p><p><strong>enum</strong> 有一个很实用的特性，就是在 <strong>switch</strong> 语句中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Burrito.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:</span><br><span class="line">                System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM:</span><br><span class="line">                System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;maybe too hot&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Burrito plain = <span class="keyword">new</span> Burrito(Spiciness.NOT),</span><br><span class="line">        greenChile = <span class="keyword">new</span> Burrito(Spiciness.MEDIUM),</span><br><span class="line">        jalapeno = <span class="keyword">new</span> Burrito(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This burrito is not spicy at all.</span><br><span class="line">This burrito is a little hot.</span><br><span class="line">This burrito is maybe too hot.</span><br></pre></td></tr></table></figure><p>由于 <strong>switch</strong> 是在有限的可能值集合中选择，因此它与 <strong>enum</strong> 是绝佳的组合。注意，enum 的名称是如何能够倍加清楚地表明程序的目的的。</p><p>通常，你可以将 <strong>enum</strong> 用作另一种创建数据类型的方式，然后使用所得到的类型。这正是关键所在，所以你不用过多地考虑它们。在 <strong>enum</strong> 被引入之前，你必须花费大量的精力去创建一个等同的枚举类型，并是安全可用的。</p><p>这些介绍对于你理解和使用基本的 <strong>enum</strong> 已经足够了，我们会在”枚举”一章中进行更深入的探讨。</p><h2 id="本章小结-4"><a href="#本章小结-4" class="headerlink" title="本章小结"></a>本章小结</h2><p>构造器，这种看起来精巧的初始化机制，应该给了你很强的暗示：初始化在编程语言中的重要地位。C++ 的发明者 Bjarne Stroustrup 在设计 C++ 期间，在针对 C 语言的生产效率进行的最初调查中发现，错误的初始化会导致大量编程错误。这些错误很难被发现，同样，不合理的清理也会如此。因为构造器能保证进行正确的初始化和清理（没有正确的构造器调用，编译器就不允许创建对象），所以你就有了完全的控制和安全。</p><p>在 C++ 中，析构器很重要，因为用 <strong>new</strong> 创建的对象必须被明确地销毁。在 Java 中，垃圾回收器会自动地释放所有对象的内存，所以很多时候类似的清理方法就不太需要了（但是当要用到的时候，你得自己动手）。在不需要类似析构器行为的时候，Java 的垃圾回收器极大地简化了编程，并加强了内存管理上的安全性。一些垃圾回收器甚至能清理其他资源，如图形和文件句柄。然而，垃圾回收器确实增加了运行时开销，由于 Java 解释器从一开始就很慢，所以这种开销到底造成多大的影响很难看出来。随着时间的推移，Java 在性能方面提升了很多，但是速度问题仍然是它涉足某些特定编程领域的障碍。</p><p>由于要保证所有对象被创建，实际上构造器比这里讨论得更加复杂。特别是当通过<em>组合</em>或<em>继承</em>创建新类的时候，这种保证仍然成立，并且需要一些额外的语法来支持。在后面的章节中，你会学习组合，继承以及它们如何影响构造器。</p><h1 id="第-7-章-封装"><a href="#第-7-章-封装" class="headerlink" title="第 7 章 封装"></a>第 7 章 封装</h1><p>访问控制（或者隐藏实现）与”最初的实现不恰当”有关。</p><p>所有优秀的作者——包括这些编写软件的人——都知道一件好的作品都是经过反复打磨才变得优秀的。如果你把一段代码置于某个位置一段时间，过一会重新来看，你可能发现更好的实现方式。这是重构的原动力之一，重构就是重写可工作的代码，使之更加可读，易懂，因而更易维护。</p><p>但是，在修改和完善代码的愿望下，也存在巨大的压力。通常，客户端程序员希望你的代码在某些方面保持不变。所以你想修改代码，但他们希望代码保持不变。由此引出了面向对象设计中的一个基本问题：”如何区分变动的事物和不变的事物”。</p><p>这个问题对于类库而言尤其重要。类库的使用者必须依赖他们所使用的那部分类库，并且知道如果使用了类库的新版本，不需要改写代码。另一方面，类库的开发者必须有修改和改进类库的自由，并保证客户代码不会受这些改动影响。</p><p>这可以通过约定解决。例如，类库开发者必须同意在修改类库中的一个类时，不会移除已有的方法，因为那样将会破坏客户端程序员的代码。与之相反的情况更加复杂。在有成员属性的情况下，类库开发者如何知道哪些属性被客户端程序员使用？这同样会发生在那些只为实现类库类而创建的方法上，它们也不是设计成可供客户端程序员调用的。如果类库开发者想删除旧的实现，添加新的实现，结果会怎样呢？任何这些成员的改动都可能破环客户端程序员的代码。因此类库开发者会被束缚，不能修改任何事物。</p><p>为了解决这一问题，Java 提供了访问修饰符供类库开发者指明哪些对于客户端程序员是可用的，哪些是不可用的。访问控制权限的等级，从”最大权限”到”最小权限”依次是：<strong>public</strong>，<strong>protected</strong>，包访问权限（没有关键字）和 <strong>private</strong>。根据上一段的内容，你可能会想，作为一名类库设计者，你会尽可能将一切都设为 <strong>private</strong>，仅向客户端程序员暴露你愿意他们使用的方法。这就是你通常所做的，尽管这与使用其他语言（尤其是 C）编程和访问不受任何限制的人们的直觉相违背。</p><p>然而，构建类库的概念和对类库组件的访问控制仍然不完善。其中仍然存在问题就是如何将类库组件捆绑到一个内聚到类库单元中。Java 中通过 package 关键字加以控制，类是在相同包下还是不同包下会影响访问修饰符。所以在这章开始，你将会学习如何将类库组件置于同一个包下，之后你就能明白访问修饰符的全部含义。</p><h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><p>包内包含一组类，它们被组织在一个单独的命名空间下。</p><p>例如，标准 Java 发布中有一个工具库，它被组织在 <strong>java.util</strong> 命名空间下。<strong>java.util</strong> 中含有一个类，叫做 <strong>ArrayList</strong>。使用 <strong>ArrayList</strong> 的一种方式是用其全名 <strong>java.util.ArrayList</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/FullQualification.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullQualification</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.ArrayList list = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式使得程序冗长乏味，因此你可以换一种方式，使用 <strong>import</strong> 关键字。如果需要导入某个类，就需要在 <strong>import</strong> 语句中声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/SingleImport.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleImport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你就可以不加限定词，直接使用 <strong>ArrayList</strong> 了。但是对于 <strong>java.util</strong> 包下的其他类，你还是不能用。要导入其中所有的类，只需使用 <strong>*</strong> ，就像本书中其他示例那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br></pre></td></tr></table></figure><p>之所以使用导入，是为了提供一种管理命名空间的机制。所有类名之间都是相互隔离的。类 <strong>A</strong> 中的方法 <code>f()</code> 不会与类 <strong>B</strong> 中具有相同签名的方法 <code>f()</code> 冲突。但是如果类名冲突呢？假设你创建了一个 <strong>Stack</strong> 类，打算安装在一台已经有别人所写的 <strong>Stack</strong> 类的机器上，该怎么办呢？这种类名的潜在冲突，正是我们需要在 Java 中对命名空间进行完全控制的原因。为了解决冲突，我们为每个类创建一个唯一标识符组合。</p><p>到目前为止的大部分示例都只存在单个文件，并为本地使用的，所以尚未受到包名的干扰。但是，这些示例其实已经位于包中了，叫做”未命名”包或默认包。这当然是一种选择，为了简单起见，本书其余部分会尽可能采用这种方式。但是，如果你打算为相同机器上的其他 Java 程序创建友好的类库或程序时，就必须仔细考虑以防类名冲突。</p><p>一个 Java 源代码文件称为一个<em>编译单元</em>（有时也称<em>翻译单元</em>）。每个编译单元的文件名后缀必须是 <strong>.java</strong>。在编译单元中可以有一个 <strong>public</strong> 类，它的类名必须与文件名相同（包括大小写，但不包括后缀名 <strong>.java</strong>）。每个编译单元中只能有一个 <strong>public</strong> 类，否则编译器不接受。如果这个编译单元中还有其他类，那么在包之外是无法访问到这些类的，因为它们不是 <strong>public</strong> 类，此时它们支持主 <strong>public</strong> 类。</p><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>当编译一个 <strong>.java</strong> 文件时，<strong>.java</strong> 文件的每个类都会有一个输出文件。每个输出的文件名和 <strong>.java</strong> 文件中每个类的类名相同，只是后缀名是 <strong>.class</strong>。因此，在编译少量的 <strong>.java</strong> 文件后，会得到大量的 <strong>.class</strong> 文件。如果你使用过编译型语言，那么你可能习惯编译后产生一个中间文件（通常称为”obj”文件），然后与使用链接器（创建可执行文件）或类库生成器（创建类库）产生的其他同类文件打包到一起的情况。这不是 Java 工作的方式。在 Java 中，可运行程序是一组 <strong>.class</strong> 文件，它们可以打包压缩成一个 Java 文档文件（JAR，使用 <strong>jar</strong> 文档生成器）。Java 解释器负责查找、加载和解释这些文件。</p><p>类库是一组类文件。每个源文件通常都含有一个 <strong>public</strong> 类和任意数量的非 <strong>public</strong> 类，因此每个文件都有一个构件。如果把这些组件集中在一起，就需要使用关键字 <strong>package</strong>。</p><p>如果你使用了 <strong>package</strong> 语句，它必须是文件中除了注释之外的第一行代码。当你如下这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hiding;</span><br></pre></td></tr></table></figure><p>意味着这个编译单元是一个名为 <strong>hiding</strong> 类库的一部分。换句话说，你正在声明的编译单元中的 <strong>public</strong> 类名称位于名为 <strong>hiding</strong> 的保护伞下。任何人想要使用该名称，必须指明完整的类名或者使用 <strong>import</strong> 关键字导入 <strong>hiding</strong>。（注意，Java 包名按惯例一律小写，即使中间的单词也需要小写，与驼峰命名不同）</p><p>例如，假设文件名是 <strong>MyClass.java</strong>，这意味着文件中只能有一个 <strong>public</strong> 类，且类名必须是 MyClass（大小写也与文件名相同）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/mypackage/MyClass.java</span></span><br><span class="line"><span class="keyword">package</span> hiding.mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果有人想使用 <strong>MyClass</strong> 或 <strong>hiding.mypackage</strong> 中的其他 <strong>public</strong> 类，就必须使用关键字 <strong>import</strong> 来使 <strong>hiding.mypackage</strong> 中的名称可用。还有一种选择是使用完整的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/QualifiedMyClass.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifiedMyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hiding.mypackage.MyClass m = <span class="keyword">new</span> hiding.mypackage.MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字 <strong>import</strong> 使之更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/ImportedMyClass.java</span></span><br><span class="line"><span class="keyword">import</span> hiding.mypackage.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportedMyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass m = <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>package</strong> 和 <strong>import</strong> 这两个关键字将单一的全局命名空间分隔开，从而避免名称冲突。</p><h3 id="创建独一无二的包名"><a href="#创建独一无二的包名" class="headerlink" title="创建独一无二的包名"></a>创建独一无二的包名</h3><p>你可能注意到，一个包从未真正被打包成单一的文件，它可以由很多 <strong>.class</strong> 文件构成，因而事情就变得有点复杂了。为了避免这种情况，一种合乎逻辑的做法是将特定包下的所有 <strong>.class</strong> 文件都放在一个目录下。也就是说，利用操作系统的文件结构的层次性。这是 Java 解决混乱问题的一种方式；稍后你还会在我们介绍 <strong>jar</strong> 工具时看到另一种方式。</p><p>将所有的文件放在一个子目录还解决了其他的两个问题：创建独一无二的包名和查找可能隐藏于目录结构某处的类。这是通过将 <strong>.class</strong> 文件所在的路径位置编码成 <strong>package</strong> 名称来实现的。按照惯例，<strong>package</strong> 名称是类的创建者的反顺序的 Internet 域名。如果你遵循惯例，因为 Internet 域名是独一无二的，所以你的 <strong>package</strong> 名称也应该是独一无二的，不会发生名称冲突。如果你没有自己的域名，你就得构造一组不大可能与他人重复的组合（比如你的姓名），来创建独一无二的 package 名称。如果你打算发布 Java 程序代码，那么花些力气去获取一个域名是值得的。</p><p>此技巧的第二部分是把 <strong>package</strong> 名称分解成你机器上的一个目录，所以当 Java 解释器必须要加载一个 .class 文件时，它能定位到 <strong>.class</strong> 文件所在的位置。首先，它找出环境变量 <strong>CLASSPATH</strong>（通过操作系统设置，有时也能通过 Java 的安装程序或基于 Java 的工具设置）。<strong>CLASSPATH</strong> 包含一个或多个目录，用作查找 .<strong>class</strong> 文件的根目录。从根目录开始，Java 解释器获取包名并将每个句点替换成反斜杠，生成一个基于根目录的路径名（包名 foo.bar.baz 变成 foo\bar\baz 或 foo/bar/baz 或其它，取决于你的操作系统）。然后这个路径与 <strong>CLASSPATH</strong> 的不同项连接，解释器就在这些目录中查找与你所创建的类名称相关的 <strong>.class</strong> 文件（解释器还会查找某些涉及 Java 解释器所在位置的标准目录）。</p><p>为了理解这点，比如说我的域名 <strong>MindviewInc.com</strong>，将之反转并全部改为小写后就是 <strong>com.mindviewinc</strong>，这将作为我创建的类的独一无二的全局名称。（com、edu、org 等扩展名之前在 Java 包中都是大写，但是 Java 2 之后都统一用小写。）我决定再创建一个名为 <strong>simple</strong> 的类库，从而细分名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mindviewinc.simple;</span><br></pre></td></tr></table></figure><p>这个包名可以用作下面两个文件的命名空间保护伞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/mindviewinc/simple/Vector.java</span></span><br><span class="line"><span class="comment">// Creating a package</span></span><br><span class="line"><span class="keyword">package</span> com.mindviewinc.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;com.mindviewinc.simple.Vector&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前所述，<strong>package</strong> 语句必须是文件的第一行非注释代码。第二个文件看上去差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/mindviewinc/simple/List.java</span></span><br><span class="line"><span class="comment">// Creating a package</span></span><br><span class="line"><span class="keyword">package</span> com.mindviewinc.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;com.mindview.simple.List&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个文件都位于我机器上的子目录中，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\DOC\Java\com\mindviewinc\simple</span><br></pre></td></tr></table></figure><p>（注意，本书的每个文件的第一行注释都指明了文件在源代码目录树中的位置——供本书的自动代码提取工具使用。）</p><p>如果你回头看这个路径，会看到包名 <strong>com.mindviewinc.simple</strong>，但是路径的第一部分呢？CLASSPATH 环境变量会处理它。我机器上的环境变量部分如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH=.;D:\JAVA\LIB;C:\DOC\Java</span><br></pre></td></tr></table></figure><p>CLASSPATH 可以包含多个不同的搜索路径。</p><p>但是在使用 JAR 文件时，有点不一样。你必须在类路径写清楚 JAR 文件的实际名称，不能仅仅是 JAR 文件所在的目录。因此，对于一个名为 <strong>grape.jar</strong> 的 JAR 文件，类路径应包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH=.;D\JAVA\LIB;C:\flavors\grape.jar</span><br></pre></td></tr></table></figure><p>一旦设置好类路径，下面的文件就可以放在任意目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/LibTest.java</span></span><br><span class="line"><span class="comment">// Uses the library</span></span><br><span class="line"><span class="keyword">import</span> com.mindviewinc.simple.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">        List l = <span class="keyword">new</span> List();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.mindviewinc.simple.Vector</span><br><span class="line">com.mindviewinc.simple.List</span><br></pre></td></tr></table></figure><p>当编译器遇到导入 <strong>simple</strong> 库的 <strong>import</strong> 语句时，它首先会在 CLASSPATH 指定的目录中查找子目录 <strong>com/mindviewinc/simple</strong>，然后从已编译的文件中找出名称相符者（对 <strong>Vector</strong> 而言是 <strong>Vector.class</strong>，对 <strong>List</strong> 而言是 <strong>List.class</strong>）。注意，这两个类和其中要访问的方法都必须是 <strong>public</strong> 修饰的。</p><p>对于 Java 新手而言，设置 CLASSPATH 是一件麻烦的事（我最初使用时这么觉得），后面版本的 JDK 更加智能。你会发现当你安装好 JDK 时，即使不设置 CLASSPATH，也能够编译和运行基本的 Java 程序。但是，为了编译和运行本书的代码示例（从<a href="https://github.com/BruceEckel/OnJava8-examples">https://github.com/BruceEckel/OnJava8-examples</a> 取得），你必须将本书程序代码树的基本目录加入到 CLASSPATH 中（ gradlew 命令管理自身的 CLASSPATH，所以如果你想直接使用 javac 和 java，不用 Gradle 的话，就需要设置 CLASSPATH）。</p><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>如果通过 <strong>*</strong> 导入了两个包含相同名字类名的类库，会发生什么？例如，假设程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mindviewinc.simple.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><p>因为 <strong>java.util.*</strong> 也包含了 <strong>Vector</strong> 类，这就存在潜在的冲突。但是只要你不写导致冲突的代码，就不会有问题——这样很好，否则就得做很多类型检查工作来防止那些根本不会出现的冲突。</p><p>现在如果要创建一个 Vector 类，就会出现冲突：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br></pre></td></tr></table></figure><p>这里的 <strong>Vector</strong> 类指的是谁呢？编译器不知道，读者也不知道。所以编译器报错，强制你明确指明。对于标准的 Java 类 <strong>Vector</strong>，你可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.Vector v = <span class="keyword">new</span> java.util.Vector();</span><br></pre></td></tr></table></figure><p>这种写法完全指明了 <strong>Vector</strong> 类的位置（配合 CLASSPATH），那么就没有必要写 <strong>import java.util.*</strong> 语句，除非使用其他来自 <strong>java.util</strong> 中的类。</p><p>或者，可以导入单个类以防冲突——只要不在同一个程序中使用有冲突的名字（若使用了有冲突的名字，必须明确指明全名）。</p><h3 id="定制工具库"><a href="#定制工具库" class="headerlink" title="定制工具库"></a>定制工具库</h3><p>具备了以上知识，现在就可以创建自己的工具库来减少重复的程序代码了。</p><p>一般来说，我会使用反转后的域名来命名要创建的工具包，比如 <strong>com.mindviewinc.util</strong>，但为了简化，这里我把工具包命名为 <strong>onjava</strong>。</p><p>比如，下面是”控制流”一章中使用到的 <code>range()</code> 方法，采用了 for-in 语法进行简单的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Range.java</span></span><br><span class="line"><span class="comment">// Array creation methods that can be used without</span></span><br><span class="line"><span class="comment">// qualifiers, using static imports:</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Range</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Produce a sequence [0,n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] range(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            result[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Produce a sequence [start..end)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] range(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = end - start;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            result[i] = start + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Produce sequence [start..end) incrementing by step</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] range(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> step) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = (end - start) / step;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            result[i] = start + (i * step);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件的位置一定是在某个以一个 CLASSPATH 位置开始，然后接着是 <strong>onjava</strong> 的目录下。编译完之后，就可以在系统的任何地方使用 <strong>import static</strong> 语句来使用这些方法了。</p><p>从现在开始，无论何时你创建了有用的新工具，都可以把它加入到自己的类库中。在本书中，你将会看到更多的组件加入到 <strong>onjava</strong> 库。</p><h3 id="使用-import-改变行为"><a href="#使用-import-改变行为" class="headerlink" title="使用 import 改变行为"></a>使用 import 改变行为</h3><p>Java 没有 C 的<em>条件编译</em>功能，该功能使你不必更改任何程序代码而能够切换开关产生不同的行为。Java 之所以去掉此功能，可能是因为 C 在绝大多数情况下使用该功能解决跨平台问题：程序代码的不同部分要根据不同的平台来编译。而 Java 自身就是跨平台设计的，这个功能就没有必要了。</p><p>但是，条件编译还有其他的用途。调试是一个很常见的用途，调试功能在开发过程中是开启的，在发布的产品中是禁用的。可以通过改变导入的 <strong>package</strong> 来实现这一目的，修改的方法是将程序中的代码从调试版改为发布版。这个技术可用于任何种类的条件代码。</p><h3 id="使用包的忠告"><a href="#使用包的忠告" class="headerlink" title="使用包的忠告"></a>使用包的忠告</h3><p>当创建一个包时，包名就隐含了目录结构。这个包必须位于包名指定的目录中，该目录必须在以 CLASSPATH 开始的目录中可以查询到。 最初使用关键字 <strong>package</strong> 可能会有点不顺，因为除非遵守”包名对应目录路径”的规则，否则会收到很多意外的运行时错误信息如找不到特定的类，即使这个类就位于同一目录中。如果你收到类似信息，尝试把 <strong>package</strong> 语句注释掉，如果程序能运行的话，你就知道问题出现在哪里了。</p><p>注意，编译过的代码通常位于与源代码的不同目录中。这是很多工程的标准，而且集成开发环境（IDE）通常会自动为我们做这些。必须保证 JVM 通过 CLASSPATH 能找到编译后的代码。</p><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>Java 访问权限修饰符 <strong>public</strong>，<strong>protected</strong> 和 <strong>private</strong> 位于定义的类名，属性名和方法名之前。每个访问权限修饰符只能控制它所修饰的对象。</p><p>如果不提供访问修饰符，就意味着”包访问权限”。所以无论如何，万物都有某种形式的访问控制权。接下来的几节中，你将学习各种类型的访问权限。</p><h3 id="包访问权限"><a href="#包访问权限" class="headerlink" title="包访问权限"></a>包访问权限</h3><p>本章之前的所有示例要么使用 <strong>public</strong> 访问修饰符，要么就没使用修饰符（默认访问）。默认访问权限没有关键字，通常被称为包访问权限（有时也称为 friendly）。这意味着当前包中的所有其他类都可以访问那个成员。对于这个包之外的类，这个成员看上去是 <strong>private</strong> 的。由于一个编译单元（即一个文件）只能隶属于一个包，所以通过包访问权限，位于同一编译单元中的所有类彼此之间都是可访问的。</p><p>包访问权限可以把相关类聚到一个包下，以便它们能轻易地相互访问。包里的类给它们的包访问权限的成员赋予了相互访问的权限，所以你”拥有”了包内的程序代码。只有你拥有的代码才能访问你拥有的其他代码是有意义的。包访问为把类聚在一个包中提供了理由。在许多语言中，在文件中组织定义的方式是任意的，但是在 Java 中你被强制以一种合理的方式组织它们。另外，你可以把不能访问当前包里的类的其他类排除在外。</p><p>类控制着哪些代码有权访问自己的成员。其他包中的代码不能一上来就说”嗨，我是 <strong>Bob</strong> 的朋友！”，然后想看到 <strong>Bob</strong> 的 <strong>protected</strong>，包访问权限和 <strong>private</strong> 成员。取得对成员的访问权的唯一方式是：</p><ol><li>使成员成为 public。那么无论是谁，无论在哪，都可以访问它。</li><li>赋予成员默认包访问权限，不用加任何访问修饰符，然后将其他类放在相同的包内。这样，其他类就可以访问该成员。</li><li>在”复用”这一章你将看到，继承的类既可以访问 <strong>public</strong> 成员，也可以访问 <strong>protected</strong> 成员（但不能访问 <strong>private</strong> 成员）。只有当两个类处于同一个包内，它才可以访问包访问权限的成员。但现在不用担心继承和 <strong>protected</strong>。</li><li>提供访问器（accessor）和修改器（mutator）方法（有时也称为”get/set” 方法），从而读取和改变值。</li></ol><h3 id="public-接口访问权限"><a href="#public-接口访问权限" class="headerlink" title="public: 接口访问权限"></a>public: 接口访问权限</h3><p>当你使用关键字 <strong>public</strong>，就意味着紧随 public 后声明的成员对于每个人都是可用的，尤其是使用类库的客户端程序员更是如此。假设定义了一个包含下面编译单元的 <strong>dessert</strong> 包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/dessert/Cookie.java</span></span><br><span class="line"><span class="comment">// Creates a library</span></span><br><span class="line"><span class="keyword">package</span> hiding.dessert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cookie constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bite&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，<strong>Cookie.java</strong> 文件产生的类文件必须位于名为 <strong>dessert</strong> 的子目录中，该子目录在 <strong>hiding</strong> （表明本书的”封装”章节）下，它必须在 CLASSPATH 的几个目录之下。不要错误地认为 Java 总是会将当前目录视作查找行为的起点之一。如果你的 CLASSPATH 中没有 <code>.</code>，Java 就不会查找单独当前目录。</p><p>现在，使用 <strong>Cookie</strong> 创建一个程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/Dinner.java</span></span><br><span class="line"><span class="comment">// Uses the library</span></span><br><span class="line"><span class="keyword">import</span> hiding.dessert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dinner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cookie x = <span class="keyword">new</span> Cookie();</span><br><span class="line">        <span class="comment">// -x.bite(); // Can&#x27;t access</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie constructor</span><br></pre></td></tr></table></figure><p>你可以创建一个 <strong>Cookie</strong> 对象，因为它构造器和类都是 <strong>public</strong> 的。（后面会看到更多 <strong>public</strong> 的概念）但是，在 <strong>Dinner.java</strong> 中无法访问到 <strong>Cookie</strong> 对象中的 <code>bite()</code> 方法，因为 <code>bite()</code> 只提供了包访问权限，因而在 <strong>dessert</strong> 包之外无法访问，编译器禁止你使用它。</p><h3 id="默认包"><a href="#默认包" class="headerlink" title="默认包"></a>默认包</h3><p>你可能惊讶地发现，以下代码尽管看上去破坏了规则，但是仍然可以编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/Cake.java</span></span><br><span class="line"><span class="comment">// Accesses a class in a separate compilation unit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pie x = <span class="keyword">new</span> Pie();</span><br><span class="line">        x.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pie.f()</span><br></pre></td></tr></table></figure><p>同一目录下的第二个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/Pie.java</span></span><br><span class="line"><span class="comment">// The other class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pie.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初看上去这两个文件毫不相关，但在 <strong>Cake</strong> 中可以创建一个 <strong>Pie</strong> 对象并调用它的 <code>f()</code> 方法。（注意，你的 CLASSPATH 中一定得有 <code>.</code>，这样文件才能编译）通常会认为 <strong>Pie</strong> 和 <code>f()</code> 具有包访问权限，因此不能被 <strong>Cake</strong> 访问。它们的确具有包访问权限，这是部分正确。<strong>Cake.java</strong> 可以访问它们是因为它们在相同的目录中且没有给自己设定明确的包名。Java 把这样的文件看作是隶属于该目录的默认包中，因此它们为该目录中所有的其他文件都提供了包访问权限。</p><h3 id="private-你无法访问"><a href="#private-你无法访问" class="headerlink" title="private: 你无法访问"></a>private: 你无法访问</h3><p>关键字 <strong>private</strong> 意味着除了包含该成员的类，其他任何类都无法访问这个成员。同一包中的其他类无法访问 <strong>private</strong> 成员，因此这等于说是自己隔离自己。另一方面，让许多人合作创建一个包也是有可能的。使用 <strong>private</strong>，你可以自由地修改那个被修饰的成员，无需担心会影响同一包下的其他类。</p><p>默认的包访问权限通常提供了足够的隐藏措施；记住，使用类的客户端程序员无法访问包访问权限成员。这样做很好，因为默认访问权限是一种我们常用的权限（同时也是一种在忘记添加任何访问权限时自动得到的权限）。因此，通常考虑的是把哪些成员声明成 <strong>public</strong> 供客户端程序员使用。所以，最初不常使用关键字 <strong>private</strong>，因为程序没有它也可以照常工作。然而，使用 <strong>private</strong> 是非常重要的，尤其是在多线程环境中。（在”并发编程”一章中将看到）。</p><p>以下是一个使用 <strong>private</strong> 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/IceCream.java</span></span><br><span class="line"><span class="comment">// Demonstrates &quot;private&quot; keyword</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sundae</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sundae</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Sundae <span class="title">makeASundae</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sundae();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- Sundae x = new Sundae();</span></span><br><span class="line">        Sundae x = Sundae.makeASundae();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上展示了 <strong>private</strong> 的用武之地：控制如何创建对象，防止别人直接访问某个特定的构造器（或全部构造器）。例子中，你无法通过构造器创建一个 <strong>Sundae</strong> 对象，而必须调用 <code>makeASundae()</code> 方法创建对象。</p><p>任何可以肯定只是该类的”助手”方法，都可以声明为 <strong>private</strong>，以确保不会在包中的其他地方误用它，也防止了你会去改变或删除它。将方法声明为 <strong>private</strong> 确保了你拥有这种选择权。</p><p>对于类中的 <strong>private</strong> 属性也是一样。除非必须公开底层实现（这种情况很少见），否则就将属性声明为 <strong>private</strong>。然而，不能因为类中某个对象的引用是 <strong>private</strong>，就认为其他对象也无法拥有该对象的 <strong>public</strong> 引用（参见附录：对象传递和返回）。</p><h3 id="protected-继承访问权限"><a href="#protected-继承访问权限" class="headerlink" title="protected: 继承访问权限"></a>protected: 继承访问权限</h3><p>要理解 <strong>protected</strong> 的访问权限，我们在内容上需要作一点跳跃。首先，在介绍本书”复用”章节前，你不必真正理解本节的内容。但为了内容的完整性，这里作了简要介绍，举了个使用 <strong>protected</strong> 的例子。</p><p>关键字 <strong>protected</strong> 处理的是继承的概念，通过继承可以利用一个现有的类——我们称之为基类，然后添加新成员到现有类中而不必碰现有类。我们还可以改变类的现有成员的行为。为了从一个类中继承，需要声明新类 extends 一个现有类，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>类定义的其他部分看起来是一样的。</p><p>如果你创建了一个新包，并从另一个包继承类，那么唯一能访问的就是被继承类的 <strong>public</strong> 成员。（如果在同一个包中继承，就可以操作所有的包访问权限的成员。）有时，基类的创建者会希望某个特定成员能被继承类访问，但不能被其他类访问。这时就需要使用 <strong>protected</strong>。<strong>protected</strong> 也提供包访问权限，也就是说，相同包内的其他类可以访问 <strong>protected</strong> 元素。</p><p>回顾下先前的文件 <strong>Cookie.java</strong>，下面的类不能调用包访问权限的方法 <code>bite()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/ChocolateChip.java</span></span><br><span class="line"><span class="comment">// Can&#x27;t use package-access member from another package</span></span><br><span class="line"><span class="keyword">import</span> hiding.dessert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChocolateChip</span> <span class="keyword">extends</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChocolateChip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ChocolateChip constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chomp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- bite(); // Can&#x27;t access bite</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChocolateChip x = <span class="keyword">new</span> ChocolateChip();</span><br><span class="line">        x.chomp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie constructor</span><br><span class="line">ChocolateChip constructor</span><br></pre></td></tr></table></figure><p>如果类 <strong>Cookie</strong> 中存在一个方法 <code>bite()</code>，那么它的任何子类中都存在 <code>bite()</code> 方法。但是因为 <code>bite()</code> 具有包访问权限并且位于另一个包中，所以我们在这个包中无法使用它。你可以把它声明为 <strong>public</strong>，但这样一来每个人都能访问它，这可能也不是你想要的。如果你将 <strong>Cookie</strong> 改成如下这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/cookie2/Cookie.java</span></span><br><span class="line"><span class="keyword">package</span> hiding.cookie2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cookie constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bite&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>bite()</code> 对于所有继承 <strong>Cookie</strong> 的类，都是可访问的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/ChocolateChip2.java</span></span><br><span class="line"><span class="keyword">import</span> hiding.cookie2.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChocolateChip2</span> <span class="keyword">extends</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChocoalteChip2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ChocolateChip2 constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chomp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bite(); <span class="comment">// Protected method</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChocolateChip2 x = <span class="keyword">new</span> ChocolateChip2();</span><br><span class="line">        x.chomp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie constructor</span><br><span class="line">ChocolateChip2 constructor</span><br><span class="line">bite</span><br></pre></td></tr></table></figure><p>尽管 <code>bite()</code> 也具有包访问权限，但它不是 <strong>public</strong> 的。</p><h3 id="包访问权限-Vs-Public-构造器"><a href="#包访问权限-Vs-Public-构造器" class="headerlink" title="包访问权限 Vs Public 构造器"></a>包访问权限 Vs Public 构造器</h3><p>当你定义一个具有包访问权限的类时，你可以在类中定义一个 public 构造器，编译器不会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/packageaccess/PublicConstructor.java</span></span><br><span class="line"><span class="keyword">package</span> hiding.packageaccess;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublicConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublicConstructor</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个 Checkstyle 工具，你可以运行命令 <strong>gradlew hiding:checkstyleMain</strong> 使用它，它会指出这种写法是虚假的，而且从技术上来说是错误的。实际上你不能从包外访问到这个 <strong>public</strong> 构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/CreatePackageAccessObject.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">import</span> hiding.packageaccess.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatePackageAcessObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> PublicConstructor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你编译下这个类，会得到编译错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreatePackageAccessObject.java:6:error:</span><br><span class="line">PublicConstructor is not public in hiding.packageaccess;</span><br><span class="line">cannot be accessed from outside package</span><br><span class="line">new PublicConstructor();</span><br><span class="line">^</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure><p>因此，在一个具有包访问权限的类中定义一个 <strong>public</strong> 的构造器并不能真的使这个构造器成为 <strong>public</strong>，在声明的时候就应该标记为编译时错误。</p><h2 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h2><p>访问控制通常被称为实现的隐藏。将数据和方法包装进类中并把具体实现隐藏被称作是封装。其结果就是一个同时带有特征和行为的数据类型。</p><p>出于两个重要的原因，访问控制在数据类型内部划定了边界。第一个原因是确立客户端程序员可以使用和不能使用的边界。可以在结构中建立自己的内部机制而不必担心客户端程序员偶尔将内部实现作为他们可以使用的接口的一部分。</p><p>这直接引出了第二个原因：将接口与实现分离。如果在一组程序中使用结构，而客户端程序员只能向 <strong>public</strong> 接口发送消息的话，那么就可以自由地修改任何不是 <strong>public</strong> 的事物（例如包访问权限，protected，或 private 修饰的事物），却不会破坏客户端代码。</p><p>为了清晰起见，你可以采用一种创建类的风格：<strong>public</strong> 成员放在类的开头，接着是 <strong>protected</strong> 成员，包访问权限成员，最后是 <strong>private</strong> 成员。这么做的好处是类的使用者可以从头读起，首先会看到对他们而言最重要的部分（public 成员，因为可以从文件外访问它们），直到遇到非 <strong>public</strong> 成员时停止阅读，下面就是内部实现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/OrganizedByAccess.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizedByAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pub1</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pub2</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pub3</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priv1</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priv2</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priv3</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做只能是程序阅读起来稍微容易一些，因为实现和接口还是混合在一起。也就是说，你仍然能看到源代码——实现部分，因为它就在类中。另外，javadoc 提供的注释文档功能降低了程序代码的可读性对客户端程序员的重要性。将接口展现给类的使用者实际上是类浏览器的任务，类浏览器会展示所有可用的类，并告诉你如何使用它们（比如说哪些成员可用）。在 Java 中，JDK 文档起到了类浏览器的作用。</p><h2 id="类访问权限"><a href="#类访问权限" class="headerlink" title="类访问权限"></a>类访问权限</h2><p>访问权限修饰符也可以用于确定类库中的哪些类对于类库的使用者是可用的。如果希望某个类可以被客户端程序员使用，就把关键字 <strong>public</strong> 作用于整个类的定义。这甚至控制着客户端程序员能否创建类的对象。</p><p>为了控制一个类的访问权限，修饰符必须出现在关键字 <strong>class</strong> 之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>如果你的类库名是 <strong>hiding</strong>，那么任何客户端程序员都可以通过如下声明访问 <strong>Widget</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hiding.Widget;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hiding.*;</span><br></pre></td></tr></table></figure><p>这里有一些额外的限制：</p><ol><li>每个编译单元（即每个文件）中只能有一个 <strong>public</strong> 类。这表示，每个编译单元有一个公共的接口用 <strong>public</strong> 类表示。该接口可以包含许多支持包访问权限的类。一旦一个编译单元中出现一个以上的 <strong>public</strong> 类，编译就会报错。</li><li><strong>public</strong> 类的名称必须与含有该编译单元的文件名相同，包括大小写。所以对于 <strong>Widget</strong> 来说，文件名必须是 <strong>Widget.java</strong>，不能是 <strong>widget.java</strong> 或 <strong>WIDGET.java</strong>。再次强调，如果名字不匹配，编译器会报错。</li><li>虽然不是很常见，但是编译单元内没有 <strong>public</strong> 类也是可能的。这时可以随意命名文件（尽管随意命名会让代码的阅读者和维护者感到困惑）。</li></ol><p>如果获取了一个在 <strong>hiding</strong> 包中的类，只用来完成 <strong>Widget</strong> 或 <strong>hiding</strong> 包下一些其他 <strong>public</strong> 类所要执行的任务，怎么办呢？ 你不想自找麻烦为客户端程序员创建说明文档，并且你认为不久后会完全改变原有方案并将旧版本删除，替换成新版本。为了保留此灵活性，需要确保客户端程序员不依赖隐藏在 <strong>hiding</strong> 中的任何特定细节，那么把 <strong>public</strong> 关键字从类中去掉，给予它包访问权限，就可以了。</p><p>当你创建了一个包访问权限的类，把类中的属性声明为 <strong>private</strong> 仍然是有意义的——应该尽可能将所有属性都声明为 <strong>private</strong>，但是通常把方法声明成与类（包访问权限）相同的访问权限也是合理的。由于一个包访问权限的类只能被用于包内，除非你被强制将某些方法声明为 <strong>public</strong>，这种情况下，编译器会告诉你。</p><p>注意，类既不能是 <strong>private</strong> 的（这样除了该类自身，任何类都不能访问它），也不能是 <strong>protected</strong> 的。所以对于类的访问权限只有两种选择：包访问权限或者 <strong>public</strong>。为了防止类被外界访问，可以将所有的构造器声明为 <strong>private</strong>，这样只有你自己能创建对象（在类的 static 成员中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding/Lunch.java</span></span><br><span class="line"><span class="comment">// Demonstrates class access specifiers. Make a class</span></span><br><span class="line"><span class="comment">// effectively private with private constructors:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Soup1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup1 <span class="title">makeSoup</span><span class="params">()</span> </span>&#123; <span class="comment">// [1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Soup1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Soup2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Soup2 ps1 = <span class="keyword">new</span> Soup2(); <span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup2 <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ps1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Only one public class allowed per file:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Can&#x27;t do this! Private constructor:</span></span><br><span class="line">        <span class="comment">//- Soup1 soup = new Soup1();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Soup1 soup = Soup1.makeSoup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Soup2.access().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以像 [1] 那样通过 <strong>static</strong> 方法创建对象，也可以像 [2] 那样先创建一个静态对象，当用户需要访问它时返回对象的引用即可。</p><p>到目前为止，大部分的方法要么返回 void，要么返回基本类型，所以 [1] 处的定义乍看之下会有点困惑。方法名（<strong>makeSoup</strong>）前面的 <strong>Soup1</strong> 表明了方法返回的类型。到目前为止，这里经常是 <strong>void</strong>，即不返回任何东西。然而也可以返回对象的引用，就像这里一样。这个方法返回了对 <strong>Soup1</strong> 类对象的引用。</p><p><strong>Soup1</strong> 和 <strong>Soup2</strong> 展示了如何通过将你所有的构造器声明为 <strong>private</strong> 的方式防止直接创建某个类的对象。记住，如果你不显式地创建构造器，编译器会自动为你创建一个无参构造器（没有参数的构造器）。如果我们编写了无参构造器，那么编译器就不会自动创建构造器了。将构造器声明为 <strong>private</strong>，那么谁也无法创建该类的对象了。但是现在别人该怎么使用这个类呢？上述例子给出了两个选择。在 <strong>Soup1</strong> 中，有一个 <strong>static</strong> 方法，它的作用是创建一个新的 <strong>Soup1</strong> 对象并返回对象的引用。如果想要在返回引用之前在 <strong>Soup1</strong> 上做一些额外操作，或是记录创建了多少个 <strong>Soup1</strong> 对象（可以用来限制数量），这种做法是有用的。</p><p><strong>Soup2</strong> 用到了所谓的<em>设计模式</em>。这种模式叫做<em>单例模式</em>，因为它只允许创建类的一个对象。<strong>Soup2</strong> 类的对象是作为 <strong>Soup2</strong> 的 <strong>static</strong> <strong>private</strong> 成员而创建的，所以有且只有一个，你只能通过 <strong>public</strong> 修饰的 <code>access()</code> 方法访问到这个对象。</p><h2 id="本章小结-5"><a href="#本章小结-5" class="headerlink" title="本章小结"></a>本章小结</h2><p>无论在什么样的关系中，划定一些供各成员共同遵守的界限是很重要的。当你创建了一个类库，也就与该类库的使用者产生了联系，他们是类库的客户端程序员，需要使用你的类库创建应用或更大的类库。</p><p>没有规则，客户端程序员就可以对类的所有成员为所欲为，即使你希望他们不要操作部分成员。这种情况下，所有事物都是公开的。</p><p>本章讨论了类库是如何通过类构建的：首先，介绍了将一组类打包到类库的方式，其次介绍了类如何控制对其成员的访问。</p><p>据估计，用 C 语言开发项目，当代码量达到 5 万行和 10 万行时就会出现问题，因为 C 语言只有单一的命名空间，名称开始冲突造成额外的管理开销。在 Java 中，关键字 <strong>package</strong>，包命名模式和关键字 <strong>import</strong> 给了你对于名称的完全控制权，因此可以轻易地避免名称冲突的问题。</p><p>控制成员访问权限有两个原因。第一个原因是使用户不要接触他们不该接触的部分，这部分对于类内部来说是必要的，但是不属于客户端程序员所需接口的一部分。因此将方法和属性声明为 <strong>private</strong> 对于客户端程序员来说是一种服务，可以让他们清楚地看到什么是重要的，什么可以忽略。这可以简化他们对类的理解。</p><p>第二个也是最重要的原因是为了让类库设计者更改类内部的工作方式，而不用担心会影响到客户端程序员。比如最初以某种方式创建一个类，随后发现如果更改代码结构可以极大地提高运行速度。如果接口与实现被明确地隔离和保护，你可以实现这一目的，而不必强制客户端程序员重新编写代码。访问权限控制确保客户端程序员不会依赖某个类的底层实现的任何部分。</p><p>当你具备更改底层实现的能力时，不但可以自由地改善设计，还可能会随意地犯错。无论如何细心地计划和设计，都有可能犯错。当了解到犯错是相对安全的时候，你可以更加放心地实验，更快地学会，更快地完成项目。</p><p>类的 <strong>public</strong> 接口是用户真正看到的，所以在分析和设计阶段决定这部分接口是最重要的部分。尽管如此，你仍然有改变的空间。如果最初没有创建出正确的接口，可以添加更多的方法，只要你不删除那些客户端程序员已经在他们的代码中使用的东西。</p><p>注意到访问权限控制关注的是类库创建者和外部使用者之间的关系，一种交流方式。很多情况下，事实并非如此。例如，你自己编写了所有的代码，或者在一个小组中工作，所有的东西都放在同一个包下。这些情况下，交流方式则是另外一种，此时严格地遵循访问权限规则也许不是最佳选择，默认（包）访问权限也许就足够好了。</p><h1 id="第-8-章-复用"><a href="#第-8-章-复用" class="headerlink" title="第 8 章 复用"></a>第 8 章 复用</h1><blockquote><p>代码复用是面向对象编程（OOP）最具魅力的原因之一。</p></blockquote><p>对于像 C 语言等面向过程语言来说，“复用”通常指的就是“复制代码”。任何语言都可通过简单复制来达到代码复用的目的，但是这样做的效果并不好。Java 围绕“类”（Class）来解决问题。我们可以直接使用别人构建或调试过的代码，而非创建新类、重新开始。</p><p>如何在不污染源代码的前提下使用现存代码是需要技巧的。在本章里，你将学习到两种方式来达到这个目的：</p><ol><li><p>第一种方式直接了当。在新类中创建现有类的对象。这种方式叫做“组合”（Composition），通过这种方式复用代码的功能，而非其形式。</p></li><li><p>第二种方式更为微妙。创建现有类类型的新类。照字面理解：采用现有类形式，又无需在编码时改动其代码，这种方式就叫做“继承”（Inheritance），编译器会做大部分的工作。<strong>继承</strong>是面向对象编程（OOP）的重要基础之一。更多功能相关将在<a href="./09-Polymorphism.md">多态</a>（Polymorphism）章节中介绍。</p></li></ol><p>组合与继承的语法、行为上有许多相似的地方（这其实是有道理的，毕竟都是基于现有类型构建新的类型）。在本章中，你会学到这两种代码复用的方法。</p><h2 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h2><p>在前面的学习中，“组合”（Composition）已经被多次使用。你仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。例如，假设你需要一个对象，其中内置了几个 <strong>String</strong> 对象，两个基本类型（primitives）的属性字段，一个其他类的对象。对于非基本类型对象，将引用直接放置在新类中，对于基本类型属性字段则仅进行声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/SprinklerSystem.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Composition for code reuse</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterSource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String s;</span><br><span class="line">  WaterSource() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;WaterSource()&quot;</span>);</span><br><span class="line">    s = <span class="string">&quot;Constructed&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SprinklerSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String valve1, valve2, valve3, valve4;</span><br><span class="line">  <span class="keyword">private</span> WaterSource source = <span class="keyword">new</span> WaterSource();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> f;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="string">&quot;valve1 = &quot;</span> + valve1 + <span class="string">&quot; &quot;</span> +</span><br><span class="line">      <span class="string">&quot;valve2 = &quot;</span> + valve2 + <span class="string">&quot; &quot;</span> +</span><br><span class="line">      <span class="string">&quot;valve3 = &quot;</span> + valve3 + <span class="string">&quot; &quot;</span> +</span><br><span class="line">      <span class="string">&quot;valve4 = &quot;</span> + valve4 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot; &quot;</span> + <span class="string">&quot;f = &quot;</span> + f + <span class="string">&quot; &quot;</span> +</span><br><span class="line">      <span class="string">&quot;source = &quot;</span> + source; <span class="comment">// [1]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SprinklerSystem sprinklers = <span class="keyword">new</span> SprinklerSystem();</span><br><span class="line">    System.out.println(sprinklers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">WaterSource()</span></span><br><span class="line"><span class="comment">valve1 = null valve2 = null valve3 = null valve4 = null</span></span><br><span class="line"><span class="comment">i = 0 f = 0.0 source = Constructed</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两个类中定义的一个方法是特殊的: <code>toString()</code>。每个非基本类型对象都有一个 <code>toString()</code> 方法，在编译器需要字符串但它有对象的特殊情况下调用该方法。因此，在 [1] 中，编译器看到你试图“添加”一个 <strong>WaterSource</strong> 类型的字符串对象 。因为字符串只能拼接另一个字符串，所以它就先会调用 <code>toString()</code> 将 <strong>source</strong> 转换成一个字符串。然后，它可以拼接这两个字符串并将结果字符串传递给 <code>System.out.println()</code>。要对创建的任何类允许这种行为，只需要编写一个 <strong>toString()</strong> 方法。在 <code>toString()</code> 上使用 <strong>@Override</strong> 注释来告诉编译器，以确保正确地覆盖。<strong>@Override</strong> 是可选的，但它有助于验证你没有拼写错误 (或者更微妙地说，大小写字母输入错误)。类中的基本类型字段自动初始化为零，正如 <strong>object Everywhere</strong> 一章中所述。但是对象引用被初始化为 <strong>null</strong>，如果你尝试调用其任何一个方法，你将得到一个异常（一个运行时错误）。方便的是，打印 <strong>null</strong> 引用却不会得到异常。</p><p>编译器不会为每个引用创建一个默认对象，这是有意义的，因为在许多情况下，这会导致不必要的开销。初始化引用有四种方法:</p><ol><li>当对象被定义时。这意味着它们总是在调用构造函数之前初始化。</li><li>在该类的构造函数中。</li><li>在实际使用对象之前。这通常称为<em>延迟初始化</em>。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。</li><li>使用实例初始化。</li></ol><p>以上四种实例创建的方法例子在这：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Bath.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Constructor initialization with composition</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String s;</span><br><span class="line">  Soap() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Soap()&quot;</span>);</span><br><span class="line">    s = <span class="string">&quot;Constructed&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bath</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String <span class="comment">// Initializing at point of definition:</span></span><br><span class="line">    s1 = <span class="string">&quot;Happy&quot;</span>,</span><br><span class="line">    s2 = <span class="string">&quot;Happy&quot;</span>,</span><br><span class="line">    s3, s4;</span><br><span class="line">  <span class="keyword">private</span> Soap castille;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> toy;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Bath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Inside Bath()&quot;</span>);</span><br><span class="line">    s3 = <span class="string">&quot;Joy&quot;</span>;</span><br><span class="line">    toy = <span class="number">3.14f</span>;</span><br><span class="line">    castille = <span class="keyword">new</span> Soap();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Instance initialization:</span></span><br><span class="line">  &#123; i = <span class="number">47</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s4 == <span class="keyword">null</span>) <span class="comment">// Delayed initialization:</span></span><br><span class="line">      s4 = <span class="string">&quot;Joy&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="string">&quot;s1 = &quot;</span> + s1 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;s2 = &quot;</span> + s2 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;s3 = &quot;</span> + s3 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;s4 = &quot;</span> + s4 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;toy = &quot;</span> + toy + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;castille = &quot;</span> + castille;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bath b = <span class="keyword">new</span> Bath();</span><br><span class="line">    System.out.println(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Inside Bath()</span></span><br><span class="line"><span class="comment">Soap()</span></span><br><span class="line"><span class="comment">s1 = Happy</span></span><br><span class="line"><span class="comment">s2 = Happy</span></span><br><span class="line"><span class="comment">s3 = Joy</span></span><br><span class="line"><span class="comment">s4 = Joy</span></span><br><span class="line"><span class="comment">i = 47</span></span><br><span class="line"><span class="comment">toy = 3.14</span></span><br><span class="line"><span class="comment">castille = Constructed</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <strong>Bath</strong> 构造函数中，有一个代码块在所有初始化发生前就已经执行了。当你不在定义处初始化时，仍然不能保证在向对象引用发送消息之前执行任何初始化——如果你试图对未初始化的引用调用方法，则未初始化的引用将产生运行时异常。</p><p>当调用 <code>toString()</code> 时，它将赋值 s4，以便在使用字段的时候所有的属性都已被初始化。</p><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><p>继承是所有面向对象语言的一个组成部分。事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。</p><p>组合的语法很明显，但是继承使用了一种特殊的语法。当你继承时，你说，“这个新类与那个旧类类似。你可以在类主体的左大括号前的代码中声明这一点，使用关键字 <strong>extends</strong> 后跟基类的名称。当你这样做时，你将自动获得基类中的所有字段和方法。这里有一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Detergent.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Inheritance syntax &amp; properties</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cleanser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String s = <span class="string">&quot;Cleanser&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String a)</span> </span>&#123; s += a; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dilute</span><span class="params">()</span> </span>&#123; append(<span class="string">&quot; dilute()&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123; append(<span class="string">&quot; apply()&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span><span class="params">()</span> </span>&#123; append(<span class="string">&quot; scrub()&quot;</span>); &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cleanser x = <span class="keyword">new</span> Cleanser();</span><br><span class="line">    x.dilute(); x.apply(); x.scrub();</span><br><span class="line">    System.out.println(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Detergent</span> <span class="keyword">extends</span> <span class="title">Cleanser</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Change a method:</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    append(<span class="string">&quot; Detergent.scrub()&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.scrub(); <span class="comment">// Call base-class version</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Add methods to the interface:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foam</span><span class="params">()</span> </span>&#123; append(<span class="string">&quot; foam()&quot;</span>); &#125;</span><br><span class="line">  <span class="comment">// Test the new class:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Detergent x = <span class="keyword">new</span> Detergent();</span><br><span class="line">    x.dilute();</span><br><span class="line">    x.apply();</span><br><span class="line">    x.scrub();</span><br><span class="line">    x.foam();</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    System.out.println(<span class="string">&quot;Testing base class:&quot;</span>);</span><br><span class="line">    Cleanser.main(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Cleanser dilute() apply() Detergent.scrub() scrub()</span></span><br><span class="line"><span class="comment">foam()</span></span><br><span class="line"><span class="comment">Testing base class:</span></span><br><span class="line"><span class="comment">Cleanser dilute() apply() scrub()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这演示了一些特性。首先，在 <strong>Cleanser</strong> 的 <code>append()</code> 方法中，使用 <code>+=</code> 操作符将字符串连接到 <strong>s</strong>，这是 Java 设计人员“重载”来处理字符串的操作符之一 (还有 + )。</p><p>第二，<strong>Cleanser</strong> 和 <strong>Detergent</strong> 都包含一个 <code>main()</code> 方法。你可以为每个类创建一个 <code>main()</code> ; 这允许对每个类进行简单的测试。当你完成测试时，不需要删除 <code>main()</code>; 你可以将其留在以后的测试中。即使程序中有很多类都有 <code>main()</code> 方法，惟一运行的只有在命令行上调用的 <code>main()</code>。这里，当你使用 <strong>java Detergent</strong> 时候，就调用了 <code>Detergent.main()</code>。但是你也可以使用 <strong>java Cleanser</strong> 来调用 <code>Cleanser.main()</code>，即使 <strong>Cleanser</strong> 不是一个公共类。即使类只具有包访问权，也可以访问 <code>public main()</code>。</p><p>在这里，<code>Detergent.main()</code> 显式地调用 <code>Cleanser.main()</code>，从命令行传递相同的参数(当然，你可以传递任何字符串数组)。</p><p><strong>Cleanser</strong> 中的所有方法都是公开的。请记住，如果不使用任何访问修饰符，则成员默认为包访问权限，这只允许包内成员访问。因此，如果没有访问修饰符，那么包内的任何人都可以使用这些方法。例如，<strong>Detergent</strong> 就没有问题。但是，如果其他包中的类继承 <strong>Cleanser</strong>，则该类只能访问 <strong>Cleanser</strong> 的公共成员。因此，为了允许继承，一般规则是所有字段为私有，所有方法为公共。(受保护成员也允许派生类访问;你以后会知道的。)在特定的情况下，你必须进行调整，但这是一个有用的指南。</p><p><strong>Cleanser</strong> 的接口中有一组方法: <code>append()</code>、<code>dilute()</code>、<code>apply()</code>、<code>scrub()</code> 和 <code>toString()</code>。因为 <strong>Detergent</strong> 是从 <strong>Cleanser</strong> 派生的(通过 <strong>extends</strong> 关键字)，所以它会在其接口中自动获取所有这些方法，即使你没有在 <strong>Detergent</strong> 中看到所有这些方法的显式定义。那么，可以把继承看作是复用类。如在 <code>scrub()</code> 中所见，可以使用基类中定义的方法并修改它。在这里，你可以在新类中调用基类的该方法。但是在 <code>scrub()</code> 内部，不能简单地调用 <code>scrub()</code>，因为这会产生递归调用。为了解决这个问题，Java 的 <strong>super</strong> 关键字引用了当前类继承的“超类”(基类)。因此表达式 <code>super.scrub()</code> 调用方法 <code>scrub()</code> 的基类版本。</p><p>继承时，你不受限于使用基类的方法。你还可以像向类添加任何方法一样向派生类添加新方法:只需定义它。方法 <code>foam()</code> 就是一个例子。<code>Detergent.main()</code> 中可以看到，对于 <strong>Detergent</strong> 对象，你可以调用 <strong>Cleanser</strong> 和 <strong>Detergent</strong> 中可用的所有方法 (如 <code>foam()</code> )。</p><h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>现在涉及到两个类:基类和派生类。想象派生类生成的结果对象可能会让人感到困惑。从外部看，新类与基类具有相同的接口，可能还有一些额外的方法和字段。但是继承并不只是复制基类的接口。当你创建派生类的对象时，它包含基类的子对象。这个子对象与你自己创建基类的对象是一样的。只是从外部看，基类的子对象被包装在派生类的对象中。</p><p>必须正确初始化基类子对象，而且只有一种方法可以保证这一点 : 通过调用基类构造函数在构造函数中执行初始化，该构造函数具有执行基类初始化所需的所有适当信息和特权。Java 自动在派生类构造函数中插入对基类构造函数的调用。下面的例子展示了三个层次的继承:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Cartoon.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Constructor calls during inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art</span> </span>&#123;</span><br><span class="line">  Art() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Art constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Art</span> </span>&#123;</span><br><span class="line">  Drawing() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Drawing constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cartoon</span> <span class="keyword">extends</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cartoon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cartoon constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cartoon x = <span class="keyword">new</span> Cartoon();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Art constructor</span></span><br><span class="line"><span class="comment">Drawing constructor</span></span><br><span class="line"><span class="comment">Cartoon constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构造从基类“向外”进行，因此基类在派生类构造函数能够访问它之前进行初始化。即使不为 <strong>Cartoon</strong> 创建构造函数，编译器也会为你合成一个无参数构造函数，调用基类构造函数。尝试删除 <strong>Cartoon</strong> 构造函数来查看这个。</p><h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h3><p>上面的所有例子中构造函数都是无参数的 ; 编译器很容易调用这些构造函数，因为不需要参数。如果没有无参数的基类构造函数，或者必须调用具有参数的基类构造函数，则必须使用 <strong>super</strong> 关键字和适当的参数列表显式地编写对基类构造函数的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Chess.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Inheritance, constructors and arguments</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">  Game(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Game constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoardGame</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">  BoardGame(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;BoardGame constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">BoardGame</span> </span>&#123;</span><br><span class="line">  Chess() &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">11</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Chess constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Chess x = <span class="keyword">new</span> Chess();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Game constructor</span></span><br><span class="line"><span class="comment">BoardGame constructor</span></span><br><span class="line"><span class="comment">Chess constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有在 <strong>BoardGame</strong> 构造函数中调用基类构造函数，编译器就会报错找不到 <code>Game()</code> 的构造函数。此外，对基类构造函数的调用必须是派生类构造函数中的第一个操作。(如果你写错了，编译器会提醒你。)</p><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>Java 不直接支持的第三种重用关系称为委托。这介于继承和组合之间，因为你将一个成员对象放在正在构建的类中(比如组合)，但同时又在新类中公开来自成员对象的所有方法(比如继承)。例如，宇宙飞船需要一个控制模块:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/SpaceShipControls.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipControls</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建造宇宙飞船的一种方法是使用继承:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/DerivedSpaceShip.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">DerivedSpaceShip</span> <span class="keyword">extends</span> <span class="title">SpaceShipControls</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DerivedSpaceShip</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DerivedSpaceShip protector =</span><br><span class="line">        <span class="keyword">new</span> DerivedSpaceShip(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然而， <strong>DerivedSpaceShip</strong> 并不是真正的“一种” <strong>SpaceShipControls</strong> ，即使你“告诉” <strong>DerivedSpaceShip</strong> 调用 <code>forward()</code>。更准确地说，一艘宇宙飞船包含了 <strong>SpaceShipControls </strong>，同时 <strong>SpaceShipControls</strong> 中的所有方法都暴露在宇宙飞船中。委托解决了这个难题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/SpaceShipDelegation.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipDelegation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> SpaceShipControls controls =</span><br><span class="line">    <span class="keyword">new</span> SpaceShipControls();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpaceShipDelegation</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Delegated methods:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.back(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.down(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.forward(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.left(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.right(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    controls.turboBoost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.up(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpaceShipDelegation protector =</span><br><span class="line">      <span class="keyword">new</span> SpaceShipDelegation(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法被转发到底层 <strong>control</strong> 对象，因此接口与继承的接口是相同的。但是，你对委托有更多的控制，因为你可以选择只在成员对象中提供方法的子集。</p><p>虽然 Java 语言不支持委托，但是开发工具常常支持。例如，上面的例子是使用 JetBrains Idea IDE 自动生成的。</p><h2 id="结合组合与继承"><a href="#结合组合与继承" class="headerlink" title="结合组合与继承"></a>结合组合与继承</h2><p>你将经常同时使用组合和继承。下面的例子展示了使用继承和组合创建类，以及必要的构造函数初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/PlaceSetting.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Combining composition &amp; inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span> </span>&#123;</span><br><span class="line">  Plate(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Plate constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DinnerPlate</span> <span class="keyword">extends</span> <span class="title">Plate</span> </span>&#123;</span><br><span class="line">  DinnerPlate(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;DinnerPlate constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">  Utensil(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Utensil constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> <span class="keyword">extends</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">  Spoon(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Spoon constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fork</span> <span class="keyword">extends</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">  Fork(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Fork constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knife</span> <span class="keyword">extends</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">  Knife(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Knife constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A cultural way of doing something:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Custom</span> </span>&#123;</span><br><span class="line">  Custom(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Custom constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceSetting</span> <span class="keyword">extends</span> <span class="title">Custom</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Spoon sp;</span><br><span class="line">  <span class="keyword">private</span> Fork frk;</span><br><span class="line">  <span class="keyword">private</span> Knife kn;</span><br><span class="line">  <span class="keyword">private</span> DinnerPlate pl;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PlaceSetting</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(i + <span class="number">1</span>);</span><br><span class="line">    sp = <span class="keyword">new</span> Spoon(i + <span class="number">2</span>);</span><br><span class="line">    frk = <span class="keyword">new</span> Fork(i + <span class="number">3</span>);</span><br><span class="line">    kn = <span class="keyword">new</span> Knife(i + <span class="number">4</span>);</span><br><span class="line">    pl = <span class="keyword">new</span> DinnerPlate(i + <span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;PlaceSetting constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PlaceSetting x = <span class="keyword">new</span> PlaceSetting(<span class="number">9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Custom constructor</span></span><br><span class="line"><span class="comment">Utensil constructor</span></span><br><span class="line"><span class="comment">Spoon constructor</span></span><br><span class="line"><span class="comment">Utensil constructor</span></span><br><span class="line"><span class="comment">Fork constructor</span></span><br><span class="line"><span class="comment">Utensil constructor</span></span><br><span class="line"><span class="comment">Knife constructor</span></span><br><span class="line"><span class="comment">Plate constructor</span></span><br><span class="line"><span class="comment">DinnerPlate constructor</span></span><br><span class="line"><span class="comment">PlaceSetting constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管编译器强制你初始化基类，并要求你在构造函数的开头就初始化基类，但它并不监视你以确保你初始化了成员对象。注意类是如何干净地分离的。你甚至不需要方法重用代码的源代码。你最多只导入一个包。(这对于继承和组合都是正确的。)</p><h3 id="保证适当的清理"><a href="#保证适当的清理" class="headerlink" title="保证适当的清理"></a>保证适当的清理</h3><p>Java 没有 C++ 中析构函数的概念，析构函数是在对象被销毁时自动调用的方法。原因可能是，在 Java 中，通常是忘掉而不是销毁对象，从而允许垃圾收集器根据需要回收内存。通常这是可以的，但是有时你的类可能在其生命周期中执行一些需要清理的活动。初始化和清理章节提到，你无法知道垃圾收集器何时会被调用，甚至它是否会被调用。因此，如果你想为类清理一些东西，必须显式地编写一个特殊的方法来完成它，并确保客户端程序员知道他们必须调用这个方法。最重要的是——正如在”异常”章节中描述的——你必须通过在 <strong>finally </strong>子句中放置此类清理来防止异常。</p><p>请考虑一个在屏幕上绘制图片的计算机辅助设计系统的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/CADSystem.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Ensuring proper cleanup</span></span><br><span class="line"><span class="comment">// &#123;java reuse.CADSystem&#125;</span></span><br><span class="line"><span class="keyword">package</span> reuse;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Shape(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Shape constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Shape dispose&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Circle(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Drawing Circle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Erasing Circle&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Triangle(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Drawing Triangle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Erasing Triangle&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> start, end;</span><br><span class="line">  Line(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    <span class="keyword">super</span>(start);</span><br><span class="line">    <span class="keyword">this</span>.start = start;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;Drawing Line: &quot;</span> + start + <span class="string">&quot;, &quot;</span> + end);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;Erasing Line: &quot;</span> + start + <span class="string">&quot;, &quot;</span> + end);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CADSystem</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Circle c;</span><br><span class="line">  <span class="keyword">private</span> Triangle t;</span><br><span class="line">  <span class="keyword">private</span> Line[] lines = <span class="keyword">new</span> Line[<span class="number">3</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CADSystem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lines.length; j++)</span><br><span class="line">      lines[j] = <span class="keyword">new</span> Line(j, j*j);</span><br><span class="line">    c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">    t = <span class="keyword">new</span> Triangle(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Combined constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CADSystem.dispose()&quot;</span>);</span><br><span class="line">    <span class="comment">// The order of cleanup is the reverse</span></span><br><span class="line">    <span class="comment">// of the order of initialization:</span></span><br><span class="line">    t.dispose();</span><br><span class="line">    c.dispose();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lines.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      lines[i].dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CADSystem x = <span class="keyword">new</span> CADSystem(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Code and exception handling...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      x.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Line: 0, 0</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Line: 1, 1</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Line: 2, 4</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Circle</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Triangle</span></span><br><span class="line"><span class="comment">Combined constructor</span></span><br><span class="line"><span class="comment">CADSystem.dispose()</span></span><br><span class="line"><span class="comment">Erasing Triangle</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Erasing Circle</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Erasing Line: 2, 4</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Erasing Line: 1, 1</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Erasing Line: 0, 0</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个系统中的所有东西都是某种 <strong>Shape</strong> (它本身是一种 <strong>Object</strong>，因为它是从根类隐式继承的) 。除了使用 <strong>super</strong> 调用该方法的基类版本外，每个类还覆盖 <code>dispose()</code> 方法。特定的 <strong>Shape</strong> 类——<strong>Circle</strong>、<strong>Triangle</strong> 和 <strong>Line</strong>，都有 “draw” 构造函数，尽管在对象的生命周期中调用的任何方法都可以负责做一些需要清理的事情。每个类都有自己的 <code>dispose()</code> 方法来将非内存的内容恢复到对象存在之前的状态。</p><p>在 <code>main()</code> 中，有两个关键字是你以前没有见过的，在”异常”一章之前不会详细解释: <strong>try</strong> 和 <strong>finally</strong>。<strong>try</strong> 关键字表示后面的块 (用花括号分隔 )是一个受保护的区域，这意味着它得到了特殊处理。其中一个特殊处理是，无论 <strong>try</strong> 块如何退出，在这个保护区域之后的 <strong>finally</strong> 子句中的代码总是被执行。(通过异常处理，可以用许多不同寻常的方式留下 <strong>try</strong> 块。)这里，<strong>finally</strong> 子句的意思是，“无论发生什么，始终调用 <code>x.dispose()</code>。”</p><p>在清理方法 (在本例中是 <code>dispose()</code> ) 中，还必须注意基类和成员对象清理方法的调用顺序，以防一个子对象依赖于另一个子对象。首先，按与创建的相反顺序执行特定于类的所有清理工作。(一般来说，这要求基类元素仍然是可访问的。) 然后调用基类清理方法，如这所示。</p><p>在很多情况下，清理问题不是问题；你只需要让垃圾收集器来完成这项工作。但是，当你必须执行显式清理时，就需要多做努力，更加细心，因为在垃圾收集方面没有什么可以依赖的。可能永远不会调用垃圾收集器。如果调用，它可以按照它想要的任何顺序回收对象。除了内存回收外，你不能依赖垃圾收集来做任何事情。如果希望进行清理，可以使用自己的清理方法，不要使用 <code>finalize()</code>。</p><h3 id="名称隐藏"><a href="#名称隐藏" class="headerlink" title="名称隐藏"></a>名称隐藏</h3><p>如果 Java 基类的方法名多次重载，则在派生类中重新定义该方法名不会隐藏任何基类版本。不管方法是在这个级别定义的，还是在基类中定义的，重载都会起作用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Hide.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Overloading a base-class method name in a derived</span></span><br><span class="line"><span class="comment">// class does not hide the base-class versions</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Homer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">doh</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doh(char)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">float</span> <span class="title">doh</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doh(float)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milhouse</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bart</span> <span class="keyword">extends</span> <span class="title">Homer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doh</span><span class="params">(Milhouse m)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doh(Milhouse)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hide</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bart b = <span class="keyword">new</span> Bart();</span><br><span class="line">    b.doh(<span class="number">1</span>);</span><br><span class="line">    b.doh(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    b.doh(<span class="number">1.0f</span>);</span><br><span class="line">    b.doh(<span class="keyword">new</span> Milhouse());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">doh(float)</span></span><br><span class="line"><span class="comment">doh(char)</span></span><br><span class="line"><span class="comment">doh(float)</span></span><br><span class="line"><span class="comment">doh(Milhouse)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Homer</strong> 的所有重载方法在 <strong>Bart</strong> 中都是可用的，尽管 <strong>Bart</strong> 引入了一种新的重载方法。在下一章中你将看到，使用与基类中完全相同的签名和返回类型覆盖相同名称的方法要常见得多。否则就会令人困惑。</p><p>你已经看到了 Java 5 <strong>@Override </strong>注释，它不是关键字，但是可以像使用关键字一样使用它。当你打算重写一个方法时，你可以选择添加这个注释，如果你不小心用了重载而不是重写，编译器会产生一个错误消息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Lisa.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lisa</span> <span class="keyword">extends</span> <span class="title">Homer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">doh</span><span class="params">(Milhouse m)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doh(Milhouse)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>{WillNotCompile}</strong> 标记将该文件排除在本书的 <strong>Gradle</strong> 构建之外，但是如果你手工编译它，你将看到:方法不会覆盖超类中的方法， <strong>@Override</strong> 注释防止你意外地重载。</p><h2 id="组合与继承的选择"><a href="#组合与继承的选择" class="headerlink" title="组合与继承的选择"></a>组合与继承的选择</h2><p>组合和继承都允许在新类中放置子对象（组合是显式的，而继承是隐式的）。你或许想知道这二者之间的区别，以及怎样在二者间做选择。</p><p>当你想在新类中包含一个已有类的功能时，使用组合，而非继承。也就是说，在新类中嵌入一个对象（通常是私有的），以实现其功能。新类的使用者看到的是你所定义的新类的接口，而非嵌入对象的接口。</p><p>有时让类的用户直接访问到新类中的组合成分是有意义的。只需将成员对象声明为 <strong>public</strong> 即可（可以把这当作“半委托”的一种）。成员对象隐藏了具体实现，所以这是安全的。当用户知道你正在组装一组部件时，会使得接口更加容易理解。下面的 car 对象是个很好的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Car.java</span></span><br><span class="line"><span class="comment">// Composition with public objects</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> psi)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">pubilc <span class="keyword">void</span> <span class="title">rolldown</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Window window = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">    <span class="keyword">public</span> Wheel[] wheel = <span class="keyword">new</span> Wheel[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">public</span> Door left = <span class="keyword">new</span> Door(), right = <span class="keyword">new</span> Door(); <span class="comment">// 2-door</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            wheel[i] = <span class="keyword">new</span> Wheel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.left.window.rollup();</span><br><span class="line">        car.wheel[<span class="number">0</span>].inflate(<span class="number">72</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在这个例子中 car 的组合也是问题分析的一部分（不是底层设计的部分），所以声明成员为 <strong>public</strong> 有助于客户端程序员理解如何使用类，且降低了类创建者面临的代码复杂度。但是，记住这是一个特例。通常来说，属性还是应该声明为 <strong>private</strong>。</p><p>当使用继承时，使用一个现有类并开发出它的新版本。通常这意味着使用一个通用类，并为了某个特殊需求将其特殊化。稍微思考下，你就会发现，用一个交通工具对象来组成一部车是毫无意义的——车不包含交通工具，它就是交通工具。这种“是一个”的关系是用继承来表达的，而“有一个“的关系则用组合来表达。</p><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>即然你已经接触到继承，关键字 <strong>protected</strong> 就变得有意义了。在理想世界中，仅靠关键字 <strong>private</strong> 就足够了。在实际项目中，却经常想把一个事物尽量对外界隐藏，而允许派生类的成员访问。</p><p>关键字 <strong>protected</strong> 就起这个作用。它表示“就类的用户而言，这是 <strong>private</strong> 的。但对于任何继承它的子类或在同一包中的类，它是可访问的。”（<strong>protected</strong> 也提供了包访问权限）</p><p>尽管可以创建 <strong>protected</strong> 属性，但是最好的方式是将属性声明为 <strong>private</strong> 以一直保留更改底层实现的权利。然后通过 <strong>protected</strong> 控制类的继承者的访问权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Orc.java</span></span><br><span class="line"><span class="comment">// The protected keyword</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Villain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String nm)</span> </span>&#123;</span><br><span class="line">        name = nm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Villain(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a Villain and my name is &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orc</span> <span class="keyword">extends</span> <span class="title">Villain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orcNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Orc</span><span class="params">(String name, <span class="keyword">int</span> orcNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.orcNumber = orcNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String name, <span class="keyword">int</span> orcNumber)</span> </span>&#123;</span><br><span class="line">        set(name); <span class="comment">// Available because it&#x27;s protected</span></span><br><span class="line">        <span class="keyword">this</span>.orcNumber = orcNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Orc &quot;</span> + orcNumber + <span class="string">&quot;: &quot;</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Orc orc = <span class="keyword">new</span> Orc(<span class="string">&quot;Limburger&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(orc);</span><br><span class="line">        orc.change(<span class="string">&quot;Bob&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        System.out.println(orc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Orc 12: I&#x27;m a Villain and my name is Limburger</span><br><span class="line">Orc 19: I&#x27;m a Villain and my name is Bob</span><br></pre></td></tr></table></figure><p><code>change()</code> 方法可以访问 <code>set()</code> 方法，因为 <code>set()</code> 方法是 <strong>protected</strong>。注意到，类 <strong>Orc</strong> 的 <code>toString()</code> 方法也使用了基类的版本。</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>继承最重要的方面不是为新类提供方法。它是新类与基类的一种关系。简而言之，这种关系可以表述为“新类是已有类的一种类型”。</p><p>这种描述并非是解释继承的一种花哨方式，这是直接由语言支持的。例如，假设有一个基类 <strong>Instrument</strong> 代表音乐乐器和一个派生类 <strong>Wind</strong>。 因为继承保证了基类的所有方法在派生类中也是可用的，所以任意发送给该基类的消息也能发送给派生类。如果 <strong>Instrument</strong> 有一个 <code>play()</code> 方法，那么 <strong>Wind</strong> 也有该方法。这意味着你可以准确地说 <strong>Wind</strong> 对象也是一种类型的 <strong>Instrument</strong>。下面例子展示了编译器是如何支持这一概念的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Wind.java</span></span><br><span class="line"><span class="comment">// Inheritance &amp; upcasting</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wind objects are instruments</span></span><br><span class="line"><span class="comment">// because they have the same interface:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        Instrument.tune(flute); <span class="comment">// Upcasting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tune()</code> 方法接受了一个 <strong>Instrument</strong> 类型的引用。但是，在 <strong>Wind</strong> 的 <code>main()</code> 方法里，<code>tune()</code> 方法却传入了一个 <strong>Wind</strong> 引用。鉴于 Java 对类型检查十分严格，一个接收一种类型的方法接受了另一种类型看起来很奇怪，除非你意识到 <strong>Wind</strong> 对象同时也是一个 <strong>Instrument</strong> 对象，而且 <strong>Instrument</strong> 的 <code>tune</code> 方法一定会存在于 <strong>Wind</strong> 中。在 <code>tune()</code> 中，代码对 <strong>Instrument</strong> 和 所有 <strong>Instrument</strong> 的派生类起作用，这种把 <strong>Wind</strong> 引用转换为 <strong>Instrument</strong> 引用的行为称作<em>向上转型</em>。</p><p>该术语是基于传统的类继承图：图最上面是根，然后向下铺展。（当然你可以以任意方式画你认为有帮助的类图。）于是，<strong>Wind.java</strong> 的类图是：</p><p><img src="/.com//Users\SYR\Desktop\images\1561774164644.png" alt="Wind 类图"></p><p>继承图中派生类转型为基类是向上的，所以通常称作<em>向上转型</em>。因为是从一个更具体的类转化为一个更一般的类，所以向上转型永远是安全的。也就是说，派生类是基类的一个超集。它可能比基类包含更多的方法，但它必须至少具有与基类一样的方法。在向上转型期间，类接口只可能失去方法，不会增加方法。这就是为什么编译器在没有任何明确转型或其他特殊标记的情况下，仍然允许向上转型的原因。</p><p>也可以执行与向上转型相反的向下转型，但是会有问题，对于该问题会放在下一章和“类型信息”一章进行更深入的探讨。</p><h3 id="再论组合和继承"><a href="#再论组合和继承" class="headerlink" title="再论组合和继承"></a>再论组合和继承</h3><p>在面向对象编程中，创建和使用代码最有可能的方法是将数据和方法一起打包到类中，然后使用该类的对象。也可以使用已有的类通过组合来创建新类。继承其实不太常用。因此尽管在教授 OOP 的过程中我们多次强调继承，但这并不意味着要尽可能使用它。恰恰相反，尽量少使用它，除非确实使用继承是有帮助的。一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类。如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。“多态”一章提出了一个使用向上转型的最有力的理由，但是只要记住问一问“我需要向上转型吗？”，就能在这两者中作出较好的选择。</p><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>根据上下文环境，Java 的关键字 <strong>final</strong> 的含义有些微的不同，但通常它指的是“这是不能被改变的”。防止改变有两个原因：设计或效率。因为这两个原因相差很远，所以有可能误用关键字 <strong>final</strong>。</p><p>以下几节讨论了可能使用 <strong>final</strong> 的三个地方：数据、方法和类。</p><h3 id="final-数据"><a href="#final-数据" class="headerlink" title="final 数据"></a>final 数据</h3><p>许多编程语言都有某种方法告诉编译器有一块数据是恒定不变的。恒定是有用的，如：</p><ol><li>一个永不改变的编译时常量。</li><li>一个在运行时初始化就不会改变的值。</li></ol><p>对于编译时常量这种情况，编译器可以把常量带入计算中；也就是说，可以在编译时计算，减少了一些运行时的负担。在 Java 中，这类常量必须是基本类型，而且用关键字 <strong>final</strong> 修饰。你必须在定义常量的时候进行赋值。</p><p>一个被 <strong>static</strong> 和 <strong>final</strong> 同时修饰的属性只会占用一段不能改变的存储空间。</p><p>当用 <strong>final</strong> 修饰对象引用而非基本类型时，其含义会有一点令人困惑。对于基本类型，<strong>final</strong> 使数值恒定不变，而对于对象引用，<strong>final</strong> 使引用恒定不变。一旦引用被初始化指向了某个对象，它就不能改为指向其他对象。但是，对象本身是可以修改的，Java 没有提供将任意对象设为常量的方法。（你可以自己编写类达到使对象恒定不变的效果）这一限制同样适用数组，数组也是对象。</p><p>下面例子展示了 <strong>final</strong> 属性的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/FinalData.java</span></span><br><span class="line"><span class="comment">// The effect of final on fields</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// package access</span></span><br><span class="line"></span><br><span class="line">    Value(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalData</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Can be compile-time constants:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> valueOne = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE_TWO = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// Typical public constant:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE_THREE = <span class="number">39</span>;</span><br><span class="line">    <span class="comment">// Cannot be compile-time constants:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i4 = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_5 = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">private</span> Value v1 = <span class="keyword">new</span> Value(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Value v2 = <span class="keyword">new</span> Value(<span class="number">22</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Value VAL_3 = <span class="keyword">new</span> Value(<span class="number">33</span>);</span><br><span class="line">    <span class="comment">// Arrays:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot;: &quot;</span> + <span class="string">&quot;i4 = &quot;</span> + i4 + <span class="string">&quot;, INT_5 = &quot;</span> + INT_5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalData fd1 = <span class="keyword">new</span> FinalData(<span class="string">&quot;fd1&quot;</span>);</span><br><span class="line">        <span class="comment">//- fd1.valueOne++; // Error: can&#x27;t change value</span></span><br><span class="line">        fd1.v2.i++; <span class="comment">// Object isn&#x27;t constant</span></span><br><span class="line">        fd1.v1 = <span class="keyword">new</span> Value(<span class="number">9</span>); <span class="comment">// OK -- not final</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fd1.a.length; i++) &#123;</span><br><span class="line">            fd1.a[i]++; <span class="comment">// Object isn&#x27;t constant</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//- fd1.v2 = new Value(0); // Error: Can&#x27;t</span></span><br><span class="line">        <span class="comment">//- fd1.VAL_3 = new Value(1); // change reference</span></span><br><span class="line">        <span class="comment">//- fd1.a = new int[3];</span></span><br><span class="line">        System.out.println(fd1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating new FinalData&quot;</span>);</span><br><span class="line">        FinalData fd2 = <span class="keyword">new</span> FinalData(<span class="string">&quot;fd2&quot;</span>);</span><br><span class="line">        System.out.println(fd1);</span><br><span class="line">        System.out.println(fd2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd1: i4 = 15, INT_5 = 18</span><br><span class="line">Creating new FinalData</span><br><span class="line">fd1: i4 = 15, INT_5 = 18</span><br><span class="line">fd2: i4 = 13, INT_5 = 18</span><br></pre></td></tr></table></figure><p>因为 <strong>valueOne</strong> 和 <strong>VALUE_TWO</strong> 都是带有编译时值的 <strong>final</strong> 基本类型，它们都可用作编译时常量，没有多大区别。<strong>VALUE_THREE</strong> 是一种更加典型的常量定义的方式：<strong>public</strong> 意味着可以在包外访问，<strong>static</strong> 强调只有一个，<strong>final</strong> 说明是一个常量。</p><p>按照惯例，带有恒定初始值的 <strong>final</strong> <strong>static</strong> 基本变量（即编译时常量）命名全部使用大写，单词之间用下划线分隔。（源于 C 语言中定义常量的方式。）</p><p>我们不能因为某数据被 <strong>final</strong> 修饰就认为在编译时可以知道它的值。由上例中的 <strong>i4</strong> 和 <strong>INT_5</strong> 可以看出，它们在运行时才会赋值随机数。示例部分也展示了将 <strong>final</strong> 值定义为 <strong>static</strong> 和非 <strong>static</strong> 的区别。此区别只有当值在运行时被初始化时才会显现，因为编译器对编译时数值一视同仁。（而且编译时数值可能因优化而消失。）当运行程序时就能看到这个区别。注意到 <strong>fd1</strong> 和 <strong>fd2</strong> 的 <strong>i4</strong> 值不同，但 <strong>INT_5</strong> 的值并没有因为创建了第二个 <strong>FinalData</strong> 对象而改变，这是因为它是 <strong>static</strong> 的，在加载时已经被初始化，并不是每次创建新对象时都初始化。</p><p><strong>v1</strong> 到 <strong>VAL_3</strong> 变量说明了 <strong>final</strong> 引用的意义。正如你在 <code>main()</code> 中所见，<strong>v2</strong> 是 <strong>final</strong> 的并不意味着你不能修改它的值。因为它是引用，所以只是说明它不能指向一个新的对象。这对于数组具有同样的意义，数组只不过是另一种引用。（我不知道有什么方法能使数组引用本身成为 <strong>final</strong>。）看起来，声明引用为 <strong>final</strong> 没有声明基本类型 <strong>final</strong> 有用。</p><h3 id="空白-final"><a href="#空白-final" class="headerlink" title="空白 final"></a>空白 final</h3><p>空白 final 指的是没有初始化值的 <strong>final</strong> 属性。编译器确保空白 final 在使用前必须被初始化。这样既能使一个类的每个对象的 <strong>final</strong> 属性值不同，也能保持它的不变性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/BlankFinal.java</span></span><br><span class="line"><span class="comment">// &quot;Blank&quot; final fields</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poppet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    Poppet(<span class="keyword">int</span> ii) &#123;</span><br><span class="line">        i = ii;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// Initialized final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> j; <span class="comment">// Blank final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Poppet p; <span class="comment">// Blank final reference</span></span><br><span class="line">    <span class="comment">// Blank finals MUST be initialized in constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j = <span class="number">1</span>; <span class="comment">// Initialize blank final</span></span><br><span class="line">        p = <span class="keyword">new</span> Poppet(<span class="number">1</span>); <span class="comment">// Init blank final reference</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        j = x; <span class="comment">// Initialize blank final</span></span><br><span class="line">        p = <span class="keyword">new</span> Poppet(x); <span class="comment">// Init blank final reference</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BlankFinal();</span><br><span class="line">        <span class="keyword">new</span> BlankFinal(<span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你必须在定义时或在每个构造器中执行 final 变量的赋值操作。这保证了 final 属性在使用前已经被初始化过。</p><h3 id="final-参数"><a href="#final-参数" class="headerlink" title="final 参数"></a>final 参数</h3><p>在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/FinalArguments.java</span></span><br><span class="line"><span class="comment">// Using &quot;final&quot; with method arguments</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">with</span><span class="params">(<span class="keyword">final</span> Gizmo g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//-g = new Gizmo(); // Illegal -- g is final</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">without</span><span class="params">(Gizmo g)</span> </span>&#123;</span><br><span class="line">        g = <span class="keyword">new</span> Gizmo(); <span class="comment">// OK -- g is not final</span></span><br><span class="line">        g.spin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void f(final int i) &#123; i++; &#125; // Can&#x27;t change</span></span><br><span class="line">    <span class="comment">// You can only read from a final primitive</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalArguments bf = <span class="keyword">new</span> FinalArguments();</span><br><span class="line">        bf.without(<span class="keyword">null</span>);</span><br><span class="line">        bf.with(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法 <code>f()</code> 和 <code>g()</code> 展示了 <strong>final</strong> 基本类型参数的使用情况。你只能读取而不能修改参数。这个特性主要用于传递数据给匿名内部类。这将在”内部类“章节中详解。</p><h3 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h3><p>使用 <strong>final</strong> 方法的原因有两个。第一个原因是给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。</p><p>过去建议使用 <strong>final</strong> 方法的第二个原因是效率。在早期的 Java 实现中，如果将一个方法指明为 <strong>final</strong>，就是同意编译器把对该方法的调用转化为内嵌调用。当编译器遇到 <strong>final</strong> 方法的调用时，就会很小心地跳过普通的插入代码以执行方法的调用机制（将参数压栈，跳至方法代码处执行，然后跳回并清理栈中的参数，最终处理返回值），而用方法体内实际代码的副本替代方法调用。这消除了方法调用的开销。但是如果一个方法很大代码膨胀，你也许就看不到内嵌带来的性能提升，因为内嵌调用带来的性能提高被花费在方法里的时间抵消了。</p><p>在最近的 Java 版本中，虚拟机可以探测到这些情况（尤其是 <em>hotspot</em> 技术），并优化去掉这些效率反而降低的内嵌调用方法。有很长一段时间，使用 <strong>final</strong> 来提高效率都被阻止。你应该让编译器和 JVM 处理性能问题，只有在为了明确禁止覆写方法时才使用 <strong>final</strong>。</p><h3 id="final-和-private"><a href="#final-和-private" class="headerlink" title="final 和 private"></a>final 和 private</h3><p>类中所有的 <strong>private</strong> 方法都隐式地指定为 <strong>final</strong>。因为不能访问 <strong>private</strong> 方法，所以不能覆写它。可以给 <strong>private</strong> 方法添加 <strong>final</strong> 修饰，但是并不能给方法带来额外的含义。</p><p>以下情况会令人困惑，当你试图覆写一个 <strong>private</strong> 方法（隐式是 <strong>final</strong> 的）时，看上去奏效，而且编译器不会给出错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/FinalOverridingIllusion.java</span></span><br><span class="line"><span class="comment">// It only looks like you can override</span></span><br><span class="line"><span class="comment">// a private or private final method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithFinals</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Identical to &quot;private&quot; alone:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WithFinals.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Also automatically &quot;final&quot;:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WithFinals.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingPrivate</span> <span class="keyword">extends</span> <span class="title">WithFinals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingPrivate2</span> <span class="keyword">extends</span> <span class="title">OverridingPrivate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate2.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate2.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalOverridingIllusion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverridingPrivate2 op2 = <span class="keyword">new</span> OverridingPrivate2();</span><br><span class="line">        op2.f();</span><br><span class="line">        op2.g();</span><br><span class="line">        <span class="comment">// You can upcast:</span></span><br><span class="line">        OverridingPrivate op = op2;</span><br><span class="line">        <span class="comment">// But you can&#x27;t call the methods:</span></span><br><span class="line">        <span class="comment">//- op.f();</span></span><br><span class="line">        <span class="comment">//- op.g();</span></span><br><span class="line">        <span class="comment">// Same here:</span></span><br><span class="line">        WithFinals wf = op2;</span><br><span class="line">        <span class="comment">//- wf.f();</span></span><br><span class="line">        <span class="comment">//- wf.g();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OverridingPrivate2.f()</span><br><span class="line">OverridingPrivate2.g()</span><br></pre></td></tr></table></figure><p>“覆写”只发生在方法是基类的接口时。也就是说，必须能将一个对象向上转型为基类并调用相同的方法（这一点在下一章阐明）。如果一个方法是 <strong>private</strong> 的，它就不是基类接口的一部分。它只是隐藏在类内部的代码，且恰好有相同的命名而已。但是如果你在派生类中以相同的命名创建了 <strong>public</strong>，<strong>protected</strong> 或包访问权限的方法，这些方法与基类中的方法没有联系，你没有覆写方法，只是在创建新的方法而已。由于 <strong>private</strong> 方法无法触及且能有效隐藏，除了把它看作类中的一部分，其他任何事物都不需要考虑到它。</p><h3 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h3><p>当说一个类是 <strong>final</strong> （<strong>final</strong> 关键字在类定义之前），就意味着它不能被继承。之所以这么做，是因为类的设计就是永远不需要改动，或者是出于安全考虑不希望它有子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Jurassic.java</span></span><br><span class="line"><span class="comment">// Making an entire class final</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallBrain</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dinosaur</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    SmallBrain x = <span class="keyword">new</span> SmallBrain();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- class Further extends Dinosaur &#123;&#125;</span></span><br><span class="line"><span class="comment">// error: Cannot extend final class &#x27;Dinosaur&#x27;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jurassic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dinosaur n = <span class="keyword">new</span> Dinosaur();</span><br><span class="line">        n.f();</span><br><span class="line">        n.i = <span class="number">40</span>;</span><br><span class="line">        n.j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>final</strong> 类的属性可以根据个人选择是或不是 <strong>final</strong>。这同样适用于不管类是否是 <strong>final</strong> 的内部 <strong>final</strong> 属性。然而，由于 <strong>final</strong> 类禁止继承，类中所有的方法都被隐式地指定为 <strong>final</strong>，所以没有办法覆写它们。你可以在 final 类中的方法加上 <strong>final</strong> 修饰符，但不会增加任何意义。</p><h3 id="final-忠告"><a href="#final-忠告" class="headerlink" title="final 忠告"></a>final 忠告</h3><p>在设计类时将一个方法指明为 final 看上去是明智的。你可能会觉得没人会覆写那个方法。有时这是对的。</p><p>但请留意你的假设。通常来说，预见一个类如何被复用是很困难的，特别是通用类。如果将一个方法指定为 <strong>final</strong>，可能会防止其他程序员的项目中通过继承来复用你的类，而这仅仅是因为你没有想到它被以那种方式使用。</p><p>Java 标准类库就是一个很好的例子。尤其是 Java 1.0/1.1 的 <strong>Vector</strong> 类被广泛地使用，而且从效率考虑（这近乎是个幻想），如果它的所有方法没有被指定为 <strong>final</strong>，可能会更加有用。很容易想到，你可能会继承并覆写这么一个基础类，但是设计者们认为这么做不合适。有两个讽刺的原因。第一，<strong>Stack</strong> 继承自 <strong>Vector</strong>，就是说 <strong>Stack</strong> 是个 <strong>Vector</strong>，但从逻辑上来说不对。尽管如此，Java 设计者们仍然这么做，在用这种方式创建 <strong>Stack</strong> 时，他们应该意识到了 <strong>final</strong> 方法过于约束。</p><p>第二，<strong>Vector</strong> 中的很多重要方法，比如 <code>addElement()</code> 和 <code>elementAt()</code> 方法都是同步的。在“并发编程”一章中会看同步会导致很大的执行开销，可能会抹煞 <strong>final</strong> 带来的好处。这加强了程序员永远无法正确猜到优化应该发生在何处的观点。如此笨拙的设计却出现在每个人都要使用的标准库中，太糟糕了。庆幸的是，现代 Java 容器用 <strong>ArrayList</strong> 代替了 <strong>Vector</strong>，它的行为要合理得多。不幸的是，仍然有很多新代码使用旧的集合类库，其中就包括 <strong>Vector</strong>。</p><p>Java 1.0/1.1 标准类库中另一个重要的类是 <strong>Hashtable</strong>（后来被 <strong>HashMap</strong> 取代），它不含任何 <strong>final</strong> 方法。本书中其他地方也提到，很明显不同的类是由不同的人设计的。<strong>Hashtable</strong> 就比 <strong>Vector</strong> 中的方法名简洁得多，这又是一条证据。对于类库的使用者来说，这是一个本不应该如此草率的事情。这种不规则的情况造成用户需要做更多的工作——这是对粗糙的设计和代码的又一讽刺。</p><h2 id="类初始化和加载"><a href="#类初始化和加载" class="headerlink" title="类初始化和加载"></a>类初始化和加载</h2><p>在许多传统语言中，程序在启动时一次性全部加载。接着初始化，然后程序开始运行。必须仔细控制这些语言的初始化过程，以确保 <strong>statics</strong> 初始化的顺序不会造成麻烦。在 C++ 中，如果一个 <strong>static</strong> 期望使用另一个 <strong>static</strong>，而另一个 <strong>static</strong> 还没有初始化，就会出现问题。</p><p>Java 中不存在这样的问题，因为它采用了一种不同的方式加载。因为 Java 中万物皆对象，所以加载活动就容易得多。记住每个类的编译代码都存在于它自己独立的文件中。该文件只有在使用程序代码时才会被加载。一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的 <strong>static</strong> 属性或方法。构造器也是一个 <strong>static</strong> 方法尽管它的 <strong>static</strong> 关键字是隐式的。因此，准确地说，一个类当它任意一个 <strong>static</strong> 成员被访问时，就会被加载。</p><p>首次使用时就是 <strong>static</strong> 初始化发生时。所有的 <strong>static</strong> 对象和 <strong>static</strong> 代码块在加载时按照文本的顺序（在类中定义的顺序）依次初始化。<strong>static</strong> 变量只被初始化一次。</p><h3 id="继承和初始化"><a href="#继承和初始化" class="headerlink" title="继承和初始化"></a>继承和初始化</h3><p>了解包括继承在内的整个初始化过程是有帮助的，这样可以对所发生的一切有全局性的把握。考虑下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Beetle.java</span></span><br><span class="line"><span class="comment">// The full process of initialization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    Insect() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">        j = <span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x1 = printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printInit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k = printInit(<span class="string">&quot;Beetle.k.initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Beetle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;k = &quot;</span> + k);</span><br><span class="line">        System.out.println(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x2 = printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">        Beetle b = <span class="keyword">new</span> Beetle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static Insect.x1 initialized</span><br><span class="line">static Beetle.x2 initialized</span><br><span class="line">Beetle constructor</span><br><span class="line">i = 9, j = 0</span><br><span class="line">Beetle.k initialized</span><br><span class="line">k = 47</span><br><span class="line">j = 39</span><br></pre></td></tr></table></figure><p>当执行 <strong>java Beetle</strong>，首先会试图访问 <strong>Beetle</strong> 类的 <code>main()</code> 方法（一个静态方法），加载器启动并找出 <strong>Beetle</strong> 类的编译代码（在名为 <strong>Beetle.class</strong> 的文件中）。在加载过程中，编译器注意到有一个基类，于是继续加载基类。不论是否创建了基类的对象，基类都会被加载。（可以尝试把创建基类对象的代码注释掉证明这点。）</p><p>如果基类还存在自身的基类，那么第二个基类也将被加载，以此类推。接下来，根基类（例子中根基类是 <strong>Insect</strong>）的 <strong>static</strong> 的初始化开始执行，接着是派生类，以此类推。这点很重要，因为派生类中 <strong>static</strong> 的初始化可能依赖基类成员是否被正确地初始化。</p><p>至此，必要的类都加载完毕，可以创建对象了。首先，对象中的所有基本类型变量都被置为默认值，对象引用被设为 <strong>null</strong> —— 这是通过将对象内存设为二进制零值一举生成的。接着会调用基类的构造器。本例中是自动调用的，但是你也可以使用 <strong>super</strong> 调用指定的基类构造器（在 <strong>Beetle</strong> 构造器中的第一步操作）。基类构造器和派生类构造器一样以相同的顺序经历相同的过程。当基类构造器完成后，实例变量按文本顺序初始化。最终，构造器的剩余部分被执行。</p><h2 id="本章小结-6"><a href="#本章小结-6" class="headerlink" title="本章小结"></a>本章小结</h2><p>继承和组合都是从已有类型创建新类型。组合将已有类型作为新类型底层实现的一部分，继承复用的是接口。</p><p>使用继承时，派生类具有基类接口，因此可以向上转型为基类，这对于多态至关重要，在下一章你将看到。</p><p>尽管在面向对象编程时极力强调继承，但在开始设计时，优先使用组合（或委托），只有当确实需要时再使用继承。组合更具灵活性。另外，通过对成员类型使用继承的技巧，可以在运行时改变成员的类型和行为。因此，可以在运行时改变组合对象的行为。</p><p>在设计一个系统时，目标是发现或创建一系列类，每个类有特定的用途，而且既不应太大（包括太多功能难以复用），也不应太小（不添加其他功能就无法使用）。如果设计变得过于复杂，通过将现有类拆分为更小的部分而添加更多的对象，通常是有帮助的。</p><p>当开始设计一个系统时，记住程序开发是一个增量过程，正如人类学习。它依赖实验，你可以尽可能多做分析，然而在项目开始时仍然无法知道所有的答案。如果把项目视作一个有机的，进化着的生命去培养，而不是视为像摩天大楼一样快速见效，就能获得更多的成功和更迅速的反馈。继承和组合正是可以让你执行如此实验的面向对象编程中最基本的两个工具。</p><h1 id="第-9-章-多态"><a href="#第-9-章-多态" class="headerlink" title="第 9 章 多态"></a>第 9 章 多态</h1><blockquote><p>曾经有人请教我 “ Babbage 先生，如果输入错误的数字到机器中，会得出正确结果吗？” 我无法理解产生如此问题的概念上的困惑。 —— Charles Babbage (1791 - 1871)</p></blockquote><p>多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。</p><p>多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。多态不仅能改善代码的组织，提高代码的可读性，而且能创建有扩展性的程序——无论在最初创建项目时还是在添加新特性时都可以“生长”的程序。</p><p>封装通过合并特征和行为来创建新的数据类型。隐藏实现通过将细节<strong>私有化</strong>把接口与实现分离。这种类型的组织机制对于有面向过程编程背景的人来说，更容易理解。而多态是消除类型之间的耦合。在上一章中，继承允许把一个对象视为它本身的类型或它的基类类型。这样就能把很多派生自一个基类的类型当作同一类型处理，因而一段代码就可以无差别地运行在所有不同的类型上了。多态方法调用允许一种类型表现出与相似类型的区别，只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由方法的不同行为表现出来的。</p><p>在本章中，通过一些基本、简单的例子（这些例子中只保留程序中与多态有关的行为），你将逐步学习多态（也称为<em>动态绑定</em>或<em>后期绑定</em>或<em>运行时绑定</em>）。</p><h2 id="向上转型回顾"><a href="#向上转型回顾" class="headerlink" title="向上转型回顾"></a>向上转型回顾</h2><p>在上一章中，你看到了如何把一个对象视作它的自身类型或它的基类类型。这种把一个对象引用当作它的基类引用的做法称为向上转型，因为继承图中基类一般都位于最上方。</p><p>同样你也在下面的音乐乐器例子中发现了问题。即然几个例子都要演奏乐符（<strong>Note</strong>），首先我们先在包中单独创建一个 Note 枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Note.java</span></span><br><span class="line"><span class="comment">// Notes to play on musical instruments</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Note</span> </span>&#123;</span><br><span class="line">    MIDDLE_C, C_SHARP, B_FLAT; <span class="comment">// Etc.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举已经在”第 6 章初始化和清理“一章中介绍过了。</p><p>这里，<strong>Wind</strong> 是一种 <strong>Instrument</strong>；因此，<strong>Wind</strong> 继承 <strong>Instrument</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Instrument.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrument.play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/music/Wind.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"><span class="comment">// Wind objects are instruments</span></span><br><span class="line"><span class="comment">// because they have the same interface:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Redefine interface method:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Music</strong> 的方法 <code>tune()</code> 接受一个 <strong>Instrument</strong> 引用，同时也接受任何派生自 <strong>Instrument</strong> 的类引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Music.java</span></span><br><span class="line"><span class="comment">// Inheritance &amp; upcasting</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music.Music&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        tune(flute); <span class="comment">// Upcasting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 中你看到了 <code>tune()</code> 方法传入了一个 <strong>Wind</strong> 引用，而没有做类型转换。这样做是允许的—— <strong>Instrument</strong> 的接口一定存在于 <strong>Wind</strong> 中，因此 <strong>Wind</strong> 继承了 <strong>Instrument</strong>。从 <strong>Wind</strong> 向上转型为 <strong>Instrument</strong> 可能“缩小”接口，但不会比 <strong>Instrument</strong> 的全部接口更少。</p><h3 id="忘掉对象类型"><a href="#忘掉对象类型" class="headerlink" title="忘掉对象类型"></a>忘掉对象类型</h3><p><strong>Music.java</strong> 看起来似乎有点奇怪。为什么所有人都故意忘记掉对象类型呢？当向上转型时，就会发生这种情况，而且看起来如果 <code>tune()</code> 接受的参数是一个 <strong>Wind</strong> 引用会更为直观。这会带来一个重要问题：如果你那么做，就要为系统内 <strong>Instrument</strong> 的每种类型都编写一个新的 <code>tune()</code> 方法。假设按照这种推理，再增加 <strong>Stringed</strong> 和 <strong>Brass</strong> 这两种 <strong>Instrument</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Music2.java</span></span><br><span class="line"><span class="comment">// Overloading instead of upcasting</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music.Music2&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stringed.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Brass.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Wind i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Stringed i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Brass i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        Stringed violin = <span class="keyword">new</span> Stringed();</span><br><span class="line">        Brass frenchHorn = <span class="keyword">new</span> Brass();</span><br><span class="line">        tune(flute); <span class="comment">// No upcasting</span></span><br><span class="line">        tune(violin);</span><br><span class="line">        tune(frenchHorn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>这样行得通，但是有一个主要缺点：必须为添加的每个新 <strong>Instrument</strong> 类编写特定的方法。这意味着开始时就需要更多的编程，而且以后如果添加类似 <code>tune()</code> 的新方法或 <strong>Instrument</strong> 的新类型时，还有大量的工作要做。考虑到如果你忘记重载某个方法，编译器也不会提示你，这会造成类型的整个处理过程变得难以管理。</p><p>如果只写一个方法以基类作为参数，而不用管是哪个具体派生类，这样会变得更好吗？也就是说，如果忘掉派生类，编写的代码只与基类打交道，会不会更好呢？</p><p>这正是多态所允许的。但是大部分拥有面向过程编程背景的程序员会对多态的运作方式感到一些困惑。</p><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>运行程序后会看到 <strong>Music.java</strong> 的难点。<strong>Wind.play()</strong> 的输出结果正是我们期望的，然而它看起来似乎不应该得出这样的结果。观察 <code>tune()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它接受一个 <strong>Instrument</strong> 引用。那么编译器是如何知道这里的 <strong>Instrument</strong> 引用指向的是 <strong>Wind</strong>，而不是 <strong>Brass</strong> 或 <strong>Stringed</strong> 呢？编译器无法得知。为了深入理解这个问题，有必要研究一下<em>绑定</em>这个主题。</p><h3 id="方法调用绑定"><a href="#方法调用绑定" class="headerlink" title="方法调用绑定"></a>方法调用绑定</h3><p>将一个方法调用和一个方法主体关联起来称作<em>绑定</em>。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做<em>前期绑定</em>。你可能从来没有听说这个术语，因为它是面向过程语言不需选择默认的绑定方式，例如在 C 语言中就只有<em>前期绑定</em>这一种方法调用。</p><p>上述程序让人困惑的地方就在于前期绑定，因为编译器只知道一个 <strong>Instrument</strong> 引用，它无法得知究竟会调用哪个方法。</p><p>解决方法就是<em>后期绑定</em>，意味着在运行时根据对象的类型进行绑定。后期绑定也称为<em>动态绑定</em>或<em>运行时绑定</em>。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是可以想到，对象中一定存在某种类型信息。</p><p>Java 中除了 <strong>static</strong> 和 <strong>final</strong> 方法（<strong>private</strong> 方法也是隐式的 <strong>final</strong>）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。</p><p>为什么将一个对象指明为 <strong>final</strong> ？正如前一章所述，它可以防止方法被重写。但更重要的一点可能是，它有效地”关闭了“动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为 <strong>final</strong> 方法生成更高效的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用 <strong>final</strong>，而不是为了提升性能而使用。</p><h3 id="产生正确的行为"><a href="#产生正确的行为" class="headerlink" title="产生正确的行为"></a>产生正确的行为</h3><p>一旦当你知道 Java 中所有方法都是通过后期绑定来实现多态时，就可以编写只与基类打交道的代码，而且代码对于派生类来说都能正常地工作。或者换种说法，你向对象发送一条消息，让对象自己做正确的事。</p><p>面向对象编程中的经典例子是形状 <strong>Shape</strong>。这个例子很直观，但不幸的是，它可能让初学者困惑，认为面向对象编程只适合图形化程序设计，实际上不是这样。</p><p>形状的例子中，有一个基类称为 <strong>Shape</strong> ，多个不同的派生类型分别是：<strong>Circle</strong>，<strong>Square</strong>，<strong>Triangle</strong> 等等。这个例子之所以好用，是因为我们可以直接说“圆(Circle)是一种形状(Shape)”，这很容易理解。继承图展示了它们之间的关系：</p><p><img src="/.com//Users\SYR\Desktop\images\1562204648023.png" alt="形状继承图"></p><p>向上转型就像下面这么简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape s = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure><p>这会创建一个 <strong>Circle</strong> 对象，引用被赋值给 <strong>Shape</strong> 类型的变量 s，这看似错误（将一种类型赋值给另一种类型），然而是没问题的，因此从继承上可认为圆(Circle)就是一个形状(Shape)。因此编译器认可了赋值语句，没有报错。</p><p>假设你调用了一个基类方法（在各个派生类中都被重写）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.draw()</span><br></pre></td></tr></table></figure><p>你可能再次认为 <strong>Shape</strong> 的 <code>draw()</code> 方法被调用，因为 s 是一个 <strong>Shape</strong> 引用——编译器怎么可能知道要做其他的事呢？然而，由于后期绑定（多态）被调用的是 <strong>Circle</strong> 的 <code>draw()</code> 方法，这是正确的。</p><p>下面的例子稍微有些不同。首先让我们创建一个可复用的 <strong>Shape</strong> 类库，基类 <strong>Shape</strong> 为它的所有子类建立了公共接口——所有的形状都可以被绘画和擦除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/Shape.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类通过重写这些方法为每个具体的形状提供独一无二的方法行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/Circle.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle.erase()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/shape/Square.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square.erase()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/shape/Triangle.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Triangle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Triangle.erase()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RandomShapes</strong> 是一种工厂，每当我们调用 <code>get()</code> 方法时，就会产生一个指向随机创建的 <strong>Shape</strong> 对象的引用。注意，向上转型发生在 <strong>return</strong> 语句中，每条 <strong>return</strong> 语句取得一个指向某个 <strong>Circle</strong>，<strong>Square</strong> 或 <strong>Triangle</strong> 的引用， 并将其以 <strong>Shape</strong> 类型从 <code>get()</code> 方法发送出去。因此无论何时调用 <code>get()</code> 方法，你都无法知道具体的类型是什么，因为你总是得到一个简单的 <strong>Shape</strong> 引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/RandomShapes.java</span></span><br><span class="line"><span class="comment">// A &quot;factory&quot; that randomly creates shapes</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomShapes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(rand.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> Triangle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shape[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> Shape[sz];</span><br><span class="line">        <span class="comment">// Fill up the array with shapes:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shapes.length; i++) &#123;</span><br><span class="line">            shapes[i] = get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shapes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>array()</code> 方法分配并填充了 <strong>Shape</strong> 数组，这里使用了 for-in 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Shapes.java</span></span><br><span class="line"><span class="comment">// Polymorphism in Java</span></span><br><span class="line"><span class="keyword">import</span> polymorphism.shape.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomShapes gen = <span class="keyword">new</span> RandomShapes();</span><br><span class="line">        <span class="comment">// Make polymorphic method calls:</span></span><br><span class="line">        <span class="keyword">for</span> (Shape shape: gen.array(<span class="number">9</span>)) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Triangle.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Circle.draw()</span><br></pre></td></tr></table></figure><p><code>main()</code> 方法中包含了一个 <strong>Shape</strong> 引用组成的数组，其中每个元素通过调用 <strong>RandomShapes</strong> 类的 <code>get()</code> 方法生成。现在你只知道拥有一些形状，但除此之外一无所知（编译器也是如此）。然而当遍历这个数组为每个元素调用 <code>draw()</code> 方法时，从运行程序的结果中可以看到，与类型有关的特定行为奇迹般地发生了。</p><p>随机生成形状是为了让大家理解：在编译时，编译器不需要知道任何具体信息以进行正确的调用。所有对方法 <code>draw()</code> 的调用都是通过动态绑定进行的。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>现在让我们回头看音乐乐器的例子。由于多态机制，你可以向系统中添加任意多的新类型，而不需要修改 <code>tune()</code> 方法。在一个设计良好的面向对象程序中，许多方法将会遵循 <code>tune()</code> 的模型，只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类派生出新的数据类型，从而添加新的功能。那些操纵基类接口的方法不需要改动就可以应用于新类。</p><p>考虑一下乐器的例子，如果在基类中添加更多的方法，并加入一些新类，将会发生什么呢：</p><p><img src="/.com//Users\SYR\Desktop\images\1562252767216.png" alt="乐器继承图"></p><p>所有的新类都可以和原有类正常运行，不需要改动 <code>tune()</code> 方法。即使 <code>tune()</code> 方法单独存放在某个文件中，而且向 <strong>Instrument</strong> 接口中添加了新的方法，<code>tune()</code> 方法也无需再编译就能正确运行。下面是类图的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music3/Music3.java</span></span><br><span class="line"><span class="comment">// An extensible program</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music3.Music3&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music3;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrument.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Instrument&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Instrument&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Wind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Percussion.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Percussion&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Percussion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stringed.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Stringed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Stringed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Brass.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Brass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woodwind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woodwind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn&#x27;t care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to the system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Percussion.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">Woodwind.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>新方法 <code>what()</code> 返回一个带有类描述的 <strong>String</strong> 引用，<code>adjust()</code> 提供一些乐器调音的方法。</p><p>在 <code>main()</code> 方法中，当向 <strong>orchestra</strong> 数组添加元素时，元素会自动向上转型为 <strong>Instrument</strong>。</p><p><code>tune()</code> 方法可以忽略周围所有代码发生的变化，仍然可以正常运行。这正是我们期待多态能提供的特性。代码中的修改不会破坏程序中其他不应受到影响的部分。换句话说，多态是一项“将改变的事物与不变的事物分离”的重要技术。</p><h3 id="陷阱：“重写”私有方法"><a href="#陷阱：“重写”私有方法" class="headerlink" title="陷阱：“重写”私有方法"></a>陷阱：“重写”私有方法</h3><p>你可能天真地试图像下面这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PrivateOverride.java</span></span><br><span class="line"><span class="comment">// Trying to override a private method</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.PrivateOverride&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrivateOverride po = <span class="keyword">new</span> Derived();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Derived extends PrivateOverride &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private f()</span><br></pre></td></tr></table></figure><p>你可能期望输出是 <strong>public f()</strong>，然而 <strong>private</strong> 方法也是 <strong>final</strong> 的，对于派生类来说是隐蔽的。因此，这里 <strong>Derived</strong> 的 <code>f()</code> 是一个全新的方法；因为基类版本的 <code>f()</code> 屏蔽了 <strong>Derived</strong> ，因此它都不算是重写方法。</p><p>结论是只有非 <strong>private</strong> 方法才能被重写，但是得小心重写 <strong>private</strong> 方法的现象，编译器不报错，但不会按我们所预期的执行。为了清晰起见，派生类中的方法名采用与基类中 <strong>private</strong> 方法名不同的命名。</p><p>如果使用了 <code>@Override</code> 注解，就能检测出问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PrivateOverride2.java</span></span><br><span class="line"><span class="comment">// Detecting a mistaken override using @Override</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrivateOverride2 po = <span class="keyword">new</span> Derived2();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">PrivateOverride2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器报错信息是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: method does not override or</span><br><span class="line">implement a method from a supertype</span><br></pre></td></tr></table></figure><h3 id="陷阱：属性与静态方法"><a href="#陷阱：属性与静态方法" class="headerlink" title="陷阱：属性与静态方法"></a>陷阱：属性与静态方法</h3><p>一旦学会了多态，就可以以多态的思维方式考虑每件事。然而，只有普通的方法调用可以是多态的。例如，如果你直接访问一个属性，该访问会在编译时解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/FieldAccess.java</span></span><br><span class="line"><span class="comment">// Direct field access is determined at compile time</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Super sup = <span class="keyword">new</span> Sub(); <span class="comment">// Upcast</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sup.field = &quot;</span> + sup.field +</span><br><span class="line">                          <span class="string">&quot;, sup.getField() = &quot;</span> + sup.getField());</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        System.out.println(<span class="string">&quot;sub.field = &quot;</span> + sub.field +</span><br><span class="line">                          <span class="string">&quot;, sub.getField() = &quot;</span> + sub.getField()</span><br><span class="line">                          + <span class="string">&quot;, sub.getSuperField() = &quot;</span> + sub.getSuperField())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sup.field = 0, sup.getField() = 1</span><br><span class="line">sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0</span><br></pre></td></tr></table></figure><p>当 <strong>Sub</strong> 对象向上转型为 <strong>Super</strong> 引用时，任何属性访问都被编译器解析，因此不是多态的。在这个例子中，<strong>Super.field</strong> 和 <strong>Sub.field</strong> 被分配了不同的存储空间，因此，<strong>Sub</strong> 实际上包含了两个称为 <strong>field</strong> 的属性：它自己的和来自 <strong>Super</strong> 的。然而，在引用 <strong>Sub</strong> 的 <strong>field</strong> 时，默认的 <strong>field</strong> 属性并不是 <strong>Super</strong> 版本的 <strong>field</strong> 属性。为了获取 <strong>Super</strong> 的 <strong>field</strong> 属性，需要显式地指明 <strong>super.field</strong>。</p><p>尽管这看起来是个令人困惑的问题，实际上基本不会发生。首先，通常会将所有的属性都指明为 <strong>private</strong>，因此不能直接访问它们，只能通过方法来访问。此外，你可能也不会给基类属性和派生类属性起相同的名字，这样做会令人困惑。</p><p>如果一个方法是静态(<strong>static</strong>)的，它的行为就不具有多态性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/StaticPolymorphism.java</span></span><br><span class="line"><span class="comment">// static methods are not polymorphic</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base staticGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamicGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base dynamicGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSub</span> <span class="keyword">extends</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived staticGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamicGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived dynamicGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPolymorphism</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticSuper sup = <span class="keyword">new</span> StaticSub(); <span class="comment">// Upcast</span></span><br><span class="line">        System.out.println(StaticSuper.staticGet());</span><br><span class="line">        System.out.println(sup.dynamicGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base staticGet()</span><br><span class="line">Derived dynamicGet()</span><br></pre></td></tr></table></figure><p>静态的方法只与类关联，与单个的对象无关。</p><h2 id="构造器和多态"><a href="#构造器和多态" class="headerlink" title="构造器和多态"></a>构造器和多态</h2><p>通常，构造器不同于其他类型的方法。在涉及多态时也是如此。尽管构造器不具有多态性（它们实际上是静态方法，但是隐式声明的），但是理解构造器在复杂层次结构中运作多态还是非常重要的。这个理解可以帮助你避免一些不愉快的困扰。</p><h3 id="构造器调用顺序"><a href="#构造器调用顺序" class="headerlink" title="构造器调用顺序"></a>构造器调用顺序</h3><p>在“初始化和清理”和“复用”两章中已经简单地介绍过构造器的调用顺序，但那时还没有介绍多态。</p><p>在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。这么做是有意义的，因为构造器有着特殊的任务：检查对象是否被正确地构造。由于属性通常声明为 <strong>private</strong>，你必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。这就是编译器强制每个派生类部分必须调用构造器的原因。如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器。如果没有无参构造器，编译器就会报错（当类中不含构造器时，编译器会自动合成一个无参构造器）。</p><p>下面的例子展示了组合、继承和多态在构建顺序上的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Sandwich.java</span></span><br><span class="line"><span class="comment">// Order of constructor calls</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.Sandwich&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    Meal() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</span><br><span class="line">    Bread() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bread()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</span><br><span class="line">    Cheese() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cheese()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</span><br><span class="line">    Lettuce() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lettuce()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    Lunch() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lunch()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">    PortableLunch() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PortableLunch()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">    <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese();</span><br><span class="line">    <span class="keyword">private</span> Lettuce l = <span class="keyword">new</span> Lettuce();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sandwich()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sandwich();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Meal()</span><br><span class="line">Lunch()</span><br><span class="line">PortableLunch()</span><br><span class="line">Bread()</span><br><span class="line">Cheese()</span><br><span class="line">Lettuce()</span><br><span class="line">Sandwich()</span><br></pre></td></tr></table></figure><p>这个例子用其他类创建了一个复杂的类。每个类都在构造器中声明自己。重要的类是 <strong>Sandwich</strong>，它反映了三层继承（如果算上 <strong>Object</strong> 的话，就是四层），包含了三个成员对象。</p><p>从创建 <strong>Sandwich</strong> 对象的输出中可以看出对象的构造器调用顺序如下：</p><ol><li>基类构造器被调用。这个步骤重复递归，直到根基类的构造器被调用，然后是它的派生类，以此类推，直到最底层的派生类构造器被调用。</li><li>按声明顺序初始化成员。</li><li>最终调用派生类的构造器。</li></ol><p>构造器的调用顺序很重要。当使用继承时，就已经知道了基类的一切，并可以访问基类中任意 <strong>public</strong> 和 <strong>protected</strong> 的成员。这意味着在派生类中可以假定所有的基类成员都是有效的。在一个标准方法中，构造动作已经发生过，对象其他部分的所有成员都已经创建好。</p><p>在构造器中必须确保所有的成员都已经构建完。唯一能保证这点的方法就是首先调用基类的构造器。接着，在派生类的构造器中，所有你可以访问的基类成员都已经初始化。另一个在构造器中能知道所有成员都是有效的理由是：无论何时有可能的话，你应该在所有成员对象（通过组合将对象置于类中）定义处初始化它们（例如，例子中的 <strong>b</strong>、<strong>c</strong> 和 <strong>l</strong>）。如果遵循这条实践，就可以帮助确保所有的基类成员和当前对象的成员对象都已经初始化。</p><p>不幸的是，这不能处理所有情况，在下一节会看到。</p><h3 id="继承和清理"><a href="#继承和清理" class="headerlink" title="继承和清理"></a>继承和清理</h3><p>在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃圾收集器处理。如果你存在清理问题，那么必须用心地为新类创建一个 <code>dispose()</code> 方法（这里用的是我选择的名称，你可以使用更好的名称）。由于继承，如果有其他特殊的清理工作的话，就必须在派生类中重写 <code>dispose()</code> 方法。当重写 <code>dispose()</code> 方法时，记得调用基类的 <code>dispose()</code> 方法，否则基类的清理工作不会发生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Frog.java</span></span><br><span class="line"><span class="comment">// Cleanup and inheritance</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.Frog&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Characteristic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    Characteristic(String s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating Characteristic &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disposing Characteristic &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Description</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    Description(String s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating Description &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disposing Description &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LivingCreature</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">&quot;is alive&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">&quot;Basic Living Creature&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LivingCreature() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LivingCreature()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LivingCreature dispose&quot;</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">LivingCreature</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">&quot;has heart&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">&quot;Animal not Vegetable&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Animal() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal dispose&quot;</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">&quot;can live in water&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">&quot;Both water and land&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Amphibian() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Amphibian()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Amphibian dispose&quot;</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">Amphibian</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">&quot;Croaks&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">&quot;Eats Bugs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Frog()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Frog dispose&quot;</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frog frog = <span class="keyword">new</span> Frog();</span><br><span class="line">        System.out.println(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">        frog.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Creating Characteristic is alive</span><br><span class="line">Creating Description Basic Living Creature</span><br><span class="line">LivingCreature()</span><br><span class="line">Creating Characteristiv has heart</span><br><span class="line">Creating Description Animal not Vegetable</span><br><span class="line">Animal()</span><br><span class="line">Creating Characteristic can live in water</span><br><span class="line">Creating Description Both water and land</span><br><span class="line">Amphibian()</span><br><span class="line">Creating Characteristic Croaks</span><br><span class="line">Creating Description Eats Bugs</span><br><span class="line">Frog()</span><br><span class="line">Bye!</span><br><span class="line">Frog dispose</span><br><span class="line">disposing Description Eats Bugs</span><br><span class="line">disposing Characteristic Croaks</span><br><span class="line">Amphibian dispose</span><br><span class="line">disposing Description Both wanter and land</span><br><span class="line">disposing Characteristic can live in water</span><br><span class="line">Animal dispose</span><br><span class="line">disposing Description Animal not Vegetable</span><br><span class="line">disposing Characteristic has heart</span><br><span class="line">LivingCreature dispose</span><br><span class="line">disposing Description Basic Living Creature</span><br><span class="line">disposing Characteristic is alive</span><br></pre></td></tr></table></figure><p>层级结构中的每个类都有 <strong>Characteristic</strong> 和 <strong>Description</strong> 两个类型的成员对象，它们必须得被销毁。销毁的顺序应该与初始化的顺序相反，以防一个对象依赖另一个对象。对于属性来说，就意味着与声明的顺序相反（因为属性是按照声明顺序初始化的）。对于基类（遵循 C++ 析构函数的形式），首先进行派生类的清理工作，然后才是基类的清理。这是因为派生类的清理可能调用基类的一些方法，所以基类组件这时得存活，不能过早地被销毁。输出显示了，<strong>Frog</strong> 对象的所有部分都是按照创建的逆序销毁的。</p><p>尽管通常不必进行清理工作，但万一需要时，就得谨慎小心地执行。</p><p><strong>Frog</strong> 对象拥有自己的成员对象，它创建了这些成员对象，并且知道它们能存活多久，所以它知道何时调用 <code>dispose()</code> 方法。然而，一旦某个成员对象被其它一个或多个对象共享时，问题就变得复杂了，不能只是简单地调用 <code>dispose()</code>。这里，也许就必须使用<em>引用计数</em>来跟踪仍然访问着共享对象的对象数量，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/ReferenceCounting.java</span></span><br><span class="line"><span class="comment">// Cleaning up shared member objects</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    Shared() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refcount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (--refcount == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Disposing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Shared &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shared shared;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    Composing(Shared shared) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.shared = shared;</span><br><span class="line">        <span class="keyword">this</span>.shared.addRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disposing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        shared.dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Composing &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCounting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shared shared = <span class="keyword">new</span> Shared();</span><br><span class="line">        Composing[] composing = &#123;</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (Composing c: composing) &#123;</span><br><span class="line">            c.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating Shared 0</span><br><span class="line">Creating Composing 0</span><br><span class="line">Creating Composing 1</span><br><span class="line">Creating Composing 2</span><br><span class="line">Creating Composing 3</span><br><span class="line">Creating Composing 4</span><br><span class="line">disposing Composing 0</span><br><span class="line">disposing Composing 1</span><br><span class="line">disposing Composing 2</span><br><span class="line">disposing Composing 3</span><br><span class="line">disposing Composing 4</span><br><span class="line">Disposing Shared 0</span><br></pre></td></tr></table></figure><p><strong>static long counter</strong> 跟踪所创建的 <strong>Shared</strong> 实例数量，还提供了 <strong>id</strong> 的值。<strong>counter</strong> 的类型是 <strong>long</strong> 而不是 <strong>int</strong>，以防溢出（这只是个良好实践，对于本书的所有示例，<strong>counter</strong> 不会溢出）。<strong>id</strong> 是 <strong>final</strong> 的，因为它的值在初始化时确定后不应该变化。</p><p>在将一个 <strong>shared</strong> 对象附着在类上时，必须记住调用 <code>addRef()</code>，而 <code>dispose()</code> 方法会跟踪引用数，以确定在何时真正地执行清理工作。使用这种技巧需要加倍细心，但是如果正在共享需要被清理的对象，就没有太多选择了。</p><h3 id="构造器内部多态方法的行为"><a href="#构造器内部多态方法的行为" class="headerlink" title="构造器内部多态方法的行为"></a>构造器内部多态方法的行为</h3><p>构造器调用的层次结构带来了一个困境。如果在构造器中调用了正在构造的对象的动态绑定方法，会发生什么呢？</p><p>在普通的方法中，动态绑定的调用是在运行时解析的，因为对象不知道它属于方法所在的类还是类的派生类。</p><p>如果在构造器中调用了动态绑定方法，就会用到那个方法的重写定义。然而，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些 bug 很隐蔽，难以发现。</p><p>从概念上讲，构造器的工作就是创建对象（这并非是平常的工作）。在构造器内部，整个对象可能只是部分形成——只知道基类对象已经初始化。如果构造器只是构造对象过程中的一个步骤，且构造的对象所属的类是从构造器所属的类派生出的，那么派生部分在当前构造器被调用时还没有初始化。然而，一个动态绑定的方法调用向外深入到继承层次结构中，它可以调用派生类的方法。如果你在构造器中这么做，就可能调用一个方法，该方法操纵的成员可能还没有初始化——这肯定会带来灾难。</p><p>下面例子展示了这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PolyConstructors.java</span></span><br><span class="line"><span class="comment">// Constructors and polymorphism</span></span><br><span class="line"><span class="comment">// don&#x27;t produce what you might expect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Glyph() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        System.out.println(<span class="string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glyph() before draw()</span><br><span class="line">RoundGlyph.draw(), radius = 0</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RoundGlyph.RoundGlyph(), radius = 5</span><br></pre></td></tr></table></figure><p><strong>Glyph</strong> 的 <code>draw()</code> 被设计为可重写，在 <strong>RoundGlyph</strong> 这个方法被重写。但是 <strong>Glyph</strong> 的构造器里调用了这个方法，结果调用了 <strong>RoundGlyph</strong> 的 <code>draw()</code> 方法，这看起来正是我们的目的。输出结果表明，当 <strong>Glyph</strong> 构造器调用了 <code>draw()</code> 时，<strong>radius</strong> 的值不是默认初始值 1 而是 0。这可能会导致在屏幕上只画了一个点或干脆什么都不画，于是我们只能干瞪眼，试图找到程序不工作的原因。</p><p>前一小节描述的初始化顺序并不十分完整，而这正是解决谜团的关键所在。初始化的实际过程是：</p><ol><li>在所有事发生前，分配给对象的存储空间会被初始化为二进制 0。</li><li>如前所述调用基类构造器。此时调用重写后的 <code>draw()</code> 方法（是的，在调用 <strong>RoundGraph</strong> 构造器之前调用），由步骤 1 可知，<strong>radius</strong> 的值为 0。</li><li>按声明顺序初始化成员。</li><li>最终调用派生类的构造器。</li></ol><p>这么做有个优点：所有事物至少初始化为 0（或某些特殊数据类型与 0 等价的值），而不是仅仅留作垃圾。这包括了通过组合嵌入类中的对象引用，被赋予 <strong>null</strong>。如果忘记初始化该引用，就会在运行时出现异常。观察输出结果，就会发现所有事物都是 0。</p><p>另一方面，应该震惊于输出结果。逻辑方面我们已经做得非常完美，然而行为仍不可思议的错了，编译器也没有报错（C++ 在这种情况下会产生更加合理的行为）。像这样的 bug 很容易被忽略，需要花很长时间才能发现。</p><p>因此，编写构造器有一条良好规范：做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在构造器中唯一能安全调用的只有基类的 <strong>final</strong> 方法（包括 <strong>private</strong> 方法，它们自动属于 <strong>final</strong>）。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。</p><h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p>Java 5 中引入了协变返回类型，这表示派生类的被重写方法可以返回基类方法返回类型的派生类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/CovariantReturn.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Grain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheat</span> <span class="keyword">extends</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wheat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="function">Grain <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Grain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheatMill</span> <span class="keyword">extends</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Wheat <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wheat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mill m = <span class="keyword">new</span> Mill();</span><br><span class="line">        Grain g = m.process();</span><br><span class="line">        System.out.println(g);</span><br><span class="line">        m = <span class="keyword">new</span> WheatMill();</span><br><span class="line">        g = m.process();</span><br><span class="line">        System.out.println(g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Grain</span><br><span class="line">Wheat</span><br></pre></td></tr></table></figure><p>关键区别在于 Java 5 之前的版本强制要求被重写的 <code>process()</code> 方法必须返回 <strong>Grain</strong> 而不是 <strong>Wheat</strong>，即使 <strong>Wheat</strong> 派生自 <strong>Grain</strong>，因而也应该是一种合法的返回类型。协变返回类型允许返回更具体的 <strong>Wheat</strong> 类型。</p><h2 id="使用继承设计"><a href="#使用继承设计" class="headerlink" title="使用继承设计"></a>使用继承设计</h2><p>学习过多态之后，一切看似都可以被继承，因为多态是如此巧妙的工具。这会给设计带来负担。事实上，如果利用已有类创建新类首先选择继承的话，事情会变得莫名的复杂。</p><p>更好的方法是首先选择组合，特别是不知道该使用哪种方法时。组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（因而选择相应的行为），而继承要求必须在编译时知道确切类型。下面例子说明了这点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Transmogrify.java</span></span><br><span class="line"><span class="comment">// Dynamically changing the behavior of an object</span></span><br><span class="line"><span class="comment">// via composition (the &quot;State&quot; design pattern)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HappyActor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SadActor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor = <span class="keyword">new</span> HappyActor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        actor = <span class="keyword">new</span> SadActor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        actor.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmogrify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stage stage = <span class="keyword">new</span> Stage();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">        stage.change();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HappyActor</span><br><span class="line">SadActor</span><br></pre></td></tr></table></figure><p><strong>Stage</strong> 对象中包含了 <strong>Actor</strong> 引用，该引用被初始化为指向一个 <strong>HappyActor</strong> 对象，这意味着 <code>performPlay()</code> 会产生一个特殊行为。但是既然引用可以在运行时与其他不同的对象绑定，那么它就可以被替换成对 <strong>SadActor</strong> 的引用，<code>performPlay()</code> 的行为随之改变。这样你就获得了运行时的动态灵活性（这被称为状态模式）。与之相反，我们不能在运行时决定继承不同的对象，那在编译时就完全确定下来了。</p><p>有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化。在上个例子中，两者都用到了。通过继承的到的两个不同类在 <code>act()</code> 方法中表达了不同的行为，<strong>Stage</strong> 通过组合使自己的状态发生变化。这里状态的改变产生了行为的改变。</p><h3 id="替代-vs-扩展"><a href="#替代-vs-扩展" class="headerlink" title="替代 vs 扩展"></a>替代 vs 扩展</h3><p>采用“纯粹”的方式创建继承层次结构看上去是最清晰的方法。即只有基类的方法才能在派生类中被重写，就像下图这样：</p><p><img src="/.com//Users\SYR\Desktop\images\1562406479787.png" alt="类图"></p><p>这被称作纯粹的“is - a”关系，因为类的接口已经确定了它是什么。继承可以确保任何派生类都拥有基类的接口，绝对不会少。如果按图上这么做，派生类将只拥有基类的接口。</p><p>纯粹的替代意味着派生类可以完美地替代基类，当使用它们时，完全不需要知道这些子类的信息。也就是说，基类可以接收任意发送给派生类的消息，因为它们具有完全相同的接口。只需将派生类向上转型，不要关注对象的具体类型。所有一切都可以通过多态处理。</p><p>按这种方式思考，似乎只有纯粹的“is - a”关系才是唯一明智的做法，其他任何设计只会导致混乱且注定失败。这其实也是个陷阱。一旦按这种方式开始思考，就会转而发现继承扩展接口（遗憾的是，extends 关键字似乎怂恿我们这么做）才是解决特定问题的完美方案。这可以称为“is - like - a” 关系，因为派生类就像是基类——它有着相同的基本接口，但还具有需要额外方法实现的其他特性：</p><p><img src="/.com//Users\SYR\Desktop\images\1562409366637.png" alt></p><p>虽然这是一种有用且明智的方法（依赖具体情况），但是也存在缺点。派生类中接口的扩展部分在基类中不存在（不能通过基类访问到这些扩展接口），因此一旦向上转型，就不能通过基类调用这些新方法：</p><p><img src="/.com//Users\SYR\Desktop\images\1562409926765.png" alt></p><p>如果不向上转型，就不会遇到这个问题。但是通常情况下，我们需要重新查明对象的确切类型，从而能够访问该类型中的扩展方法。下一节说明如何做到这点。</p><h3 id="向下转型与运行时类型信息"><a href="#向下转型与运行时类型信息" class="headerlink" title="向下转型与运行时类型信息"></a>向下转型与运行时类型信息</h3><p>由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用<em>向下转型</em>。</p><p>向上转型永远是安全的，因为基类不会具有比派生类更多的接口。因此，每条发送给基类接口的消息都能被接收。但是对于向下转型，你无法知道一个形状是圆，它有可能是三角形、正方形或其他一些类型。</p><p>为了解决这个问题，必须得有某种方法确保向下转型是正确的，防止意外转型到一个错误类型，进而发送对象无法接收的消息。这么做是不安全的。</p><p>在某些语言中（如 C++），必须执行一个特殊的操作来获得安全的向下转型，但是在 Java 中，每次转型都会被检查！所以即使只是进行一次普通的加括号形式的类型转换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型。如果不是，就会得到 ClassCastException （类转型异常）。这种在运行时检查类型的行为称作运行时类型信息。下面例子展示了 RTTI 的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/RTTI.java</span></span><br><span class="line"><span class="comment">// Downcasting &amp; Runtime type information (RTTI)</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreUseful</span> <span class="keyword">extends</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RTTI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Useful[] x = &#123;</span><br><span class="line">            <span class="keyword">new</span> Useful(),</span><br><span class="line">            <span class="keyword">new</span> MoreUseful()</span><br><span class="line">        &#125;;</span><br><span class="line">        x[<span class="number">0</span>].f();</span><br><span class="line">        x[<span class="number">1</span>].g();</span><br><span class="line">        <span class="comment">// Compile time: method not found in Useful:</span></span><br><span class="line">        <span class="comment">//- x[1].u();</span></span><br><span class="line">        ((MoreUseful) x[<span class="number">1</span>]).u(); <span class="comment">// Downcast/RTTI</span></span><br><span class="line">        ((MoreUseful) x[<span class="number">0</span>]).u(); <span class="comment">// Exception thrown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot;</span><br><span class="line">java.lang.ClassCastException: Useful cannot be cast to</span><br><span class="line">MoreUseful</span><br><span class="line">at RTTI.main</span><br></pre></td></tr></table></figure><p>正如前面类图所示，<strong>MoreUseful</strong> 扩展了 <strong>Useful</strong> 的接口。而 <strong>MoreUseful</strong> 也继承了 <strong>Useful</strong>，所以它可以向上转型为 <strong>Useful</strong>。在 <code>main()</code> 方法中可以看到这种情况的发生。因为两个对象都是 <strong>Useful</strong> 类型，所以对它们都可以调用 <code>f()</code> 和 <code>g()</code> 方法。如果试图调用 <code>u()</code> 方法（只存在于 <strong>MoreUseful</strong> 中），就会得到编译时错误信息。</p><p>为了访问 <strong>MoreUseful</strong> 对象的扩展接口，就得尝试向下转型。如果转型为正确的类型，就转型成功。否则，就会得到 ClassCastException 异常。你不必为这个异常编写任何特殊代码，因为它指出了程序员在程序的任何地方都可能犯的错误。<strong>{ThrowsException}</strong> 注释标签告知本书的构建系统：在运行程序时，预期抛出一个异常。</p><p>RTTI 不仅仅包括简单的转型。例如，它还提供了一种方法，使你可以在试图向下转型前检查所要处理的类型。“类型信息”一章中会详细阐述运行时类型信息的方方面面。</p><h2 id="本章小结-7"><a href="#本章小结-7" class="headerlink" title="本章小结"></a>本章小结</h2><p>多态意味着“不同的形式”。在面向对象编程中，我们持有从基类继承而来的相同接口和使用该接口的不同形式：不同版本的动态绑定方法。</p><p>在本章中，你可以看到，如果不使用数据抽象和继承，就不可能理解甚至创建多态的例子。多态是一种不能单独看待的特性（比如像 <strong>switch</strong> 语句那样），它只能作为类关系全景中的一部分，与其他特性协同工作。</p><p>为了在程序中有效地使用多态乃至面向对象的技术，就必须扩展自己的编程视野，不能只看到单一类中的成员和消息，而要看到类之间的共同特性和它们之间的关系。尽管这需要很大的努力，但是这么做是值得的。它能带来更快的程序开发、更好的代码组织、扩展性更好的程序和更易维护的代码。</p><p>但是记住，多态可能被滥用。仔细分析代码以确保多态确实能带来好处。</p><h1 id="第-10-章-接口"><a href="#第-10-章-接口" class="headerlink" title="第 10 章 接口"></a>第 10 章 接口</h1><p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p><p>这种机制在编程语言中不常见，例如 C++ 只对这种概念有间接的支持。而在 Java 中存在这些关键字，说明这些思想很重要，Java 为它们提供了直接支持。</p><p>首先，我们将学习抽象类，一种介于普通类和接口之间的折中手段。尽管你的第一想法是创建接口，但是对于构建具有属性和未实现方法的类来说，抽象类也是重要且必要的工具。你不可能总是使用纯粹的接口。</p><h2 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h2><p>在上一章的乐器例子中，基类 <strong>Instrument</strong> 中的方法往往是“哑”方法。如果调用了这些方法，就会出现一些错误。这是因为接口的目的是为它的派生类创建一个通用接口。</p><p>在那些例子中，创建这个通用接口的唯一理由是，不同的子类可以用不同的方式表示此接口。通用接口建立了一个基本形式，以此表达所有派生类的共同部分。另一种说法把 <strong>Instrument</strong> 称为抽象基类，或简称抽象类。</p><p>对于像 <strong>Instrument</strong> 那样的抽象类来说，它的对象几乎总是没有意义的。创建一个抽象类是为了通过通用接口操纵一系列类。因此，<strong>Instrument</strong> 只是表示接口，不是具体实现，所以创建一个 <strong>Instrument</strong> 的对象毫无意义，我们可能希望阻止用户这么做。通过让 <strong>Instrument</strong> 所有的方法产生错误，就可以达到这个目的，但是这么做会延迟到运行时才能得知错误信息，并且需要用户进行可靠、详尽的测试。最好能在编译时捕捉问题。</p><p>Java 提供了一个叫做<em>抽象方法</em>的机制，这个方法是不完整的：它只有声明没有方法体。下面是抽象方法的声明语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>包含抽象方法的类叫做<em>抽象类</em>。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则，编译器会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface/Basic.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unimplemented</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个抽象类是不完整的，当试图创建这个类的对象时，Java 会怎么做呢？它不会创建抽象类的对象，所以我们只会得到编译器的错误信息。这样保证了抽象类的纯粹性，我们不用担心误用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AttemptToUseBasic.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptToUseBasic</span> </span>&#123;</span><br><span class="line">    Basic b = <span class="keyword">new</span> Basic();</span><br><span class="line">    <span class="comment">// error: Basic is abstract; cannot be instantiated</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果创建一个继承抽象类的新类并为之创建对象，那么就必须为基类的所有抽象方法提供方法定义。如果不这么做（可以选择不做），新类仍然是一个抽象类，编译器会强制我们为新类加上 <strong>abstract</strong> 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Basic2.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic2</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// unimplemented() still not implemented</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将一个不包含任何抽象方法的类指明为 <strong>abstract</strong>，在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AbstractWithoutAbstracts.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No abstract methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractWithoutAbstracts</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Basic b3 = new Basic3();</span></span><br><span class="line">    <span class="comment">// error: Basic 3 is abstract; cannot be instantiated</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了创建可初始化的类，就要继承抽象类，并提供所有抽象方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Instantiable.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Uninstantiable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instantiable</span> <span class="keyword">extends</span> <span class="title">Uninstantiable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Uninstantiable ui = <span class="keyword">new</span> Instantiable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留意 <code>@Override</code> 的使用。没有这个注解的话，如果你没有定义相同的方法名或签名，抽象机制会认为你没有实现抽象方法从而产生编译时错误。因此，你可能认为这里的 <code>@Override</code> 是多余的。但是，<code>@Override</code> 还提示了这个方法被覆写——我认为这是有用的，所以我会使用 <code>@Override</code>，即使在没有这个注解，编译器告诉我错误的时候。</p><p>记住，事实上的访问权限是“friendly”。你很快会看到接口自动将其方法指明为 <strong>public</strong>。事实上，接口只允许 <strong>public</strong> 方法，如果不加访问修饰符的话，接口的方法不是 <strong>friendly</strong> 而是 <strong>public</strong>。然而，抽象类允许每件事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AbstractAccess.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private abstract void m1a(); // illegal</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m2a</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m3a</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m4a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>private abstract</strong> 被禁止了是有意义的，因为你不可能在 <strong>AbstractAccess</strong> 的任何子类中合法地定义它。</p><p>上一章的 <strong>Instrument</strong> 类可以很轻易地转换为一个抽象类。只需要部分方法是 <strong>abstract</strong> 即可。将一个类指明为 <strong>abstract</strong> 并不强制类中的所有方法必须都是抽象方法。如下图所示：</p><p><img src="/.com//Users\SYR\Desktop\images\1562653648586.png" alt="类图"></p><p>下面是修改成使用抽象类和抽象方法的管弦乐器的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/music4/Music4.java</span></span><br><span class="line"><span class="comment">// Abstract classes and methods</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.music4.Music4&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.music4;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i; <span class="comment">// Storage allocated for each</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Instrument&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Wind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Percussion.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Percussion&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Percussion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stringed.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Stringed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Stringed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Brass.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Brass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woodwind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woodwind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music4</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn&#x27;t care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Percussion.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">Woodwind.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>除了 <strong>Instrument</strong>，基本没区别。</p><p>创建抽象类和抽象方法是有帮助的，因为它们使得类的抽象性很明确，并能告知用户和编译器使用意图。抽象类同时也是一种有用的重构工具，使用它们使得我们很容易地将沿着继承层级结构上移公共方法。</p><h2 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h2><p>使用 <strong>interface</strong> 关键字创建接口。在本书中，interface 和 class 一样随处常见，除非特指关键字 <strong>interface</strong>，其他情况下都采用正常字体书写 interface。</p><p>描述 Java 8 之前的接口更加容易，因为它们只允许抽象方法。像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/PureInterface.java</span></span><br><span class="line"><span class="comment">// Interface only looked like this before Java 8</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PureInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们甚至不用为方法加上 <strong>abstract</strong> 关键字，因为方法在接口中。Java 知道这些方法不能有方法体（仍然可以为方法加上 <strong>abstract</strong> 关键字，但是看起来像是不明白接口，徒增难堪罢了）。</p><p>因此，在 Java 8 之前我们可以这么说：<strong>interface</strong> 关键字产生一个完全抽象的类，没有提供任何实现。我们只能描述类应该像什么，做什么，但不能描述怎么做，即只能决定方法名、参数列表和返回类型，但是无法确定方法体。接口只提供形式，通常来说没有实现，尽管在某些受限制的情况下可以有实现。</p><p>一个接口表示：所有实现了该接口的类看起来都像这样。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。所以，接口被用来建立类之间的协议。（一些面向对象编程语言中，使用 protocol 关键字完成相同的功能。）</p><p>Java 8 中接口稍微有些变化，因为 Java 8 允许接口包含默认方法和静态方法——基于某些重要原因，看到后面你会理解。接口的基本概念仍然没变，介于类型之上、实现之下。接口与抽象类最明显的区别可能就是使用上的惯用方式。接口的典型使用是代表一个类的类型或一个形容词，如 Runnable 或 Serializable，而抽象类通常是类层次结构的一部分或一件事物的类型，如 String 或 ActionHero。</p><p>使用关键字 <strong>interface</strong> 而不是 <strong>class</strong> 来创建接口。和类一样，需要在关键字 <strong>interface</strong> 前加上 <strong>public</strong> 关键字（但只是在接口名与文件名相同的情况下），否则接口只有包访问权限，只能在接口相同的包下才能使用它。</p><p>接口同样可以包含属性，这些属性被隐式指明为 <strong>static</strong> 和 <strong>final</strong>。</p><p>使用 <strong>implements</strong> 关键字使一个类遵循某个特定接口（或一组接口），它表示：接口只是外形，现在我要说明它是如何工作的。除此之外，它看起来像继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/ImplementingAnInterface.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Concept</span> </span>&#123; <span class="comment">// Package access</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">idea1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">idea2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation</span> <span class="keyword">implements</span> <span class="title">Concept</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">idea1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;idea1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">idea2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;idea2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以选择显式地声明接口中的方法为 <strong>public</strong>，但是即使你不这么做，它们也是 <strong>public</strong> 的。所以当实现一个接口时，来自接口中的方法必须被定义为 <strong>public</strong>。否则，它们只有包访问权限，这样在继承时，它们的可访问权限就被降低了，这是 Java 编译器所不允许的。</p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>Java 8 为关键字 <strong>default</strong> 增加了一个新的用途（之前只用于 <strong>switch</strong> 语句和注解中）。当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 <strong>default</strong> 创建的方法体。默认方法比抽象类中的方法受到更多的限制，但是非常有用，我们将在“流式编程”一章中看到。现在让我们看下如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AnInterface.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以像这样实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AnImplementation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnImplementation</span> <span class="keyword">implements</span> <span class="title">AnInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;firstMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;secondMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnInterface i = <span class="keyword">new</span> AnImplementation();</span><br><span class="line">        i.firstMethod();</span><br><span class="line">        i.secondMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstMethod</span><br><span class="line">secondMethod</span><br></pre></td></tr></table></figure><p>如果我们在 <strong>AnInterface</strong> 中增加一个新方法 <code>newMethod()</code>，而在 <strong>AnImplementation</strong> 中没有实现它，编译器就会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnImplementation.java:3:error: AnImplementation is not abstract and does not override abstract method newMethod() in AnInterface</span><br><span class="line">public class AnImplementation implements AnInterface &#123;</span><br><span class="line">^</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure><p>如果我们使用关键字 <strong>default</strong> 为 <code>newMethod()</code> 方法提供默认的实现，那么所有与接口有关的代码能正常工作，不受影响，而且这些代码还可以调用新的方法 <code>newMethod()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/InterfaceWithDefault.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceWithDefault</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">newMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;newMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字 <strong>default</strong> 允许在接口中提供方法实现——在 Java 8 之前被禁止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Implementation2.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">InterfaceWithDefault</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;firstMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;secondMethod&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InterfaceWithDefault i = <span class="keyword">new</span> Implementation2();</span><br><span class="line">        i.firstMethod();</span><br><span class="line">        i.secondMethod();</span><br><span class="line">        i.newMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firstMethod</span><br><span class="line">secondMethod</span><br><span class="line">newMethod</span><br></pre></td></tr></table></figure><p>尽管 <strong>Implementation2</strong> 中未定义 <code>newMethod()</code>，但是可以使用 <code>newMethod()</code> 了。</p><p>增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也被称为<em>守卫方法</em>或<em>虚拟扩展方法</em>。</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承意味着一个类可能从多个父类型中继承特征和特性。</p><p>Java 在设计之初，C++ 的多继承机制饱受诟病。Java 过去是一种严格要求单继承的语言：只能继承自一个类（或抽象类），但可以实现任意多个接口。在 Java 8 之前，接口没有包袱——它只是方法外貌的描述。</p><p>多年后的现在，Java 通过默认方法具有了某种多继承的特性。结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性（只有静态属性，不适用），所以属性仍然只会来自单个基类或抽象类，也就是说，不会存在状态的多继承。正如下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/MultipleInheritance.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Three</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> <span class="keyword">implements</span> <span class="title">One</span>, <span class="title">Two</span>, <span class="title">Three</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MI mi = <span class="keyword">new</span> MI();</span><br><span class="line">        mi.first();</span><br><span class="line">        mi.second();</span><br><span class="line">        mi.third();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br><span class="line">third</span><br></pre></td></tr></table></figure><p>现在我们做些在 Java 8 之前不可能完成的事：结合多个源的实现。只要基类方法中的方法名和参数列表不同，就能工作得很好，否则会得到编译器错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface/MICollision.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bob1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bob1::bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bob2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bob2::bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Bob implements Bob1, Bob2 &#123;&#125;</span></span><br><span class="line"><span class="comment">/* Produces:</span></span><br><span class="line"><span class="comment">error: class Bob inherits unrelated defaults</span></span><br><span class="line"><span class="comment">for bob() from types Bob1 and Bob2</span></span><br><span class="line"><span class="comment">class Bob implements Bob1, Bob2 &#123;&#125;</span></span><br><span class="line"><span class="comment">^</span></span><br><span class="line"><span class="comment">1 error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sam1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sam1::sam&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sam2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sam</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This works because the argument lists are distinct:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sam</span> <span class="keyword">implements</span> <span class="title">Sam1</span>, <span class="title">Sam2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Max1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Max1::max&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Max2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Max implements Max1, Max2 &#123;&#125;</span></span><br><span class="line"><span class="comment">/* Produces:</span></span><br><span class="line"><span class="comment">error: types Max2 and Max1 are imcompatible;</span></span><br><span class="line"><span class="comment">both define max(), but with unrelated return types</span></span><br><span class="line"><span class="comment">class Max implements Max1, Max2 &#123;&#125;</span></span><br><span class="line"><span class="comment">^</span></span><br><span class="line"><span class="comment">1 error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Sam</strong> 类中的两个 <code>sam()</code> 方法有相同的方法名但是签名不同——方法签名包括方法名和参数类型，编译器也是用它来区分方法。但是从 <strong>Max</strong> 类可看出，返回类型不是方法签名的一部分，因此不能用来区分方法。为了解决这个问题，需要覆写冲突的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Jim.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Jim1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Jim1::jim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Jim2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Jim2::jim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jim</span> <span class="keyword">implements</span> <span class="title">Jim1</span>, <span class="title">Jim2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jim2.<span class="keyword">super</span>.jim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Jim().jim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jim2::jim</span><br></pre></td></tr></table></figure><p>当然，你可以重定义 <code>jim()</code> 方法，但是也能像上例中那样使用 <strong>super</strong> 关键字选择基类实现中的一种。</p><h3 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h3><p>Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Operations.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runOps</span><span class="params">(Operations... ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Operations op: ops) &#123;</span><br><span class="line">            op.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是模版方法设计模式的一个版本（在“设计模式”一章中详细描述），<code>runOps()</code> 是一个模版方法。<code>runOps()</code> 使用可变参数列表，因而我们可以传入任意多的 <strong>Operation</strong> 参数并按顺序运行它们：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface/Machine.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Operations;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bing</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">&quot;Bing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crack</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">&quot;Crack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twist</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">&quot;Twist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Operations.runOps(</span><br><span class="line">        <span class="keyword">new</span> Bing(), <span class="keyword">new</span> Crack(), <span class="keyword">new</span> Twist());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bing</span><br><span class="line">Crack</span><br><span class="line">Twist</span><br></pre></td></tr></table></figure><p>这里展示了创建 <strong>Operations</strong> 的不同方式：一个外部类(Bing)，一个匿名类，一个方法引用和 lambda 表达式——毫无疑问用在这里是最好的解决方法。</p><p>这个特性是一项改善，因为它允许把静态方法放在更合适的地方。</p><h3 id="Instrument-作为接口"><a href="#Instrument-作为接口" class="headerlink" title="Instrument 作为接口"></a>Instrument 作为接口</h3><p>回顾下乐器的例子，使用接口的话：</p><p><img src="/.com//Users\SYR\Desktop\images\1562737974623.png" alt="类图"></p><p>类 <strong>Woodwind</strong> 和 <strong>Brass</strong> 说明一旦实现了某个接口，那么其实现就变成一个普通类，可以按常规方式扩展它。</p><p>接口的工作方式使得我们不需要显式声明其中的方法为 <strong>public</strong>，它们自动就是 <strong>public</strong> 的。<code>play()</code> 和 <code>adjust()</code> 使用 <strong>default</strong> 关键字定义实现。在 Java 8 之前，这些定义要在每个实现中重复实现，显得多余且令人烦恼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/music5/Music5.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.music5.Music5&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.music5;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compile-time constant:</span></span><br><span class="line">    <span class="keyword">int</span> VALUE = <span class="number">5</span>; <span class="comment">// static &amp; final</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span>  <span class="comment">// Automatically public</span></span></span><br><span class="line"><span class="function">        System.out.<span class="title">println</span><span class="params">(<span class="keyword">this</span> + <span class="string">&quot;.play() &quot;</span> + n)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Percussion&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Stringed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Brass&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woodwind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn&#x27;t care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to the system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Percussion.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">Woodwind.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>这个版本的例子的另一个变化是：<code>what()</code> 被修改为 <code>toString()</code> 方法，因为 <code>toString()</code> 实现的正是 <code>what()</code> 方法要实现的逻辑。因为 <code>toString()</code> 是根基类 <strong>Object</strong> 的方法，所以它不需要出现在接口中。</p><p>注意到，无论是将其向上转型为称作 <strong>Instrument</strong> 的普通类，或称作 <strong>Instrument</strong> 的抽象类，还是叫作 <strong>Instrument</strong> 的接口，其行为都是相同的。事实上，从 <code>tune()</code> 方法上看不出来 <strong>Instrument</strong> 到底是一个普通类、抽象类，还是一个接口。</p><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>尤其是在 Java 8 引入 <strong>default</strong> 方法之后，选择用抽象类还是用接口变得更加令人困惑。下表做了明确的区分：</p><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">接口</th><th style="text-align:center">抽象类</th></tr></thead><tbody><tr><td style="text-align:center">组合</td><td style="text-align:center">新类可以组合多个接口</td><td style="text-align:center">只能继承单一抽象类</td></tr><tr><td style="text-align:center">状态</td><td style="text-align:center">不能包含属性（除了静态属性，不支持对象状态）</td><td style="text-align:center">可以包含属性，非抽象方法可能引用这些属性</td></tr><tr><td style="text-align:center">默认方法 和 抽象方法</td><td style="text-align:center">不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td><td style="text-align:center">必须在子类中实现抽象方法</td></tr><tr><td style="text-align:center">构造器</td><td style="text-align:center">没有构造器</td><td style="text-align:center">可以有构造器</td></tr><tr><td style="text-align:center">可见性</td><td style="text-align:center">隐式 <strong>public</strong></td><td style="text-align:center">可以是 <strong>protected</strong> 或友元</td></tr></tbody></table></div><p>抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。</p><p>有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。</p><h2 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h2><p>当方法操纵的是一个类而非接口时，它就只能作用于那个类或其子类。如果想把方法应用于那个继承层级结构之外的类，就会触霉头。接口在很大程度上放宽了这个限制，因而使用接口可以编写复用性更好的代码。</p><p>例如有一个类 <strong>Process</strong> 有两个方法 <code>name()</code> 和 <code>process()</code>。<code>process()</code> 方法接受输入，修改并输出。把这个类作为基类用来创建各种不同类型的 <strong>Processor</strong>。下例中，<strong>Processor</strong> 的各个子类修改 String 对象（注意，返回类型可能是协变类型而非参数类型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Applicator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回协变类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// split() divides a String into pieces:</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String) input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applicator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Processor &quot;</span> + p.name());</span><br><span class="line">        System.out.println(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;We are such stuff as dreams are made on&quot;</span>;</span><br><span class="line">        apply(<span class="keyword">new</span> Upcase(), s);</span><br><span class="line">        apply(<span class="keyword">new</span> Downcase(), s);</span><br><span class="line">        apply(<span class="keyword">new</span> Splitter(), s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Using Processor Upcase</span><br><span class="line">WE ARE SUCH STUFF AS DREAMS ARE MADE ON</span><br><span class="line">Using Processor Downcase</span><br><span class="line">we are such stuff as dreams are made on</span><br><span class="line">Using Processor Splitter</span><br><span class="line">[We, are, such, stuff, as, dreams, are, made, on]</span><br></pre></td></tr></table></figure><p><strong>Applicator</strong> 的 <code>apply()</code> 方法可以接受任何类型的 <strong>Processor</strong>，并将其应用到一个 <strong>Object</strong> 对象上输出结果。像本例中这样，创建一个能根据传入的参数类型从而具备不同行为的方法称为<em>策略</em>设计模式。方法包含算法中不变的部分，策略包含变化的部分。策略就是传入的对象，它包含要执行的代码。在这里，<strong>Processor</strong> 对象是策略，<code>main()</code> 方法展示了三种不同的应用于 <strong>String s</strong> 上的策略。</p><p><code>split()</code> 是 <strong>String</strong> 类中的方法，它接受 <strong>String</strong> 类型的对象并以传入的参数作为分割界限，返回一个数组 <strong>String[]</strong>。在这里用它是为了更快地创建 <strong>String</strong> 数组。</p><p>假设现在发现了一组电子滤波器，它们看起来好像能使用 <strong>Applicator</strong> 的 <code>apply()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/filters/Waveform.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waveform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Waveform &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/Filter.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/LowPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cutoff;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LowPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input; <span class="comment">// Dummy processing 哑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/HighPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cutoff;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/BandPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BandPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> lowCutoff, highCutoff;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BandPass</span><span class="params">(<span class="keyword">double</span> lowCut, <span class="keyword">double</span> highCut)</span> </span>&#123;</span><br><span class="line">        lowCutoff = lowCut;</span><br><span class="line">        highCutoff = highCut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Filter</strong> 类与 <strong>Processor</strong> 类具有相同的接口元素，但是因为它不是继承自 <strong>Processor</strong> —— 因为 <strong>Filter</strong> 类的创建者根本不知道你想将它当作 <strong>Processor</strong> 使用 —— 因此你不能将 <strong>Applicator</strong> 的 <code>apply()</code> 方法应用在 <strong>Filter</strong> 类上，即使这样做也能正常运行。主要是因为 <strong>Applicator</strong> 的 <code>apply()</code> 方法和 <strong>Processor</strong> 过于耦合，这阻止了 <strong>Applicator</strong> 的 <code>apply()</code> 方法被复用。另外要注意的一点是 Filter 类中 <code>process()</code> 方法的输入输出都是 <strong>Waveform</strong>。</p><p>但如果 <strong>Processor</strong> 是一个接口，那么限制就会变得松动到足以复用 <strong>Applicator</strong> 的 <code>apply()</code> 方法，用来接受那个接口参数。下面是修改后的 <strong>Processor</strong> 和 <strong>Applicator</strong> 版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/Processor.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/interfaceprocessor/Applicator.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applicator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Processor &quot;</span> + p.name());</span><br><span class="line">        System.out.println(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复用代码的第一种方式是客户端程序员遵循接口编写类，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/StringProcessor.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.interfaceprocessor.StringProcessor&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StringProcessor</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>; <span class="comment">// [1]</span></span><br><span class="line">    String S = <span class="string">&quot;If she weighs the same as a duck, she&#x27;s made of wood&quot;</span>; <span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// [3]</span></span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Upcase(), S);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Downcase(), S);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Splitter(), S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回协变类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String) input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Using Processor Upcase</span><br><span class="line">IF SHE WEIGHS THE SAME AS A DUCK, SHE&#x27;S MADE OF WOOD</span><br><span class="line">Using Processor Downcase</span><br><span class="line">if she weighs the same as a duck, she&#x27;s made of wood</span><br><span class="line">Using Processor Splitter</span><br><span class="line">[If, she, weighs, the, same, as, a, duck,, she&#x27;s, made, of, wood]</span><br></pre></td></tr></table></figure><blockquote><p>[1] 该声明不是必要的，即使移除它，编译器也不会报错。但是注意这里的协变返回类型从 Object 变成了 String。</p><p>[2] S 自动就是 final 和 static 的，因为它是在接口中定义的。</p><p>[3] 可以在接口中定义 <code>main()</code> 方法。</p></blockquote><p>这种方式运作得很好，然而你经常遇到的情况是无法修改类。例如在电子滤波器的例子中，类库是被发现而不是创建的。在这些情况下，可以使用<em>适配器</em>设计模式。适配器允许代码接受已有的接口产生需要的接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/FilterProcessor.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.interfaceprocessor.FilterProcessor&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"><span class="keyword">import</span> interfaces.filters.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterAdapter</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    Filter filter;</span><br><span class="line"></span><br><span class="line">    FilterAdapter(Filter filter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filter.name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filter.process((Waveform) input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Waveform w = <span class="keyword">new</span> Waveform();</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> LowPass(<span class="number">1.0</span>)), w);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> HighPass(<span class="number">2.0</span>)), w);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> BandPass(<span class="number">3.0</span>, <span class="number">4.0</span>)), w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Using Processor LowPass</span><br><span class="line">Waveform 0</span><br><span class="line">Using Processor HighPass</span><br><span class="line">Waveform 0</span><br><span class="line">Using Processor BandPass</span><br><span class="line">Waveform 0</span><br></pre></td></tr></table></figure><p>在这种使用适配器的方式中，<strong>FilterAdapter</strong> 的构造器接受已有的接口 <strong>Filter</strong>，继而产生需要的 <strong>Processor</strong> 接口的对象。你可能还注意到 <strong>FilterAdapter</strong> 中使用了委托。</p><p>协变允许我们从 <code>process()</code> 方法中产生一个 <strong>Waveform</strong> 而非 <strong>Object</strong> 对象。</p><p>将接口与实现解耦使得接口可以应用于多种不同的实现，因而代码更具可复用性。</p><h2 id="多接口结合"><a href="#多接口结合" class="headerlink" title="多接口结合"></a>多接口结合</h2><p>接口没有任何实现——也就是说，没有任何与接口相关的存储——因此无法阻止结合的多接口。这是有价值的，因为你有时需要表示“一个 <strong>x</strong> 是一个 <strong>a</strong> 和一个 <strong>b</strong> 以及一个 <strong>c</strong>”。</p><p><img src="/.com//Users\SYR\Desktop\images\1562999314238.png" alt="类图"></p><p>派生类并不要求必须继承自抽象的或“具体的”（没有任何抽象方法）的基类。如果继承一个非接口的类，那么只能继承一个类，其余的基元素必须都是接口。需要将所有的接口名称置于 <strong>implements</strong> 关键字之后且用逗号分隔。可以有任意多个接口，并可以向上转型为每个接口，因为每个接口都是独立的类型。下例展示了一个由多个接口组合而成的具体类产生的新类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Adventure.java</span></span><br><span class="line"><span class="comment">// Multiple interfaces</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span> <span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span>, <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adventure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CanFight x)</span> </span>&#123;</span><br><span class="line">        x.fight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(CanSwim x)</span> </span>&#123;</span><br><span class="line">        x.swim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> staic <span class="keyword">void</span> <span class="title">v</span><span class="params">(CanFly x)</span> </span>&#123;</span><br><span class="line">        x.fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(ActionCharacter x)</span> </span>&#123;</span><br><span class="line">        x.fight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">        t(h); <span class="comment">// Treat it as a CanFight</span></span><br><span class="line">        u(h); <span class="comment">// Treat it as a CanSwim</span></span><br><span class="line">        v(h); <span class="comment">// Treat it as a CanFly</span></span><br><span class="line">        w(h); <span class="comment">// Treat it as an ActionCharacter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <strong>Hero</strong> 结合了具体类 <strong>ActionCharacter</strong> 和接口 <strong>CanFight</strong>、<strong>CanSwim</strong> 和 <strong>CanFly</strong>。当通过这种方式结合具体类和接口时，需要将具体类放在前面，后面跟着接口（否则编译器会报错）。</p><p>接口 <strong>CanFight</strong> 和类 <strong>ActionCharacter</strong> 中的 <code>fight()</code> 方法签名相同，而在类 Hero 中也没有提供 <code>fight()</code> 的定义。可以扩展一个接口，但是得到的是另一个接口。当想创建一个对象时，所有的定义必须首先都存在。类 <strong>Hero</strong> 中没有显式地提供 <code>fight()</code> 的定义，是由于该方法在类 <strong>ActionCharacter</strong> 中已经定义过，这样才使得创建 <strong>Hero</strong> 对象成为可能。</p><p>在类 <strong>Adventure</strong> 中可以看到四个方法，它们把不同的接口和具体类作为参数。当创建一个 <strong>Hero</strong> 对象时，它可以被传入这些方法中的任意一个，意味着它可以依次向上转型为每个接口。Java 中这种接口的设计方式，使得程序员不需要付出特别的努力。</p><p>记住，前面例子展示了使用接口的核心原因之一：为了能够向上转型为多个基类型（以及由此带来的灵活性）。然而，使用接口的第二个原因与使用抽象基类相同：防止客户端程序员创建这个类的对象，确保这仅仅只是一个接口。这带来了一个问题：应该使用接口还是抽象类呢？如果创建不带任何方法定义或成员变量的基类，就选择接口而不是抽象类。事实上，如果知道某事物是一个基类，可以考虑用接口实现它（这个主题在本章总结会再次讨论）。</p><h2 id="使用继承扩展接口"><a href="#使用继承扩展接口" class="headerlink" title="使用继承扩展接口"></a>使用继承扩展接口</h2><p>通过继承，可以很容易在接口中增加方法声明，还可以在新接口中结合多个接口。这两种情况都可以得到新接口，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/HorrorShow.java</span></span><br><span class="line"><span class="comment">// Extending an interface with inheritance</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DangerousMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lethal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DragonZilla</span> <span class="keyword">implements</span> <span class="title">DangerousMonster</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vampire</span> <span class="keyword">extends</span> <span class="title">DangerousMonster</span>, <span class="title">Lethal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBadVampire</span> <span class="keyword">implements</span> <span class="title">Vampire</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorrorShow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(Monster b)</span> </span>&#123;</span><br><span class="line">        b.menace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(DangerousMonster d)</span> </span>&#123;</span><br><span class="line">        d.menace();</span><br><span class="line">        d.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(Lethal l)</span> </span>&#123;</span><br><span class="line">        l.kill();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DangerousMonster barney = <span class="keyword">new</span> DragonZilla();</span><br><span class="line">        u(barney);</span><br><span class="line">        v(barney);</span><br><span class="line">        Vampire vlad = <span class="keyword">new</span> VeryBadVampire();</span><br><span class="line">        u(vlad);</span><br><span class="line">        v(vlad);</span><br><span class="line">        w(vlad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口 <strong>DangerousMonster</strong> 是 <strong>Monster</strong> 简单扩展的一个新接口，类 <strong>DragonZilla</strong> 实现了这个接口。</p><p><strong>Vampire</strong> 中使用的语法仅适用于接口继承。通常来说，<strong>extends</strong> 只能用于单一类，但是在构建接口时可以引用多个基类接口。注意到，接口名之间用逗号分隔。</p><h3 id="结合接口时的命名冲突"><a href="#结合接口时的命名冲突" class="headerlink" title="结合接口时的命名冲突"></a>结合接口时的命名冲突</h3><p>当实现多个接口时可能会存在一个小陷阱。在前面的例子中，<strong>CanFight</strong> 和 <strong>ActionCharacter</strong> 具有完全相同的 <code>fight()</code> 方法。完全相同的方法没有问题，但是如果它们的签名或返回类型不同会怎么样呢？这里有一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/InterfaceCollision.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完全相同，没问题</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的返回类型不同</span></span><br><span class="line"><span class="comment">//- class C5 extends C implements I1 &#123;&#125;</span></span><br><span class="line"><span class="comment">//- interface I4 extends I1, I3 &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>覆写、实现和重载令人不快地搅和在一起带来了困难。同时，重载方法仅根据返回类型是区分不了的。当不注释最后两行时，报错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error: C5 is not abstract and does not override abstract</span><br><span class="line">method f() in I1</span><br><span class="line">class C5 extends C implements I1 &#123;&#125;</span><br><span class="line">error: types I3 and I1 are incompatible; both define f(),</span><br><span class="line">but with unrelated return types</span><br><span class="line">interfacce I4 extends I1, I3 &#123;&#125;</span><br></pre></td></tr></table></figure><p>当打算组合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混乱，尽量避免这种情况。</p><h2 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h2><p>接口最吸引人的原因之一是相同的接口可以有多个实现。在简单情况下体现在一个方法接受接口作为参数，该接口的实现和传递对象给方法则交由你来做。</p><p>因此，接口的一种常见用法是前面提到的<em>策略</em>设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。可以说：“只要对象遵循接口，就可以调用方法” ，这使得方法更加灵活，通用，并更具可复用性。</p><p>例如，类 <strong>Scanner</strong> 的构造器接受的是一个 <strong>Readable</strong> 接口（在“字符串”一章中学习更多相关内容）。你会发现 <strong>Readable</strong> 没有用作 Java 标准库中其他任何方法的参数——它是单独为 <strong>Scanner</strong> 创建的，因此 <strong>Scanner</strong> 没有将其参数限制为某个特定类。通过这种方式，<strong>Scanner</strong> 可以与更多的类型协作。如果你创建了一个新类并想让 <strong>Scanner</strong> 作用于它，就让它实现 <strong>Readable</strong> 接口，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandomStrings.java</span></span><br><span class="line"><span class="comment">// Implementing an interface to conform to a method</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStrings</span> <span class="keyword">implements</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] CAPITALS = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] LOWERS = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] VOWELS = <span class="string">&quot;aeiou&quot;</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomStrings</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(CharBuffer cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// indicates end of input</span></span><br><span class="line">        &#125;</span><br><span class="line">        cb.append(CAPITALS[rand.nextInt(CAPITALS.length)]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            cb.append(VOWELS[rand.nextInt(VOWELS.length)]);</span><br><span class="line">            cb.append(LOWERS[rand.nextInt(LOWERS.length)]);</span><br><span class="line">        &#125;</span><br><span class="line">        cb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>; <span class="comment">// Number of characters appended</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> RandomStrings(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">while</span> (s.hasNext()) &#123;</span><br><span class="line">            System.out.println(s.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Yazeruyac</span><br><span class="line">Fowenucor</span><br><span class="line">Goeazimom</span><br><span class="line">Raeuuacio</span><br><span class="line">Nuoadesiw</span><br><span class="line">Hageaikux</span><br><span class="line">Ruqicibui</span><br><span class="line">Numasetih</span><br><span class="line">Kuuuuozog</span><br><span class="line">Waqizeyoy</span><br></pre></td></tr></table></figure><p><strong>Readable</strong> 接口只需要实现 <code>read()</code> 方法（注意 <code>@Override</code> 注解的突出方法）。在 <code>read()</code> 方法里，将输入内容添加到 <strong>CharBuffer</strong> 参数中（有多种方法可以实现，查看 <strong>CharBuffer</strong> 文档），或在没有输入时返回 <strong>-1</strong>。</p><p>假设你有一个类没有实现 <strong>Readable</strong> 接口，怎样才能让 <strong>Scanner</strong> 作用于它呢？下面是一个产生随机浮点数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandomDoubles.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomDoubles</span> </span>&#123;</span><br><span class="line">    Random RAND = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RAND.nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomDoubles rd = <span class="keyword">new</span> RandomDoubles()&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            System.out.println(rd.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.7271157860730044</span><br><span class="line">0.5309454508634242</span><br><span class="line">0.16020656493302599</span><br><span class="line">0.18847866977771732</span><br><span class="line">0.5166020801268457</span><br><span class="line">0.2678662084200585</span><br><span class="line">0.2613610344283964</span><br></pre></td></tr></table></figure><p>我们可以再次使用适配器模式，但这里适配器类可以实现两个接口。因此，通过关键字 <strong>interface</strong> 提供的多继承，我们可以创建一个既是 <strong>RandomDoubles</strong>，又是 <strong>Readable</strong> 的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AdaptedRandomDoubles.java</span></span><br><span class="line"><span class="comment">// creating an adapter with inheritance</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptedRandomDoubles</span> <span class="keyword">implements</span> <span class="title">RandomDoubles</span>, <span class="title">Readable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptedRandomDoubles</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(CharBuffer cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String result = Double.toString(next()) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cb.append(result);</span><br><span class="line">        <span class="keyword">return</span> result.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> AdaptedRandomDoubles(<span class="number">7</span>));</span><br><span class="line">        <span class="keyword">while</span> (s.hasNextDouble()) &#123;</span><br><span class="line">            System.out.print(s.nextDouble() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.7271157860730044 0.5309454508634242</span><br><span class="line">0.16020656493302599 0.18847866977771732</span><br><span class="line">0.5166020801268457 0.2678662084200585</span><br><span class="line">0.2613610344283964</span><br></pre></td></tr></table></figure><p>因为你可以以这种方式在已有类中增加新接口，所以这就意味着一个接受接口类型的方法提供了一种让任何类都可以与该方法进行适配的方式。这就是使用接口而不是类的强大之处。</p><h2 id="接口字段"><a href="#接口字段" class="headerlink" title="接口字段"></a>接口字段</h2><p>因为接口中的字段都自动是 <strong>static</strong> 和 <strong>final</strong> 的，所以接口就成为了创建一组常量的方便的工具。在 Java 5 之前，这是产生与 C 或 C++ 中的 enum (枚举类型) 具有相同效果的唯一方式。所以你可能在 Java 5 之前的代码中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Months.java</span></span><br><span class="line"><span class="comment">// Using interfaces to create groups of constants</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Months</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    JANUARY = <span class="number">1</span>, FEBRUARY = <span class="number">2</span>, MARCH = <span class="number">3</span>,</span><br><span class="line">    APRIL = <span class="number">4</span>, MAY = <span class="number">5</span>, JUNE = <span class="number">6</span>, JULY = <span class="number">7</span>,</span><br><span class="line">    AUGUST = <span class="number">8</span>, SEPTEMBER = <span class="number">9</span>, OCTOBER = <span class="number">10</span>,</span><br><span class="line">    NOVEMBER = <span class="number">11</span>, DECEMBER = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 Java 中使用大写字母的风格定义具有初始化值的 <strong>static</strong> <strong>final</strong> 变量。接口中的字段自动是 <strong>public</strong> 的，所以没有显式指明这点。</p><p>自 Java 5 开始，我们有了更加强大和灵活的关键字 <strong>enum</strong>，那么在接口中定义常量组就显得没什么意义了。然而当你阅读遗留的代码时，在很多场合你还会碰到这种旧的习惯用法。在“枚举”一章中你会学习到更多关于枚举的内容。</p><h3 id="初始化接口中的字段"><a href="#初始化接口中的字段" class="headerlink" title="初始化接口中的字段"></a>初始化接口中的字段</h3><p>接口中定义的字段不能是“空 <strong>final</strong>“，但是可以用非常量表达式初始化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandVals.java</span></span><br><span class="line"><span class="comment">// Initializing interface fields with</span></span><br><span class="line"><span class="comment">// non-constant initializers</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandVals</span> </span>&#123;</span><br><span class="line">    Random RAND = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">int</span> RANDOM_INT = RAND.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">long</span> RANDOM_LONG = RAND.nextLong() * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">float</span> RANDOM_FLOAT = RAND.nextLong() * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> RANDOM_DOUBLE = RAND.nextDouble() * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为字段是 <strong>static</strong> 的，所以它们在类第一次被加载时初始化，这发生在任何字段首次被访问时。下面是个简单的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/TestRandVals.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandVals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(RandVals.RANDOM_INT);</span><br><span class="line">        System.out.println(RandVals.RANDOM_LONG);</span><br><span class="line">        System.out.println(RandVals.RANDOM_FLOAT);</span><br><span class="line">        System.out.println(RandVals.RANDOM_DOUBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">-32032247016559954</span><br><span class="line">-8.5939291E18</span><br><span class="line">5.779976127815049</span><br></pre></td></tr></table></figure><p>这些字段不是接口的一部分，它们的值被存储在接口的静态存储区域中。</p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>接口可以嵌套在类或其他接口中。下面揭示一些有趣的特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/nesting/NestingInterfaces.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.nesting.NestingInterfaces&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.nesting;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp2</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CImp2</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp2</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DImp2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> D dRef;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line">        dRef = d;</span><br><span class="line">        dRef.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Redundant &quot;public&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Cannot be private within an interface</span></span><br><span class="line">    <span class="comment">//- private interface I &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Cannot implements a private interface except</span></span><br><span class="line">    <span class="comment">// within that interface&#x27;s defining class:</span></span><br><span class="line">    <span class="comment">//- class DImp implements A.D &#123;</span></span><br><span class="line">    <span class="comment">//- public void f() &#123;&#125;</span></span><br><span class="line">    <span class="comment">//- &#125;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImp</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EGImp</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImp2</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EG</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">// Can&#x27;t access to A.D:</span></span><br><span class="line">        <span class="comment">//- A.D ad = a.getD();</span></span><br><span class="line">        <span class="comment">// Doesn&#x27;t return anything but A.D:</span></span><br><span class="line">        <span class="comment">//- A.DImp2 di2 = a.getD();</span></span><br><span class="line">        <span class="comment">// cannot access a member of the interface:</span></span><br><span class="line">        <span class="comment">//- a.getD().f();</span></span><br><span class="line">        <span class="comment">// Only another A can do anything with getD():</span></span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">        a2.receiveD(a.getD());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中嵌套接口的语法是相当显而易见的。就像非嵌套接口一样，它们具有 <strong>public</strong> 或包访问权限的可见性。</p><p>作为一种新添加的方式，接口也可以是 <strong>private</strong> 的，例如 <strong>A.D</strong>（同样的语法同时适用于嵌套接口和嵌套类）。那么 <strong>private</strong> 嵌套接口有什么好处呢？你可能猜测它只是被用来实现一个 <strong>private</strong> 内部类，就像 <strong>DImp</strong>。然而 <strong>A.DImp2</strong> 展示了它可以被实现为 <strong>public</strong> 类，但是 <strong>A.DImp2</strong> 只能被自己使用，你无法说它实现了 <strong>private</strong> 接口 <strong>D</strong>，所以实现 <strong>private</strong> 接口是一种可以强制该接口中的方法定义不会添加任何类型信息（即不可以向上转型）的方式。</p><p><code>getD()</code> 方法产生了一个与 <strong>private</strong> 接口有关的窘境。它是一个 <strong>public</strong> 方法却返回了对 <strong>private</strong> 接口的引用。能对这个返回值做些什么呢？<code>main()</code> 方法里进行了一些使用返回值的尝试但都失败了。返回值必须交给有权使用它的对象，本例中另一个 <strong>A</strong> 通过 <code>receiveD()</code> 方法接受了它。</p><p>接口 <strong>E</strong> 说明了接口之间也能嵌套。然而，作用于接口的规则——尤其是，接口中的元素必须是 <strong>public</strong> 的——在此都会被严格执行，所以嵌套在另一个接口中的接口自动就是 <strong>public</strong> 的，不能指明为 <strong>private</strong>。</p><p>类 <strong>NestingInterfaces</strong> 展示了嵌套接口的不同实现方式。尤其是当实现某个接口时，并不需要实现嵌套在其内部的接口。同时，<strong>private</strong> 接口不能在定义它的类之外被实现。</p><p>添加这些特性的最初原因看起来像是出于对严格的语法一致性的考虑，但是我通常认为，一旦你了解了某种特性，就总能找到其用武之地。</p><h2 id="接口和工厂方法模式"><a href="#接口和工厂方法模式" class="headerlink" title="接口和工厂方法模式"></a>接口和工厂方法模式</h2><p>接口是多实现的途径，而生成符合某个接口的对象的典型方式是<em>工厂方法</em>设计模式。不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现——理论上，通过这种方式可以将接口与实现的代码完全分离，使得可以透明地将某个实现替换为另一个实现。这里是一个展示工厂方法结构的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Factories.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    Service1() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service1 method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service1 method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Service1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    Service2() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service2 method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service2 method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Service2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span> </span>&#123;</span><br><span class="line">        Service s = fact.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> Service1Factory());</span><br><span class="line">        <span class="comment">// Services are completely interchangeable:</span></span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> Service2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Service1 method1</span><br><span class="line">Service1 method2</span><br><span class="line">Service2 method1</span><br><span class="line">Service2 method2</span><br></pre></td></tr></table></figure><p>如果没有工厂方法，代码就必须在某处指定将要创建的 <strong>Service</strong> 的确切类型，从而调用恰当的构造器。</p><p>为什么要添加额外的间接层呢？一个常见的原因是创建框架。假设你正在创建一个游戏系统；例如，在相同的棋盘下国际象棋和西洋跳棋：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Games.java</span></span><br><span class="line"><span class="comment">// A Game framework using Factory Methods</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Game <span class="title">getGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkers</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Checkers move &quot;</span> + moves);</span><br><span class="line">        <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckersFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Checkers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Chess move &quot;</span> + moves);</span><br><span class="line">        <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Chess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Games</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">(GameFactory factory)</span> </span>&#123;</span><br><span class="line">        Game s = factory.getGame();</span><br><span class="line">        <span class="keyword">while</span> (s.move()) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        playGame(<span class="keyword">new</span> CheckersFactory());</span><br><span class="line">        playGame(<span class="keyword">new</span> ChessFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Checkers move 0</span><br><span class="line">Checkers move 1</span><br><span class="line">Checkers move 2</span><br><span class="line">Chess move 0</span><br><span class="line">Chess move 1</span><br><span class="line">Chess move 2</span><br><span class="line">Chess move 3</span><br></pre></td></tr></table></figure><p>如果类 <strong>Games</strong> 表示一段很复杂的代码，那么这种方式意味着你可以在不同类型的游戏里复用这段代码。你可以再想象一些能够从这个模式中受益的更加精巧的游戏。</p><p>在下一章，你将会看到一种更加优雅的使用匿名内部类的工厂实现方式。</p><h2 id="本章小结-8"><a href="#本章小结-8" class="headerlink" title="本章小结"></a>本章小结</h2><p>认为接口是好的选择，从而使用接口不用具体类，这具有诱惑性。几乎任何时候，创建类都可以替代为创建一个接口和工厂。</p><p>很多人都掉进了这个陷阱，只要有可能就创建接口和工厂。这种逻辑看起来像是可能会使用不同的实现，所以总是添加这种抽象性。这变成了一种过早的设计优化。</p><p>任何抽象性都应该是由真正的需求驱动的。当有必要时才应该使用接口进行重构，而不是到处添加额外的间接层，从而带来额外的复杂性。这种复杂性非常显著，如果你让某人去处理这种复杂性，只是因为你意识到“以防万一”而添加新接口，而没有其他具有说服力的原因——好吧，如果我碰上了这种设计，就会质疑此人所作的所有其他设计了。</p><p>恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。</p><h1 id="第-11-章-内部类"><a href="#第-11-章-内部类" class="headerlink" title="第 11 章 内部类"></a>第 11 章 内部类</h1><blockquote><p>一个定义在另一个类中的类，叫作内部类。</p></blockquote><p>内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。然而必须要了解，内部类与组合是完全不同的概念，这一点很重要。在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰，尽管并不总是这样（而且 Java 8 的 Lambda 表达式和方法引用减少了编写内部类的需求）。</p><p>最初，内部类可能看起来有些奇怪，而且要花些时间才能在设计中轻松地使用它们。对内部类的需求并非总是很明显的，但是在描述完内部类的基本语法与语义之后，”Why inner classes?”就应该使得内部类的益处明确显现了。</p><p>本章剩余部分包含了对内部类语法更加详尽的探索，这些特性是为了语言的完备性而设计的，但是你也许不需要使用它们，至少一开始不需要。因此，本章最初的部分也许就是你现在所需的全部，你可以将更详尽的探索当作参考资料。</p><h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><p>创建内部类的方式就如同你想的一样——把类的定义置于外围类的里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel1.java</span></span><br><span class="line"><span class="comment">// Creating inner classes</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">        Destination(String whereTo) &#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Using inner classes looks just like</span></span><br><span class="line">    <span class="comment">// using any other class, within Parcel1:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">        Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">        Destination d = <span class="keyword">new</span> Destination(dest);</span><br><span class="line">        System.out.println(d.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">        p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tasmania</span><br></pre></td></tr></table></figure><p>当我们在 <code>ship()</code> 方法里面使用内部类的时候，与使用普通类没什么不同。在这里，明显的区别只是内部类的名字是嵌套在 <strong>Parcel1</strong> 里面的。</p><p>更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用，就像在 <code>to()</code> 和 <code>contents()</code> 方法中看到的那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel2.java</span></span><br><span class="line"><span class="comment">// Returning a reference to an inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">        Destination(String whereTo) &#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">        Contents c = contents();</span><br><span class="line">        Destination d = to(dest);</span><br><span class="line">        System.out.println(d.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel2 p = <span class="keyword">new</span> Parcel2();</span><br><span class="line">        p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">        Parcel2 q = <span class="keyword">new</span> Parcel2();</span><br><span class="line">        <span class="comment">// Defining references to inner classes:</span></span><br><span class="line">        Parcel2.Contents c = q.contents();</span><br><span class="line">        Parcel2.Destination d = q.to(<span class="string">&quot;Borneo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tasmania</span><br></pre></td></tr></table></figure><p>如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在 <code>main()</code> 方法中那样，具体地指明这个对象的类型：<em>OuterClassName.InnerClassName</em>。(译者注：在外部类的静态方法中也可以直接指明类型 <em>InnerClassName</em>，在其他类中需要指明 <em>OuterClassName.InnerClassName</em>。)</p><h2 id="链接外部类"><a href="#链接外部类" class="headerlink" title="链接外部类"></a>链接外部类</h2><p>到目前为止，内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的外围对象（enclosing object）之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Sequence.java</span></span><br><span class="line"><span class="comment">// Holds a sequence of Objects</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(next &lt; items.length)</span><br><span class="line">            items[next++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i == items.length; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> items[i]; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(i &lt; items.length) i++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            sequence.add(Integer.toString(i));</span><br><span class="line">        Selector selector = sequence.selector();</span><br><span class="line">        <span class="keyword">while</span>(!selector.end()) &#123;</span><br><span class="line">            System.out.print(selector.current() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            selector.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p><strong>Sequence</strong> 类只是一个固定大小的 <strong>Object</strong> 的数组，以类的形式包装了起来。可以调用 <code>add()</code> 在序列末尾增加新的 <strong>Object</strong>（只要还有空间），要获取 <strong>Sequence</strong> 中的每一个对象，可以使用 <strong>Selector</strong> 接口。这是“迭代器”设计模式的一个例子，在本书稍后的部分将更多地学习它。<strong>Selector</strong> 允许你检查序列是否到末尾了（<code>end()</code>），访问当前对象（<code>current()</code>），以及移到序列中的下一个对象（<code>next()</code>）。因为 <strong>Selector</strong> 是一个接口，所以别的类可以按它们自己的方式来实现这个接口，并且其他方法能以此接口为参数，来生成更加通用的代码。</p><p>这里，<strong>SequenceSelector</strong> 是提供 <strong>Selector</strong> 功能的 <strong>private</strong> 类。可以看到，在 <code>main()</code> 中创建了一个 <strong>Sequence</strong>，并向其中添加了一些 <strong>String</strong> 对象。然后通过调用 <code>selector()</code> 获取一个 <strong>Selector</strong>，并用它在 <strong>Sequence</strong> 中移动和选择每一个元素。<br>最初看到 <strong>SequenceSelector</strong>，可能会觉得它只不过是另一个内部类罢了。但请仔细观察它，注意方法 <code>end()</code>，<code>current()</code> 和 <code>next()</code> 都用到了 <strong>items</strong>，这是一个引用，它并不是 <strong>SequenceSelector</strong> 的一部分，而是外围类中的一个 <strong>private</strong> 字段。然而内部类可以访问其外围类的方法和字段，就像自己拥有它们似的，这带来了很大的方便，就如前面的例子所示。</p><p>所以内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节，但你现在可以看到：内部类的对象只能在与其外围类的对象相关联的情况下才能被创建（就像你应该看到的，内部类是非 <strong>static</strong> 类时）。构建内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。不过绝大多数时候这都无需程序员操心。</p><h2 id="使用-this-和-new"><a href="#使用-this-和-new" class="headerlink" title="使用 .this 和 .new"></a>使用 .this 和 .new</h2><p>如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 <strong>this</strong>。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。下面的示例展示了如何使用 <strong>.this</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/DotThis.java</span></span><br><span class="line"><span class="comment">// Accessing the outer-class object</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">        DotThis.Inner dti = dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DotThis.f()</span><br></pre></td></tr></table></figure><p>有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在 <strong>new</strong> 表达式中提供对其他外部类对象的引用，这是需要使用 <strong>.new</strong> 语法，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/DotNew.java</span></span><br><span class="line"><span class="comment">// Creating an inner class directly using .new syntax</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner dni = dn.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字 <strong>DotNew</strong>，而是必须使用外部类的对象来创建该内部类对象，就像在上面的程序中所看到的那样。这也解决了内部类名字作用域的问题，因此你不必声明（实际上你不能声明）dn.new DotNew.Inner。</p><p>下面你可以看到将 <strong>.new</strong> 应用于 Parcel 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel3.java</span></span><br><span class="line"><span class="comment">// Using .new to create instances of inner classes</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel3</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        Destination(String whereTo) &#123; label = whereTo; &#125;</span><br><span class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel3 p = <span class="keyword">new</span> Parcel3();</span><br><span class="line">        <span class="comment">// Must use instance of outer class</span></span><br><span class="line">        <span class="comment">// to create an instance of the inner class:</span></span><br><span class="line">        Parcel3.Contents c = p.n<span class="function">ew <span class="title">Contents</span><span class="params">()</span></span>;</span><br><span class="line">        Parcel3.Destination d =</span><br><span class="line">                p.n<span class="function">ew <span class="title">Destination</span><span class="params">(<span class="string">&quot;Tasmania&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。</p><h2 id="内部类与向上转型"><a href="#内部类与向上转型" class="headerlink" title="内部类与向上转型"></a>内部类与向上转型</h2><p>当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。）这是因为此内部类-某个接口的实现-能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。</p><p>我们可以创建前一个示例的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Destination.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Contents.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <strong>Contents</strong> 和 <strong>Destination</strong> 表示客户端程序员可用的接口。记住，接口的所有成员自动被设置为 <strong>public</strong>。</p><p>当取得了一个指向基类或接口的引用时，甚至可能无法找出它确切的类型，看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/TestParcel.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel4 p = <span class="keyword">new</span> Parcel4();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">        <span class="comment">// Illegal -- can&#x27;t access private class:</span></span><br><span class="line">        <span class="comment">//- Parcel4.PContents pc = p.new PContents();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>Parcel4</strong> 中，内部类 <strong>PContents</strong> 是 <strong>private</strong>，所以除了 <strong>Parcel4</strong>，没有人能访问它。普通（非内部）类的访问权限不能被设为 <strong>private</strong> 或者 <strong>protected</strong>；他们只能设置为 <strong>public</strong> 或 <strong>package</strong> 访问权限。</p><p><strong>PDestination</strong> 是 <strong>protected</strong>，所以只有 <strong>Parcel4</strong> 及其子类、还有与 <strong>Parcel4</strong> 同一个包中的类（因为 <strong>protected</strong> 也给予了包访问权）能访问 <strong>PDestination</strong>，其他类都不能访问 <strong>PDestination</strong>，这意味着，如果客户端程序员想了解或访问这些成员，那是要受到限制的。实际上，甚至不能向下转型成 <strong>private</strong> 内部类（或 <strong>protected</strong> 内部类，除非是继承自它的子类），因为不能访问其名字，就像在 <strong>TestParcel</strong> 类中看到的那样。</p><p><strong>private</strong> 内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。此外，从客户端程序员的角度来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给 Java 编译器提供了生成高效代码的机会。</p><h2 id="内部类方法和作用域"><a href="#内部类方法和作用域" class="headerlink" title="内部类方法和作用域"></a>内部类方法和作用域</h2><p>到目前为止，读者所看到的只是内部类的典型用途。通常，如果所读、写的代码包含了内部类，那么它们都是“平凡的”内部类，简单并且容易理解。然而，内部类的语法覆盖了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任意的作用域内定义内部类。</p><p>这么做有两个理由：</p><ol><li>如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。</li><li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</li></ol><p>在后面的例子中，先前的代码将被修改，以用来实现：</p><ol><li>一个定义在方法中的类。</li><li>一个定义在作用域内的类，此作用域在方法的内部。</li><li>一个实现了接口的匿名类。</li><li>一个匿名类，它扩展了没有默认构造器的类。</li><li>一个匿名类，它执行字段初始化。</li><li>一个匿名类，它通过实例初始化实现构造（匿名内部类不可能有构造器）。</li></ol><p>第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel5.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a method</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 p = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PDestination</strong> 类是 <code>destination()</code> 方法的一部分，而不是 <strong>Parcel5</strong> 的一部分。所以，在 <code>destination()</code> 之外不能访问 <strong>PDestination</strong>，注意出现在 <strong>return</strong> 语句中的向上转型-返回的是 <strong>Destination</strong> 的引用，它是 <strong>PDestination</strong> 的基类。当然，在 <code>destination()</code> 中定义了内部类 <strong>PDestination</strong>，并不意味着一旦 <code>dest()</code> 方法执行完毕，<strong>PDestination</strong> 就不可用了。</p><p>你可以在同一个子目录下的任意类中对某个内部类使用类标识符 <strong>PDestination</strong>，这并不会有命名冲突。</p><p>下面的例子展示了如何在任意的作用域内嵌入一个内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel6.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a scope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span> </span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">&quot;slip&quot;</span>);</span><br><span class="line">            String s = ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Can&#x27;t use it here! Out of scope:</span></span><br><span class="line">        <span class="comment">//- TrackingSlip ts = new TrackingSlip(&quot;x&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span> </span>&#123; internalTracking(<span class="keyword">true</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel6 p = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TrackingSlip</strong> 类被嵌入在 <strong>if</strong> 语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义 <strong>Trackingslip</strong> 的作用域之外，它是不可用的，除此之外，它与普通的类一样。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>下面的例子看起来有点奇怪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel7.java</span></span><br><span class="line"><span class="comment">// Returning an instance of an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123; <span class="comment">// Insert class definition</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">        &#125;; <span class="comment">// Semicolon required</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7 p = <span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>contents()</code> 方法将返回值的生成与表示这个返回值的类的定义结合在一起！另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个 <strong>Contents</strong> 对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义。</p><p>这种奇怪的语法指的是：“创建一个继承自 <strong>Contents</strong> 的匿名类的对象。”通过 <strong>new</strong> 表达式返回的引用被自动向上转型为对 <strong>Contents</strong> 的引用。上述匿名内部类的语法是下述形式的简化形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel7b.java</span></span><br><span class="line"><span class="comment">// Expanded version of Parcel7.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyContents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7b p = <span class="keyword">new</span> Parcel7b();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个匿名内部类中，使用了默认的构造器来生成 <strong>Contents</strong>。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel8.java</span></span><br><span class="line"><span class="comment">// Calling the base-class constructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Base constructor call:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123; <span class="comment">// [1]</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// [2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel8 p = <span class="keyword">new</span> Parcel8();</span><br><span class="line">        Wrapping w = p.wrapping(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>[1] 将合适的参数传递给基类的构造器。</li><li>[2] 在匿名内部类末尾的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的地方使用的分号是一致的。</li></ul><p>尽管 <strong>Wrapping</strong> 只是一个具有具体实现的普通类，但它还是被导出类当作公共“接口”来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Wrapping.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; i = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了多样性，<strong>Wrapping</strong> 拥有一个要求传递一个参数的构造器。</p><p>在匿名类中定义字段时，还能够对其执行初始化操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel9.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel9</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Argument must be final or &quot;effectively final&quot;</span></span><br><span class="line">    <span class="comment">// to use within the anonymous inner class:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel9 p = <span class="keyword">new</span> Parcel9();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是 <strong>final</strong> 的（也就是说，它在初始化后不会改变，所以可以被当作 <strong>final</strong>），就像你在 <code>destination()</code> 的参数中看到的那样。这里省略掉 <strong>final</strong> 也没问题，但是通常最好加上 <strong>final</strong> 作为一种暗示。</p><p>如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/AnonymousConstructor.java</span></span><br><span class="line"><span class="comment">// Creating a constructor for an anonymous inner class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    Base(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor, i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(i) &#123;</span><br><span class="line">            &#123; System.out.println(</span><br><span class="line">                    <span class="string">&quot;Inside instance initializer&quot;</span>); &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;In anonymous f()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = getBase(<span class="number">47</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor, i = 47</span><br><span class="line">Inside instance initializer</span><br><span class="line">In anonymous f()</span><br></pre></td></tr></table></figure><p>在此例中，不要求变量一定是 <strong>final</strong> 的。因为被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。</p><p>下例是带实例初始化的”parcel”形式。注意 <code>destination()</code> 的参数必须是 <strong>final</strong> 的，因为它们是在匿名类内部使用的（译者注：即使不加 <strong>final</strong>, Java 8 的编译器也会为我们自动加上 <strong>final</strong>，以保证数据的一致性）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel10.java</span></span><br><span class="line"><span class="comment">// Using &quot;instance initialization&quot; to perform</span></span><br><span class="line"><span class="comment">// construction on an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination</span></span><br><span class="line"><span class="function">    <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            <span class="comment">// Instance initialization for each object:</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">                    System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel10 p = <span class="keyword">new</span> Parcel10();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Over budget!</span><br></pre></td></tr></table></figure><p>在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是 <strong>if</strong> 语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制-你不能重载实例初始化方法，所以你仅有一个这样的构造器。</p><p>匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为 <strong>static</strong>，这通常称为嵌套类。想要理解 <strong>static</strong> 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p><ol><li>要创建嵌套类的对象，并不需要其外围类的对象。</li><li>不能从嵌套类的对象中访问非静态的外围类对象。</li></ol><p>嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 <strong>static</strong> 数据和 <strong>static</strong> 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel11.java</span></span><br><span class="line"><span class="comment">// Nested classes (static inner classes)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel11</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ParcelDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        <span class="comment">// Nested classes can contain other static elements:</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelContents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Contents c = contents();</span><br><span class="line">        Destination d = destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 中，没有任何 <strong>Parcel11</strong> 的对象是必需的；而是使用选取 <strong>static</strong> 成员的普通语法来调用方法-这些方法返回对 <strong>Contents</strong> 和 <strong>Destination</strong> 的引用。</p><p>就像你在本章前面看到的那样，在一个普通的（非 <strong>static</strong>）内部类中，通过一个特殊的 <strong>this</strong> 引用可以链接到其外围类对象。嵌套类就没有这个特殊的 <strong>this</strong> 引用，这使得它类似于一个 <strong>static</strong> 方法。</p><h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3><p>嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 <strong>public</strong> 和 <strong>static</strong> 的。因为类是 <strong>static</strong> 的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现其外围接口，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/ClassInInterface.java</span></span><br><span class="line"><span class="comment">// &#123;java ClassInInterface$Test&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Howdy!</span><br></pre></td></tr></table></figure><p>如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。</p><p>我曾在本书中建议过，在每个类中都写一个 <code>main()</code> 方法，用来测试这个类。这样做有一个缺点，那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/TestBed.java</span></span><br><span class="line"><span class="comment">// Putting test code in a nested class</span></span><br><span class="line"><span class="comment">// &#123;java TestBed$Tester&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;f()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            TestBed t = <span class="keyword">new</span> TestBed();</span><br><span class="line">            t.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f()</span><br></pre></td></tr></table></figure><p>这生成了一个独立的类 <strong>TestBed$Tester</strong>（要运行这个程序，执行 <strong>java TestBed$Tester</strong>，在 Unix/Linux 系统中需要转义 <strong>$</strong>）。你可以使用这个类测试，但是不必在发布的产品中包含它，可以在打包产品前删除 <strong>TestBed$Tester.class</strong>。</p><h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外围类的所有成员，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiNestingAccess.java</span></span><br><span class="line"><span class="comment">// Nested classes can access all members of all</span></span><br><span class="line"><span class="comment">// levels of the classes they are nested within</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                g();</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiNestingAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MNA mna = <span class="keyword">new</span> MNA();</span><br><span class="line">        MNA.A mnaa = mna.n<span class="function">ew <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        MNA.A.B mnaab = mnaa.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        mnaab.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <strong>MNA.A.B</strong> 中，调用方法 <code>g()</code> 和 <code>f()</code> 不需要任何条件（即使它们被定义为 <strong>private</strong>）。这个例子同时展示了如何从不同的类里创建多层嵌套的内部类对象的基本语法。”<strong>.new</strong>“语法能产生正确的作用域，所以不必在调用构造器时限定类名。</p><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>至此，我们已经看到了许多描述内部类的语法和语义，但是这并不能同答“为什么需要内部类”这个问题。那么，Java 设计者们为什么会如此费心地增加这项基本的语言特性呢？</p><p>一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。</p><p>内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外围类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：</p><blockquote><p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p></blockquote><p>如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。</p><p>为了看到更多的细节，让我们考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择；使用单一类，或者使用内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/mui/MultiInterfaces.java</span></span><br><span class="line"><span class="comment">// Two ways a class can implement multiple interfaces</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.mui.MultiInterfaces&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses.mui;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">makeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Anonymous inner class:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X x = <span class="keyword">new</span> X();</span><br><span class="line">        Y y = <span class="keyword">new</span> Y();</span><br><span class="line">        takesA(x);</span><br><span class="line">        takesA(y);</span><br><span class="line">        takesB(x);</span><br><span class="line">        takesB(y.makeB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这里假设在两种方式下的代码结构都确实有逻辑意义。然而遇到问题的时候，通常问题本身就能给出某些指引，告诉你是应该使用单一类，还是使用内部类。但如果没有任何其他限制，从实现的观点来看，前面的例子并没有什么区别，它们都能正常运作。</p><p>如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiImplementation.java</span></span><br><span class="line"><span class="comment">// For concrete or abstract classes, inner classes</span></span><br><span class="line"><span class="comment">// produce &quot;multiple implementation inheritance&quot;</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.MultiImplementation&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">makeE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> E() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiImplementation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesD</span><span class="params">(D d)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesE</span><span class="params">(E e)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Z z = <span class="keyword">new</span> Z();</span><br><span class="line">        takesD(z);</span><br><span class="line">        takesE(z.makeE());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：</p><ol><li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。</li><li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。<br>稍后就会展示一个这样的例子。</li><li>创建内部类对象的时刻并不依赖于外围类对象的创建</li><li>内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。</li></ol><p>举个例子，如果 <strong>Sequence.java</strong> 不使用内部类，就必须声明”<strong>Sequence</strong> 是一个 <strong>Selector</strong>“，对于某个特定的 <strong>Sequence</strong> 只能有一个 <strong>Selector</strong>，然而使用内部类很容易就能拥有另一个方法 <code>reverseSelector()</code>，用它来生成一个反方向遍历序列的 <strong>Selector</strong>，只有内部类才有这种灵活性。</p><h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3><p>闭包（<strong>closure</strong>）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 <strong>private</strong> 成员。</p><p>在 Java 8 之前，生成闭包行为的唯一方式就是内部类。在 Java 8 之后，我们可以使用 lambda 表达式来生成闭包行为，并且语法更加精细和简洁；你将会在 <a href>函数式编程 </a> 这一章节中学习相关细节。即使应该优先使用 lambda 表达式用于内部类闭包，你依旧会看到那些 Java 8 以前的代码，即使用内部类来表示闭包的方式，所以非常有必要来理解这种形式。</p><p>Java 最引人争议的问题之一就是，人们认为 Java 应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java 更小心仔细，所以没有在语言中包括指针。</p><p>通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。见下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Callbacks.java</span></span><br><span class="line"><span class="comment">// Using inner classes for callbacks</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.Callbacks&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Very simple to just implement the interface:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span> </span>&#123; mi.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If your class must implement increment() in</span></span><br><span class="line"><span class="comment">// some other way, you must use an inner class:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise</span></span><br><span class="line">            <span class="comment">// you&#x27;ll get an infinite recursion:</span></span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; callbackReference.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee1 c1 = <span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2 = <span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2 =</span><br><span class="line">                <span class="keyword">new</span> Caller(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Other operation</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Other operation</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Other operation</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>这个例子进一步展示了外围类实现一个接口与内部类实现此接口之间的区别。就代码而言，<strong>Calleel</strong> 是更简单的解决方式。<strong>Callee2</strong> 继承自 <strong>MyIncrement</strong>，后者已经有了一个不同的 <code>increment()</code> 方法，并且与 <strong>Incrementable</strong> 接口期望的 <code>increment()</code> 方法完全不相关。所以如果 <strong>Callee2</strong> 继承了 <strong>MyIncrement</strong>，就不能为了 <strong>Incrementable</strong> 的用途而覆盖 <code>increment()</code> 方法，于是只能使用内部类独立地实现 <strong>Incrementable</strong>，还要注意，当创建了一个内部类时，并没有在外围类的接口中添加东西，也没有修改外围类的接口。</p><p>注意，在 <strong>Callee2</strong> 中除了 <code>getCallbackReference()</code> 以外，其他成员都是 <strong>private</strong> 的。要想建立与外部世界的任何连接，接口 <strong>Incrementable</strong> 都是必需的。在这里可以看到，<strong>interface</strong> 是如何允许接口与接口的实现完全独立的。<br>内部类 <strong>Closure</strong> 实现了 <strong>Incrementable</strong>，以提供一个返回 <strong>Callee2</strong> 的“钩子”（hook）-而且是一个安全的钩子。无论谁获得此 <strong>Incrementable</strong> 的引用，都只能调用 <code>increment()</code>，除此之外没有其他功能（不像指针那样，允许你做很多事情）。</p><p><strong>Caller</strong> 的构造器需要一个 <strong>Incrementable</strong> 的引用作为参数（虽然可以在任意时刻捕获回调引用），然后在以后的某个时刻，<strong>Caller</strong> 对象可以使用此引用回调 <strong>Callee</strong> 类。</p><p>回调的价值在于它的灵活性-可以在运行时动态地决定需要调用什么方法。例如，在图形界面实现 GUI 功能的时候，到处都用到回调。</p><h3 id="内部类与控制框架"><a href="#内部类与控制框架" class="headerlink" title="内部类与控制框架"></a>内部类与控制框架</h3><p>在将要介绍的控制框架（control framework）中，可以看到更多使用内部类的具体例子。</p><p>应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题。这是设计模式中模板方法的一个例子，模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。</p><p>控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作<em>事件驱动</em>系统。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动的系统。</p><p>要理解内部类是如何允许简单的创建过程以及如何使用控制框架的，请考虑这样一个控制框架，它的工作就是在事件“就绪”的时候执行事件。虽然“就绪”可以指任何事，但在本例中是指基于时间触发的事件。接下来的问题就是，对于要控制什么，控制框架并不包含任何具体的信息。那些信息是在实现算法的 <code>action()</code> 部分时，通过继承来提供的。</p><p>首先，接口描述了要控制的事件。因为其默认的行为是基于时间去执行控制，所以使用抽象类代替实际的接口。下面的例子包含了某些实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/controller/Event.java</span></span><br><span class="line"><span class="comment">// The common methods for any control event</span></span><br><span class="line"><span class="keyword">package</span> innerclasses.controller;</span><br><span class="line"><span class="keyword">import</span> java.time.*; <span class="comment">// Java 8 time classes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Instant eventTime;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Duration delayTime;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(<span class="keyword">long</span> millisecondDelay)</span> </span>&#123;</span><br><span class="line">        delayTime = Duration.ofMillis(millisecondDelay);</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="comment">// Allows restarting</span></span><br><span class="line">        eventTime = Instant.now().plus(delayTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.now().isAfter(eventTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当希望运行 <strong>Event</strong> 并随后调用 <code>start()</code> 时，那么构造器就会捕获（从对象创建的时刻开始的）时间，此时间是这样得来的：<code>start()</code> 获取当前时间，然后加上一个延迟时间，这样生成触发事件的时间。<code>start()</code> 是一个独立的方法，而没有包含在构造器内，因为这样就可以在事件运行以后重新启动计时器，也就是能够重复使用 <strong>Event</strong> 对象。例如，如果想要重复一个事件，只需简单地在 <code>action()</code> 中调用 <code>start()</code> 方法。</p><p><code>ready()</code> 告诉你何时可以运行 <code>action()</code> 方法了。当然，可以在派生类中覆盖 <code>ready()</code> 方法，使得 <strong>Event</strong> 能够基于时间以外的其他因素而触发。</p><p>下面的文件包含了一个用来管理并触发事件的实际控制框架。<strong>Event</strong> 对象被保存在 <strong>List</strong>\&lt;<strong>Event</strong>> 类型（读作“Event 的列表”）的容器对象中，容器会在 <a href>集合 </a> 中详细介绍。目前读者只需要知道 <code>add()</code> 方法用来将一个 <strong>Event</strong> 添加到 <strong>List</strong> 的尾端，<code>size()</code> 方法用来得到 <strong>List</strong> 中元素的个数，foreach 语法用来连续获联 <strong>List</strong> 中的 <strong>Event</strong>，<code>remove()</code> 方法用来从 <strong>List</strong> 中移除指定的 <strong>Event</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/controller/Controller.java</span></span><br><span class="line"><span class="comment">// The reusable framework for control systems</span></span><br><span class="line"><span class="keyword">package</span> innerclasses.controller;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A class from java.util to hold Event objects:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; eventList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEvent</span><span class="params">(Event c)</span> </span>&#123; eventList.add(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(eventList.size() &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// Make a copy so you&#x27;re not modifying the list</span></span><br><span class="line">            <span class="comment">// while you&#x27;re selecting the elements in it:</span></span><br><span class="line">            <span class="keyword">for</span>(Event e : <span class="keyword">new</span> ArrayList&lt;&gt;(eventList))</span><br><span class="line">                <span class="keyword">if</span>(e.ready()) &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                    e.action();</span><br><span class="line">                    eventList.remove(e);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run()</code> 方法循环遍历 <strong>eventList</strong>，寻找就绪的（<code>ready()</code>）、要运行的 <strong>Event</strong> 对象。对找到的每一个就绪的（<code>ready()</code>）事件，使用对象的 <code>toString()</code> 打印其信息，调用其 <code>action()</code> 方法，然后从列表中移除此 <strong>Event</strong>。</p><p>注意，在目前的设计中你并不知道 <strong>Event</strong> 到底做了什么。这正是此设计的关键所在—“使变化的事物与不变的事物相互分离”。用我的话说，“变化向量”就是各种不同的 <strong>Event</strong> 对象所具有的不同行为，而你通过创建不同的 <strong>Event</strong> 子类来表现不同的行为。</p><p>这正是内部类要做的事情，内部类允许：</p><ol><li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的 <code>action()</code>。</li><li>内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。</li></ol><p>考虑此控制框架的一个特定实现，如控制温室的运作：控制灯光、水、温度调节器的开关，以及响铃和重新启动系统，每个行为都是完全不同的。控制框架的设计使得分离这些不同的代码变得非常容易。使用内部类，可以在单一的类里面产生对同一个基类 <strong>Event</strong> 的多种派生版本。对于温室系统的每一种行为，都继承创建一个新的 <strong>Event</strong> 内部类，并在要实现的 <code>action()</code> 中编写控制代码。</p><p>作为典型的应用程序框架，<strong>GreenhouseControls</strong> 类继承自 <strong>Controller</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/GreenhouseControls.java</span></span><br><span class="line"><span class="comment">// This produces a specific application of the</span></span><br><span class="line"><span class="comment">// control system, all in a single class. Inner</span></span><br><span class="line"><span class="comment">// classes allow you to encapsulate different</span></span><br><span class="line"><span class="comment">// functionality for each type of event.</span></span><br><span class="line"><span class="keyword">import</span> innerclasses.controller.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseControls</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> light = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOn</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LightOn</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here to</span></span><br><span class="line">            <span class="comment">// physically turn on the light.</span></span><br><span class="line">            light = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Light is on&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOff</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LightOff</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here to</span></span><br><span class="line">            <span class="comment">// physically turn off the light.</span></span><br><span class="line">            light = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Light is off&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> water = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterOn</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WaterOn</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here.</span></span><br><span class="line">            water = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Greenhouse water is on&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterOff</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WaterOff</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here.</span></span><br><span class="line">            water = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Greenhouse water is off&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String thermostat = <span class="string">&quot;Day&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThermostatNight</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThermostatNight</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here.</span></span><br><span class="line">            thermostat = <span class="string">&quot;Night&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Thermostat on night setting&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThermostatDay</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThermostatDay</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here.</span></span><br><span class="line">            thermostat = <span class="string">&quot;Day&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Thermostat on day setting&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// An example of an action() that inserts a</span></span><br><span class="line">    <span class="comment">// new one of itself into the event list:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bell</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bell</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            addEvent(<span class="keyword">new</span> Bell(delayTime.toMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bing!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restart</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Event[] eventList;</span><br><span class="line">        <span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function">        <span class="title">Restart</span><span class="params">(<span class="keyword">long</span> delayTime, Event[] eventList)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">            <span class="keyword">this</span>.eventList = eventList;</span><br><span class="line">            <span class="keyword">for</span>(Event e : eventList)</span><br><span class="line">                addEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(Event e : eventList) &#123;</span><br><span class="line">                e.start(); <span class="comment">// Rerun each event</span></span><br><span class="line">                addEvent(e);</span><br><span class="line">            &#125;</span><br><span class="line">            start(); <span class="comment">// Rerun this Event</span></span><br><span class="line">            addEvent(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Restarting system&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Terminate</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Terminate</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123; System.exit(<span class="number">0</span>); &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Terminating&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>light</strong>，<strong>water</strong> 和 <strong>thermostat</strong> 都属于外围类 <strong>GreenhouseControls</strong>，而这些内部类能够自由地访问那些字段，无需限定条件或特殊许可。而且，<code>action()</code> 方法通常都涉及对某种硬件的控制。</p><p>大多数 <strong>Event</strong> 类看起来都很相似，但是 <strong>Bell</strong> 和 <strong>Restart</strong> 则比较特别。<strong>Bell</strong> 控制响铃，然后在事件列表中增加一个 <strong>Bell</strong> 对象，于是过一会儿它可以再次响铃。读者可能注意到了内部类是多么像多重继承：<strong>Bell</strong> 和 <strong>Restart</strong> 有 <strong>Event</strong> 的所有方法，并且似乎也拥有外围类 <strong>GreenhouseContrlos</strong> 的所有方法。</p><p>一个由 <strong>Event</strong> 对象组成的数组被递交给 <strong>Restart</strong>，该数组要加到控制器上。由于 <code>Restart()</code> 也是一个 <strong>Event</strong> 对象，所以同样可以将 <strong>Restart</strong> 对象添加到 <code>Restart.action()</code> 中，以使系统能够有规律地重新启动自己。</p><p>下面的类通过创建一个 <strong>GreenhouseControls</strong> 对象，并添加各种不同的 <strong>Event</strong> 对象来配置该系统，这是命令设计模式的一个例子—<strong>eventList</strong> 中的每个对象都被封装成对象的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/GreenhouseController.java</span></span><br><span class="line"><span class="comment">// Configure and execute the greenhouse system</span></span><br><span class="line"><span class="keyword">import</span> innerclasses.controller.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GreenhouseControls gc = <span class="keyword">new</span> GreenhouseControls();</span><br><span class="line">        <span class="comment">// Instead of using code, you could parse</span></span><br><span class="line">        <span class="comment">// configuration information from a text file:</span></span><br><span class="line">        gc.addEvent(gc.n<span class="function">ew <span class="title">Bell</span><span class="params">(<span class="number">900</span>)</span>)</span>;</span><br><span class="line">        Event[] eventList = &#123;</span><br><span class="line">                gc.n<span class="function">ew <span class="title">ThermostatNight</span><span class="params">(<span class="number">0</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">LightOn</span><span class="params">(<span class="number">200</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">LightOff</span><span class="params">(<span class="number">400</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">WaterOn</span><span class="params">(<span class="number">600</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">WaterOff</span><span class="params">(<span class="number">800</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">ThermostatDay</span><span class="params">(<span class="number">1400</span>)</span></span></span><br><span class="line"><span class="function">        &#125;</span>;</span><br><span class="line">        gc.addEvent(gc.n<span class="function">ew <span class="title">Restart</span><span class="params">(<span class="number">2000</span>, eventList)</span>)</span>;</span><br><span class="line">        gc.addEvent(</span><br><span class="line">                <span class="keyword">new</span> GreenhouseControls.Terminate(<span class="number">5000</span>));</span><br><span class="line">        gc.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Thermostat on night setting</span><br><span class="line">Light is on</span><br><span class="line">Light is off</span><br><span class="line">Greenhouse water is on</span><br><span class="line">Greenhouse water is off</span><br><span class="line">Bing!</span><br><span class="line">Thermostat on day setting</span><br><span class="line">Bing!</span><br><span class="line">Restarting system</span><br><span class="line">Thermostat on night setting</span><br><span class="line">Light is on</span><br><span class="line">Light is off</span><br><span class="line">Greenhouse water is on</span><br><span class="line">Bing!</span><br><span class="line">Greenhouse water is off</span><br><span class="line">Thermostat on day setting</span><br><span class="line">Bing!</span><br><span class="line">Restarting system</span><br><span class="line">Thermostat on night setting</span><br><span class="line">Light is on</span><br><span class="line">Light is off</span><br><span class="line">Bing!</span><br><span class="line">Greenhouse water is on</span><br><span class="line">Greenhouse water is off</span><br><span class="line">Terminating</span><br></pre></td></tr></table></figure><p>这个类的作用是初始化系统，所以它添加了所有相应的事件。<strong>Restart</strong> 事件反复运行，而且它每次都会将 <strong>eventList</strong> 加载到 <strong>GreenhouseControls</strong> 对象中。如果提供了命令行参数，系统会以它作为毫秒数，决定什么时候终止程序（这是测试程序时使用的）。</p><p>当然，更灵活的方法是避免对事件进行硬编码。</p><p>这个例子应该使读者更了解内部类的价值了，特别是在控制框架中使用内部类的时候。</p><h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><p>因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在干，那个指向外围类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/InheritInner.java</span></span><br><span class="line"><span class="comment">// Inheriting an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//- InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>InheritInner</strong> 只继承自内部类，而不是外围类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外围类对象的引用。此外，必须在构造器内使用如下语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enclosingClassReference.<span class="keyword">super</span>();</span><br></pre></td></tr></table></figure><p>这样才提供了必要的引用，然后程序才能编译通过。</p><h2 id="内部类可以被覆盖么？"><a href="#内部类可以被覆盖么？" class="headerlink" title="内部类可以被覆盖么？"></a>内部类可以被覆盖么？</h2><p>如果创建了一个内部类，然后继承其外围类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？这看起来似乎是个很有用的思想，但是“覆盖”内部类就好像它是外围类的一个方法，其实并不起什么作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg.java</span></span><br><span class="line"><span class="comment">// An inner class cannot be overridden like a method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Egg() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">        y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New Egg()</span><br><span class="line">Egg.Yolk()</span><br></pre></td></tr></table></figure><p>默认的无参构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了 <strong>BigEgg</strong> 的对象，那么所使用的应该是“覆盖后”的 <strong>Yolk</strong> 版本，但从输出中可以看到实际情况并不是这样的。</p><p>这个例子说明，当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg2.java</span></span><br><span class="line"><span class="comment">// Proper inheritance of an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Yolk y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    Egg2() &#123; System.out.println(<span class="string">&quot;New Egg2()&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span> </span>&#123; y = yy; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; y.f(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg2</span> <span class="keyword">extends</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg2</span>.<span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigEgg2</span><span class="params">()</span> </span>&#123; insertYolk(<span class="keyword">new</span> Yolk()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Egg2 e2 = <span class="keyword">new</span> BigEgg2();</span><br><span class="line">        e2.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Egg2.Yolk()</span><br><span class="line">New Egg2()</span><br><span class="line">Egg2.Yolk()</span><br><span class="line">BigEgg2.Yolk()</span><br><span class="line">BigEgg2.Yolk.f()</span><br></pre></td></tr></table></figure><p>现在 <strong>BigEgg2.Yolk</strong> 通过 <strong>extends Egg2.Yolk</strong> 明确地继承了此内部类，并且覆盖了其中的方法。<code>insertYolk()</code> 方法允许 <strong>BigEgg2</strong> 将它自己的 <strong>Yolk</strong> 对象向上转型为 <strong>Egg2</strong> 中的引用 <strong>y</strong>。所以当 <code>g()</code> 调用 <code>y.f()</code> 时，覆盖后的新版的 <code>f()</code> 被执行。第二次调用 <code>Egg2.Yolk()</code>，结果是 <strong>BigEgg2.Yolk</strong> 的构造器调用了其基类的构造器。可以看到在调用 <code>g()</code> 的时候，新版的 <code>f()</code> 被调用了。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/LocalInnerClass.java</span></span><br><span class="line"><span class="comment">// Holds a sequence of Objects</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A local inner class:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">            LocalCounter() &#123;</span><br><span class="line">                <span class="comment">// Local inner class can have a constructor</span></span><br><span class="line">                System.out.println(<span class="string">&quot;LocalCounter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Repeat, but with an anonymous inner class:</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            <span class="comment">// Anonymous inner class cannot have a named</span></span><br><span class="line">            <span class="comment">// constructor, only an instance initializer:</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Counter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">        Counter</span><br><span class="line">                c1 = lic.getCounter(<span class="string">&quot;Local inner &quot;</span>),</span><br><span class="line">                c2 = lic.getCounter2(<span class="string">&quot;Anonymous inner &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c1.next());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c2.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalCounter()</span><br><span class="line">Counter()</span><br><span class="line">Local inner 0</span><br><span class="line">Local inner 1</span><br><span class="line">Local inner 2</span><br><span class="line">Local inner 3</span><br><span class="line">Local inner 4</span><br><span class="line">Anonymous inner 5</span><br><span class="line">Anonymous inner 6</span><br><span class="line">Anonymous inner 7</span><br><span class="line">Anonymous inner 8</span><br><span class="line">Anonymous inner 9</span><br></pre></td></tr></table></figure><p><strong>Counter</strong> 返回的是序列中的下一个值。我们分别使用局部内部类和匿名内部类实现了这个功能，它们具有相同的行为和能力，既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。</p><p>所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。</p><h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>由于编译后每个类都会产生一个<strong>.class</strong> 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个”meta-class”，叫做 <strong>Class</strong> 对象）。</p><p>你可能猜到了，内部类也必须生成一个<strong>.class</strong> 文件以包含它们的 <strong>Class</strong> 对象信息。这些类文件的命名有严格的规则：外围类的名字，加上“<strong>$</strong>“，再加上内部类的名字。例如，<strong>LocalInnerClass.java</strong> 生成的 <strong>.class</strong> 文件包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter.class</span><br><span class="line">LocalInnerClass$<span class="number">1.</span>class</span><br><span class="line">LocalInnerClass$1LocalCounter.class</span><br><span class="line">LocalInnerClass.class</span><br></pre></td></tr></table></figure><p>如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外围类标识符与“<strong>$</strong>”的后面。</p><p>虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是 java 的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java 编译器会尽可能地转换它们。）</p><h2 id="本章小结-9"><a href="#本章小结-9" class="headerlink" title="本章小结"></a>本章小结</h2><p>比起面向对象编程中其他的概念来，接口和内部类更深奥复杂，比如 C++ 就没有这些。将两者结合起来，同样能够解决 C++ 中的用多重继承所能解决的问题。然而，多重继承在 C++ 中被证明是相当难以使用的，相比较而言，Java 的接口和内部类就容易理解多了。</p><p>虽然这些特性本身是相当直观的，但是就像多态机制一样，这些特性的使用应该是设计阶段考虑的问题。随着时间的推移，读者将能够更好地识别什么情况下应该使用接口，什么情况使用内部类，或者两者同时使用。但此时，读者至少应该已经完全理解了它们的语法和语义。</p><p>当读者见到这些语言特性的实际应用时，就能最终理解它们了。</p><h1 id="第-12-章-集合"><a href="#第-12-章-集合" class="headerlink" title="第 12 章 集合"></a>第 12 章 集合</h1><blockquote><p>如果一个程序只包含固定数量的对象且对象的生命周期都是已知的，那么这是一个非常简单的程序。</p></blockquote><p>通常，程序总是根据运行时才知道的某些条件去创建新的对象。在此之前，无法知道所需对象的数量甚至确切类型。为了解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象。因此，不能依靠创建命名的引用来持有每一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyType aReference;</span><br></pre></td></tr></table></figure><p>因为从来不会知道实际需要多少个这样的引用。</p><p>大多数编程语言都提供了某种方法来解决这个基本问题。Java 有多种方式保存对象（确切地说，是对象的引用）。例如前边曾经学习过的数组，它是编译器支持的类型。数组是保存一组对象的最有效的方式，如果想要保存一组基本类型数据，也推荐使用数组。但是数组具有固定的大小尺寸，而且在更一般的情况下，在写程序的时候并不知道将需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制就显得太过受限了。</p><p><strong>java.util</strong> 库提供了一套相当完整的<em>集合类</em>（collection classes）来解决这个问题，其中基本的类型有 <strong>List</strong> 、 <strong>Set</strong> 、 <strong>Queue</strong> 和 <strong>Map</strong>。这些类型也被称作<em>容器类</em>（container classes），但我将使用 Java 类库使用的术语。集合提供了完善的方法来保存对象，可以使用这些工具来解决大量的问题。</p><p>集合还有一些其它特性。例如， <strong>Set</strong> 对于每个值都只保存一个对象， <strong>Map</strong> 是一个关联数组，允许将某些对象与其他对象关联起来。Java 集合类都可以自动地调整自己的大小。因此，与数组不同，在编程时，可以将任意数量的对象放置在集合中，而不用关心集合应该有多大。</p><p>尽管在 Java 中没有直接的关键字支持，<sup><a href="#fn_1" id="reffn_1">1</a></sup>但集合类仍然是可以显著增强编程能力的基本工具。在本章中，将介绍 Java 集合类库的基本知识，并重点介绍一些典型用法。这里将专注于在日常编程中使用的集合。稍后，在<a href>附录：集合主题</a>中，还将学习到其余的那些集合和相关功能，以及如何使用它们的更多详细信息。</p><h2 id="泛型和类型安全的集合"><a href="#泛型和类型安全的集合" class="headerlink" title="泛型和类型安全的集合"></a>泛型和类型安全的集合</h2><p>使用 Java 5 之前的集合的一个主要问题是编译器允许你向集合中插入不正确的类型。例如，考虑一个 <strong>Apple</strong> 对象的集合，这里使用最基本最可靠的 <strong>ArrayList</strong> 。现在，可以把 <strong>ArrayList</strong> 看作“可以自动扩充自身尺寸的数组”来看待。使用 <strong>ArrayList</strong> 相当简单：创建一个实例，用 <code>add()</code> 插入对象；然后用 <code>get()</code> 来访问这些对象，此时需要使用索引，就像数组那样，但是不需要方括号。<sup><a href="#fn_2" id="reffn_2">2</a></sup> <strong>ArrayList</strong> 还有一个 <code>size()</code> 方法，来说明集合中包含了多少个元素，所以不会不小心因数组越界而引发错误（通过抛出<em>运行时异常</em>，<a href>异常</a>章节介绍了异常）。</p><p>在本例中， <strong>Apple</strong> 和 <strong>Orange</strong> 都被放到了集合中，然后将它们取出。正常情况下，Java 编译器会给出警告，因为这个示例没有使用泛型。在这里，使用特定的注解来抑制警告信息。注解以“@”符号开头，可以带参数。这里的 <code>@SuppressWarning</code> 注解及其参数表示只抑制“unchecked”类型的警告（<a href>注解</a>章节将介绍更多有关注解的信息）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ApplesAndOrangesWithoutGenerics.java</span></span><br><span class="line"><span class="comment">// Simple collection use (suppressing compiler warnings)</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplesAndOrangesWithoutGenerics</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList apples = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="comment">// No problem adding an Orange to apples:</span></span><br><span class="line">    apples.add(<span class="keyword">new</span> Orange());</span><br><span class="line">    <span class="keyword">for</span>(Object apple : apples) &#123;</span><br><span class="line">      ((Apple) apple).id();</span><br><span class="line">      <span class="comment">// Orange is detected only at run time</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: Orange cannot be cast to</span></span><br><span class="line"><span class="comment">Apple</span></span><br><span class="line"><span class="comment">        at ApplesAndOrangesWithoutGenerics.main(ApplesA</span></span><br><span class="line"><span class="comment">ndOrangesWithoutGenerics.java:23)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Apple</strong> 和 <strong>Orange</strong> 是截然不同的，它们除了都是 <strong>Object</strong> 之外没有任何共同点（如果一个类没有显式地声明继承自哪个类，那么它就自动继承自 <strong>Object</strong>）。因为 <strong>ArrayList</strong> 保存的是 <strong>Object</strong> ，所以不仅可以通过 <strong>ArrayList</strong> 的 <code>add()</code> 方法将 <strong>Apple</strong> 对象放入这个集合，而且可以放入 <strong>Orange</strong> 对象，这无论在编译期还是运行时都不会有问题。当使用 <strong>ArrayList</strong> 的 <code>get()</code> 方法来取出你认为是 <strong>Apple</strong> 的对象时，得到的只是 <strong>Object</strong> 引用，必须将其转型为 <strong>Apple</strong>。然后需要将整个表达式用括号括起来，以便在调用 <strong>Apple</strong> 的 <code>id()</code> 方法之前，强制执行转型。否则，将会产生语法错误。</p><p>在运行时，当尝试将 <strong>Orange</strong> 对象转为 <strong>Apple</strong> 时，会出现输出中显示的错误。</p><p>在<a href>泛型</a>章节中，你将了解到使用 Java 泛型来创建类可能很复杂。但是，使用预先定义的泛型类却相当简单。例如，要定义一个用于保存 <strong>Apple</strong> 对象的 <strong>ArrayList</strong> ，只需要使用 <strong>ArrayList\<Apple\></Apple\></strong> 来代替 <strong>ArrayList</strong> 。尖括号括起来的是<em>类型参数</em>（可能会有多个），它指定了这个集合实例可以保存的类型。</p><p>通过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。<sup><a href="#fn_3" id="reffn_3">3</a></sup>下面还是这个示例，但是使用了泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ApplesAndOrangesWithGenerics.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplesAndOrangesWithGenerics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="comment">// Compile-time error:</span></span><br><span class="line">    <span class="comment">// apples.add(new Orange());</span></span><br><span class="line">    <span class="keyword">for</span>(Apple apple : apples) &#123;</span><br><span class="line">      System.out.println(apple.id());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 <strong>apples</strong> 定义的右侧，可以看到 <code>new ArrayList&lt;&gt;()</code> 。这有时被称为“菱形语法”（diamond syntax）。在 Java 7 之前，必须要在两端都进行类型声明，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br></pre></td></tr></table></figure><p>随着类型变得越来越复杂，这种重复产生的代码非常混乱且难以阅读。程序员发现所有类型信息都可以从左侧获得，因此，编译器没有理由强迫右侧再重复这些。虽然<em>类型推断</em>（type inference）只是个很小的请求，Java 语言团队仍然欣然接受并进行了改进。</p><p>有了 <strong>ArrayList</strong> 声明中的类型指定，编译器会阻止将 <strong>Orange</strong> 放入 <strong>apples</strong> ，因此，这会成为一个编译期错误而不是运行时错误。</p><p>使用泛型，从 <strong>List</strong> 中获取元素不需要强制类型转换。因为 <strong>List</strong> 知道它持有什么类型，因此当调用 <code>get()</code> 时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。</p><p>当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/GenericsAndUpcasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrannySmith</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gala</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fuji</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Braeburn</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndUpcasting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    apples.add(<span class="keyword">new</span> GrannySmith());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Gala());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Fuji());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Braeburn());</span><br><span class="line">    <span class="keyword">for</span>(Apple apple : apples)</span><br><span class="line">      System.out.println(apple);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">GrannySmith@15db9742</span></span><br><span class="line"><span class="comment">Gala@6d06d69c</span></span><br><span class="line"><span class="comment">Fuji@7852e922</span></span><br><span class="line"><span class="comment">Braeburn@4e25154f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因此，可以将 <strong>Apple</strong> 的子类型添加到被指定为保存 <strong>Apple</strong> 对象的集合中。</p><p>程序的输出是从 <strong>Object</strong> 默认的 <code>toString()</code> 方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示（这个散列码是通过 <code>hashCode()</code> 方法产生的）。将在<a href>附录：理解 equals 和 hashCode 方法</a>中了解有关散列码的内容。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java 集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：</p><ol><li><strong>集合（Collection）</strong> ：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong> 必须以插入的顺序保存元素， <strong>Set</strong> 不能包含重复元素， <strong>Queue</strong> 按照<em>排队规则</em>来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li><li><strong>映射（Map）</strong> ： 一组成对的“键值对”对象，允许使用键来查找值。 <strong>ArrayList</strong> 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 <strong>map</strong> 允许我们使用一个对象来查找另一个对象，它也被称作<em>关联数组</em>（associative array），因为它将对象和其它对象关联在一起；或者称作<em>字典</em>（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 <strong>Map</strong> 是强大的编程工具。</li></ol><p>尽管并非总是可行，但在理想情况下，你编写的大部分代码都在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个 <strong>List</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>请注意， <strong>ArrayList</strong> 已经被向上转型为了 <strong>List</strong> ，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。</p><p>这种方式并非总是有效的，因为某些具体类有额外的功能。例如， <strong>LinkedList</strong> 具有 <strong>List</strong> 接口中未包含的额外方法，而 <strong>TreeMap</strong> 也具有在 <strong>Map</strong> 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。</p><p><strong>Collection</strong> 接口概括了<em>序列</em>的概念——一种存放一组对象的方式。下面是个简单的示例，用 <strong>Integer</strong> 对象填充了一个 <strong>Collection</strong> （这里用 <strong>ArrayList</strong> 表示），然后打印集合中的每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SimpleCollection.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCollection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      c.add(i); <span class="comment">// Autoboxing</span></span><br><span class="line">    <span class="keyword">for</span>(Integer i : c)</span><br><span class="line">      System.out.print(i + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个例子仅使用了 <strong>Collection</strong> 中的方法（即 <code>add()</code> ），所以使用任何继承自 <strong>Collection</strong> 的类的对象都可以正常工作。但是 <strong>ArrayList</strong> 是最基本的序列类型。</p><p><code>add()</code> 方法的名称就表明它是在 <strong>Collection</strong> 中添加一个新元素。但是，文档中非常详细地叙述到 <code>add()</code> “要确保这个 <strong>Collection</strong> 包含指定的元素。”这是因为考虑到了 <strong>Set</strong> 的含义，因为在 <strong>Set</strong>中，只有当元素不存在时才会添加元素。在使用 <strong>ArrayList</strong> ，或任何其他类型的 <strong>List</strong> 时，<code>add()</code> 总是表示“把它放进去”，因为 <strong>List</strong> 不关心是否存在重复元素。</p><p>可以使用 <em>for-in</em> 语法来遍历所有的 <strong>Collection</strong> ，就像这里所展示的那样。在本章的后续部分，还将学习到一个更灵活的概念，<em>迭代器</em>。</p><h2 id="添加元素组"><a href="#添加元素组" class="headerlink" title="添加元素组"></a>添加元素组</h2><p>在 <strong>java.util</strong> 包中的 <strong>Arrays</strong> 和 <strong>Collections</strong> 类中都有很多实用的方法，可以在一个 <strong>Collection</strong> 中添加一组元素。</p><p><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。 <code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中。下边的示例展示了这两个方法，以及更通用的 <code>addAll()</code> 方法，所有 <strong>Collection</strong> 类型都包含该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AddingGroups.java</span></span><br><span class="line"><span class="comment">// Adding groups of elements to Collection objects</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroups</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; collection =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    Integer[] moreInts = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    collection.addAll(Arrays.asList(moreInts));</span><br><span class="line">    <span class="comment">// Runs significantly faster, but you can&#x27;t</span></span><br><span class="line">    <span class="comment">// construct a Collection this way:</span></span><br><span class="line">    Collections.addAll(collection, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>);</span><br><span class="line">    Collections.addAll(collection, moreInts);</span><br><span class="line">    <span class="comment">// Produces a list &quot;backed by&quot; an array:</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>);</span><br><span class="line">    list.set(<span class="number">1</span>, <span class="number">99</span>); <span class="comment">// OK -- modify an element</span></span><br><span class="line">    <span class="comment">// list.add(21); // Runtime error; the underlying</span></span><br><span class="line">                     <span class="comment">// array cannot be resized.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Collection</strong> 的构造器可以接受另一个 <strong>Collection</strong>，用它来将自身初始化。因此，可以使用 <code>Arrays.asList()</code> 来为这个构造器产生输入。但是， <code>Collections.addAll()</code> 运行得更快，而且很容易构建一个不包含元素的 <strong>Collection</strong> ，然后调用 <code>Collections.addAll()</code> ，因此这是首选方式。</p><p><code>Collection.addAll()</code> 方法只能接受另一个 <strong>Collection</strong> 作为参数，因此它没有 <code>Arrays.asList()</code> 或 <code>Collections.addAll()</code> 灵活。这两个方法都使用可变参数列表。</p><p>也可以直接使用 <code>Arrays.asList()</code> 的输出作为一个 <strong>List</strong> ，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 <strong>List</strong> 上调用 <code>add()</code> 或 <code>remove()</code>，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AsListInference.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Powder</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heavy</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crusty</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slush</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsListInference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Snow&gt; snow1 = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Crusty(), <span class="keyword">new</span> Slush(), <span class="keyword">new</span> Powder());</span><br><span class="line">    <span class="comment">//- snow1.add(new Heavy()); // Exception</span></span><br><span class="line"></span><br><span class="line">    List&lt;Snow&gt; snow2 = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy());</span><br><span class="line">    <span class="comment">//- snow2.add(new Slush()); // Exception</span></span><br><span class="line"></span><br><span class="line">    List&lt;Snow&gt; snow3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(snow3,</span><br><span class="line">      <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy(), <span class="keyword">new</span> Powder());</span><br><span class="line">    snow3.add(<span class="keyword">new</span> Crusty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint with explicit type argument specification:</span></span><br><span class="line">    List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList(</span><br><span class="line">       <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy(), <span class="keyword">new</span> Slush());</span><br><span class="line">    <span class="comment">//- snow4.add(new Powder()); // Exception</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>snow4</strong> 中，注意 <code>Arrays.asList()</code> 中间的“暗示”（即 <code>&lt;Snow&gt;</code> ），告诉编译器 <code>Arrays.asList()</code> 生成的结果 <strong>List</strong> 类型的实际目标类型是什么。这称为<em>显式类型参数说明</em>（explicit type argument specification）。</p><h2 id="集合的打印"><a href="#集合的打印" class="headerlink" title="集合的打印"></a>集合的打印</h2><p>必须使用 <code>Arrays.toString()</code> 来生成数组的可打印形式。但是打印集合无需任何帮助。下面是一个例子，这个例子中也介绍了基本的 Java 集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/PrintingCollections.java</span></span><br><span class="line"><span class="comment">// Collections print themselves automatically</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintingCollections</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Collection</span></span><br><span class="line"><span class="function">  <span class="title">fill</span><span class="params">(Collection&lt;String&gt; collection)</span> </span>&#123;</span><br><span class="line">    collection.add(<span class="string">&quot;rat&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> collection;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Map <span class="title">fill</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;Fuzzy&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;Rags&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;Bosco&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;Spot&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> LinkedList&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> HashSet&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> TreeSet&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> LinkedHashSet&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> HashMap&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> TreeMap&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> LinkedHashMap&lt;&gt;()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">[cat, dog, rat]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span></span><br><span class="line"><span class="comment">&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;</span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这显示了 Java 集合库中的两个主要类型。它们的区别在于集合中的每个“槽”（slot）保存的元素个数。 <strong>Collection</strong> 类型在每个槽中只能保存一个元素。此类集合包括： <strong>List</strong> ，它以特定的顺序保存一组元素； <strong>Set</strong> ，其中元素不允许重复； <strong>Queue</strong> ，只能在集合一端插入对象，并从另一端移除对象（就本例而言，这只是查看序列的另一种方式，因此并没有显示它）。 <strong>Map</strong> 在每个槽中存放了两个元素，即<em>键</em>和与之关联的<em>值</em>。</p><p>默认的打印行为，使用集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接（键在左侧，值在右侧）。</p><p>第一个 <code>fill()</code> 方法适用于所有类型的 <strong>Collection</strong> ，这些类型都实现了 <code>add()</code> 方法以添加新元素。</p><p><strong>ArrayList</strong> 和 <strong>LinkedList</strong> 都是 <strong>List</strong> 的类型，从输出中可以看出，它们都按插入顺序保存元素。两者之间的区别不仅在于执行某些类型的操作时的性能，而且 <strong>LinkedList</strong> 包含的操作多于 <strong>ArrayList</strong> 。本章后面将对这些内容进行更全面的探讨。</p><p><strong>HashSet</strong> ， <strong>TreeSet</strong> 和 <strong>LinkedHashSet</strong> 是 <strong>Set</strong> 的类型。从输出中可以看到， <strong>Set</strong> 仅保存每个相同项中的一个，并且不同的 <strong>Set</strong> 实现存储元素的方式也不同。 <strong>HashSet</strong> 使用相当复杂的方法存储元素，这在<a href>附录：集合主题</a>中进行了探讨。现在只需要知道，这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是 <strong>Set</strong> 的成员，而存储顺序并不重要）。如果存储顺序很重要，则可以使用 <strong>TreeSet</strong> ，它将按比较结果的升序保存对象）或 <strong>LinkedHashSet</strong> ，它按照被添加的先后顺序保存对象。</p><p><strong>Map</strong> （也称为<em>关联数组</em>）使用<em>键</em>来查找对象，就像一个简单的数据库。所关联的对象称为<em>值</em>。 假设有一个 <strong>Map</strong> 将美国州名与它们的首府联系在一起，如果想要俄亥俄州（Ohio）的首府，可以用“Ohio”作为键来查找，几乎就像使用数组下标一样。正是由于这种行为，对于每个键， <strong>Map</strong> 只存储一次。</p><p><code>Map.put(key, value)</code> 添加一个所想要添加的值并将它与一个键（用来查找值）相关联。 <code>Map.get(key)</code> 生成与该键相关联的值。上面的示例仅添加键值对，并没有执行查找。这将在稍后展示。</p><p>请注意，这里没有指定（或考虑） <strong>Map</strong> 的大小，因为它会自动调整大小。 此外， <strong>Map</strong> 还知道如何打印自己，它会显示相关联的键和值。</p><p>本例使用了 <strong>Map</strong> 的三种基本风格： <strong>HashMap</strong> ， <strong>TreeMap</strong> 和 <strong>LinkedHashMap</strong> 。</p><p>键和值保存在 <strong>HashMap</strong> 中的顺序不是插入顺序，因为 <strong>HashMap</strong> 实现使用了非常快速的算法来控制顺序。 <strong>TreeMap</strong> 通过比较结果的升序来保存键， <strong>LinkedHashMap</strong> 在保持 <strong>HashMap</strong> 查找速度的同时按键的插入顺序保存键。</p><h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h2><p><strong>List</strong>s 承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p><p>有两种类型的 <strong>List</strong> ：</p><ul><li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li><li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集。</li></ul><p>下面的示例导入 <strong>typeinfo.pets</strong> ，超前使用了<a href>类型信息</a>一章中的类库。这个类库包含了 <strong>Pet</strong> 类层次结构，以及用于随机生成 <strong>Pet</strong> 对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点：</p><ol><li>有一个 <strong>Pet</strong> 类，以及 <strong>Pet</strong> 的各种子类型。</li><li>静态的 <code>Pets.arrayList()</code> 方法返回一个填充了随机选取的 <strong>Pet</strong> 对象的 <strong>ArrayList</strong>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ListFeatures.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFeatures</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;1: &quot;</span> + pets);</span><br><span class="line">    Hamster h = <span class="keyword">new</span> Hamster();</span><br><span class="line">    pets.add(h); <span class="comment">// Automatically resizes</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2: &quot;</span> + pets);</span><br><span class="line">    System.out.println(<span class="string">&quot;3: &quot;</span> + pets.contains(h));</span><br><span class="line">    pets.remove(h); <span class="comment">// Remove by object</span></span><br><span class="line">    Pet p = pets.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;4: &quot;</span> +  p + <span class="string">&quot; &quot;</span> + pets.indexOf(p));</span><br><span class="line">    Pet cymric = <span class="keyword">new</span> Cymric();</span><br><span class="line">    System.out.println(<span class="string">&quot;5: &quot;</span> + pets.indexOf(cymric));</span><br><span class="line">    System.out.println(<span class="string">&quot;6: &quot;</span> + pets.remove(cymric));</span><br><span class="line">    <span class="comment">// Must be the exact object:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;7: &quot;</span> + pets.remove(p));</span><br><span class="line">    System.out.println(<span class="string">&quot;8: &quot;</span> + pets);</span><br><span class="line">    pets.add(<span class="number">3</span>, <span class="keyword">new</span> Mouse()); <span class="comment">// Insert at an index</span></span><br><span class="line">    System.out.println(<span class="string">&quot;9: &quot;</span> + pets);</span><br><span class="line">    List&lt;Pet&gt; sub = pets.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;10: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    Collections.sort(sub); <span class="comment">// In-place sort</span></span><br><span class="line">    System.out.println(<span class="string">&quot;sorted subList: &quot;</span> + sub);</span><br><span class="line">    <span class="comment">// Order is not important in containsAll():</span></span><br><span class="line">    System.out.println(<span class="string">&quot;11: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    Collections.shuffle(sub, rand); <span class="comment">// Mix it up</span></span><br><span class="line">    System.out.println(<span class="string">&quot;shuffled subList: &quot;</span> + sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;12: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    List&lt;Pet&gt; copy = <span class="keyword">new</span> ArrayList&lt;&gt;(pets);</span><br><span class="line">    sub = Arrays.asList(pets.get(<span class="number">1</span>), pets.get(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sub: &quot;</span> + sub);</span><br><span class="line">    copy.retainAll(sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;13: &quot;</span> + copy);</span><br><span class="line">    copy = <span class="keyword">new</span> ArrayList&lt;&gt;(pets); <span class="comment">// Get a fresh copy</span></span><br><span class="line">    copy.remove(<span class="number">2</span>); <span class="comment">// Remove by index</span></span><br><span class="line">    System.out.println(<span class="string">&quot;14: &quot;</span> + copy);</span><br><span class="line">    copy.removeAll(sub); <span class="comment">// Only removes exact objects</span></span><br><span class="line">    System.out.println(<span class="string">&quot;15: &quot;</span> + copy);</span><br><span class="line">    copy.set(<span class="number">1</span>, <span class="keyword">new</span> Mouse()); <span class="comment">// Replace an element</span></span><br><span class="line">    System.out.println(<span class="string">&quot;16: &quot;</span> + copy);</span><br><span class="line">    copy.addAll(<span class="number">2</span>, sub); <span class="comment">// Insert a list in the middle</span></span><br><span class="line">    System.out.println(<span class="string">&quot;17: &quot;</span> + copy);</span><br><span class="line">    System.out.println(<span class="string">&quot;18: &quot;</span> + pets.isEmpty());</span><br><span class="line">    pets.clear(); <span class="comment">// Remove all elements</span></span><br><span class="line">    System.out.println(<span class="string">&quot;19: &quot;</span> + pets);</span><br><span class="line">    System.out.println(<span class="string">&quot;20: &quot;</span> + pets.isEmpty());</span><br><span class="line">    pets.addAll(Pets.list(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;21: &quot;</span> + pets);</span><br><span class="line">    Object[] o = pets.toArray();</span><br><span class="line">    System.out.println(<span class="string">&quot;22: &quot;</span> + o[<span class="number">3</span>]);</span><br><span class="line">    Pet[] pa = pets.toArray(<span class="keyword">new</span> Pet[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;23: &quot;</span> + pa[<span class="number">3</span>].id());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]</span></span><br><span class="line"><span class="comment">3: true</span></span><br><span class="line"><span class="comment">4: Cymric 2</span></span><br><span class="line"><span class="comment">5: -1</span></span><br><span class="line"><span class="comment">6: false</span></span><br><span class="line"><span class="comment">7: true</span></span><br><span class="line"><span class="comment">8: [Rat, Manx, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">subList: [Manx, Mutt, Mouse]</span></span><br><span class="line"><span class="comment">10: true</span></span><br><span class="line"><span class="comment">sorted subList: [Manx, Mouse, Mutt]</span></span><br><span class="line"><span class="comment">11: true</span></span><br><span class="line"><span class="comment">shuffled subList: [Mouse, Manx, Mutt]</span></span><br><span class="line"><span class="comment">12: true</span></span><br><span class="line"><span class="comment">sub: [Mouse, Pug]</span></span><br><span class="line"><span class="comment">13: [Mouse, Pug]</span></span><br><span class="line"><span class="comment">14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">15: [Rat, Mutt, Cymric, Pug]</span></span><br><span class="line"><span class="comment">16: [Rat, Mouse, Cymric, Pug]</span></span><br><span class="line"><span class="comment">17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">18: false</span></span><br><span class="line"><span class="comment">19: []</span></span><br><span class="line"><span class="comment">20: true</span></span><br><span class="line"><span class="comment">21: [Manx, Cymric, Rat, EgyptianMau]</span></span><br><span class="line"><span class="comment">22: EgyptianMau</span></span><br><span class="line"><span class="comment">23: 14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>打印行都编了号，因此可从输出追溯到源代码。 第 1 行输出展示了原始的由 <strong>Pet</strong> 组成的 <strong>List</strong> 。 与数组不同， <strong>List</strong> 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。在第 2 行输出中可以看到添加一个 <strong>Hamster</strong> 的结果，该对象将被追加到列表的末尾。</p><p>可以使用 <code>contains()</code> 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 <code>remove()</code> 方法。同样，如果有一个对象的引用，可以使用 <code>indexOf()</code> 在 <strong>List</strong> 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。</p><p>当确定元素是否是属于某个 <strong>List</strong> ，寻找某个元素的索引，以及通过引用从 <strong>List</strong> 中删除元素时，都会用到 <code>equals()</code> 方法（根类 <strong>Object</strong> 的一个方法）。每个 <strong>Pet</strong> 被定义为一个唯一的对象，所以即使列表中已经有两个 <strong>Cymrics</strong> ，如果再创建一个新的 <strong>Cymric</strong> 对象并将其传递给 <code>indexOf()</code> 方法，结果仍为 <strong>-1</strong> （表示未找到），并且尝试调用 <code>remove()</code> 方法来删除这个对象将返回 <strong>false</strong> 。对于其他类， <code>equals()</code> 的定义可能有所不同。例如，如果两个 <strong>String</strong> 的内容相同，则这两个 <strong>String</strong> 相等。因此，为了防止出现意外，请务必注意 <strong>List</strong> 行为会根据 <code>equals()</code> 行为而发生变化。</p><p>第 7、8 行输出展示了删除与 <strong>List</strong> 中的对象完全匹配的对象是成功的。</p><p>可以在 <strong>List</strong> 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 <strong>LinkedList</strong> ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 <strong>ArrayList</strong> ，这可是代价高昂的操作。这是否意味着永远不应该在 <strong>ArrayList</strong> 的中间插入元素，并最好是转换为 <strong>LinkedList</strong> ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 <strong>ArrayList</strong> 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 <strong>List</strong> 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。</p><p><code>subList()</code> 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 <code>containsAll()</code> 方法时，很自然地会得到 <strong>true</strong>。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 <strong>sub</strong> 上调用直观命名的 <code>Collections.sort()</code> 和 <code>Collections.shuffle()</code> 方法，不会影响 <code>containsAll()</code> 的结果。 <code>subList()</code> 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。</p><p><code>retainAll()</code> 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 <strong>copy</strong> 和 <strong>sub</strong> 中的所有元素。请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。</p><p>第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 <code>equals()</code> 的行为。</p><p><code>removeAll()</code> 方法也是基于 <code>equals()</code> 方法运行的。 顾名思义，它会从 <strong>List</strong> 中删除在参数 <strong>List</strong> 中的所有元素。</p><p><code>set()</code> 方法的命名显得很不合时宜，因为它与 <strong>Set</strong> 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。</p><p>第 17 行输出表明，对于 <strong>List</strong> ，有一个重载的 <code>addAll()</code> 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 <strong>Collection</strong> 的 <code>addAll()</code> 方法将其追加到列表的末尾。</p><p>第 18 - 20 行输出展示了 <code>isEmpty()</code> 和 <code>clear()</code> 方法的效果。</p><p>第 22、23 行输出展示了如何使用 <code>toArray()</code> 方法将任意的 <strong>Collection</strong> 转换为数组。这是一个重载方法，其无参版本返回一个 <strong>Object</strong> 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 <strong>List</strong> 中的所有元素（就像本例一样），则 <code>toArray()</code> 会创建一个具有合适尺寸的新数组。 <strong>Pet</strong> 对象有一个 <code>id()</code> 方法，可以在所产生的数组中的对象上调用这个方法。</p><h2 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器 Iterators"></a>迭代器 Iterators</h2><p>在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 <strong>List</strong> ， <code>add()</code> 是插入元素的一种方式， <code>get()</code> 是获取元素的一种方式。</p><p>如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 <strong>List</strong> 编码的，但是后来发现如果能够将相同的代码应用于 <strong>Set</strong> 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？</p><p><em>迭代器</em>（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为<em>轻量级对象</em>（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p><ol><li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li><li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li><li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li><li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li></ol><p>为了观察它的工作方式，这里再次使用<a href>类型信息</a>章节中的 <strong>Pet</strong> 工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SimpleIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">12</span>);</span><br><span class="line">    Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// A simpler approach, when possible:</span></span><br><span class="line">    <span class="keyword">for</span>(Pet p : pets)</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// An Iterator can also remove elements:</span></span><br><span class="line">    it = pets.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>有了 <strong>Iterator</strong> ，就不必再为集合中元素的数量操心了。这是由 <code>hasNext()</code> 和 <code>next()</code> 关心的事情。</p><p>如果只是想向前遍历 <strong>List</strong> ，并不打算修改 <strong>List</strong> 对象本身，那么使用 <em>for-in</em> 语法更加简洁。</p><p><strong>Iterator</strong> 还可以删除由 <code>next()</code> 生成的最后一个元素，这意味着在调用 <code>remove()</code> 之前必须先调用 <code>next()</code> 。<sup><a href="#fn_4" id="reffn_4">4</a></sup></p><p>在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。</p><p>现在考虑创建一个 <code>display()</code> 方法，它不必知晓集合的确切类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossCollectionIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> HashSet&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> TreeSet&lt;&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>display()</code> 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 <strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。</p><p>我们可以使用 <strong>Iterable</strong> 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 <strong>Iterator</strong> 的任何东西”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration2.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossCollectionIteration2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterable&lt;Pet&gt; ip)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Pet&gt; it = ip.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> HashSet&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> TreeSet&lt;&gt;(pets);</span><br><span class="line">    display(pets);</span><br><span class="line">    display(petsLL);</span><br><span class="line">    display(petsHS);</span><br><span class="line">    display(petsTS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里所有的类都是 <strong>Iterable</strong> ，所以现在对 <code>display()</code> 的调用显然更简单。</p><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它还可以生成相对于迭代器在列表中指向的当前位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。 下面的示例演示了所有这些能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ListIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">      System.out.print(it.next() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.nextIndex() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// Backwards:</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasPrevious())</span><br><span class="line">      System.out.print(it.previous().id() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.set(Pets.get());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug,</span></span><br><span class="line"><span class="comment">5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;</span></span><br><span class="line"><span class="comment">7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster,</span></span><br><span class="line"><span class="comment">EgyptianMau]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Pets.get()</code> 方法用来从位置 3 开始替换 <strong>List</strong> 中的所有 Pet 对象。</p><h2 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 LinkedList"></a>链表 LinkedList</h2><p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p><p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p><ul><li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>addFirst()</code> 在列表的开头插入一个元素。</li><li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li><li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li></ul><p>下面的示例展示了这些功能之间基本的相似性和差异性。它并不是重复执行 <strong>ListFeatures.java</strong> 中所示的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/LinkedListFeatures.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListFeatures</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Pet&gt; pets =</span><br><span class="line">      <span class="keyword">new</span> LinkedList&lt;&gt;(Pets.list(<span class="number">5</span>));</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    <span class="comment">// Identical:</span></span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.getFirst(): &quot;</span> + pets.getFirst());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.element(): &quot;</span> + pets.element());</span><br><span class="line">    <span class="comment">// Only differs in empty-list behavior:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pets.peek(): &quot;</span> + pets.peek());</span><br><span class="line">    <span class="comment">// Identical; remove and return the first element:</span></span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.remove(): &quot;</span> + pets.remove());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.removeFirst(): &quot;</span> + pets.removeFirst());</span><br><span class="line">    <span class="comment">// Only differs in empty-list behavior:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pets.poll(): &quot;</span> + pets.poll());</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    pets.addFirst(<span class="keyword">new</span> Rat());</span><br><span class="line">    System.out.println(<span class="string">&quot;After addFirst(): &quot;</span> + pets);</span><br><span class="line">    pets.offer(Pets.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;After offer(): &quot;</span> + pets);</span><br><span class="line">    pets.add(Pets.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;After add(): &quot;</span> + pets);</span><br><span class="line">    pets.addLast(<span class="keyword">new</span> Hamster());</span><br><span class="line">    System.out.println(<span class="string">&quot;After addLast(): &quot;</span> + pets);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.removeLast(): &quot;</span> + pets.removeLast());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug]</span></span><br><span class="line"><span class="comment">pets.getFirst(): Rat</span></span><br><span class="line"><span class="comment">pets.element(): Rat</span></span><br><span class="line"><span class="comment">pets.peek(): Rat</span></span><br><span class="line"><span class="comment">pets.remove(): Rat</span></span><br><span class="line"><span class="comment">pets.removeFirst(): Manx</span></span><br><span class="line"><span class="comment">pets.poll(): Cymric</span></span><br><span class="line"><span class="comment">[Mutt, Pug]</span></span><br><span class="line"><span class="comment">After addFirst(): [Rat, Mutt, Pug]</span></span><br><span class="line"><span class="comment">After offer(): [Rat, Mutt, Pug, Cymric]</span></span><br><span class="line"><span class="comment">After add(): [Rat, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]</span></span><br><span class="line"><span class="comment">pets.removeLast(): Hamster</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Pets.list()</code> 的结果被传递给 <strong>LinkedList</strong> 的构造器，以便使用它来填充 <strong>LinkedList</strong> 。如果查看 <strong>Queue</strong> 接口就会发现，它在 <strong>LinkedList</strong> 的基础上添加了 <code>element()</code> ， <code>offer()</code> ， <code>peek()</code> ， <code>poll()</code> 和 <code>remove()</code> 方法，以使其可以成为一个 <strong>Queue</strong> 的实现。 <strong>Queue</strong> 的完整示例将在本章稍后给出。</p><h2 id="堆栈-Stack"><a href="#堆栈-Stack" class="headerlink" title="堆栈 Stack"></a>堆栈 Stack</h2><p>堆栈是“后进先出”（LIFO）集合。它有时被称为<em>叠加栈</em>（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。经常用来类比栈的事物是带有弹簧支架的自助餐厅托盘。最后装入的托盘总是最先拿出来使用的。</p><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 <strong>ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即使它是作为一个堆栈在使用，我们仍然必须将其声明为 <strong>Deque</strong> 。有时一个名为 <strong>Stack</strong> 的类更能把事情讲清楚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Stack.java</span></span><br><span class="line"><span class="comment">// A Stack class built with an ArrayDeque</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Deque&lt;T&gt; storage = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123; storage.push(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.peek(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.pop(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.isEmpty(); &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> storage.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了使用泛型的类定义的最简单的可能示例。类名称后面的 <strong><T></T></strong> 告诉编译器这是一个参数化类型，而其中的类型参数 <strong>T</strong> 会在使用类时被实际类型替换。基本上，这个类是在声明“我们在定义一个可以持有 <strong>T</strong> 类型对象的 <strong>Stack</strong> 。” <strong>Stack</strong> 是使用 <strong>ArrayDeque</strong> 实现的，而 <strong>ArrayDeque</strong> 也被告知它将持有 <strong>T</strong> 类型对象。注意， <code>push()</code> 接受类型为 <strong>T</strong> 的对象，而 <code>peek()</code> 和 <code>pop()</code> 返回类型为 <strong>T</strong> 的对象。 <code>peek()</code> 方法将返回栈顶元素，但并不将其从栈顶删除，而 <code>pop()</code> 删除并返回顶部元素。</p><p>如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类（在<a href>附录：集合主题</a>中将会看到， <strong>Java 1.0</strong> 设计者在创建 <strong>java.util.Stack</strong> 时，就犯了这个错误）。使用组合，可以选择要公开的方法以及如何命名它们。</p><p>下面将使用 <strong>StackTest.java</strong> 中的相同代码来演示这个新的 <strong>Stack</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackTest2.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果想在自己的代码中使用这个 <strong>Stack</strong> 类，当在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能会与 <strong>java.util</strong> 包中的 <strong>Stack</strong> 发生冲突。例如，如果我们在上面的例子中导入 <strong>java.util.*</strong>，那么就必须使用包名来防止冲突：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackCollision.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackCollision</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    onjava.Stack&lt;String&gt; stack = <span class="keyword">new</span> onjava.Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    java.util.Stack&lt;String&gt; stack2 =</span><br><span class="line">      <span class="keyword">new</span> java.util.Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack2.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack2.empty())</span><br><span class="line">      System.out.print(stack2.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>尽管已经有了 <strong>java.util.Stack</strong> ，但是 <strong>ArrayDeque</strong> 可以产生更好的 <strong>Stack</strong> ，因此更可取。</p><p>还可以使用显式导入来控制对“首选” <strong>Stack</strong> 实现的选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> onjava.Stack;</span><br></pre></td></tr></table></figure><p>现在,任何对 <strong>Stack</strong> 的引用都将选择 <strong>onjava</strong> 版本，而在选择 <strong>java.util.Stack</strong> 时，必须使用全限定名称（full qualification）。</p><h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h2><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。 <strong>Set</strong> 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 <strong>Set</strong> 中。因此，查找通常是 <strong>Set</strong> 最重要的操作，因此通常会选择 <strong>HashSet</strong> 实现，该实现针对快速查找进行了优化。</p><p><strong>Set</strong> 具有与 <strong>Collection</strong> 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 <strong>List</strong> 那样。实际上， <strong>Set</strong> 就是一个 <strong>Collection</strong> ，只是行为不同。（这是继承和多态思想的典型应用：表现不同的行为。）<strong>Set</strong> 根据对象的“值”确定归属性，更复杂的内容将在<a href>附录：集合主题</a>中介绍。</p><p>下面是使用存放 <strong>Integer</strong> 对象的 <strong>HashSet</strong> 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SetOfInteger.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfInteger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">      intset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">    System.out.println(intset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,</span></span><br><span class="line"><span class="comment">16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 0 到 29 之间的 10000 个随机整数被添加到 <strong>Set</strong> 中，因此可以想象每个值都重复了很多次。但是从结果中可以看到，每一个数只有一个实例出现在结果中。</p><p>早期 Java 版本中的 <strong>HashSet</strong> 产生的输出没有可辨别的顺序。这是因为出于对速度的追求， <strong>HashSet</strong> 使用了散列，请参阅<a href>附录：集合主题</a>一章。由 <strong>HashSet</strong> 维护的顺序与 <strong>TreeSet</strong> 或 <strong>LinkedHashSet</strong> 不同，因为它们的实现具有不同的元素存储方式。 <strong>TreeSet</strong> 将元素存储在红-黑树数据结构中，而 <strong>HashSet</strong> 使用散列函数。 <strong>LinkedHashSet</strong> 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。看起来散列算法好像已经改变了，现在 <strong>Integer</strong> 按顺序排序。但是，您不应该依赖此行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SetOfString.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfString</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; colors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      colors.add(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Purple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(colors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Red, Yellow, Blue, Purple, Orange]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>String</strong> 对象似乎没有排序。要对结果进行排序，一种方法是使用 <strong>TreeSet</strong> 而不是 <strong>HashSet</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SortedSetOfString.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSetOfString</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; colors = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      colors.add(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Purple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(colors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Blue, Orange, Purple, Red, Yellow]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>最常见的操作之一是使用 <code>contains()</code> 测试成员归属性，但也有一些其它操作，这可能会让你想起在小学学过的维恩图（译者注：利用图形的交合表示多个集合之间的逻辑关系）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SetOperations.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOperations</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Collections.addAll(set1,</span><br><span class="line">      <span class="string">&quot;A B C D E F G H I J K L&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    set1.add(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;H: &quot;</span> + set1.contains(<span class="string">&quot;H&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;N: &quot;</span> + set1.contains(<span class="string">&quot;N&quot;</span>));</span><br><span class="line">    Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Collections.addAll(set2, <span class="string">&quot;H I J K L&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;set2 in set1: &quot;</span> + set1.containsAll(set2));</span><br><span class="line">    set1.remove(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;set1: &quot;</span> + set1);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;set2 in set1: &quot;</span> + set1.containsAll(set2));</span><br><span class="line">    set1.removeAll(set2);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;set2 removed from set1: &quot;</span> + set1);</span><br><span class="line">    Collections.addAll(set1, <span class="string">&quot;X Y Z&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;&#x27;X Y Z&#x27; added to set1: &quot;</span> + set1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">H: true</span></span><br><span class="line"><span class="comment">N: false</span></span><br><span class="line"><span class="comment">set2 in set1: true</span></span><br><span class="line"><span class="comment">set1: [A, B, C, D, E, F, G, I, J, K, L, M]</span></span><br><span class="line"><span class="comment">set2 in set1: false</span></span><br><span class="line"><span class="comment">set2 removed from set1: [A, B, C, D, E, F, G, M]</span></span><br><span class="line"><span class="comment">&#x27;X Y Z&#x27; added to set1: [A, B, C, D, E, F, G, M, X, Y,</span></span><br><span class="line"><span class="comment">Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这些方法名都是自解释的，JDK 文档中还有一些其它的方法。</p><p>能够产生每个元素都唯一的列表是相当有用的功能。例如，假设想要列出上面的 <strong>SetOperations.java</strong> 文件中的所有单词，通过使用本书后面介绍的 <code>java.nio.file.Files.readAllLines()</code> 方法，可以打开一个文件，并将其作为一个 <strong>List\<String></String></strong> 读取，每个 <strong>String</strong> 都是输入文件中的一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/UniqueWords.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueWords</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; lines = Files.readAllLines(</span><br><span class="line">      Paths.get(<span class="string">&quot;SetOperations.java&quot;</span>));</span><br><span class="line">    Set&lt;String&gt; words = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String line : lines)</span><br><span class="line">      <span class="keyword">for</span>(String word : line.split(<span class="string">&quot;\\W+&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span>(word.trim().length() &gt; <span class="number">0</span>)</span><br><span class="line">          words.add(word);</span><br><span class="line">    System.out.println(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A, B, C, Collections, D, E, F, G, H, HashSet, I, J, K,</span></span><br><span class="line"><span class="comment">L, M, N, Output, Set, SetOperations, String, System, X,</span></span><br><span class="line"><span class="comment">Y, Z, add, addAll, added, args, class, collections,</span></span><br><span class="line"><span class="comment">contains, containsAll, false, from, import, in, java,</span></span><br><span class="line"><span class="comment">main, new, out, println, public, remove, removeAll,</span></span><br><span class="line"><span class="comment">removed, set1, set2, split, static, to, true, util,</span></span><br><span class="line"><span class="comment">void]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们逐步浏览文件中的每一行，并使用 <code>String.split()</code> 将其分解为单词，这里使用正则表达式 <strong>\\ W +</strong> ，这意味着它会依据一个或多个（即 <strong>+</strong> ）非单词字母来拆分字符串（正则表达式将在<a href>字符串</a>章节介绍）。每个结果单词都会添加到 <strong>Set words</strong> 中。因为它是 <strong>TreeSet</strong> ，所以对结果进行排序。这里，排序是按<em>字典顺序</em>（lexicographically）完成的，因此大写和小写字母位于不同的组中。如果想按<em>字母顺序</em>（alphabetically）对其进行排序，可以向 <strong>TreeSet</strong> 构造器传入 <strong>String.CASE_INSENSITIVE_ORDER</strong> 比较器（比较器是一个建立排序顺序的对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/UniqueWordsAlphabetic.java</span></span><br><span class="line"><span class="comment">// Producing an alphabetic listing</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueWordsAlphabetic</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; lines = Files.readAllLines(</span><br><span class="line">      Paths.get(<span class="string">&quot;SetOperations.java&quot;</span>));</span><br><span class="line">    Set&lt;String&gt; words =</span><br><span class="line">      <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">    <span class="keyword">for</span>(String line : lines)</span><br><span class="line">      <span class="keyword">for</span>(String word : line.split(<span class="string">&quot;\\W+&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span>(word.trim().length() &gt; <span class="number">0</span>)</span><br><span class="line">          words.add(word);</span><br><span class="line">    System.out.println(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A, add, addAll, added, args, B, C, class, collections,</span></span><br><span class="line"><span class="comment">contains, containsAll, D, E, F, false, from, G, H,</span></span><br><span class="line"><span class="comment">HashSet, I, import, in, J, java, K, L, M, main, N, new,</span></span><br><span class="line"><span class="comment">out, Output, println, public, remove, removeAll,</span></span><br><span class="line"><span class="comment">removed, Set, set1, set2, SetOperations, split, static,</span></span><br><span class="line"><span class="comment">String, System, to, true, util, void, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Comparator</strong> 比较器将在<a href>数组</a>章节详细介绍。</p><h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 Map"></a>映射 Map</h2><p>将对象映射到其他对象的能力是解决编程问题的有效方法。例如，考虑一个程序，它被用来检查 Java 的 <strong>Random</strong> 类的随机性。理想情况下， <strong>Random</strong> 会产生完美的数字分布，但为了测试这一点，则需要生成大量的随机数，并计算落在各种范围内的数字个数。 <strong>Map</strong> 可以很容易地解决这个问题。在本例中，键是 <strong>Random</strong> 生成的数字，而值是该数字出现的次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/Statistics.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Simple demonstration of HashMap</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Statistics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// Produce a number between 0 and 20:</span></span><br><span class="line">      <span class="keyword">int</span> r = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">      Integer freq = m.get(r); <span class="comment">// [1]</span></span><br><span class="line">      m.put(r, freq == <span class="keyword">null</span> ? <span class="number">1</span> : freq + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">&#123;0=481, 1=502, 2=489, 3=508, 4=481, 5=503, 6=519,</span></span><br><span class="line"><span class="comment">7=471, 8=468, 9=549, 10=513, 11=531, 12=521, 13=506,</span></span><br><span class="line"><span class="comment">14=477, 15=497, 16=533, 17=509, 18=478, 19=464&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>[1]</strong> 自动包装机制将随机生成的 <strong>int</strong> 转换为可以与 <strong>HashMap</strong> 一起使用的 <strong>Integer</strong> 引用（不能使用基本类型的集合）。如果键不在集合中，则 <code>get()</code> 返回 <strong>null</strong> （这意味着该数字第一次出现）。否则， <code>get()</code> 会为键生成与之关联的 <strong>Integer</strong> 值，然后该值被递增（自动包装机制再次简化了表达式，但实际上确实发生了对 <strong>Integer</strong> 的装箱和拆箱）。</li></ul><p>接下来的示例将使用一个 <strong>String</strong> 描述来查找 <strong>Pet</strong> 对象。它还展示了通过使用 <code>containsKey()</code> 和 <code>containsValue()</code> 方法去测试一个 <strong>Map</strong> ，以查看它是否包含某个键或某个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/PetMap.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetMap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Pet&gt; petMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    petMap.put(<span class="string">&quot;My Cat&quot;</span>, <span class="keyword">new</span> Cat(<span class="string">&quot;Molly&quot;</span>));</span><br><span class="line">    petMap.put(<span class="string">&quot;My Dog&quot;</span>, <span class="keyword">new</span> Dog(<span class="string">&quot;Ginger&quot;</span>));</span><br><span class="line">    petMap.put(<span class="string">&quot;My Hamster&quot;</span>, <span class="keyword">new</span> Hamster(<span class="string">&quot;Bosco&quot;</span>));</span><br><span class="line">    System.out.println(petMap);</span><br><span class="line">    Pet dog = petMap.get(<span class="string">&quot;My Dog&quot;</span>);</span><br><span class="line">    System.out.println(dog);</span><br><span class="line">    System.out.println(petMap.containsKey(<span class="string">&quot;My Dog&quot;</span>));</span><br><span class="line">    System.out.println(petMap.containsValue(dog));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">&#123;My Dog=Dog Ginger, My Cat=Cat Molly, My</span></span><br><span class="line"><span class="comment">Hamster=Hamster Bosco&#125;</span></span><br><span class="line"><span class="comment">Dog Ginger</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Map</strong> 与数组和其他的 <strong>Collection</strong> 一样，可以轻松地扩展到多个维度，只需要创建一个值为 <strong>Map</strong> 的 <strong>Map</strong>（这些 <strong>Map</strong> 的值可以是其他集合，甚至是其他 <strong>Map</strong>）。因此，能够很容易地将集合组合起来以快速生成强大的数据结构。例如，假设你正在追踪有多个宠物的人，只需要一个 <strong>Map\<Person, list\<pet>&gt;</Person,></strong> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/MapOfList.java</span></span><br><span class="line"><span class="comment">// &#123;java collections.MapOfList&#125;</span></span><br><span class="line"><span class="keyword">package</span> collections;</span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapOfList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Person, List&lt; ? extends Pet&gt;&gt;</span><br><span class="line">    petPeople = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Dawn&quot;</span>),</span><br><span class="line">      Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Cymric(<span class="string">&quot;Molly&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> Mutt(<span class="string">&quot;Spot&quot;</span>)));</span><br><span class="line">    petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Kate&quot;</span>),</span><br><span class="line">      Arrays.asList(<span class="keyword">new</span> Cat(<span class="string">&quot;Shackleton&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> Cat(<span class="string">&quot;Elsie May&quot;</span>), <span class="keyword">new</span> Dog(<span class="string">&quot;Margrett&quot;</span>)));</span><br><span class="line">    petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Marilyn&quot;</span>),</span><br><span class="line">      Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Pug(<span class="string">&quot;Louie aka Louis Snorkelstein Dupree&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> Cat(<span class="string">&quot;Stanford&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> Cat(<span class="string">&quot;Pinkola&quot;</span>)));</span><br><span class="line">    petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Luke&quot;</span>),</span><br><span class="line">      Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Rat(<span class="string">&quot;Fuzzy&quot;</span>), <span class="keyword">new</span> Rat(<span class="string">&quot;Fizzy&quot;</span>)));</span><br><span class="line">    petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Isaac&quot;</span>),</span><br><span class="line">      Arrays.asList(<span class="keyword">new</span> Rat(<span class="string">&quot;Freckly&quot;</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;People: &quot;</span> + petPeople.keySet());</span><br><span class="line">    System.out.println(<span class="string">&quot;Pets: &quot;</span> + petPeople.values());</span><br><span class="line">    <span class="keyword">for</span>(Person person : petPeople.keySet()) &#123;</span><br><span class="line">      System.out.println(person + <span class="string">&quot; has:&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(Pet pet : petPeople.get(person))</span><br><span class="line">        System.out.println(<span class="string">&quot;    &quot;</span> + pet);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">People: [Person Dawn, Person Kate, Person Isaac, Person</span></span><br><span class="line"><span class="comment">Marilyn, Person Luke]</span></span><br><span class="line"><span class="comment">Pets: [[Cymric Molly, Mutt Spot], [Cat Shackleton, Cat</span></span><br><span class="line"><span class="comment">Elsie May, Dog Margrett], [Rat Freckly], [Pug Louie aka</span></span><br><span class="line"><span class="comment">Louis Snorkelstein Dupree, Cat Stanford, Cat Pinkola],</span></span><br><span class="line"><span class="comment">[Rat Fuzzy, Rat Fizzy]]</span></span><br><span class="line"><span class="comment">Person Dawn has:</span></span><br><span class="line"><span class="comment">    Cymric Molly</span></span><br><span class="line"><span class="comment">    Mutt Spot</span></span><br><span class="line"><span class="comment">Person Kate has:</span></span><br><span class="line"><span class="comment">    Cat Shackleton</span></span><br><span class="line"><span class="comment">    Cat Elsie May</span></span><br><span class="line"><span class="comment">    Dog Margrett</span></span><br><span class="line"><span class="comment">Person Isaac has:</span></span><br><span class="line"><span class="comment">    Rat Freckly</span></span><br><span class="line"><span class="comment">Person Marilyn has:</span></span><br><span class="line"><span class="comment">    Pug Louie aka Louis Snorkelstein Dupree</span></span><br><span class="line"><span class="comment">    Cat Stanford</span></span><br><span class="line"><span class="comment">    Cat Pinkola</span></span><br><span class="line"><span class="comment">Person Luke has:</span></span><br><span class="line"><span class="comment">    Rat Fuzzy</span></span><br><span class="line"><span class="comment">    Rat Fizzy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Map</strong> 可以返回由其键组成的 <strong>Set</strong> ，由其值组成的 <strong>Collection</strong> ，或者其键值对的 <strong>Set</strong> 。 <code>keySet()</code> 方法生成由在 <strong>petPeople</strong> 中的所有键组成的 <strong>Set</strong> ，它在 <em>for-in</em> 语句中被用来遍历该 <strong>Map</strong> 。</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p>队列是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在<a href>并发编程</a>中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。</p><p><strong>LinkedList</strong> 实现了 <strong>Queue</strong> 接口，并且提供了一些方法以支持队列行为，因此 <strong>LinkedList</strong> 可以用作 <strong>Queue</strong> 的一种实现。 通过将 <strong>LinkedList</strong> 向上转换为 <strong>Queue</strong> ，下面的示例使用了在 <strong>Queue</strong> 接口中与 <strong>Queue</strong> 相关(Queue-specific)的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/QueueDemo.java</span></span><br><span class="line"><span class="comment">// Upcasting to a Queue from a LinkedList</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(queue.peek() != <span class="keyword">null</span>)</span><br><span class="line">      System.out.print(queue.remove() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      queue.offer(rand.nextInt(i + <span class="number">10</span>));</span><br><span class="line">    printQ(queue);</span><br><span class="line">    Queue&lt;Character&gt; qc = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : <span class="string">&quot;Brontosaurus&quot;</span>.toCharArray())</span><br><span class="line">      qc.offer(c);</span><br><span class="line">    printQ(qc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">8 1 1 1 5 14 3 1 0 1</span></span><br><span class="line"><span class="comment">B r o n t o s a u r u s</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>offer()</code> 是与 <strong>Queue</strong> 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。 <code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 <code>poll()</code> 和 <code>remove()</code>* 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</p><p>自动包装机制会自动将 <code>nextInt()</code> 的 <strong>int</strong> 结果转换为 <strong>queue</strong> 所需的 <strong>Integer</strong> 对象，并将 <strong>char c</strong> 转换为 <strong>qc</strong> 所需的 <strong>Character</strong> 对象。 <strong>Queue</strong> 接口窄化了对 <strong>LinkedList</strong> 方法的访问权限，因此只有适当的方法才能使用，因此能够访问到的 <strong>LinkedList</strong> 的方法会变少（这里实际上可以将 <strong>Queue</strong> 强制转换回 <strong>LinkedList</strong> ，但至少我们不鼓励这样做）。</p><p>与 <strong>Queue</strong> 相关的方法提供了完整而独立的功能。 也就是说，对于 <strong>Queue</strong> 所继承的 <strong>Collection</strong> ，在不需要使用它的任何方法的情况下，就可以拥有一个可用的 <strong>Queue</strong> 。</p><h3 id="优先级队列-PriorityQueue"><a href="#优先级队列-PriorityQueue" class="headerlink" title="优先级队列 PriorityQueue"></a>优先级队列 PriorityQueue</h3><p>先进先出（FIFO）描述了最典型的<em>队列规则</em>（queuing discipline）。队列规则是指在给定队列中的一组元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个弹出的元素应该是等待时间最长的元素。</p><p>优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。例如，在机场，当飞机临近起飞时，这架飞机的乘客可以在办理登机手续时排到队头。如果构建了一个消息传递系统，某些消息比其他消息更重要，应该尽快处理，而不管它们何时到达。在 Java 5 中添加了 <strong>PriorityQueue</strong> ，以便自动实现这种行为。</p><p>当在 <strong>PriorityQueue</strong> 上调用 <code>offer()</code> 方法来插入一个对象时，该对象会在队列中被排序。<sup><a href="#fn_5" id="reffn_5">5</a></sup>默认的排序使用队列中对象的<em>自然顺序</em>（natural order），但是可以通过提供自己的 <strong>Comparator</strong> 来修改这个顺序。 <strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素。</p><p>让 <strong>PriorityQueue</strong> 与 <strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 这样的内置类型一起工作易如反掌。在下面的示例中，第一组值与前一个示例中的随机值相同，可以看到它们从 <strong>PriorityQueue</strong> 中弹出的顺序与前一个示例不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/PriorityQueueDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; priorityQueue =</span><br><span class="line">      <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      priorityQueue.offer(rand.nextInt(i + <span class="number">10</span>));</span><br><span class="line">    QueueDemo.printQ(priorityQueue);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; ints = Arrays.asList(<span class="number">25</span>, <span class="number">22</span>, <span class="number">20</span>,</span><br><span class="line">      <span class="number">18</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>);</span><br><span class="line">    priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(ints);</span><br><span class="line">    QueueDemo.printQ(priorityQueue);</span><br><span class="line">    priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        ints.size(), Collections.reverseOrder());</span><br><span class="line">    priorityQueue.addAll(ints);</span><br><span class="line">    QueueDemo.printQ(priorityQueue);</span><br><span class="line"></span><br><span class="line">    String fact = <span class="string">&quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;</span>;</span><br><span class="line">    List&lt;String&gt; strings =</span><br><span class="line">      Arrays.asList(fact.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    PriorityQueue&lt;String&gt; stringPQ =</span><br><span class="line">      <span class="keyword">new</span> PriorityQueue&lt;&gt;(strings);</span><br><span class="line">    QueueDemo.printQ(stringPQ);</span><br><span class="line">    stringPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">      strings.size(), Collections.reverseOrder());</span><br><span class="line">    stringPQ.addAll(strings);</span><br><span class="line">    QueueDemo.printQ(stringPQ);</span><br><span class="line"></span><br><span class="line">    Set&lt;Character&gt; charSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : fact.toCharArray())</span><br><span class="line">      charSet.add(c); <span class="comment">// Autoboxing</span></span><br><span class="line">    PriorityQueue&lt;Character&gt; characterPQ =</span><br><span class="line">      <span class="keyword">new</span> PriorityQueue&lt;&gt;(charSet);</span><br><span class="line">    QueueDemo.printQ(characterPQ);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 1 1 1 1 3 5 8 14</span></span><br><span class="line"><span class="comment">1 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25</span></span><br><span class="line"><span class="comment">25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1</span></span><br><span class="line"><span class="comment">      A A B C C C D D E E E F H H I I L N N O O O O S S</span></span><br><span class="line"><span class="comment">S T T U U U W</span></span><br><span class="line"><span class="comment">W U U U T T S S S O O O O N N L I I H H F E E E D D C C</span></span><br><span class="line"><span class="comment">C B A A</span></span><br><span class="line"><span class="comment">  A B C D E F H I L N O S T U W</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>PriorityQueue</strong> 是允许重复的，最小的值具有最高的优先级（如果是 <strong>String</strong> ，空格也可以算作值，并且比字母的优先级高）。为了展示如何通过提供自己的 <strong>Comparator</strong> 对象来改变顺序，第三个对 <strong>PriorityQueue\<Integer></Integer></strong> 构造器的调用，和第二个对 <strong>PriorityQueue\<String></String></strong> 的调用使用了由 <code>Collections.reverseOrder()</code> （Java 5 中新添加的）产生的反序的 <strong>Comparator</strong> 。</p><p>最后一部分添加了一个 <strong>HashSet</strong> 来消除重复的 <strong>Character</strong>。</p><p><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。在<a href>附录：集合主题</a>中有一个更复杂的示例来演示这种情况。</p><h2 id="集合与迭代器"><a href="#集合与迭代器" class="headerlink" title="集合与迭代器"></a>集合与迭代器</h2><p><strong>Collection</strong> 是所有序列集合共有的根接口。它可能会被认为是一种“附属接口”（incidental interface），即因为要表示其他若干个接口的共性而出现的接口。此外，<strong>java.util.AbstractCollection</strong> 类提供了 <strong>Collection</strong> 的默认实现，使得你可以创建 <strong>AbstractCollection</strong> 的子类型，而其中没有不必要的代码重复。</p><p>使用接口描述的一个理由是它可以使我们创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多类型的对象。<sup><a href="#fn_6" id="reffn_6">6</a></sup>因此，如果所编写的方法接受一个 <strong>Collection</strong> ，那么该方法可以应用于任何实现了 <strong>Collection</strong> 的类——这也就使得一个新类可以选择去实现 <strong>Collection</strong> 接口，以便该方法可以使用它。标准 C++ 类库中的的集合并没有共同的基类——集合之间的所有共性都是通过迭代器实现的。在 Java 中，遵循 C++ 的方式看起来似乎很明智，即用迭代器而不是 <strong>Collection</strong> 来表示集合之间的共性。但是，这两种方法绑定在了一起，因为实现 <strong>Collection</strong> 就意味着需要提供 <code>iterator()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/InterfaceVsIterator.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceVsIterator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Collection&lt;Pet&gt; pets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Pet p : pets)</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; petList = Pets.list(<span class="number">8</span>);</span><br><span class="line">    Set&lt;Pet&gt; petSet = <span class="keyword">new</span> HashSet&lt;&gt;(petList);</span><br><span class="line">    Map&lt;String, Pet&gt; petMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    String[] names = (<span class="string">&quot;Ralph, Eric, Robin, Lacey, &quot;</span> +</span><br><span class="line">      <span class="string">&quot;Britney, Sam, Spot, Fluffy&quot;</span>).split(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length; i++)</span><br><span class="line">      petMap.put(names[i], petList.get(i));</span><br><span class="line">    display(petList);</span><br><span class="line">    display(petSet);</span><br><span class="line">    display(petList.iterator());</span><br><span class="line">    display(petSet.iterator());</span><br><span class="line">    System.out.println(petMap);</span><br><span class="line">    System.out.println(petMap.keySet());</span><br><span class="line">    display(petMap.values());</span><br><span class="line">    display(petMap.values().iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">&#123;Ralph=Rat, Eric=Manx, Robin=Cymric, Lacey=Mutt,</span></span><br><span class="line"><span class="comment">Britney=Pug, Sam=Cymric, Spot=Pug, Fluffy=Manx&#125;</span></span><br><span class="line"><span class="comment">[Ralph, Eric, Robin, Lacey, Britney, Sam, Spot, Fluffy]</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>两个版本的 <code>display()</code> 方法都可以使用 <strong>Map</strong> 或 <strong>Collection</strong> 的子类型来工作。 而且<strong>Collection</strong> 接口和 <strong>Iterator</strong> 都将 <code>display()</code> 方法与低层集合的特定实现解耦。</p><p>在本例中，这两种方式都可以奏效。事实上， <strong>Collection</strong> 要更方便一点，因为它是 <strong>Iterable</strong> 类型，因此在 <code>display(Collection)</code> 的实现中可以使用 <em>for-in</em> 构造，这使得代码更加清晰。</p><p>当需要实现一个不是 <strong>Collection</strong> 的外部类时，由于让它去实现 <strong>Collection</strong> 接口可能非常困难或麻烦，因此使用 <strong>Iterator</strong> 就会变得非常吸引人。例如，如果我们通过继承一个持有 <strong>Pet</strong> 对象的类来创建一个 <strong>Collection</strong> 的实现，那么我们必须实现 <strong>Collection</strong> 所有的方法，即使我们不在 <code>display()</code> 方法中使用它们，也必须这样做。虽然这可以通过继承 <strong>AbstractCollection</strong> 而很容易地实现，但是无论如何还是要被强制去实现 <code>iterator()</code> 和 <code>size()</code> 方法，这些方法 <strong>AbstractCollection</strong> 没有实现，但是 <strong>AbstractCollection</strong> 中的其它方法会用到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CollectionSequence.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionSequence</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">Pet</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Pet[] pets = Pets.array(<span class="number">8</span>);</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pets.length; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;Pet&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Pet&gt;() &#123; <span class="comment">// [1]</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; pets.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Pet <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pets[index++]; &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CollectionSequence c = <span class="keyword">new</span> CollectionSequence();</span><br><span class="line">    InterfaceVsIterator.display(c);</span><br><span class="line">    InterfaceVsIterator.display(c.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>remove()</code> 方法是一个“可选操作”，在<a href>附录：集合主题</a>中详细介绍。 这里可以不必实现它，如果你调用它，它将抛出异常。</p><ul><li><strong>[1]</strong> 你可能会认为，因为 <code>iterator()</code> 返回 <strong>Iterator\<Pet></Pet></strong> ，匿名内部类定义可以使用菱形语法，Java 可以推断出类型。但这不起作用，类型推断仍然非常有限。</li></ul><p>这个例子表明，如果实现了 <strong>Collection</strong> ，就必须实现 <code>iterator()</code> ，并且只拿实现 <code>iterator()</code> 与继承 <strong>AbstractCollection</strong> 相比，花费的代价只有略微减少。但是，如果类已经继承了其他的类，那么就不能继承再 <strong>AbstractCollection</strong> 了。在这种情况下，要实现 <strong>Collection</strong> ，就必须实现该接口中的所有方法。此时，继承并提供创建迭代器的能力要容易得多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/NonCollectionSequence.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetSequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Pet[] pets = Pets.array(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCollectionSequence</span> <span class="keyword">extends</span> <span class="title">PetSequence</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;Pet&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Pet&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; pets.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Pet <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pets[index++]; &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    NonCollectionSequence nc =</span><br><span class="line">      <span class="keyword">new</span> NonCollectionSequence();</span><br><span class="line">    InterfaceVsIterator.display(nc.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>生成 <strong>Iterator</strong> 是将序列与消费该序列的方法连接在一起耦合度最小的方式，并且与实现 <strong>Collection</strong> 相比，它在序列类上所施加的约束也少得多。</p><h2 id="for-in-和迭代器"><a href="#for-in-和迭代器" class="headerlink" title="for-in 和迭代器"></a>for-in 和迭代器</h2><p>到目前为止，<em>for-in</em> 语法主要用于数组，但它也适用于任何 <strong>Collection</strong> 对象。实际上在使用 <strong>ArrayList</strong> 时，已经看到了一些使用它的示例，下面是一个更通用的证明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ForInCollections.java</span></span><br><span class="line"><span class="comment">// All collections work with for-in</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInCollections</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; cs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(cs,</span><br><span class="line">      <span class="string">&quot;Take the long way home&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="keyword">for</span>(String s : cs)</span><br><span class="line">      System.out.print(<span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">&#x27;Take&#x27; &#x27;the&#x27; &#x27;long&#x27; &#x27;way&#x27; &#x27;home&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由于 <strong>cs</strong> 是一个 <strong>Collection</strong> ，因此该代码展示了使用 <em>for-in</em> 是所有 <strong>Collection</strong> 对象的特征。</p><p>这样做的原因是 Java 5 引入了一个名为 <strong>Iterable</strong> 的接口，该接口包含一个能够生成 <strong>Iterator</strong> 的 <code>iterator()</code> 方法。<em>for-in</em> 使用此 <strong>Iterable</strong> 接口来遍历序列。因此，如果创建了任何实现了 <strong>Iterable</strong> 的类，都可以将它用于 <em>for-in</em> 语句中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/IterableClass.java</span></span><br><span class="line"><span class="comment">// Anything Iterable works with for-in</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableClass</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> String[] words = (<span class="string">&quot;And that is how &quot;</span> +</span><br><span class="line">    <span class="string">&quot;we know the Earth to be banana-shaped.&quot;</span></span><br><span class="line">    ).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;String&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; words.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> words[index++]; &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="keyword">new</span> IterableClass())</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">And that is how we know the Earth to be banana-shaped.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>iterator()</code> 返回的是实现了 <strong>Iterator\<String></String></strong> 的匿名内部类的实例，该匿名内部类可以遍历数组中的每个单词。在主方法中，可以看到 <strong>IterableClass</strong> 确实可以用于 <em>for-in</em> 语句。</p><p>在 Java 5 中，许多类都是 <strong>Iterable</strong> ，主要包括所有的 <strong>Collection</strong> 类（但不包括各种 <strong>Maps</strong> ）。 例如，下面的代码可以显示所有的操作系统环境变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/EnvironmentVariables.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentVariables</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry entry: System.getenv().entrySet()) &#123;</span><br><span class="line">      System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">        entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>System.getenv()</code> <sup><a href="#fn_7" id="reffn_7">7</a></sup>返回一个 <strong>Map</strong> ， <code>entrySet()</code> 产生一个由 <strong>Map.Entry</strong> 的元素构成的 <strong>Set</strong> ，并且这个 <strong>Set</strong> 是一个 <strong>Iterable</strong> ，因此它可以用于 <em>for-in</em> 循环。</p><p><em>for-in</em> 语句适用于数组或其它任何 <strong>Iterable</strong> ，但这并不意味着数组肯定也是个 <strong>Iterable</strong> ，也不会发生任何自动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ArrayIsNotIterable.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayIsNotIterable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Iterable&lt;T&gt; ib)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : ib)</span><br><span class="line">      System.out.print(t + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    String[] strings = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// An array works in for-in, but it&#x27;s not Iterable:</span></span><br><span class="line">    <span class="comment">//- test(strings);</span></span><br><span class="line">    <span class="comment">// You must explicitly convert it to an Iterable:</span></span><br><span class="line">    test(Arrays.asList(strings));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">1 2 3 A B C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>尝试将数组作为一个 <strong>Iterable</strong> 参数传递会导致失败。这说明不存在任何从数组到 <strong>Iterable</strong> 的自动转换; 必须手工执行这种转换。</p><h3 id="适配器方法惯用法"><a href="#适配器方法惯用法" class="headerlink" title="适配器方法惯用法"></a>适配器方法惯用法</h3><p>如果现在有一个 <strong>Iterable</strong> 类，你想要添加一种或多种在 <em>for-in</em> 语句中使用这个类的方法，应该怎么做呢？例如，你希望可以选择正向还是反向遍历一个单词列表。如果直接继承这个类，并覆盖 <code>iterator()</code> 方法，则只能替换现有的方法，而不能实现遍历顺序的选择。</p><p>一种解决方案是所谓<em>适配器方法</em>（Adapter Method）的惯用法。“适配器”部分来自于设计模式，因为必须要提供特定的接口来满足 <em>for-in</em> 语句。如果已经有一个接口并且需要另一个接口时，则编写适配器就可以解决这个问题。<br>在这里，若希望在默认的正向迭代器的基础上，添加产生反向迭代器的能力，因此不能使用覆盖，相反，而是添加了一个能够生成 <strong>Iterable</strong> 对象的方法，该对象可以用于 <em>for-in</em> 语句。这使得我们可以提供多种使用 <em>for-in</em> 语句的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AdapterMethodIdiom.java</span></span><br><span class="line"><span class="comment">// The &quot;Adapter Method&quot; idiom uses for-in</span></span><br><span class="line"><span class="comment">// with additional kinds of Iterables</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReversibleArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ReversibleArrayList(Collection&lt;T&gt; c) &#123;</span><br><span class="line">    <span class="keyword">super</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterable&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;T&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;</span><br><span class="line">          <span class="keyword">int</span> current = size() - <span class="number">1</span>;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current &gt; -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> get(current--); &#125;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterMethodIdiom</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReversibleArrayList&lt;String&gt; ral =</span><br><span class="line">      <span class="keyword">new</span> ReversibleArrayList&lt;String&gt;(</span><br><span class="line">        Arrays.asList(<span class="string">&quot;To be or not to be&quot;</span>.split(<span class="string">&quot; &quot;</span>)));</span><br><span class="line">    <span class="comment">// Grabs the ordinary iterator via iterator():</span></span><br><span class="line">    <span class="keyword">for</span>(String s : ral)</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// Hand it the Iterable of your choice</span></span><br><span class="line">    <span class="keyword">for</span>(String s : ral.reversed())</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">To be or not to be</span></span><br><span class="line"><span class="comment">be to not or be To</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在主方法中，如果直接将 <strong>ral</strong> 对象放在 <em>for-in</em> 语句中，则会得到（默认的）正向迭代器。但是如果在该对象上调用 <code>reversed()</code> 方法，它会产生不同的行为。</p><p>通过使用这种方式，可以在 <strong>IterableClass.java</strong> 示例中添加两种适配器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/MultiIterableClass.java</span></span><br><span class="line"><span class="comment">// Adding several Adapter Methods</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiIterableClass</span> <span class="keyword">extends</span> <span class="title">IterableClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;String&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;String&gt;() &#123;</span><br><span class="line">          <span class="keyword">int</span> current = words.length - <span class="number">1</span>;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current &gt; -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> words[current--];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">randomized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;String&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; shuffled =</span><br><span class="line">          <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(words));</span><br><span class="line">        Collections.shuffle(shuffled, <span class="keyword">new</span> Random(<span class="number">47</span>));</span><br><span class="line">        <span class="keyword">return</span> shuffled.iterator();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MultiIterableClass mic = <span class="keyword">new</span> MultiIterableClass();</span><br><span class="line">    <span class="keyword">for</span>(String s : mic.reversed())</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(String s : mic.randomized())</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(String s : mic)</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">banana-shaped. be to Earth the know we how is that And</span></span><br><span class="line"><span class="comment">is banana-shaped. Earth that how the be And we know to</span></span><br><span class="line"><span class="comment">And that is how we know the Earth to be banana-shaped.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意，第二个方法 <code>random()</code> 没有创建它自己的 <strong>Iterator</strong> ，而是直接返回被打乱的 <strong>List</strong> 中的 <strong>Iterator</strong> 。</p><p>从输出中可以看到， <code>Collections.shuffle()</code> 方法不会影响到原始数组，而只是打乱了 <strong>shuffled</strong> 中的引用。之所以这样，是因为 <code>randomized()</code> 方法用一个 <strong>ArrayList</strong> 将 <code>Arrays.asList()</code> 的结果包装了起来。如果这个由 <code>Arrays.asList()</code> 生成的 <strong>List</strong> 被直接打乱，那么它将修改底层数组，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ModifyingArraysAsList.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModifyingArraysAsList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    Integer[] ia = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    List&lt;Integer&gt; list1 =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(ia));</span><br><span class="line">    System.out.println(<span class="string">&quot;Before shuffling: &quot;</span> + list1);</span><br><span class="line">    Collections.shuffle(list1, rand);</span><br><span class="line">    System.out.println(<span class="string">&quot;After shuffling: &quot;</span> + list1);</span><br><span class="line">    System.out.println(<span class="string">&quot;array: &quot;</span> + Arrays.toString(ia));</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list2 = Arrays.asList(ia);</span><br><span class="line">    System.out.println(<span class="string">&quot;Before shuffling: &quot;</span> + list2);</span><br><span class="line">    Collections.shuffle(list2, rand);</span><br><span class="line">    System.out.println(<span class="string">&quot;After shuffling: &quot;</span> + list2);</span><br><span class="line">    System.out.println(<span class="string">&quot;array: &quot;</span> + Arrays.toString(ia));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Before shuffling: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="comment">After shuffling: [4, 6, 3, 1, 8, 7, 2, 5, 10, 9]</span></span><br><span class="line"><span class="comment">array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="comment">Before shuffling: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="comment">After shuffling: [9, 1, 6, 3, 7, 2, 5, 10, 4, 8]</span></span><br><span class="line"><span class="comment">array: [9, 1, 6, 3, 7, 2, 5, 10, 4, 8]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在第一种情况下， <code>Arrays.asList()</code> 的输出被传递给了 <strong>ArrayList</strong> 的构造器，这将创建一个引用 <strong>ia</strong> 的元素的 <strong>ArrayList</strong> ，因此打乱这些引用不会修改该数组。但是，如果直接使用 <code>Arrays.asList(ia)</code> 的结果，这种打乱就会修改 <strong>ia</strong> 的顺序。重要的是要注意 <code>Arrays.asList()</code> 生成一个 <strong>List</strong> 对象，该对象使用底层数组作为其物理实现。如果执行的操作会修改这个 <strong>List</strong> ，并且不希望修改原始数组，那么就应该在另一个集合中创建一个副本。</p><h2 id="本章小结-10"><a href="#本章小结-10" class="headerlink" title="本章小结"></a>本章小结</h2><p>Java 提供了许多保存对象的方法：</p><ol><li><p>数组将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。</p></li><li><p><strong>Collection</strong> 保存单一的元素，而 <strong>Map</strong> 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 <strong>Collection</strong> 和各种 <strong>Map</strong> 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。</p></li><li><p>像数组一样， <strong>List</strong> 也将数字索引与对象相关联，因此，数组和 <strong>List</strong> 都是有序集合。</p></li><li><p>如果要执行大量的随机访问，则使用 <strong>ArrayList</strong> ，如果要经常从表中间插入或删除元素，则应该使用 <strong>LinkedList</strong> 。</p></li><li><p>队列和堆栈的行为是通过 <strong>LinkedList</strong> 提供的。</p></li><li><p><strong>Map</strong> 是一种将对象（而非数字）与对象相关联的设计。 <strong>HashMap</strong> 专为快速访问而设计，而 <strong>TreeMap</strong> 保持键始终处于排序状态，所以没有 <strong>HashMap</strong> 快。 <strong>LinkedHashMap</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</p></li><li><p><strong>Set</strong> 不接受重复元素。 <strong>HashSet</strong> 提供最快的查询速度，而 <strong>TreeSet</strong> 保持元素处于排序状态。 <strong>LinkedHashSet</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</p></li><li><p>不要在新代码中使用遗留类 <strong>Vector</strong> ，<strong>Hashtable</strong> 和 <strong>Stack</strong> 。</p></li></ol><p>浏览一下 Java 集合的简图（不包含抽象类或遗留组件）会很有帮助。这里仅包括在一般情况下会碰到的接口和类。（译者注：下图为原著 PDF 中的截图，可能由于未知原因存在问题。这里可参考译者绘制版<sup><a href="#fn_8" id="reffn_8">8</a></sup>）</p><p><img src="C:/Users/SYR/Desktop/images/simple-collection-taxonomy.png" alt="simple collection taxonomy"></p><h3 id="简单集合分类"><a href="#简单集合分类" class="headerlink" title="简单集合分类"></a>简单集合分类</h3><p>可以看到，实际上只有四个基本的集合组件： <strong>Map</strong> ， <strong>List</strong> ， <strong>Set</strong> 和 <strong>Queue</strong> ，它们各有两到三个实现版本（<strong>Queue</strong> 的 <strong>java.util.concurrent</strong> 实现未包含在此图中）。最常使用的集合用黑色粗线线框表示。</p><p>虚线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的虚线表示特定的类实现了一个接口。实心箭头表示某个类可以生成箭头指向的类的对象。例如，任何 <strong>Collection</strong> 都可以生成 <strong>Iterator</strong> ， <strong>List</strong> 可以生成 <strong>ListIterator</strong> （也能生成普通的 <strong>Iterator</strong> ，因为 <strong>List</strong> 继承自 <strong>Collection</strong> ）。</p><p>下面的示例展示了各种不同的类在方法上的差异。实际代码来自<a href>泛型</a>章节，在这里只是调用它来产生输出。程序的输出还展示了在每个类或接口中所实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CollectionDifferences.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDifferences</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CollectionMethodDifferences.main(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Collection: [add, addAll, clear, contains, containsAll,</span></span><br><span class="line"><span class="comment">equals, forEach, hashCode, isEmpty, iterator,</span></span><br><span class="line"><span class="comment">parallelStream, remove, removeAll, removeIf, retainAll,</span></span><br><span class="line"><span class="comment">size, spliterator, stream, toArray]</span></span><br><span class="line"><span class="comment">Interfaces in Collection: [Iterable]</span></span><br><span class="line"><span class="comment">Set extends Collection, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in Set: [Collection]</span></span><br><span class="line"><span class="comment">HashSet extends Set, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in HashSet: [Set, Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedHashSet extends HashSet, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in LinkedHashSet: [Set, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">TreeSet extends Set, adds: [headSet,</span></span><br><span class="line"><span class="comment">descendingIterator, descendingSet, pollLast, subSet,</span></span><br><span class="line"><span class="comment">floor, tailSet, ceiling, last, lower, comparator,</span></span><br><span class="line"><span class="comment">pollFirst, first, higher]</span></span><br><span class="line"><span class="comment">Interfaces in TreeSet: [NavigableSet, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">List extends Collection, adds: [replaceAll, get,</span></span><br><span class="line"><span class="comment">indexOf, subList, set, sort, lastIndexOf, listIterator]</span></span><br><span class="line"><span class="comment">Interfaces in List: [Collection]</span></span><br><span class="line"><span class="comment">ArrayList extends List, adds: [trimToSize,</span></span><br><span class="line"><span class="comment">ensureCapacity]</span></span><br><span class="line"><span class="comment">Interfaces in ArrayList: [List, RandomAccess,</span></span><br><span class="line"><span class="comment">Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedList extends List, adds: [offerFirst, poll,</span></span><br><span class="line"><span class="comment">getLast, offer, getFirst, removeFirst, element,</span></span><br><span class="line"><span class="comment">removeLastOccurrence, peekFirst, peekLast, push,</span></span><br><span class="line"><span class="comment">pollFirst, removeFirstOccurrence, descendingIterator,</span></span><br><span class="line"><span class="comment">pollLast, removeLast, pop, addLast, peek, offerLast,</span></span><br><span class="line"><span class="comment">addFirst]</span></span><br><span class="line"><span class="comment">Interfaces in LinkedList: [List, Deque, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">Queue extends Collection, adds: [poll, peek, offer,</span></span><br><span class="line"><span class="comment">element]</span></span><br><span class="line"><span class="comment">Interfaces in Queue: [Collection]</span></span><br><span class="line"><span class="comment">PriorityQueue extends Queue, adds: [comparator]</span></span><br><span class="line"><span class="comment">Interfaces in PriorityQueue: [Serializable]</span></span><br><span class="line"><span class="comment">Map: [clear, compute, computeIfAbsent,</span></span><br><span class="line"><span class="comment">computeIfPresent, containsKey, containsValue, entrySet,</span></span><br><span class="line"><span class="comment">equals, forEach, get, getOrDefault, hashCode, isEmpty,</span></span><br><span class="line"><span class="comment">keySet, merge, put, putAll, putIfAbsent, remove,</span></span><br><span class="line"><span class="comment">replace, replaceAll, size, values]</span></span><br><span class="line"><span class="comment">HashMap extends Map, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in HashMap: [Map, Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedHashMap extends HashMap, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in LinkedHashMap: [Map]</span></span><br><span class="line"><span class="comment">SortedMap extends Map, adds: [lastKey, subMap,</span></span><br><span class="line"><span class="comment">comparator, firstKey, headMap, tailMap]</span></span><br><span class="line"><span class="comment">Interfaces in SortedMap: [Map]</span></span><br><span class="line"><span class="comment">TreeMap extends Map, adds: [descendingKeySet,</span></span><br><span class="line"><span class="comment">navigableKeySet, higherEntry, higherKey, floorKey,</span></span><br><span class="line"><span class="comment">subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,</span></span><br><span class="line"><span class="comment">headMap, tailMap, lowerEntry, ceilingEntry,</span></span><br><span class="line"><span class="comment">descendingMap, pollFirstEntry, lastKey, firstEntry,</span></span><br><span class="line"><span class="comment">floorEntry, comparator, lastEntry]</span></span><br><span class="line"><span class="comment">Interfaces in TreeMap: [NavigableMap, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除 <strong>TreeSet</strong> 之外的所有 <strong>Set</strong> 都具有与 <strong>Collection</strong> 完全相同的接口。<strong>List</strong> 和 <strong>Collection</strong> 存在着明显的不同，尽管 <strong>List</strong> 所要求的方法都在 <strong>Collection</strong> 中。另一方面，在 <strong>Queue</strong> 接口中的方法是独立的，在创建具有 <strong>Queue</strong> 功能的实现时，不需要使用 <strong>Collection</strong> 方法。最后， <strong>Map</strong> 和 <strong>Collection</strong> 之间唯一的交集是 <strong>Map</strong> 可以使用 <code>entrySet()</code> 和 <code>values()</code> 方法来产生 <strong>Collection</strong> 。</p><p>请注意，标记接口 <strong>java.util.RandomAccess</strong> 附加到了 <strong>ArrayList</strong> 上，但不附加到 <strong>LinkedList</strong> 上。这为根据特定 <strong>List</strong> 动态改变其行为的算法提供了信息。</p><p>从面向对象的继承层次结构来看，这种组织结构确实有些奇怪。但是，当了解了 <strong>java.util</strong> 中更多的有关集合的内容后（特别是在<a href>附录：集合主题</a>中的内容），就会发现出了继承结构有点奇怪外，还有更多的问题。集合类库一直以来都是设计难题——解决这些问题涉及到要去满足经常彼此之间互为牵制的各方面需求。所以要做好准备，在各处做出妥协。</p><p>尽管存在这些问题，但 Java 集合仍是在日常工作中使用的基本工具，它可以使程序更简洁、更强大、更有效。你可能需要一段时间才能熟悉集合类库的某些方面，但我想你很快就会找到自己的路子，来获得和使用这个类库中的类。</p><blockquote id="fn_1"><sup>1</sup>. 许多语言，例如 Perl ，Python 和 Ruby ，都有集合的本地支持。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 这里是操作符重载的用武之地，C++和 C#的集合类都使用操作符重载生成了更简洁的语法。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. 在<a href>泛型</a>章节的末尾，有个关于这个问题是否很严重的讨论。但是，<a href>泛型</a>章节还将展示 Java 泛型远不止是类型安全的集合这么简单。<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <code>remove()</code> 是一个所谓的“可选”方法（还有一些其它的这种方法），这意味着并非所有的 <strong>Iterator</strong> 实现都必须实现该方法。这个问题将在<a href>附录：集合主题</a>中介绍。但是，标准 Java 库集合实现了 <code>remove()</code> ，因此在<a href>附录：集合主题</a>章节之前，都不必担心这个问题。<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. 这实际上依赖于具体实现。优先级队列算法通常会按插入顺序排序（维护一个<em>堆</em>），但它们也可以在删除时选择最重要的元素。 如果对象的优先级在它在队列中等待时可以修改，那么算法的选择就显得很重要了。<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. 有些人提倡这样一种自动创建机制，即对一个类中所有可能的方法组合都自动创建一个接口，有时候对于单个的类都是如此。 我相信接口的意义不应该仅限于方法组合的机械地复制，因此我在创建接口之前，总是要先看到增加接口带来的价值。<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. 这在 Java 5 之前是不可用的，因为该方法被认为与操作系统的耦合度过紧，因此违反“一次编写，处处运行”的原则。现在却提供它，这一事实表明， Java 的设计者们更加务实了。<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. 下面是译者绘制的 Java 集合框架简图，黄色为接口，绿色为抽象类，蓝色为具体类。虚线箭头表示实现关系，实线箭头表示继承关系。<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><p><img src="C:/Users/SYR/Desktop/images/collection.png" alt="collection"><br><img src="../images/map.png" alt="map"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第-1-章-对象的概念&quot;&gt;&lt;a href=&quot;#第-1-章-对象的概念&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 对象的概念&quot;&gt;&lt;/a&gt;第 1 章 对象的概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“我们没有意识到惯用语言的结构有多大的力量</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
