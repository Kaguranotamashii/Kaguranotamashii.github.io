<h1 id="附录-对象传递和返回"><a href="#附录-对象传递和返回" class="headerlink" title="附录:对象传递和返回"></a>附录:对象传递和返回</h1><blockquote>
<p>到现在为止，你已经对“传递”对象实际上是传递引用这一想法想法感到满意。</p>
</blockquote>
<p>在许多编程语言中，你可以使用该语言的“常规”方式来传递对象，并且大多数情况下一切正常。 但是通常会出现这种情况，你必须做一些不平常的事情，突然事情变得更加复杂。 Java 也不例外，当您传递对象并对其进行操作时，准确了解正在发生的事情很重要。 本附录提供了这种见解。</p>
<p>提出本附录问题的另一种方法是，如果你之前使用类似 C++的编程语言，则是“ Java 是否有指针？” Java 中的每个对象标识符（除原语外）都是这些指针之一，但它们的用法是不仅受编译器的约束，而且受运行时系统的约束。 换一种说法，Java 有指针，但没有指针算法。 这些就是我一直所说的“引用”，您可以将它们视为“安全指针”，与小学的安全剪刀不同-它们不敏锐，因此您不费吹灰之力就无法伤害自己，但是它们有时可能很乏味。</p>
<h2 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h2><p>当你将引用传递给方法时，它仍指向同一对象。 一个简单的实验演示了这一点：</p>
<pre><code class="lang-java">// references/PassReferences.java
public class PassReferences {
public static void f(PassReferences h) {
        System.out.println(&quot;h inside f(): &quot; + h);
    }
    public static void main(String[] args) {
        PassReferences p = new PassReferences();
        System.out.println(&quot;p inside main(): &quot; + p);
        f(p);
    }
}
/* Output:
p inside main(): PassReferences@15db9742
h inside f(): PassReferences@15db9742
*/
</code></pre>
<p>方法 <code>toString()</code> 在打印语句中自动调用，并且 <code>PassReferences</code> 直接从 <code>Object</code> 继承而无需重新定义 <code>toString（）</code> 。 因此，使用的是 <code>Object</code> 的 <code>toString（）</code> 版本，它打印出对象的类，然后打印出该对象所在的地址（不是引用，而是实际的对象存储）。</p>
<h2 id="本地拷贝"><a href="#本地拷贝" class="headerlink" title="本地拷贝"></a>本地拷贝</h2><h2 id="控制克隆"><a href="#控制克隆" class="headerlink" title="控制克隆"></a>控制克隆</h2><h2 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h2><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2>