<h1 id="附录-标准IO"><a href="#附录-标准IO" class="headerlink" title="附录:标准IO"></a>附录:标准IO</h1><blockquote>
<p><em>标准 I/O</em>这个术语参考Unix中的概念，指程序所使用的单一信息流（这种思想在大多数操作系统中，也有相似形式的实现）。</p>
</blockquote>
<p>程序的所有输入都可以来自于<em>标准输入</em>，其所有输出都可以流向<em>标准输出</em>，并且其所有错误信息均可以发送到<em>标准错误</em>。<em>标准 I/O</em> 的意义在于程序之间可以很容易地连接起来，一个程序的标准输出可以作为另一个程序的标准输入。这是一个非常强大的工具。</p>
<h2 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h2><p>遵循标准 I/O 模型，Java 提供了标准输入流 <code>System.in</code>、标准输出流 <code>System.out</code> 和标准错误流 <code>System.err</code>。在本书中，你已经了解到如何使用 <code>System.out</code>将数据写到标准输出。 <code>System.out</code> 已经预先包装<sup><a href="#fn_1" id="reffn_1">1</a></sup>成了 <code>PrintStream</code> 对象。标准错误流 <code>System.err</code> 也预先包装为 <code>PrintStream</code> 对象，但是标准输入流 <code>System.in</code> 是原生的没有经过包装的 <code>InputStream</code>。这意味着尽管可以直接使用标准输出流 <code>System.in</code> 和标准错误流 <code>System.err</code>，但是在读取 <code>System.in</code> 之前必须先对其进行包装。</p>
<p>我们通常一次一行地读取输入。为了实现这个功能，将 <code>System.in</code> 包装成 <code>BufferedReader</code> 来使用，这要求我们用 <code>InputStreamReader</code> 把 <code>System.in</code> 转换<sup><a href="#fn_2" id="reffn_2">2</a></sup>成 <code>Reader</code> 。下面这个例子将键入的每一行显示出来：</p>
<pre><code class="lang-java">// standardio/Echo.java
// How to read from standard input
import java.io.*;
import onjava.TimedAbort;

public class Echo {
    public static void main(String[] args) {
        TimedAbort abort = new TimedAbort(2);
        new BufferedReader(
                new InputStreamReader(System.in))
                .lines()
                .peek(ln -&gt; abort.restart())
                .forEach(System.out::println);
        // Ctrl-Z or two seconds inactivity
        // terminates the program
    }
}
</code></pre>
<p><code>BufferedReader</code> 提供了 <code>lines()</code> 方法，返回类型是 <code>Stream&lt;String&gt;</code> 。这显示出流模型的的灵活性：仅使用标准输入就能很好地工作。 <code>peek()</code> 方法重启 <code>TimeAbort</code>，只要保证至少每隔两秒有输入就能够使程序保持开启状态。</p>
<h2 id="将System-out-转换成-PrintWriter"><a href="#将System-out-转换成-PrintWriter" class="headerlink" title="将System.out 转换成 PrintWriter"></a>将<code>System.out</code> 转换成 <code>PrintWriter</code></h2><p><code>System.out</code> 是一个 <code>PrintStream</code>，而 <code>PrintStream</code> 是一个<code>OutputStream</code>。 <code>PrintWriter</code> 有一个把 <code>OutputStream</code> 作为参数的构造器。因此，如果你需要的话，可以使用这个构造器把 <code>System.out</code> 转换成 <code>PrintWriter</code> 。</p>
<pre><code class="lang-java">// standardio/ChangeSystemOut.java
// Turn System.out into a PrintWriter

import java.io.*;

public class ChangeSystemOut {
    public static void main(String[] args) {
        PrintWriter out =
                new PrintWriter(System.out, true);
        out.println(&quot;Hello, world&quot;);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>Hello, world
</code></pre><p>要使用 <code>PrintWriter</code> 带有两个参数的构造器，并设置第二个参数为 <code>true</code>，从而使能自动刷新到输出缓冲区的功能；否则，可能无法看到打印输出。</p>
<h2 id="重定向标准-I-O"><a href="#重定向标准-I-O" class="headerlink" title="重定向标准 I/O"></a>重定向标准 I/O</h2><p>Java的 <code>System</code> 类提供了简单的 <code>static</code> 方法调用，从而能够重定向标准输入流、标准输出流和标准错误流：</p>
<ul>
<li>setIn（InputStream）</li>
<li>setOut（PrintStream）</li>
<li>setErr(PrintStream)</li>
</ul>
<p>如果我们突然需要在显示器上创建大量的输出，而这些输出滚动的速度太快以至于无法阅读时，重定向输出就显得格外有用，可把输出内容重定向到文件中供后续查看。对于我们想重复测试特定的用户输入序列的命令行程序来说，重定向输入就很有价值。下例简单演示了这些方法的使用：</p>
<pre><code class="lang-java">// standardio/Redirecting.java
// Demonstrates standard I/O redirection
import java.io.*;

public class Redirecting {
    public static void main(String[] args) {
        PrintStream console = System.out;
        try (
                BufferedInputStream in = new BufferedInputStream(
                        new FileInputStream(&quot;Redirecting.java&quot;));
                PrintStream out = new PrintStream(
                        new BufferedOutputStream(
                                new FileOutputStream(&quot;Redirecting.txt&quot;)))
        ) {
            System.setIn(in);
            System.setOut(out);
            System.setErr(out);
            new BufferedReader(
                    new InputStreamReader(System.in))
                    .lines()
                    .forEach(System.out::println);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            System.setOut(console);
        }
    }
}
</code></pre>
<p>该程序将文件中内容载入到标准输入，并把标准输出和标准错误重定向到另一个文件。它在程序的开始保存了最初对 <code>System.out</code> 对象的引用，并且在程序结束时将系统输出恢复到了该对象上。</p>
<p>I/O重定向操作的是字节流而不是字符流，因此使用 <code>InputStream</code> 和 <code>OutputStream</code>，而不是 <code>Reader</code> 和 <code>Writer</code>。</p>
<h2 id="执行控制"><a href="#执行控制" class="headerlink" title="执行控制"></a>执行控制</h2><p>你经常需要在Java内部直接执行操作系统的程序，并控制这些程序的输入输出，Java类库提供了执行这些操作的类。</p>
<p>一项常见的任务是运行程序并将输出结果发送到控制台。本节包含了一个可以简化此任务的实用工具。</p>
<p>在使用这个工具时可能会产生两种类型的错误：导致异常的普通错误——对于这些错误我们只需要重新抛出一个 <code>RuntimeException</code> 即可，以及进程自身的执行过程中导致的错误——我们需要用单独的异常来报告这些错误：</p>
<pre><code class="lang-java">// onjava/OSExecuteException.java
package onjava;

public class OSExecuteException extends RuntimeException {
    public OSExecuteException(String why) {
        super(why);
    }
}
</code></pre>
<p>为了运行程序，我们需要传递给 <code>OSExecute.command()</code> 一个 <code>String command</code>，我们可以在控制台键入同样的指令运行程序。该命令传递给 <code>java.lang.ProcessBuilder</code> 的构造器（需要将其作为 <code>String</code> 对象的序列），然后启动生成的 <code>ProcessBuilder</code> 对象。</p>
<pre><code class="lang-java">// onjava/OSExecute.java
// Run an operating system command
// and send the output to the console
package onjava;
import java.io.*;

public class OSExecute {
    public static void command(String command) {
        boolean err = false;
        try {
            Process process = new ProcessBuilder(
                    command.split(&quot; &quot;)).start();
            try (
                    BufferedReader results = new BufferedReader(
                            new InputStreamReader(
                                    process.getInputStream()));
                    BufferedReader errors = new BufferedReader(
                            new InputStreamReader(
                                    process.getErrorStream()))
            ) {
                results.lines()
                        .forEach(System.out::println);
                err = errors.lines()
                        .peek(System.err::println)
                        .count() &gt; 0;
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        if (err)
            throw new OSExecuteException(
                    &quot;Errors executing &quot; + command);
    }
}
</code></pre>
<p>为了捕获在程序执行时产生的标准输出流，我们可以调用 <code>getInputStream()</code>。这是因为 <code>InputStream</code> 是我们可以从中读取信息的流。</p>
<p>这里这些行只是被打印了出来，但是你也可以从 <code>command()</code> 捕获和返回它们。</p>
<p>该程序的错误被发送到了标准错误流，可以调用 <code>getErrorStream()</code> 捕获。如果存在任何错误，它们都会被打印并且抛出 <code>OSExcuteException</code> ，以便调用程序处理这个问题。</p>
<p>下面是展示如何使用 <code>OSExecute</code> 的示例：</p>
<pre><code class="lang-java">// standardio/OSExecuteDemo.java
// Demonstrates standard I/O redirection
// {javap -cp build/classes/main OSExecuteDemo}
import onjava.*;

public class OSExecuteDemo {}
</code></pre>
<p>这里使用 <code>javap</code> 反编译器（随JDK发布）来反编译程序，编译结果：</p>
<pre><code>Compiled from &quot;OSExecuteDemo.java&quot;
public class OSExecuteDemo {
  public OSExecuteDemo();
}
</code></pre><blockquote id="fn_1">
<sup>1</sup>. 译者注：这里用到了<strong>装饰器模式</strong>。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 译者注：这里用到了<strong>适配器模式</strong>。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
